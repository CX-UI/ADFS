
hash.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <get_hash_table>:
//#include "zone.h"
#include "nova.h"

/*allocate htable blocks and get h_addr*/
int  get_hash_table(struct super_block *sb, u8 hlevel,  u64 *h_addr)
{
       0:	e8 00 00 00 00       	callq  5 <get_hash_table+0x5>
       5:	55                   	push   %rbp
       6:	83 ee 01             	sub    $0x1,%esi
       9:	31 c9                	xor    %ecx,%ecx
       b:	48 89 e5             	mov    %rsp,%rbp
       e:	53                   	push   %rbx
       f:	48 89 d3             	mov    %rdx,%rbx
      12:	48 83 ec 10          	sub    $0x10,%rsp
      16:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
      1d:	00 00 
      1f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      23:	31 c0                	xor    %eax,%eax
      25:	40 80 fe 04          	cmp    $0x4,%sil
      29:	77 0c                	ja     37 <get_hash_table+0x37>
      2b:	40 0f b6 f6          	movzbl %sil,%esi
      2f:	0f b7 8c 36 00 00 00 	movzwl 0x0(%rsi,%rsi,1),%ecx
      36:	00 
            break;
        case 5:
            btype = HTABLE_LE_SIZE;
            break;
    }
    allocated = nova_new_blocks(sb, &blocknr, 1, btype, 1, HTABLE);
      37:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
      3b:	41 b9 04 00 00 00    	mov    $0x4,%r9d
      41:	41 b8 01 00 00 00    	mov    $0x1,%r8d
      47:	ba 01 00 00 00       	mov    $0x1,%edx
      4c:	e8 00 00 00 00       	callq  51 <get_hash_table+0x51>

    //nova_dbg("%s: allocate zone @ 0x%lx\n", __func__,
	//						blocknr);
    if(allocated != 1 || blocknr == 0)
      51:	83 f8 01             	cmp    $0x1,%eax
        return -ENOMEM;
      54:	b9 f4 ff ff ff       	mov    $0xfffffff4,%ecx
    }
    allocated = nova_new_blocks(sb, &blocknr, 1, btype, 1, HTABLE);

    //nova_dbg("%s: allocate zone @ 0x%lx\n", __func__,
	//						blocknr);
    if(allocated != 1 || blocknr == 0)
      59:	75 15                	jne    70 <get_hash_table+0x70>
      5b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
      5f:	48 85 d2             	test   %rdx,%rdx
      62:	74 0c                	je     70 <get_hash_table+0x70>
        return -ENOMEM;

    block = nova_get_block_off(sb, blocknr, btype); 
    //bp = (unsigned long)nova_get_block(sb, block);
    /*偏移量*/
    *h_addr = block;
      64:	48 c1 e2 0c          	shl    $0xc,%rdx
      68:	48 89 13             	mov    %rdx,(%rbx)
	/* TODO: Fix me. */
}

static inline void PERSISTENT_BARRIER(void)
{
	asm volatile ("sfence\n" : : );
      6b:	0f ae f8             	sfence 

    PERSISTENT_BARRIER();
    return 0;
      6e:	31 c9                	xor    %ecx,%ecx
}
      70:	48 8b 5d f0          	mov    -0x10(%rbp),%rbx
      74:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
      7b:	00 00 
      7d:	89 c8                	mov    %ecx,%eax
      7f:	75 07                	jne    88 <get_hash_table+0x88>
      81:	48 83 c4 10          	add    $0x10,%rsp
      85:	5b                   	pop    %rbx
      86:	5d                   	pop    %rbp
      87:	c3                   	retq   
      88:	e8 00 00 00 00       	callq  8d <get_hash_table+0x8d>
      8d:	0f 1f 00             	nopl   (%rax)

0000000000000090 <record_pos_htable_le>:

/* record dentry-pos pairs in hash table
 * ht_addr comes from last level*/
int record_pos_htable_le(struct super_block *sb, u64 block, u64 hashname,\
         u32 pos, u8 hlevel)
{
      90:	e8 00 00 00 00       	callq  95 <record_pos_htable_le+0x5>
      95:	55                   	push   %rbp
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
      96:	48 85 f6             	test   %rsi,%rsi
    u8 valid_flag;
    //u8 level = hlevel;

    ht = (struct hash_table_le *)nova_get_block(sb, block);  
    if(!ht)
        return -EINVAL;
      99:	b8 ea ff ff ff       	mov    $0xffffffea,%eax

/* record dentry-pos pairs in hash table
 * ht_addr comes from last level*/
int record_pos_htable_le(struct super_block *sb, u64 block, u64 hashname,\
         u32 pos, u8 hlevel)
{
      9e:	48 89 e5             	mov    %rsp,%rbp
      a1:	74 66                	je     109 <record_pos_htable_le+0x79>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
      a3:	48 8b bf b0 03 00 00 	mov    0x3b0(%rdi),%rdi
    //int offset, buckets;
    u8 valid_flag;
    //u8 level = hlevel;

    ht = (struct hash_table_le *)nova_get_block(sb, block);  
    if(!ht)
      aa:	48 03 77 18          	add    0x18(%rdi),%rsi
      ae:	74 59                	je     109 <record_pos_htable_le+0x79>
      b0:	48 8d 7e 03          	lea    0x3(%rsi),%rdi
      b4:	31 c0                	xor    %eax,%eax
      b6:	eb 14                	jmp    cc <record_pos_htable_le+0x3c>
        he = &ht->hash_entry[h_pos];
        valid_flag = he->invalid;
        if(!valid_flag)
            goto fill_he;
        i++;
        h_pos ++;
      b8:	44 8d 40 01          	lea    0x1(%rax),%r8d
      bc:	48 83 c7 10          	add    $0x10,%rdi
    if(!ht)
        return -EINVAL;

    h_pos = 0;

    while(i<NR_HASH_ENTRIES_L5){
      c0:	41 81 f8 00 10 00 00 	cmp    $0x1000,%r8d
      c7:	74 08                	je     d1 <record_pos_htable_le+0x41>
      c9:	44 89 c0             	mov    %r8d,%eax
        he = &ht->hash_entry[h_pos];
        valid_flag = he->invalid;
        if(!valid_flag)
      cc:	80 3f 00             	cmpb   $0x0,(%rdi)
      cf:	75 e7                	jne    b8 <record_pos_htable_le+0x28>
        return -EINVAL;

    h_pos = 0;

    while(i<NR_HASH_ENTRIES_L5){
        he = &ht->hash_entry[h_pos];
      d1:	48 c1 e0 04          	shl    $0x4,%rax
      d5:	48 01 f0             	add    %rsi,%rax
        h_pos ++;
    }

fill_he:
    //he = &ht->hash_entry[h_pos];
    he->hd_name = cpu_to_le64(hashname);
      d8:	48 89 50 08          	mov    %rdx,0x8(%rax)
    he->hd_pos = cpu_to_le32(pos);
    he->invalid = 1;
      dc:	c6 40 03 01          	movb   $0x1,0x3(%rax)
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
      e0:	89 c6                	mov    %eax,%esi
	if (support_clwb) {
      e2:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # e8 <record_pos_htable_le+0x58>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
      e8:	83 e6 3f             	and    $0x3f,%esi
    }

fill_he:
    //he = &ht->hash_entry[h_pos];
    he->hd_name = cpu_to_le64(hashname);
    he->hd_pos = cpu_to_le32(pos);
      eb:	89 48 04             	mov    %ecx,0x4(%rax)
      ee:	83 c6 10             	add    $0x10,%esi
	if (support_clwb) {
      f1:	31 c9                	xor    %ecx,%ecx
      f3:	85 d2                	test   %edx,%edx
      f5:	74 14                	je     10b <record_pos_htable_le+0x7b>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
      f7:	89 ca                	mov    %ecx,%edx
      f9:	48 01 c2             	add    %rax,%rdx
      fc:	66 0f ae 32          	clwb   (%rdx)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     100:	83 c1 40             	add    $0x40,%ecx
     103:	39 ce                	cmp    %ecx,%esi
     105:	77 f0                	ja     f7 <record_pos_htable_le+0x67>
    he->invalid = 1;
    nova_flush_buffer(he, sizeof(struct hash_entry),0);
    return 0;
     107:	31 c0                	xor    %eax,%eax
}
     109:	5d                   	pop    %rbp
     10a:	c3                   	retq   
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
     10b:	89 ca                	mov    %ecx,%edx
     10d:	48 01 c2             	add    %rax,%rdx
     110:	0f ae 3a             	clflush (%rdx)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     113:	83 c1 40             	add    $0x40,%ecx
     116:	39 ce                	cmp    %ecx,%esi
     118:	77 f1                	ja     10b <record_pos_htable_le+0x7b>
     11a:	eb eb                	jmp    107 <record_pos_htable_le+0x77>
     11c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000000120 <record_pos_htable_lf>:

/* record dentry-pos pairs in hash table
 * ht_addr comes from last level*/
int record_pos_htable_lf(struct super_block *sb, u64 block, u64 hashname,\
         u32 pos, u8 hlevel)
{
     120:	e8 00 00 00 00       	callq  125 <record_pos_htable_lf+0x5>
     125:	55                   	push   %rbp
     126:	48 89 e5             	mov    %rsp,%rbp
     129:	41 55                	push   %r13
     12b:	41 54                	push   %r12
     12d:	53                   	push   %rbx
     12e:	48 83 ec 18          	sub    $0x18,%rsp
     132:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     139:	00 00 
     13b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
     13f:	31 c0                	xor    %eax,%eax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     141:	48 85 f6             	test   %rsi,%rsi

    buckets = 8191;
    offset = 4;
    ht = (struct hash_table_lf *)nova_get_block(sb, block);  
    if(!ht)
        return -EINVAL;
     144:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
     149:	0f 84 ba 00 00 00    	je     209 <record_pos_htable_lf+0xe9>
     14f:	49 89 d4             	mov    %rdx,%r12
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     152:	48 8b 97 b0 03 00 00 	mov    0x3b0(%rdi),%rdx
    u8 level = hlevel;

    buckets = 8191;
    offset = 4;
    ht = (struct hash_table_lf *)nova_get_block(sb, block);  
    if(!ht)
     159:	48 89 f3             	mov    %rsi,%rbx
     15c:	49 89 fd             	mov    %rdi,%r13
     15f:	48 03 5a 18          	add    0x18(%rdx),%rbx
     163:	0f 84 a0 00 00 00    	je     209 <record_pos_htable_lf+0xe9>
        return -EINVAL;

    h_pos = ((hashname % buckets)-1) * offset;
     169:	4c 89 e0             	mov    %r12,%rax
     16c:	48 ba 01 10 00 02 40 	movabs $0x8004002001001,%rdx
     173:	00 08 00 
     176:	4c 89 e7             	mov    %r12,%rdi
     179:	48 f7 e2             	mul    %rdx
     17c:	4c 89 e0             	mov    %r12,%rax
     17f:	48 29 d0             	sub    %rdx,%rax
     182:	48 d1 e8             	shr    %rax
     185:	48 01 c2             	add    %rax,%rdx
     188:	48 c1 ea 0c          	shr    $0xc,%rdx
     18c:	48 89 d0             	mov    %rdx,%rax
     18f:	48 c1 e0 0d          	shl    $0xd,%rax
     193:	48 29 d0             	sub    %rdx,%rax
     196:	48 29 c7             	sub    %rax,%rdi
     199:	8d 14 bd fc ff ff ff 	lea    -0x4(,%rdi,4),%edx
     1a0:	8d 7a 04             	lea    0x4(%rdx),%edi

    while(i<offset){
        he =  &ht->hash_entry[h_pos];
        valid_flag = he->invalid;
     1a3:	89 d6                	mov    %edx,%esi
     1a5:	48 8d 46 04          	lea    0x4(%rsi),%rax
     1a9:	48 c1 e0 04          	shl    $0x4,%rax
     1ad:	48 01 d8             	add    %rbx,%rax
        if(!valid_flag)
     1b0:	80 78 03 00          	cmpb   $0x0,0x3(%rax)
     1b4:	0f 84 80 00 00 00    	je     23a <record_pos_htable_lf+0x11a>
            goto fill_he;
        i++;
        h_pos ++;
     1ba:	83 c2 01             	add    $0x1,%edx
    if(!ht)
        return -EINVAL;

    h_pos = ((hashname % buckets)-1) * offset;

    while(i<offset){
     1bd:	39 fa                	cmp    %edi,%edx
     1bf:	75 e2                	jne    1a3 <record_pos_htable_lf+0x83>
            goto fill_he;
        i++;
        h_pos ++;
    }

    tail = le64_to_cpu(ht->hash_tail);
     1c1:	48 8b 73 38          	mov    0x38(%rbx),%rsi
    if(!tail){
     1c5:	48 85 f6             	test   %rsi,%rsi
            goto fill_he;
        i++;
        h_pos ++;
    }

    tail = le64_to_cpu(ht->hash_tail);
     1c8:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
    if(!tail){
     1cc:	75 55                	jne    223 <record_pos_htable_lf+0x103>
        //nova_dbg("%s %d extend",__func__, hlevel);
        level ++;
        get_hash_table(sb, hlevel, &tail);
     1ce:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
     1d2:	41 0f b6 f0          	movzbl %r8b,%esi
     1d6:	4c 89 ef             	mov    %r13,%rdi
     1d9:	89 4d d0             	mov    %ecx,-0x30(%rbp)
     1dc:	44 89 45 d4          	mov    %r8d,-0x2c(%rbp)
     1e0:	e8 00 00 00 00       	callq  1e5 <record_pos_htable_lf+0xc5>
        ht->hash_tail = cpu_to_le64(tail);
        record_pos_htable_le(sb, tail, hashname, pos, level);
     1e5:	44 8b 45 d4          	mov    -0x2c(%rbp),%r8d
    tail = le64_to_cpu(ht->hash_tail);
    if(!tail){
        //nova_dbg("%s %d extend",__func__, hlevel);
        level ++;
        get_hash_table(sb, hlevel, &tail);
        ht->hash_tail = cpu_to_le64(tail);
     1e9:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
        record_pos_htable_le(sb, tail, hashname, pos, level);
     1ed:	4c 89 e2             	mov    %r12,%rdx
     1f0:	8b 4d d0             	mov    -0x30(%rbp),%ecx
     1f3:	4c 89 ef             	mov    %r13,%rdi
     1f6:	41 83 c0 01          	add    $0x1,%r8d
    tail = le64_to_cpu(ht->hash_tail);
    if(!tail){
        //nova_dbg("%s %d extend",__func__, hlevel);
        level ++;
        get_hash_table(sb, hlevel, &tail);
        ht->hash_tail = cpu_to_le64(tail);
     1fa:	48 89 73 38          	mov    %rsi,0x38(%rbx)
        record_pos_htable_le(sb, tail, hashname, pos, level);
     1fe:	45 0f b6 c0          	movzbl %r8b,%r8d
     202:	e8 00 00 00 00       	callq  207 <record_pos_htable_lf+0xe7>
    he->hd_pos = cpu_to_le32(pos);
    he->invalid = 1;
    nova_flush_buffer(he, sizeof(struct hash_entry),0);
    
out:
    return 0;
     207:	31 c0                	xor    %eax,%eax
}
     209:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
     20d:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
     214:	00 00 
     216:	75 6d                	jne    285 <record_pos_htable_lf+0x165>
     218:	48 83 c4 18          	add    $0x18,%rsp
     21c:	5b                   	pop    %rbx
     21d:	41 5c                	pop    %r12
     21f:	41 5d                	pop    %r13
     221:	5d                   	pop    %rbp
     222:	c3                   	retq   
        ht->hash_tail = cpu_to_le64(tail);
        record_pos_htable_le(sb, tail, hashname, pos, level);
        goto out;
    } else {
        level ++;
        record_pos_htable_le(sb, tail, hashname,  pos, level);
     223:	41 83 c0 01          	add    $0x1,%r8d
     227:	4c 89 e2             	mov    %r12,%rdx
     22a:	4c 89 ef             	mov    %r13,%rdi
     22d:	45 0f b6 c0          	movzbl %r8b,%r8d
     231:	e8 00 00 00 00       	callq  236 <record_pos_htable_lf+0x116>
    he->hd_pos = cpu_to_le32(pos);
    he->invalid = 1;
    nova_flush_buffer(he, sizeof(struct hash_entry),0);
    
out:
    return 0;
     236:	31 c0                	xor    %eax,%eax
        record_pos_htable_le(sb, tail, hashname, pos, level);
        goto out;
    } else {
        level ++;
        record_pos_htable_le(sb, tail, hashname,  pos, level);
        goto out;
     238:	eb cf                	jmp    209 <record_pos_htable_lf+0xe9>
     23a:	48 c1 e6 04          	shl    $0x4,%rsi

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
     23e:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 244 <record_pos_htable_lf+0x124>
     244:	48 01 f3             	add    %rsi,%rbx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
     247:	89 c6                	mov    %eax,%esi
     249:	83 e6 3f             	and    $0x3f,%esi
    }

fill_he:
    //he = &ht->hash_entry[h_pos];
    he->hd_name = cpu_to_le64(hashname);
    he->hd_pos = cpu_to_le32(pos);
     24c:	89 4b 44             	mov    %ecx,0x44(%rbx)
	if (support_clwb) {
     24f:	31 c9                	xor    %ecx,%ecx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
     251:	83 c6 10             	add    $0x10,%esi
	if (support_clwb) {
     254:	85 d2                	test   %edx,%edx
        goto out;
    }

fill_he:
    //he = &ht->hash_entry[h_pos];
    he->hd_name = cpu_to_le64(hashname);
     256:	4c 89 63 48          	mov    %r12,0x48(%rbx)
    he->hd_pos = cpu_to_le32(pos);
    he->invalid = 1;
     25a:	c6 43 43 01          	movb   $0x1,0x43(%rbx)
     25e:	74 14                	je     274 <record_pos_htable_lf+0x154>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
     260:	89 ca                	mov    %ecx,%edx
     262:	48 01 c2             	add    %rax,%rdx
     265:	66 0f ae 32          	clwb   (%rdx)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     269:	83 c1 40             	add    $0x40,%ecx
     26c:	39 ce                	cmp    %ecx,%esi
     26e:	77 f0                	ja     260 <record_pos_htable_lf+0x140>
    nova_flush_buffer(he, sizeof(struct hash_entry),0);
    
out:
    return 0;
     270:	31 c0                	xor    %eax,%eax
     272:	eb 95                	jmp    209 <record_pos_htable_lf+0xe9>
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
     274:	89 ca                	mov    %ecx,%edx
     276:	48 01 c2             	add    %rax,%rdx
     279:	0f ae 3a             	clflush (%rdx)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     27c:	83 c1 40             	add    $0x40,%ecx
     27f:	39 ce                	cmp    %ecx,%esi
     281:	77 f1                	ja     274 <record_pos_htable_lf+0x154>
     283:	eb eb                	jmp    270 <record_pos_htable_lf+0x150>
}
     285:	e8 00 00 00 00       	callq  28a <record_pos_htable_lf+0x16a>
     28a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000000290 <record_pos_htable_lt>:
/* record dentry-pos pairs in hash table
 * ht_addr comes from last level*/
int record_pos_htable_lt(struct super_block *sb, u64 block, u64 hashname,\
         u32 pos, u8 hlevel)
{
     290:	e8 00 00 00 00       	callq  295 <record_pos_htable_lt+0x5>
     295:	55                   	push   %rbp
     296:	48 89 e5             	mov    %rsp,%rbp
     299:	41 57                	push   %r15
     29b:	41 56                	push   %r14
     29d:	41 55                	push   %r13
     29f:	41 54                	push   %r12
     2a1:	53                   	push   %rbx
     2a2:	48 83 ec 18          	sub    $0x18,%rsp
     2a6:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     2ad:	00 00 
     2af:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     2b3:	31 c0                	xor    %eax,%eax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     2b5:	48 85 f6             	test   %rsi,%rsi

    buckets = 16383;
    offset = 4;
    ht = (struct hash_table_lt *)nova_get_block(sb, block);  
    if(!ht)
        return -EINVAL;
     2b8:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
     2bd:	0f 84 d0 00 00 00    	je     393 <record_pos_htable_lt+0x103>
     2c3:	48 89 d3             	mov    %rdx,%rbx
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     2c6:	48 8b 97 b0 03 00 00 	mov    0x3b0(%rdi),%rdx
     2cd:	49 89 fc             	mov    %rdi,%r12
    u8 level = hlevel;

    buckets = 16383;
    offset = 4;
    ht = (struct hash_table_lt *)nova_get_block(sb, block);  
    if(!ht)
     2d0:	48 03 72 18          	add    0x18(%rdx),%rsi
     2d4:	49 89 f5             	mov    %rsi,%r13
     2d7:	0f 84 b6 00 00 00    	je     393 <record_pos_htable_lt+0x103>
        return -EINVAL;

    h_pos = ((hashname % buckets)-1) * offset;
     2dd:	48 89 d8             	mov    %rbx,%rax
     2e0:	48 ba 01 01 40 00 10 	movabs $0x4001000400101,%rdx
     2e7:	00 04 00 
     2ea:	48 89 df             	mov    %rbx,%rdi
     2ed:	48 f7 e2             	mul    %rdx
     2f0:	48 89 d8             	mov    %rbx,%rax
     2f3:	48 29 d0             	sub    %rdx,%rax
     2f6:	48 d1 e8             	shr    %rax
     2f9:	48 01 c2             	add    %rax,%rdx
     2fc:	48 c1 ea 0d          	shr    $0xd,%rdx
     300:	48 89 d0             	mov    %rdx,%rax
     303:	48 c1 e0 0e          	shl    $0xe,%rax
     307:	48 29 d0             	sub    %rdx,%rax
     30a:	48 29 c7             	sub    %rax,%rdi
     30d:	8d 14 bd fc ff ff ff 	lea    -0x4(,%rdi,4),%edx
     314:	8d 7a 04             	lea    0x4(%rdx),%edi

    while(i<offset){
        he =  &ht->hash_entry[h_pos];
        valid_flag = he->invalid;
     317:	89 d6                	mov    %edx,%esi
     319:	48 8d 46 04          	lea    0x4(%rsi),%rax
     31d:	48 c1 e0 04          	shl    $0x4,%rax
     321:	4c 01 e8             	add    %r13,%rax
        if(!valid_flag)
     324:	80 78 03 00          	cmpb   $0x0,0x3(%rax)
     328:	0f 84 9d 00 00 00    	je     3cb <record_pos_htable_lt+0x13b>
            goto fill_he;
        i++;
        h_pos ++;
     32e:	83 c2 01             	add    $0x1,%edx
    if(!ht)
        return -EINVAL;

    h_pos = ((hashname % buckets)-1) * offset;

    while(i<offset){
     331:	39 fa                	cmp    %edi,%edx
     333:	75 e2                	jne    317 <record_pos_htable_lt+0x87>
            goto fill_he;
        i++;
        h_pos ++;
    }

    tail = le64_to_cpu(ht->hash_tail);
     335:	4d 8b 7d 38          	mov    0x38(%r13),%r15
    if(!tail){
     339:	4d 85 ff             	test   %r15,%r15
            goto fill_he;
        i++;
        h_pos ++;
    }

    tail = le64_to_cpu(ht->hash_tail);
     33c:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
    if(!tail){
     340:	75 6f                	jne    3b1 <record_pos_htable_lt+0x121>
        //nova_dbg("%s %d extend",__func__, hlevel);
        level ++;
        get_hash_table(sb, hlevel, &tail);
     342:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
     346:	41 0f b6 f0          	movzbl %r8b,%esi
     34a:	4c 89 e7             	mov    %r12,%rdi
     34d:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
    }

    tail = le64_to_cpu(ht->hash_tail);
    if(!tail){
        //nova_dbg("%s %d extend",__func__, hlevel);
        level ++;
     350:	45 8d 70 01          	lea    0x1(%r8),%r14d
        get_hash_table(sb, hlevel, &tail);
     354:	e8 00 00 00 00       	callq  359 <record_pos_htable_lt+0xc9>
        htf = (struct hash_table_lf *)nova_get_block(sb, tail);
     359:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
     35d:	49 8b 84 24 b0 03 00 	mov    0x3b0(%r12),%rax
     364:	00 
        htf->hash_tail = 0;
        ht->hash_tail = cpu_to_le64(tail);
        record_pos_htable_lf(sb, tail, hashname, pos, level);
     365:	45 0f b6 c6          	movzbl %r14b,%r8d
     369:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
     36c:	48 89 da             	mov    %rbx,%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     36f:	48 89 f7             	mov    %rsi,%rdi
     372:	48 03 78 18          	add    0x18(%rax),%rdi
     376:	48 85 f6             	test   %rsi,%rsi
     379:	4c 0f 45 ff          	cmovne %rdi,%r15
     37d:	4c 89 e7             	mov    %r12,%rdi
    if(!tail){
        //nova_dbg("%s %d extend",__func__, hlevel);
        level ++;
        get_hash_table(sb, hlevel, &tail);
        htf = (struct hash_table_lf *)nova_get_block(sb, tail);
        htf->hash_tail = 0;
     380:	49 c7 47 38 00 00 00 	movq   $0x0,0x38(%r15)
     387:	00 
        ht->hash_tail = cpu_to_le64(tail);
     388:	49 89 75 38          	mov    %rsi,0x38(%r13)
        record_pos_htable_lf(sb, tail, hashname, pos, level);
     38c:	e8 00 00 00 00       	callq  391 <record_pos_htable_lt+0x101>
    he->hd_pos = cpu_to_le32(pos);
    he->invalid = 1;
    nova_flush_buffer(he, sizeof(struct hash_entry),0);
    
out:
    return 0;
     391:	31 c0                	xor    %eax,%eax
}
     393:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
     397:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
     39e:	00 00 
     3a0:	75 76                	jne    418 <record_pos_htable_lt+0x188>
     3a2:	48 83 c4 18          	add    $0x18,%rsp
     3a6:	5b                   	pop    %rbx
     3a7:	41 5c                	pop    %r12
     3a9:	41 5d                	pop    %r13
     3ab:	41 5e                	pop    %r14
     3ad:	41 5f                	pop    %r15
     3af:	5d                   	pop    %rbp
     3b0:	c3                   	retq   
        ht->hash_tail = cpu_to_le64(tail);
        record_pos_htable_lf(sb, tail, hashname, pos, level);
        goto out;
    } else {
        level ++;
        record_pos_htable_lf(sb, tail, hashname,  pos, level);
     3b1:	41 83 c0 01          	add    $0x1,%r8d
     3b5:	48 89 da             	mov    %rbx,%rdx
     3b8:	4c 89 fe             	mov    %r15,%rsi
     3bb:	45 0f b6 c0          	movzbl %r8b,%r8d
     3bf:	4c 89 e7             	mov    %r12,%rdi
     3c2:	e8 00 00 00 00       	callq  3c7 <record_pos_htable_lt+0x137>
    he->hd_pos = cpu_to_le32(pos);
    he->invalid = 1;
    nova_flush_buffer(he, sizeof(struct hash_entry),0);
    
out:
    return 0;
     3c7:	31 c0                	xor    %eax,%eax
        record_pos_htable_lf(sb, tail, hashname, pos, level);
        goto out;
    } else {
        level ++;
        record_pos_htable_lf(sb, tail, hashname,  pos, level);
        goto out;
     3c9:	eb c8                	jmp    393 <record_pos_htable_lt+0x103>
     3cb:	48 c1 e6 04          	shl    $0x4,%rsi

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
     3cf:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 3d5 <record_pos_htable_lt+0x145>
     3d5:	49 01 f5             	add    %rsi,%r13
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
     3d8:	89 c6                	mov    %eax,%esi
     3da:	83 e6 3f             	and    $0x3f,%esi
    }

fill_he:
    //he = &ht->hash_entry[h_pos];
    he->hd_name = cpu_to_le64(hashname);
    he->hd_pos = cpu_to_le32(pos);
     3dd:	41 89 4d 44          	mov    %ecx,0x44(%r13)
	if (support_clwb) {
     3e1:	31 c9                	xor    %ecx,%ecx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
     3e3:	83 c6 10             	add    $0x10,%esi
	if (support_clwb) {
     3e6:	85 d2                	test   %edx,%edx
        goto out;
    }

fill_he:
    //he = &ht->hash_entry[h_pos];
    he->hd_name = cpu_to_le64(hashname);
     3e8:	49 89 5d 48          	mov    %rbx,0x48(%r13)
    he->hd_pos = cpu_to_le32(pos);
    he->invalid = 1;
     3ec:	41 c6 45 43 01       	movb   $0x1,0x43(%r13)
     3f1:	74 14                	je     407 <record_pos_htable_lt+0x177>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
     3f3:	89 ca                	mov    %ecx,%edx
     3f5:	48 01 c2             	add    %rax,%rdx
     3f8:	66 0f ae 32          	clwb   (%rdx)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     3fc:	83 c1 40             	add    $0x40,%ecx
     3ff:	39 ce                	cmp    %ecx,%esi
     401:	77 f0                	ja     3f3 <record_pos_htable_lt+0x163>
    nova_flush_buffer(he, sizeof(struct hash_entry),0);
    
out:
    return 0;
     403:	31 c0                	xor    %eax,%eax
     405:	eb 8c                	jmp    393 <record_pos_htable_lt+0x103>
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
     407:	89 ca                	mov    %ecx,%edx
     409:	48 01 c2             	add    %rax,%rdx
     40c:	0f ae 3a             	clflush (%rdx)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     40f:	83 c1 40             	add    $0x40,%ecx
     412:	39 ce                	cmp    %ecx,%esi
     414:	77 f1                	ja     407 <record_pos_htable_lt+0x177>
     416:	eb eb                	jmp    403 <record_pos_htable_lt+0x173>
}
     418:	e8 00 00 00 00       	callq  41d <record_pos_htable_lt+0x18d>
     41d:	0f 1f 00             	nopl   (%rax)

0000000000000420 <record_pos_htable_ls>:

/* record dentry-pos pairs in hash table
 * ht_addr comes from last level*/
int record_pos_htable_ls(struct super_block *sb, u64 block, u64 hashname,\
        u32 pos, u8 hlevel)
{
     420:	e8 00 00 00 00       	callq  425 <record_pos_htable_ls+0x5>
     425:	55                   	push   %rbp
     426:	48 89 e5             	mov    %rsp,%rbp
     429:	41 57                	push   %r15
     42b:	41 56                	push   %r14
     42d:	41 55                	push   %r13
     42f:	41 54                	push   %r12
     431:	53                   	push   %rbx
     432:	48 83 ec 18          	sub    $0x18,%rsp
     436:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     43d:	00 00 
     43f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     443:	31 c0                	xor    %eax,%eax
     445:	48 85 f6             	test   %rsi,%rsi

    buckets = 32768;
    offset = 4;
    ht = (struct hash_table_ls *)nova_get_block(sb, block);  
    if(!ht)
        return -EINVAL;
     448:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
     44d:	0f 84 aa 00 00 00    	je     4fd <record_pos_htable_ls+0xdd>
     453:	49 89 d5             	mov    %rdx,%r13
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     456:	48 8b 97 b0 03 00 00 	mov    0x3b0(%rdi),%rdx
    u8 level = hlevel;

    buckets = 32768;
    offset = 4;
    ht = (struct hash_table_ls *)nova_get_block(sb, block);  
    if(!ht)
     45d:	48 89 f3             	mov    %rsi,%rbx
     460:	49 89 fc             	mov    %rdi,%r12
     463:	48 03 5a 18          	add    0x18(%rdx),%rbx
     467:	0f 84 90 00 00 00    	je     4fd <record_pos_htable_ls+0xdd>
        return -EINVAL;

    h_pos = ((hashname % buckets)-1) * offset;
     46d:	4c 89 e8             	mov    %r13,%rax
     470:	25 ff 7f 00 00       	and    $0x7fff,%eax
     475:	8d 14 85 fc ff ff ff 	lea    -0x4(,%rax,4),%edx
     47c:	44 8d 4a 04          	lea    0x4(%rdx),%r9d

    while(i<offset){
        he =  &ht->hash_entry[h_pos];
        valid_flag = he->invalid;
     480:	89 d7                	mov    %edx,%edi
     482:	48 8d 47 04          	lea    0x4(%rdi),%rax
     486:	48 c1 e0 04          	shl    $0x4,%rax
     48a:	48 01 d8             	add    %rbx,%rax
        if(!valid_flag)
     48d:	80 78 03 00          	cmpb   $0x0,0x3(%rax)
     491:	0f 84 9e 00 00 00    	je     535 <record_pos_htable_ls+0x115>
            goto fill_he;
        i++;
        h_pos ++;
     497:	83 c2 01             	add    $0x1,%edx
    if(!ht)
        return -EINVAL;

    h_pos = ((hashname % buckets)-1) * offset;

    while(i<offset){
     49a:	44 39 ca             	cmp    %r9d,%edx
     49d:	75 e1                	jne    480 <record_pos_htable_ls+0x60>
            goto fill_he;
        i++;
        h_pos ++;
    }

    tail = le64_to_cpu(ht->hash_tail);
     49f:	4c 8b 7b 38          	mov    0x38(%rbx),%r15
    if(!tail){
     4a3:	4d 85 ff             	test   %r15,%r15
            goto fill_he;
        i++;
        h_pos ++;
    }

    tail = le64_to_cpu(ht->hash_tail);
     4a6:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
    if(!tail){
     4aa:	75 6f                	jne    51b <record_pos_htable_ls+0xfb>
        //nova_dbg("%s %d extend",__func__, hlevel);
        level ++;
        get_hash_table(sb, hlevel, &tail);
     4ac:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
     4b0:	41 0f b6 f0          	movzbl %r8b,%esi
     4b4:	4c 89 e7             	mov    %r12,%rdi
     4b7:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
    }

    tail = le64_to_cpu(ht->hash_tail);
    if(!tail){
        //nova_dbg("%s %d extend",__func__, hlevel);
        level ++;
     4ba:	45 8d 70 01          	lea    0x1(%r8),%r14d
        get_hash_table(sb, hlevel, &tail);
     4be:	e8 00 00 00 00       	callq  4c3 <record_pos_htable_ls+0xa3>
        htt = (struct hash_table_lt *)nova_get_block(sb, tail);
     4c3:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
     4c7:	49 8b 84 24 b0 03 00 	mov    0x3b0(%r12),%rax
     4ce:	00 
        htt->hash_tail = 0;
        ht->hash_tail = cpu_to_le64(tail);
        record_pos_htable_lt(sb, tail, hashname, pos, level);
     4cf:	45 0f b6 c6          	movzbl %r14b,%r8d
     4d3:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
     4d6:	4c 89 ea             	mov    %r13,%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     4d9:	48 89 f7             	mov    %rsi,%rdi
     4dc:	48 03 78 18          	add    0x18(%rax),%rdi
     4e0:	48 85 f6             	test   %rsi,%rsi
     4e3:	4c 0f 45 ff          	cmovne %rdi,%r15
     4e7:	4c 89 e7             	mov    %r12,%rdi
    if(!tail){
        //nova_dbg("%s %d extend",__func__, hlevel);
        level ++;
        get_hash_table(sb, hlevel, &tail);
        htt = (struct hash_table_lt *)nova_get_block(sb, tail);
        htt->hash_tail = 0;
     4ea:	49 c7 47 38 00 00 00 	movq   $0x0,0x38(%r15)
     4f1:	00 
        ht->hash_tail = cpu_to_le64(tail);
     4f2:	48 89 73 38          	mov    %rsi,0x38(%rbx)
        record_pos_htable_lt(sb, tail, hashname, pos, level);
     4f6:	e8 00 00 00 00       	callq  4fb <record_pos_htable_ls+0xdb>
    he->hd_pos = cpu_to_le32(pos);
    he->invalid = 1;
    nova_flush_buffer(he, sizeof(struct hash_entry),0);
    
out:
    return 0;
     4fb:	31 c0                	xor    %eax,%eax
}
     4fd:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
     501:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
     508:	00 00 
     50a:	75 74                	jne    580 <record_pos_htable_ls+0x160>
     50c:	48 83 c4 18          	add    $0x18,%rsp
     510:	5b                   	pop    %rbx
     511:	41 5c                	pop    %r12
     513:	41 5d                	pop    %r13
     515:	41 5e                	pop    %r14
     517:	41 5f                	pop    %r15
     519:	5d                   	pop    %rbp
     51a:	c3                   	retq   
        ht->hash_tail = cpu_to_le64(tail);
        record_pos_htable_lt(sb, tail, hashname, pos, level);
        goto out;
    } else {
        level ++;
        record_pos_htable_lt(sb, tail, hashname, pos, level);
     51b:	41 83 c0 01          	add    $0x1,%r8d
     51f:	4c 89 ea             	mov    %r13,%rdx
     522:	4c 89 fe             	mov    %r15,%rsi
     525:	45 0f b6 c0          	movzbl %r8b,%r8d
     529:	4c 89 e7             	mov    %r12,%rdi
     52c:	e8 00 00 00 00       	callq  531 <record_pos_htable_ls+0x111>
    he->hd_pos = cpu_to_le32(pos);
    he->invalid = 1;
    nova_flush_buffer(he, sizeof(struct hash_entry),0);
    
out:
    return 0;
     531:	31 c0                	xor    %eax,%eax
        record_pos_htable_lt(sb, tail, hashname, pos, level);
        goto out;
    } else {
        level ++;
        record_pos_htable_lt(sb, tail, hashname, pos, level);
        goto out;
     533:	eb c8                	jmp    4fd <record_pos_htable_ls+0xdd>

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
     535:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 53b <record_pos_htable_ls+0x11b>
     53b:	48 c1 e7 04          	shl    $0x4,%rdi
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
     53f:	89 c6                	mov    %eax,%esi
     541:	48 01 fb             	add    %rdi,%rbx
     544:	83 e6 3f             	and    $0x3f,%esi
    }

fill_he:
    //he = &ht->hash_entry[h_pos];
    he->hd_name = cpu_to_le64(hashname);
    he->hd_pos = cpu_to_le32(pos);
     547:	89 4b 44             	mov    %ecx,0x44(%rbx)
     54a:	83 c6 10             	add    $0x10,%esi
	if (support_clwb) {
     54d:	31 c9                	xor    %ecx,%ecx
     54f:	85 d2                	test   %edx,%edx
        goto out;
    }

fill_he:
    //he = &ht->hash_entry[h_pos];
    he->hd_name = cpu_to_le64(hashname);
     551:	4c 89 6b 48          	mov    %r13,0x48(%rbx)
    he->hd_pos = cpu_to_le32(pos);
    he->invalid = 1;
     555:	c6 43 43 01          	movb   $0x1,0x43(%rbx)
     559:	74 14                	je     56f <record_pos_htable_ls+0x14f>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
     55b:	89 ca                	mov    %ecx,%edx
     55d:	48 01 c2             	add    %rax,%rdx
     560:	66 0f ae 32          	clwb   (%rdx)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     564:	83 c1 40             	add    $0x40,%ecx
     567:	39 ce                	cmp    %ecx,%esi
     569:	77 f0                	ja     55b <record_pos_htable_ls+0x13b>
    nova_flush_buffer(he, sizeof(struct hash_entry),0);
    
out:
    return 0;
     56b:	31 c0                	xor    %eax,%eax
     56d:	eb 8e                	jmp    4fd <record_pos_htable_ls+0xdd>
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
     56f:	89 ca                	mov    %ecx,%edx
     571:	48 01 c2             	add    %rax,%rdx
     574:	0f ae 3a             	clflush (%rdx)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     577:	83 c1 40             	add    $0x40,%ecx
     57a:	39 ce                	cmp    %ecx,%esi
     57c:	77 f1                	ja     56f <record_pos_htable_ls+0x14f>
     57e:	eb eb                	jmp    56b <record_pos_htable_ls+0x14b>
}
     580:	e8 00 00 00 00       	callq  585 <record_pos_htable_ls+0x165>
     585:	90                   	nop
     586:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     58d:	00 00 00 

0000000000000590 <record_pos_htable>:
/* record dentry-pos pairs in hash table
 * ht_addr comes from dzt_ei*/
int record_pos_htable(struct super_block *sb, u64 block, u64 hashname,\
         u32 pos, u8 hlevel)
{
     590:	e8 00 00 00 00       	callq  595 <record_pos_htable+0x5>
     595:	55                   	push   %rbp
     596:	48 89 e5             	mov    %rsp,%rbp
     599:	41 57                	push   %r15
     59b:	41 56                	push   %r14
     59d:	41 55                	push   %r13
     59f:	41 54                	push   %r12
     5a1:	53                   	push   %rbx
     5a2:	48 83 ec 18          	sub    $0x18,%rsp
     5a6:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     5ad:	00 00 
     5af:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     5b3:	31 c0                	xor    %eax,%eax
     5b5:	48 85 f6             	test   %rsi,%rsi
    //nova_dbg("dafs record pos in hash table address is %llu", block);
    buckets = 65535; 
    offset = 4;
    ht = (struct hash_table *)nova_get_block(sb, block);  
    if(!ht)
        return -EINVAL;
     5b8:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
     5bd:	0f 84 c5 00 00 00    	je     688 <record_pos_htable+0xf8>
     5c3:	49 89 d4             	mov    %rdx,%r12
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     5c6:	48 8b 97 b0 03 00 00 	mov    0x3b0(%rdi),%rdx

    //nova_dbg("dafs record pos in hash table address is %llu", block);
    buckets = 65535; 
    offset = 4;
    ht = (struct hash_table *)nova_get_block(sb, block);  
    if(!ht)
     5cd:	48 89 f3             	mov    %rsi,%rbx
     5d0:	49 89 fd             	mov    %rdi,%r13
     5d3:	48 03 5a 18          	add    0x18(%rdx),%rbx
     5d7:	0f 84 ab 00 00 00    	je     688 <record_pos_htable+0xf8>
        return -EINVAL;

    h_pos = ((hashname % buckets)-1) * offset;
     5dd:	4c 89 e0             	mov    %r12,%rax
     5e0:	48 ba 01 80 00 80 00 	movabs $0x8000800080008001,%rdx
     5e7:	80 00 80 
     5ea:	4c 89 e7             	mov    %r12,%rdi
     5ed:	48 f7 e2             	mul    %rdx
     5f0:	48 c1 ea 0f          	shr    $0xf,%rdx
     5f4:	48 89 d0             	mov    %rdx,%rax
     5f7:	48 c1 e0 10          	shl    $0x10,%rax
     5fb:	48 29 d0             	sub    %rdx,%rax
     5fe:	48 29 c7             	sub    %rax,%rdi
     601:	8d 14 bd fc ff ff ff 	lea    -0x4(,%rdi,4),%edx
     608:	8d 7a 04             	lea    0x4(%rdx),%edi

    while(i<offset){
        he =  &ht->hash_entry[h_pos];
        valid_flag = he->invalid;
     60b:	89 d6                	mov    %edx,%esi
     60d:	48 8d 46 04          	lea    0x4(%rsi),%rax
     611:	48 c1 e0 04          	shl    $0x4,%rax
     615:	48 01 d8             	add    %rbx,%rax
        if(!valid_flag)
     618:	80 78 03 00          	cmpb   $0x0,0x3(%rax)
     61c:	0f 84 9e 00 00 00    	je     6c0 <record_pos_htable+0x130>
            goto fill_he;
        i++;
        h_pos ++;
     622:	83 c2 01             	add    $0x1,%edx
    if(!ht)
        return -EINVAL;

    h_pos = ((hashname % buckets)-1) * offset;

    while(i<offset){
     625:	39 fa                	cmp    %edi,%edx
     627:	75 e2                	jne    60b <record_pos_htable+0x7b>
        i++;
        h_pos ++;
    }

    //nova_dbg("%s buckets full",__func__);
    tail = le64_to_cpu(ht->hash_tail);
     629:	4c 8b 73 38          	mov    0x38(%rbx),%r14
    if(!tail){
     62d:	4d 85 f6             	test   %r14,%r14
        i++;
        h_pos ++;
    }

    //nova_dbg("%s buckets full",__func__);
    tail = le64_to_cpu(ht->hash_tail);
     630:	4c 89 75 c8          	mov    %r14,-0x38(%rbp)
    if(!tail){
     634:	75 70                	jne    6a6 <record_pos_htable+0x116>
        //nova_dbg("%s hashtable %d extend",__func__, hlevel);
        hlevel ++;
        get_hash_table(sb, hlevel, &tail);
     636:	41 83 c0 01          	add    $0x1,%r8d
     63a:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
     63e:	4c 89 ef             	mov    %r13,%rdi
     641:	45 0f b6 f8          	movzbl %r8b,%r15d
     645:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
     648:	44 89 fe             	mov    %r15d,%esi
     64b:	e8 00 00 00 00       	callq  650 <record_pos_htable+0xc0>
        hts = (struct hash_table_ls *)nova_get_block(sb, tail);
     650:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
     654:	49 8b 85 b0 03 00 00 	mov    0x3b0(%r13),%rax
        hts->hash_tail = 0;
        ht->hash_tail = cpu_to_le64(tail);
        record_pos_htable_ls(sb, tail, hashname,  pos, hlevel);
     65b:	45 89 f8             	mov    %r15d,%r8d
     65e:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
     661:	4c 89 e2             	mov    %r12,%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     664:	48 89 f7             	mov    %rsi,%rdi
     667:	48 03 78 18          	add    0x18(%rax),%rdi
     66b:	48 85 f6             	test   %rsi,%rsi
     66e:	4c 0f 45 f7          	cmovne %rdi,%r14
     672:	4c 89 ef             	mov    %r13,%rdi
    if(!tail){
        //nova_dbg("%s hashtable %d extend",__func__, hlevel);
        hlevel ++;
        get_hash_table(sb, hlevel, &tail);
        hts = (struct hash_table_ls *)nova_get_block(sb, tail);
        hts->hash_tail = 0;
     675:	49 c7 46 38 00 00 00 	movq   $0x0,0x38(%r14)
     67c:	00 
        ht->hash_tail = cpu_to_le64(tail);
     67d:	48 89 73 38          	mov    %rsi,0x38(%rbx)
        record_pos_htable_ls(sb, tail, hashname,  pos, hlevel);
     681:	e8 00 00 00 00       	callq  686 <record_pos_htable+0xf6>
    he->invalid = 1;
    he->hd_pos = cpu_to_le32(pos);
    nova_flush_buffer(he, sizeof(struct hash_entry),0);
    
out:
    return 0;
     686:	31 c0                	xor    %eax,%eax
}
     688:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
     68c:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
     693:	00 00 
     695:	75 74                	jne    70b <record_pos_htable+0x17b>
     697:	48 83 c4 18          	add    $0x18,%rsp
     69b:	5b                   	pop    %rbx
     69c:	41 5c                	pop    %r12
     69e:	41 5d                	pop    %r13
     6a0:	41 5e                	pop    %r14
     6a2:	41 5f                	pop    %r15
     6a4:	5d                   	pop    %rbp
     6a5:	c3                   	retq   
        ht->hash_tail = cpu_to_le64(tail);
        record_pos_htable_ls(sb, tail, hashname,  pos, hlevel);
        goto out;
    } else {
        hlevel ++;
        record_pos_htable_ls(sb, tail, hashname, pos, hlevel);
     6a6:	41 83 c0 01          	add    $0x1,%r8d
     6aa:	4c 89 e2             	mov    %r12,%rdx
     6ad:	4c 89 f6             	mov    %r14,%rsi
     6b0:	45 0f b6 c0          	movzbl %r8b,%r8d
     6b4:	4c 89 ef             	mov    %r13,%rdi
     6b7:	e8 00 00 00 00       	callq  6bc <record_pos_htable+0x12c>
    he->invalid = 1;
    he->hd_pos = cpu_to_le32(pos);
    nova_flush_buffer(he, sizeof(struct hash_entry),0);
    
out:
    return 0;
     6bc:	31 c0                	xor    %eax,%eax
        record_pos_htable_ls(sb, tail, hashname,  pos, hlevel);
        goto out;
    } else {
        hlevel ++;
        record_pos_htable_ls(sb, tail, hashname, pos, hlevel);
        goto out;
     6be:	eb c8                	jmp    688 <record_pos_htable+0xf8>
     6c0:	48 c1 e6 04          	shl    $0x4,%rsi

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
     6c4:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 6ca <record_pos_htable+0x13a>
     6ca:	48 01 f3             	add    %rsi,%rbx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
     6cd:	89 c6                	mov    %eax,%esi
     6cf:	83 e6 3f             	and    $0x3f,%esi
fill_he:
    //he = &ht->hash_entry[h_pos];
    //nova_dbg("%s mark in pos %d",__func__, h_pos);
    he->hd_name = cpu_to_le64(hashname);
    he->invalid = 1;
    he->hd_pos = cpu_to_le32(pos);
     6d2:	89 4b 44             	mov    %ecx,0x44(%rbx)
	if (support_clwb) {
     6d5:	31 c9                	xor    %ecx,%ecx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
     6d7:	83 c6 10             	add    $0x10,%esi
	if (support_clwb) {
     6da:	85 d2                	test   %edx,%edx
    }

fill_he:
    //he = &ht->hash_entry[h_pos];
    //nova_dbg("%s mark in pos %d",__func__, h_pos);
    he->hd_name = cpu_to_le64(hashname);
     6dc:	4c 89 63 48          	mov    %r12,0x48(%rbx)
    he->invalid = 1;
     6e0:	c6 43 43 01          	movb   $0x1,0x43(%rbx)
     6e4:	74 14                	je     6fa <record_pos_htable+0x16a>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
     6e6:	89 ca                	mov    %ecx,%edx
     6e8:	48 01 c2             	add    %rax,%rdx
     6eb:	66 0f ae 32          	clwb   (%rdx)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     6ef:	83 c1 40             	add    $0x40,%ecx
     6f2:	39 ce                	cmp    %ecx,%esi
     6f4:	77 f0                	ja     6e6 <record_pos_htable+0x156>
    he->hd_pos = cpu_to_le32(pos);
    nova_flush_buffer(he, sizeof(struct hash_entry),0);
    
out:
    return 0;
     6f6:	31 c0                	xor    %eax,%eax
     6f8:	eb 8e                	jmp    688 <record_pos_htable+0xf8>
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
     6fa:	89 ca                	mov    %ecx,%edx
     6fc:	48 01 c2             	add    %rax,%rdx
     6ff:	0f ae 3a             	clflush (%rdx)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     702:	83 c1 40             	add    $0x40,%ecx
     705:	39 ce                	cmp    %ecx,%esi
     707:	77 f1                	ja     6fa <record_pos_htable+0x16a>
     709:	eb eb                	jmp    6f6 <record_pos_htable+0x166>
}
     70b:	e8 00 00 00 00       	callq  710 <lookup_ht_le>

0000000000000710 <lookup_ht_le>:

int lookup_ht_le(struct super_block *sb, u64 block, u64 hashname, u8 hlevel, u32 *pos)
{
     710:	e8 00 00 00 00       	callq  715 <lookup_ht_le+0x5>
     715:	55                   	push   %rbp
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     716:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     71d:	48 89 f7             	mov    %rsi,%rdi
     720:	48 89 e5             	mov    %rsp,%rbp
     723:	48 03 78 18          	add    0x18(%rax),%rdi
     727:	48 85 f6             	test   %rsi,%rsi
     72a:	48 89 f8             	mov    %rdi,%rax
     72d:	bf 00 00 00 00       	mov    $0x0,%edi
     732:	48 0f 45 f8          	cmovne %rax,%rdi
     736:	b8 01 00 00 00       	mov    $0x1,%eax
     73b:	48 8d 4f 03          	lea    0x3(%rdi),%rcx
     73f:	eb 0e                	jmp    74f <lookup_ht_le+0x3f>
     741:	83 c0 01             	add    $0x1,%eax
     744:	48 83 c1 10          	add    $0x10,%rcx
    //block = nova_get_block_off(sb, blocknr, HTABLE_SIZE);
    ht = (struct hash_table_le *)nova_get_block(sb, block);  

    h_pos = 0;

    while(h_pos< NR_HASH_ENTRIES_L5) {
     748:	3d 01 10 00 00       	cmp    $0x1001,%eax
     74d:	74 20                	je     76f <lookup_ht_le+0x5f>
        he = &ht->hash_entry[h_pos];
        valid_flag = ht->hash_entry[h_pos].invalid;
        if(!valid_flag){
     74f:	80 39 00             	cmpb   $0x0,(%rcx)
     752:	8d 70 ff             	lea    -0x1(%rax),%esi
     755:	74 ea                	je     741 <lookup_ht_le+0x31>
            h_pos++;
            continue;
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
     757:	48 39 51 05          	cmp    %rdx,0x5(%rcx)
     75b:	75 e4                	jne    741 <lookup_ht_le+0x31>
            *pos = le32_to_cpu(he->hd_pos);
     75d:	48 c1 e6 04          	shl    $0x4,%rsi
     761:	8b 44 37 04          	mov    0x4(%rdi,%rsi,1),%eax
        }
    }

out: 
    return ret;
}
     765:	5d                   	pop    %rbp
            continue;
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
            *pos = le32_to_cpu(he->hd_pos);
     766:	41 89 00             	mov    %eax,(%r8)
            ret = 1;
     769:	b8 01 00 00 00       	mov    $0x1,%eax
        }
    }

out: 
    return ret;
}
     76e:	c3                   	retq   
{
    struct hash_table_le *ht;
    struct hash_entry *he;
    u32 h_pos;
    //u64 tail;
    int  ret=0;
     76f:	31 c0                	xor    %eax,%eax
        }
    }

out: 
    return ret;
}
     771:	5d                   	pop    %rbp
     772:	c3                   	retq   
     773:	0f 1f 00             	nopl   (%rax)
     776:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     77d:	00 00 00 

0000000000000780 <lookup_ht_lf>:

int lookup_ht_lf(struct super_block *sb, u64 block, u64 hashname, u8 hlevel, u32 *pos)
{
     780:	e8 00 00 00 00       	callq  785 <lookup_ht_lf+0x5>
     785:	55                   	push   %rbp
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     786:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
     78d:	49 89 d1             	mov    %rdx,%r9
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     790:	48 85 f6             	test   %rsi,%rsi
     793:	4c 89 c9             	mov    %r9,%rcx
     796:	48 89 e5             	mov    %rsp,%rbp
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     799:	48 8b 78 18          	mov    0x18(%rax),%rdi
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     79d:	b8 00 00 00 00       	mov    $0x0,%eax
     7a2:	48 8d 14 37          	lea    (%rdi,%rsi,1),%rdx
     7a6:	48 0f 45 c2          	cmovne %rdx,%rax
     7aa:	48 ba 01 10 00 02 40 	movabs $0x8004002001001,%rdx
     7b1:	00 08 00 
     7b4:	48 89 c6             	mov    %rax,%rsi
     7b7:	4c 89 c8             	mov    %r9,%rax
     7ba:	48 f7 e2             	mul    %rdx
     7bd:	4c 89 c8             	mov    %r9,%rax
     7c0:	48 29 d0             	sub    %rdx,%rax
     7c3:	48 d1 e8             	shr    %rax
     7c6:	48 01 c2             	add    %rax,%rdx
     7c9:	48 c1 ea 0c          	shr    $0xc,%rdx
     7cd:	48 89 d0             	mov    %rdx,%rax
     7d0:	48 c1 e0 0d          	shl    $0xd,%rax
     7d4:	48 29 d0             	sub    %rdx,%rax
     7d7:	48 29 c1             	sub    %rax,%rcx
     7da:	8d 14 8d fd ff ff ff 	lea    -0x3(,%rcx,4),%edx
    //block = nova_get_block_off(sb, blocknr, HTABLE_SIZE);
    ht = (struct hash_table_lf *)nova_get_block(sb, block);  
    buckets = 8191;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;
     7e1:	b9 01 00 00 00       	mov    $0x1,%ecx
     7e6:	44 8d 52 ff          	lea    -0x1(%rdx),%r10d
     7ea:	4c 89 d0             	mov    %r10,%rax
     7ed:	48 c1 e0 04          	shl    $0x4,%rax
     7f1:	48 01 f0             	add    %rsi,%rax

    while(i < offset) {
        he = &ht->hash_entry[h_pos];
        valid_flag = ht->hash_entry[h_pos].invalid;
        if(!valid_flag){
     7f4:	80 78 43 00          	cmpb   $0x0,0x43(%rax)
     7f8:	74 06                	je     800 <lookup_ht_lf+0x80>
            h_pos++;
            continue;
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
     7fa:	4c 3b 48 48          	cmp    0x48(%rax),%r9
     7fe:	74 58                	je     858 <lookup_ht_lf+0xd8>
     800:	83 c1 01             	add    $0x1,%ecx
     803:	83 c2 01             	add    $0x1,%edx
    buckets = 8191;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;

    while(i < offset) {
     806:	83 f9 05             	cmp    $0x5,%ecx
     809:	75 db                	jne    7e6 <lookup_ht_lf+0x66>
            h_pos++;
        }
    }

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
     80b:	48 8b 56 38          	mov    0x38(%rsi),%rdx
{
    struct hash_table_lf *ht;
    struct hash_entry *he;
    u32 h_pos, buckets, offset, s_pos = 0;
    u64 tail;
    int i = 0, ret=0;
     80f:	31 c0                	xor    %eax,%eax
        }
    }

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
    if(tail) {
     811:	48 85 d2             	test   %rdx,%rdx
     814:	74 3a                	je     850 <lookup_ht_lf+0xd0>
     816:	48 01 d7             	add    %rdx,%rdi
     819:	b8 01 00 00 00       	mov    $0x1,%eax
     81e:	48 8d 57 03          	lea    0x3(%rdi),%rdx
     822:	eb 0e                	jmp    832 <lookup_ht_lf+0xb2>
     824:	83 c0 01             	add    $0x1,%eax
     827:	48 83 c2 10          	add    $0x10,%rdx
    //block = nova_get_block_off(sb, blocknr, HTABLE_SIZE);
    ht = (struct hash_table_le *)nova_get_block(sb, block);  

    h_pos = 0;

    while(h_pos< NR_HASH_ENTRIES_L5) {
     82b:	3d 01 10 00 00       	cmp    $0x1001,%eax
     830:	74 20                	je     852 <lookup_ht_lf+0xd2>
        he = &ht->hash_entry[h_pos];
        valid_flag = ht->hash_entry[h_pos].invalid;
        if(!valid_flag){
     832:	80 3a 00             	cmpb   $0x0,(%rdx)
     835:	8d 48 ff             	lea    -0x1(%rax),%ecx
     838:	74 ea                	je     824 <lookup_ht_lf+0xa4>
            h_pos++;
            continue;
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
     83a:	4c 3b 4a 05          	cmp    0x5(%rdx),%r9
     83e:	75 e4                	jne    824 <lookup_ht_lf+0xa4>
            *pos = le32_to_cpu(he->hd_pos);
     840:	48 c1 e1 04          	shl    $0x4,%rcx
            ret = 1;
     844:	b8 01 00 00 00       	mov    $0x1,%eax
            continue;
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
            *pos = le32_to_cpu(he->hd_pos);
     849:	8b 54 0f 04          	mov    0x4(%rdi,%rcx,1),%edx
    tail = le64_to_cpu(ht->hash_tail);
    if(tail) {
        //nova_dbg("%s need to find in next hashtable 0x%llu",__func__,tail);
        hlevel++;
        ret = lookup_ht_le(sb, tail, hashname, hlevel, &s_pos);
        *pos = s_pos;
     84d:	41 89 10             	mov    %edx,(%r8)
    }
out: 
    return ret;
}
     850:	5d                   	pop    %rbp
     851:	c3                   	retq   

int lookup_ht_lf(struct super_block *sb, u64 block, u64 hashname, u8 hlevel, u32 *pos)
{
    struct hash_table_lf *ht;
    struct hash_entry *he;
    u32 h_pos, buckets, offset, s_pos = 0;
     852:	31 d2                	xor    %edx,%edx
{
    struct hash_table_le *ht;
    struct hash_entry *he;
    u32 h_pos;
    //u64 tail;
    int  ret=0;
     854:	31 c0                	xor    %eax,%eax
     856:	eb f5                	jmp    84d <lookup_ht_lf+0xcd>
            continue;
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
            *pos = le32_to_cpu(he->hd_pos);
     858:	49 83 c2 04          	add    $0x4,%r10
     85c:	49 c1 e2 04          	shl    $0x4,%r10
     860:	42 8b 44 16 04       	mov    0x4(%rsi,%r10,1),%eax
        ret = lookup_ht_le(sb, tail, hashname, hlevel, &s_pos);
        *pos = s_pos;
    }
out: 
    return ret;
}
     865:	5d                   	pop    %rbp
            continue;
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
            *pos = le32_to_cpu(he->hd_pos);
     866:	41 89 00             	mov    %eax,(%r8)
            ret = 1;
     869:	b8 01 00 00 00       	mov    $0x1,%eax
        ret = lookup_ht_le(sb, tail, hashname, hlevel, &s_pos);
        *pos = s_pos;
    }
out: 
    return ret;
}
     86e:	c3                   	retq   
     86f:	90                   	nop

0000000000000870 <lookup_ht_lt>:

int lookup_ht_lt(struct super_block *sb, u64 block, u64 hashname, u8 hlevel, u32 *pos)
{
     870:	e8 00 00 00 00       	callq  875 <lookup_ht_lt+0x5>
     875:	55                   	push   %rbp
     876:	49 89 d1             	mov    %rdx,%r9
     879:	48 ba 01 01 40 00 10 	movabs $0x4001000400101,%rdx
     880:	00 04 00 
     883:	48 89 e5             	mov    %rsp,%rbp
     886:	53                   	push   %rbx
     887:	4c 89 c3             	mov    %r8,%rbx
     88a:	49 89 f0             	mov    %rsi,%r8
     88d:	48 83 ec 10          	sub    $0x10,%rsp
    struct hash_table_lt *ht;
    struct hash_entry *he;
    u32 h_pos, buckets, offset, s_pos = 0;
     891:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
out: 
    return ret;
}

int lookup_ht_lt(struct super_block *sb, u64 block, u64 hashname, u8 hlevel, u32 *pos)
{
     898:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     89f:	00 00 
     8a1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
     8a5:	31 c0                	xor    %eax,%eax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     8a7:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     8ae:	4c 03 40 18          	add    0x18(%rax),%r8
     8b2:	48 85 f6             	test   %rsi,%rsi
     8b5:	b8 00 00 00 00       	mov    $0x0,%eax
     8ba:	4c 89 ce             	mov    %r9,%rsi
     8bd:	4c 0f 44 c0          	cmove  %rax,%r8
     8c1:	4c 89 c8             	mov    %r9,%rax
     8c4:	48 f7 e2             	mul    %rdx
     8c7:	4c 89 c8             	mov    %r9,%rax
     8ca:	48 29 d0             	sub    %rdx,%rax
     8cd:	48 d1 e8             	shr    %rax
     8d0:	48 01 c2             	add    %rax,%rdx
     8d3:	48 c1 ea 0d          	shr    $0xd,%rdx
     8d7:	48 89 d0             	mov    %rdx,%rax
     8da:	48 c1 e0 0e          	shl    $0xe,%rax
     8de:	48 29 d0             	sub    %rdx,%rax
     8e1:	48 29 c6             	sub    %rax,%rsi
     8e4:	8d 14 b5 fd ff ff ff 	lea    -0x3(,%rsi,4),%edx
    //block = nova_get_block_off(sb, blocknr, HTABLE_SIZE);
    ht = (struct hash_table_lt *)nova_get_block(sb, block);  
    buckets = 16383;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;
     8eb:	be 01 00 00 00       	mov    $0x1,%esi
     8f0:	44 8d 52 ff          	lea    -0x1(%rdx),%r10d
     8f4:	4c 89 d0             	mov    %r10,%rax
     8f7:	48 c1 e0 04          	shl    $0x4,%rax
     8fb:	4c 01 c0             	add    %r8,%rax

    while(i < offset) {
        he = &ht->hash_entry[h_pos];
        valid_flag = ht->hash_entry[h_pos].invalid;
        if(!valid_flag){
     8fe:	80 78 43 00          	cmpb   $0x0,0x43(%rax)
     902:	74 06                	je     90a <lookup_ht_lt+0x9a>
            h_pos++;
            continue;
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
     904:	4c 3b 48 48          	cmp    0x48(%rax),%r9
     908:	74 43                	je     94d <lookup_ht_lt+0xdd>
     90a:	83 c6 01             	add    $0x1,%esi
     90d:	83 c2 01             	add    $0x1,%edx
    buckets = 16383;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;

    while(i < offset) {
     910:	83 fe 05             	cmp    $0x5,%esi
     913:	75 db                	jne    8f0 <lookup_ht_lt+0x80>
            h_pos++;
        }
    }

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
     915:	49 8b 70 38          	mov    0x38(%r8),%rsi
{
    struct hash_table_lt *ht;
    struct hash_entry *he;
    u32 h_pos, buckets, offset, s_pos = 0;
    u64 tail;
    int i = 0, ret=0;
     919:	31 c0                	xor    %eax,%eax
        }
    }

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
    if(tail) {
     91b:	48 85 f6             	test   %rsi,%rsi
     91e:	74 17                	je     937 <lookup_ht_lt+0xc7>
        //nova_dbg("%s need to find in next hashtable 0x%llu",__func__,tail);
        hlevel++;
        ret = lookup_ht_lf(sb, tail, hashname, hlevel, &s_pos);
     920:	83 c1 01             	add    $0x1,%ecx
     923:	4c 8d 45 ec          	lea    -0x14(%rbp),%r8
     927:	4c 89 ca             	mov    %r9,%rdx
     92a:	0f b6 c9             	movzbl %cl,%ecx
     92d:	e8 00 00 00 00       	callq  932 <lookup_ht_lt+0xc2>
        *pos = s_pos;
     932:	8b 55 ec             	mov    -0x14(%rbp),%edx
     935:	89 13                	mov    %edx,(%rbx)
    }
out: 
    return ret;
}
     937:	48 8b 5d f0          	mov    -0x10(%rbp),%rbx
     93b:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
     942:	00 00 
     944:	75 1d                	jne    963 <lookup_ht_lt+0xf3>
     946:	48 83 c4 10          	add    $0x10,%rsp
     94a:	5b                   	pop    %rbx
     94b:	5d                   	pop    %rbp
     94c:	c3                   	retq   
            continue;
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
            *pos = le32_to_cpu(he->hd_pos);
     94d:	49 83 c2 04          	add    $0x4,%r10
     951:	49 c1 e2 04          	shl    $0x4,%r10
     955:	43 8b 44 10 04       	mov    0x4(%r8,%r10,1),%eax
     95a:	89 03                	mov    %eax,(%rbx)
            ret = 1;
     95c:	b8 01 00 00 00       	mov    $0x1,%eax
            goto out;
     961:	eb d4                	jmp    937 <lookup_ht_lt+0xc7>
        ret = lookup_ht_lf(sb, tail, hashname, hlevel, &s_pos);
        *pos = s_pos;
    }
out: 
    return ret;
}
     963:	e8 00 00 00 00       	callq  968 <lookup_ht_lt+0xf8>
     968:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
     96f:	00 

0000000000000970 <lookup_ht_ls>:
/*look up hashname in hash table for right position
 * &pos for position of dentry
 * hlevel for hash table level 
 * return 1 for found*/
int lookup_ht_ls(struct super_block *sb, u64 block, u64 hashname, u8 hlevel, u32 *pos)
{
     970:	e8 00 00 00 00       	callq  975 <lookup_ht_ls+0x5>
     975:	55                   	push   %rbp
     976:	49 89 d1             	mov    %rdx,%r9
     979:	48 ba 11 00 08 00 04 	movabs $0x2000400080011,%rdx
     980:	00 02 00 
     983:	48 89 e5             	mov    %rsp,%rbp
     986:	53                   	push   %rbx
     987:	4c 89 c3             	mov    %r8,%rbx
     98a:	49 89 f0             	mov    %rsi,%r8
     98d:	48 83 ec 10          	sub    $0x10,%rsp
    struct hash_table_ls *ht;
    struct hash_entry *he;
    u32 h_pos, buckets, offset, s_pos = 0;
     991:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
/*look up hashname in hash table for right position
 * &pos for position of dentry
 * hlevel for hash table level 
 * return 1 for found*/
int lookup_ht_ls(struct super_block *sb, u64 block, u64 hashname, u8 hlevel, u32 *pos)
{
     998:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     99f:	00 00 
     9a1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
     9a5:	31 c0                	xor    %eax,%eax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     9a7:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     9ae:	4c 03 40 18          	add    0x18(%rax),%r8
     9b2:	48 85 f6             	test   %rsi,%rsi
     9b5:	b8 00 00 00 00       	mov    $0x0,%eax
     9ba:	4c 89 ce             	mov    %r9,%rsi
     9bd:	4c 0f 44 c0          	cmove  %rax,%r8
     9c1:	4c 89 c8             	mov    %r9,%rax
     9c4:	48 f7 e2             	mul    %rdx
     9c7:	4c 89 c8             	mov    %r9,%rax
     9ca:	48 29 d0             	sub    %rdx,%rax
     9cd:	48 d1 e8             	shr    %rax
     9d0:	48 01 c2             	add    %rax,%rdx
     9d3:	48 c1 ea 0e          	shr    $0xe,%rdx
     9d7:	48 89 d0             	mov    %rdx,%rax
     9da:	48 c1 e0 0f          	shl    $0xf,%rax
     9de:	48 29 d0             	sub    %rdx,%rax
     9e1:	48 29 c6             	sub    %rax,%rsi
     9e4:	8d 14 b5 fd ff ff ff 	lea    -0x3(,%rsi,4),%edx
    //block = nova_get_block_off(sb, blocknr, HTABLE_SIZE);
    ht = (struct hash_table_ls *)nova_get_block(sb, block);  
    buckets = 32767;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;
     9eb:	be 01 00 00 00       	mov    $0x1,%esi
     9f0:	44 8d 52 ff          	lea    -0x1(%rdx),%r10d
     9f4:	4c 89 d0             	mov    %r10,%rax
     9f7:	48 c1 e0 04          	shl    $0x4,%rax
     9fb:	4c 01 c0             	add    %r8,%rax

    while(i < offset) {
        he = &ht->hash_entry[h_pos];
        valid_flag = ht->hash_entry[h_pos].invalid;
        if(!valid_flag){
     9fe:	80 78 43 00          	cmpb   $0x0,0x43(%rax)
     a02:	74 06                	je     a0a <lookup_ht_ls+0x9a>
            h_pos++;
            continue;
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
     a04:	4c 3b 48 48          	cmp    0x48(%rax),%r9
     a08:	74 43                	je     a4d <lookup_ht_ls+0xdd>
     a0a:	83 c6 01             	add    $0x1,%esi
     a0d:	83 c2 01             	add    $0x1,%edx
    buckets = 32767;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;

    while(i < offset) {
     a10:	83 fe 05             	cmp    $0x5,%esi
     a13:	75 db                	jne    9f0 <lookup_ht_ls+0x80>
            h_pos++;
        }
    }

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
     a15:	49 8b 70 38          	mov    0x38(%r8),%rsi
{
    struct hash_table_ls *ht;
    struct hash_entry *he;
    u32 h_pos, buckets, offset, s_pos = 0;
    u64 tail;
    int i = 0, ret=0;
     a19:	31 c0                	xor    %eax,%eax
        }
    }

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
    if(tail) {
     a1b:	48 85 f6             	test   %rsi,%rsi
     a1e:	74 17                	je     a37 <lookup_ht_ls+0xc7>
        //nova_dbg("%s need to find in next hashtable 0x%llu",__func__,tail);
        hlevel++;
        ret = lookup_ht_lt(sb, tail, hashname, hlevel, &s_pos);
     a20:	83 c1 01             	add    $0x1,%ecx
     a23:	4c 8d 45 ec          	lea    -0x14(%rbp),%r8
     a27:	4c 89 ca             	mov    %r9,%rdx
     a2a:	0f b6 c9             	movzbl %cl,%ecx
     a2d:	e8 00 00 00 00       	callq  a32 <lookup_ht_ls+0xc2>
        *pos = s_pos;
     a32:	8b 55 ec             	mov    -0x14(%rbp),%edx
     a35:	89 13                	mov    %edx,(%rbx)
    }
out: 
    return ret;
}
     a37:	48 8b 5d f0          	mov    -0x10(%rbp),%rbx
     a3b:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
     a42:	00 00 
     a44:	75 1d                	jne    a63 <lookup_ht_ls+0xf3>
     a46:	48 83 c4 10          	add    $0x10,%rsp
     a4a:	5b                   	pop    %rbx
     a4b:	5d                   	pop    %rbp
     a4c:	c3                   	retq   
            continue;
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
            *pos = le32_to_cpu(he->hd_pos);
     a4d:	49 83 c2 04          	add    $0x4,%r10
     a51:	49 c1 e2 04          	shl    $0x4,%r10
     a55:	43 8b 44 10 04       	mov    0x4(%r8,%r10,1),%eax
     a5a:	89 03                	mov    %eax,(%rbx)
            ret = 1;
     a5c:	b8 01 00 00 00       	mov    $0x1,%eax
            goto out;
     a61:	eb d4                	jmp    a37 <lookup_ht_ls+0xc7>
        ret = lookup_ht_lt(sb, tail, hashname, hlevel, &s_pos);
        *pos = s_pos;
    }
out: 
    return ret;
}
     a63:	e8 00 00 00 00       	callq  a68 <lookup_ht_ls+0xf8>
     a68:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
     a6f:	00 

0000000000000a70 <lookup_in_hashtable>:
/*look up hashname in hash table for right position
 * &pos for position of dentry
 * hlevel for hash table level 
 * return 1 for found*/
int lookup_in_hashtable(struct super_block *sb, u64 block, u64 hashname, u8 hlevel, u32 *pos)
{
     a70:	e8 00 00 00 00       	callq  a75 <lookup_in_hashtable+0x5>
     a75:	55                   	push   %rbp
     a76:	48 89 e5             	mov    %rsp,%rbp
     a79:	41 54                	push   %r12
     a7b:	53                   	push   %rbx
     a7c:	48 83 ec 10          	sub    $0x10,%rsp
    struct hash_table *ht;
    struct hash_entry *he;
    //struct ht_ptr *ht_p;
    u32 h_pos, buckets, offset, s_pos=0;
     a80:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
/*look up hashname in hash table for right position
 * &pos for position of dentry
 * hlevel for hash table level 
 * return 1 for found*/
int lookup_in_hashtable(struct super_block *sb, u64 block, u64 hashname, u8 hlevel, u32 *pos)
{
     a87:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     a8e:	00 00 
     a90:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
     a94:	31 c0                	xor    %eax,%eax
    u64 h_name;
    u8 valid_flag;

    //block = nova_get_block_off(sb, blocknr, HTABLE_SIZE);
    //nova_dbg("%s start",__func__);
    BUG_ON(block==0);
     a96:	48 85 f6             	test   %rsi,%rsi
     a99:	0f 84 b0 00 00 00    	je     b4f <lookup_in_hashtable+0xdf>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     a9f:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
     aa6:	49 89 d4             	mov    %rdx,%r12
     aa9:	48 ba 01 80 00 80 00 	movabs $0x8000800080008001,%rdx
     ab0:	80 00 80 
     ab3:	4c 89 c3             	mov    %r8,%rbx
    ht = (struct hash_table *)nova_get_block(sb, block);  

    buckets = 65535;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;
     ab6:	41 ba 01 00 00 00    	mov    $0x1,%r10d
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     abc:	48 03 70 18          	add    0x18(%rax),%rsi
     ac0:	4c 89 e0             	mov    %r12,%rax
     ac3:	48 f7 e2             	mul    %rdx
     ac6:	48 c1 ea 0f          	shr    $0xf,%rdx
     aca:	48 89 d0             	mov    %rdx,%rax
     acd:	48 c1 e0 10          	shl    $0x10,%rax
     ad1:	48 29 d0             	sub    %rdx,%rax
     ad4:	4c 89 e2             	mov    %r12,%rdx
     ad7:	48 29 c2             	sub    %rax,%rdx
     ada:	44 8d 0c 95 fd ff ff 	lea    -0x3(,%rdx,4),%r9d
     ae1:	ff 
     ae2:	45 8d 59 ff          	lea    -0x1(%r9),%r11d
     ae6:	4c 89 d8             	mov    %r11,%rax
     ae9:	48 c1 e0 04          	shl    $0x4,%rax
     aed:	48 01 f0             	add    %rsi,%rax

    while(i < offset) {
        he = &ht->hash_entry[h_pos];
        valid_flag = ht->hash_entry[h_pos].invalid;
        if(!valid_flag){
     af0:	80 78 43 00          	cmpb   $0x0,0x43(%rax)
     af4:	74 06                	je     afc <lookup_in_hashtable+0x8c>
            i++;
            h_pos++;
        }else{
            /*found valid pos*/
            h_name = le64_to_cpu(he->hd_name);
            if(h_name==hashname){
     af6:	4c 3b 60 48          	cmp    0x48(%rax),%r12
     afa:	74 55                	je     b51 <lookup_in_hashtable+0xe1>
     afc:	41 83 c2 01          	add    $0x1,%r10d
     b00:	41 83 c1 01          	add    $0x1,%r9d
    buckets = 65535;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;

    while(i < offset) {
     b04:	41 83 fa 05          	cmp    $0x5,%r10d
     b08:	75 d8                	jne    ae2 <lookup_in_hashtable+0x72>
            }
        }
    }

    //nova_dbg("%s:not find pos",__func__);
    tail = le64_to_cpu(ht->hash_tail);
     b0a:	48 8b 76 38          	mov    0x38(%rsi),%rsi
    //BUG_ON(tail==NULL);
    if(tail) {
     b0e:	48 85 f6             	test   %rsi,%rsi
     b11:	75 23                	jne    b36 <lookup_in_hashtable+0xc6>
        hlevel++;
        ret = lookup_ht_ls(sb, tail, hashname, hlevel, &s_pos);
        *pos = s_pos;

    } else
        nova_dbgv("%s:not find tail ",__func__);
     b13:	f6 05 00 00 00 00 10 	testb  $0x10,0x0(%rip)        # b1a <lookup_in_hashtable+0xaa>
     b1a:	75 4b                	jne    b67 <lookup_in_hashtable+0xf7>
    struct hash_table *ht;
    struct hash_entry *he;
    //struct ht_ptr *ht_p;
    u32 h_pos, buckets, offset, s_pos=0;
    u64 tail;
    int i = 0, ret=0;
     b1c:	31 c0                	xor    %eax,%eax
        nova_dbgv("%s:not find tail ",__func__);

out: 
    //nova_dbg("dafs finish lookup in hash table");
    return ret;
}
     b1e:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
     b22:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
     b29:	00 00 
     b2b:	75 51                	jne    b7e <lookup_in_hashtable+0x10e>
     b2d:	48 83 c4 10          	add    $0x10,%rsp
     b31:	5b                   	pop    %rbx
     b32:	41 5c                	pop    %r12
     b34:	5d                   	pop    %rbp
     b35:	c3                   	retq   
    tail = le64_to_cpu(ht->hash_tail);
    //BUG_ON(tail==NULL);
    if(tail) {
        //nova_dbg("%s need to find in next hashtable 0x%llu",__func__,tail);
        hlevel++;
        ret = lookup_ht_ls(sb, tail, hashname, hlevel, &s_pos);
     b36:	83 c1 01             	add    $0x1,%ecx
     b39:	4c 8d 45 e4          	lea    -0x1c(%rbp),%r8
     b3d:	4c 89 e2             	mov    %r12,%rdx
     b40:	0f b6 c9             	movzbl %cl,%ecx
     b43:	e8 00 00 00 00       	callq  b48 <lookup_in_hashtable+0xd8>
        *pos = s_pos;
     b48:	8b 55 e4             	mov    -0x1c(%rbp),%edx
     b4b:	89 13                	mov    %edx,(%rbx)
     b4d:	eb cf                	jmp    b1e <lookup_in_hashtable+0xae>
    u64 h_name;
    u8 valid_flag;

    //block = nova_get_block_off(sb, blocknr, HTABLE_SIZE);
    //nova_dbg("%s start",__func__);
    BUG_ON(block==0);
     b4f:	0f 0b                	ud2    
        }else{
            /*found valid pos*/
            h_name = le64_to_cpu(he->hd_name);
            if(h_name==hashname){
                //nova_dbg("%s hashname %llu, pos %d",__func__, h_name, he->hd_pos);
                *pos = le32_to_cpu(he->hd_pos);
     b51:	49 83 c3 04          	add    $0x4,%r11
     b55:	49 c1 e3 04          	shl    $0x4,%r11
     b59:	42 8b 44 1e 04       	mov    0x4(%rsi,%r11,1),%eax
     b5e:	89 03                	mov    %eax,(%rbx)
                ret = 1;
     b60:	b8 01 00 00 00       	mov    $0x1,%eax
                goto out;
     b65:	eb b7                	jmp    b1e <lookup_in_hashtable+0xae>
        hlevel++;
        ret = lookup_ht_ls(sb, tail, hashname, hlevel, &s_pos);
        *pos = s_pos;

    } else
        nova_dbgv("%s:not find tail ",__func__);
     b67:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     b6e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     b75:	e8 00 00 00 00       	callq  b7a <lookup_in_hashtable+0x10a>
    struct hash_table *ht;
    struct hash_entry *he;
    //struct ht_ptr *ht_p;
    u32 h_pos, buckets, offset, s_pos=0;
    u64 tail;
    int i = 0, ret=0;
     b7a:	31 c0                	xor    %eax,%eax
     b7c:	eb a0                	jmp    b1e <lookup_in_hashtable+0xae>
        nova_dbgv("%s:not find tail ",__func__);

out: 
    //nova_dbg("dafs finish lookup in hash table");
    return ret;
}
     b7e:	e8 00 00 00 00       	callq  b83 <lookup_in_hashtable+0x113>
     b83:	0f 1f 00             	nopl   (%rax)
     b86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     b8d:	00 00 00 

0000000000000b90 <make_invalid_ht_le>:

int make_invalid_ht_le(struct super_block *sb, u64 block, u64 hashname, u8 hlevel)
{
     b90:	e8 00 00 00 00       	callq  b95 <make_invalid_ht_le+0x5>
     b95:	55                   	push   %rbp
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     b96:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     b9d:	48 89 f7             	mov    %rsi,%rdi
     ba0:	48 89 e5             	mov    %rsp,%rbp
     ba3:	48 03 78 18          	add    0x18(%rax),%rdi
     ba7:	48 85 f6             	test   %rsi,%rsi
     baa:	be 00 00 00 00       	mov    $0x0,%esi
     baf:	48 0f 45 f7          	cmovne %rdi,%rsi
    u64 h_name;
    u8 valid_flag;

    ht = (struct hash_table_le *)nova_get_block(sb, block);  

    h_pos = 0;
     bb3:	31 c9                	xor    %ecx,%ecx
     bb5:	89 c8                	mov    %ecx,%eax
     bb7:	48 c1 e0 04          	shl    $0x4,%rax
     bbb:	48 01 f0             	add    %rsi,%rax

    while(h_pos< NR_HASH_ENTRIES_L5) {
        he = &ht->hash_entry[h_pos];
        valid_flag = ht->hash_entry[h_pos].invalid;
        if(!valid_flag){
            h_pos++;
     bbe:	80 78 03 01          	cmpb   $0x1,0x3(%rax)
     bc2:	83 d1 00             	adc    $0x0,%ecx
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
     bc5:	48 39 50 08          	cmp    %rdx,0x8(%rax)
     bc9:	74 0f                	je     bda <make_invalid_ht_le+0x4a>
           he->invalid = 0;
            ret = 1;
            goto out;
        } else {
            h_pos++;
     bcb:	83 c1 01             	add    $0x1,%ecx

    ht = (struct hash_table_le *)nova_get_block(sb, block);  

    h_pos = 0;

    while(h_pos< NR_HASH_ENTRIES_L5) {
     bce:	81 f9 ff 0f 00 00    	cmp    $0xfff,%ecx
     bd4:	76 df                	jbe    bb5 <make_invalid_ht_le+0x25>
{
    struct hash_table_le *ht;
    struct hash_entry *he;
    u32 h_pos;
    //u64 tail;
    int ret=0;
     bd6:	31 c0                	xor    %eax,%eax
            h_pos++;
        }
    }
out:
    return ret;
}
     bd8:	5d                   	pop    %rbp
     bd9:	c3                   	retq   
            h_pos++;
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
           he->invalid = 0;
     bda:	c6 40 03 00          	movb   $0x0,0x3(%rax)
            ret = 1;
     bde:	b8 01 00 00 00       	mov    $0x1,%eax
            h_pos++;
        }
    }
out:
    return ret;
}
     be3:	5d                   	pop    %rbp
     be4:	c3                   	retq   
     be5:	90                   	nop
     be6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     bed:	00 00 00 

0000000000000bf0 <make_invalid_ht_lf>:

int make_invalid_ht_lf(struct super_block *sb, u64 block, u64 hashname, u8 hlevel)
{
     bf0:	e8 00 00 00 00       	callq  bf5 <make_invalid_ht_lf+0x5>
     bf5:	55                   	push   %rbp
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     bf6:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     bfd:	48 85 f6             	test   %rsi,%rsi
     c00:	49 89 d0             	mov    %rdx,%r8
    //block = nova_get_block_off(sb, blocknr, HTABLE_SIZE);
    ht = (struct hash_table_lf *)nova_get_block(sb, block);  
    buckets = 8191;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;
     c03:	48 ba 01 10 00 02 40 	movabs $0x8004002001001,%rdx
     c0a:	00 08 00 
     c0d:	4c 89 c1             	mov    %r8,%rcx
out:
    return ret;
}

int make_invalid_ht_lf(struct super_block *sb, u64 block, u64 hashname, u8 hlevel)
{
     c10:	48 89 e5             	mov    %rsp,%rbp
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     c13:	4c 8b 48 18          	mov    0x18(%rax),%r9
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     c17:	b8 00 00 00 00       	mov    $0x0,%eax
     c1c:	49 8d 3c 31          	lea    (%r9,%rsi,1),%rdi
     c20:	48 0f 44 f8          	cmove  %rax,%rdi
    //block = nova_get_block_off(sb, blocknr, HTABLE_SIZE);
    ht = (struct hash_table_lf *)nova_get_block(sb, block);  
    buckets = 8191;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;
     c24:	4c 89 c0             	mov    %r8,%rax
     c27:	48 f7 e2             	mul    %rdx
     c2a:	4c 89 c0             	mov    %r8,%rax
     c2d:	48 29 d0             	sub    %rdx,%rax
     c30:	48 d1 e8             	shr    %rax
     c33:	48 01 c2             	add    %rax,%rdx
     c36:	48 c1 ea 0c          	shr    $0xc,%rdx
     c3a:	48 89 d0             	mov    %rdx,%rax
     c3d:	48 c1 e0 0d          	shl    $0xd,%rax
     c41:	48 29 d0             	sub    %rdx,%rax
     c44:	48 29 c1             	sub    %rax,%rcx
     c47:	8d 04 8d fc ff ff ff 	lea    -0x4(,%rcx,4),%eax
{
    struct hash_table_lf *ht;
    struct hash_entry *he;
    u32 h_pos, buckets, offset;
    u64 tail;
    int i = 0, ret=0;
     c4e:	31 c9                	xor    %ecx,%ecx
     c50:	eb 0b                	jmp    c5d <make_invalid_ht_lf+0x6d>
        if(h_name==hashname){
            he->invalid = 0;
            ret = 1;
            goto out;
        } else {
            i++;
     c52:	83 c1 01             	add    $0x1,%ecx
            h_pos++;
     c55:	83 c0 01             	add    $0x1,%eax
    buckets = 8191;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;

    while(i < offset) {
     c58:	83 f9 03             	cmp    $0x3,%ecx
     c5b:	7f 32                	jg     c8f <make_invalid_ht_lf+0x9f>
     c5d:	89 c6                	mov    %eax,%esi
     c5f:	48 89 f2             	mov    %rsi,%rdx
     c62:	48 c1 e2 04          	shl    $0x4,%rdx
     c66:	48 01 fa             	add    %rdi,%rdx
        he = &ht->hash_entry[h_pos];
        valid_flag = ht->hash_entry[h_pos].invalid;
        if(!valid_flag){
     c69:	80 7a 43 00          	cmpb   $0x0,0x43(%rdx)
     c6d:	75 06                	jne    c75 <make_invalid_ht_lf+0x85>
            i++;
     c6f:	83 c1 01             	add    $0x1,%ecx
            h_pos++;
     c72:	83 c0 01             	add    $0x1,%eax
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
     c75:	4c 3b 42 48          	cmp    0x48(%rdx),%r8
     c79:	75 d7                	jne    c52 <make_invalid_ht_lf+0x62>
            he->invalid = 0;
     c7b:	48 83 c6 04          	add    $0x4,%rsi
            ret = 1;
     c7f:	b8 01 00 00 00       	mov    $0x1,%eax
            h_pos++;
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
            he->invalid = 0;
     c84:	48 c1 e6 04          	shl    $0x4,%rsi
     c88:	c6 44 37 03 00       	movb   $0x0,0x3(%rdi,%rsi,1)
        hlevel++;
        ret = make_invalid_ht_le(sb, tail, hashname, hlevel);
    }
out: 
    return ret;
}
     c8d:	5d                   	pop    %rbp
     c8e:	c3                   	retq   
            h_pos++;
        }
    }

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
     c8f:	48 8b 57 38          	mov    0x38(%rdi),%rdx
{
    struct hash_table_lf *ht;
    struct hash_entry *he;
    u32 h_pos, buckets, offset;
    u64 tail;
    int i = 0, ret=0;
     c93:	31 c0                	xor    %eax,%eax
        }
    }

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
    if(tail) {
     c95:	48 85 d2             	test   %rdx,%rdx
     c98:	74 f3                	je     c8d <make_invalid_ht_lf+0x9d>
     c9a:	49 01 d1             	add    %rdx,%r9
    u64 h_name;
    u8 valid_flag;

    ht = (struct hash_table_le *)nova_get_block(sb, block);  

    h_pos = 0;
     c9d:	31 d2                	xor    %edx,%edx
     c9f:	89 d0                	mov    %edx,%eax
     ca1:	48 c1 e0 04          	shl    $0x4,%rax
     ca5:	4c 01 c8             	add    %r9,%rax

    while(h_pos< NR_HASH_ENTRIES_L5) {
        he = &ht->hash_entry[h_pos];
        valid_flag = ht->hash_entry[h_pos].invalid;
        if(!valid_flag){
            h_pos++;
     ca8:	80 78 03 01          	cmpb   $0x1,0x3(%rax)
     cac:	83 d2 00             	adc    $0x0,%edx
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
     caf:	4c 3b 40 08          	cmp    0x8(%rax),%r8
     cb3:	74 0f                	je     cc4 <make_invalid_ht_lf+0xd4>
           he->invalid = 0;
            ret = 1;
            goto out;
        } else {
            h_pos++;
     cb5:	83 c2 01             	add    $0x1,%edx

    ht = (struct hash_table_le *)nova_get_block(sb, block);  

    h_pos = 0;

    while(h_pos< NR_HASH_ENTRIES_L5) {
     cb8:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
     cbe:	76 df                	jbe    c9f <make_invalid_ht_lf+0xaf>
{
    struct hash_table_lf *ht;
    struct hash_entry *he;
    u32 h_pos, buckets, offset;
    u64 tail;
    int i = 0, ret=0;
     cc0:	31 c0                	xor    %eax,%eax
        hlevel++;
        ret = make_invalid_ht_le(sb, tail, hashname, hlevel);
    }
out: 
    return ret;
}
     cc2:	5d                   	pop    %rbp
     cc3:	c3                   	retq   
            h_pos++;
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
           he->invalid = 0;
     cc4:	c6 40 03 00          	movb   $0x0,0x3(%rax)
            ret = 1;
     cc8:	b8 01 00 00 00       	mov    $0x1,%eax
        hlevel++;
        ret = make_invalid_ht_le(sb, tail, hashname, hlevel);
    }
out: 
    return ret;
}
     ccd:	5d                   	pop    %rbp
     cce:	c3                   	retq   
     ccf:	90                   	nop

0000000000000cd0 <make_invalid_ht_lt>:

int make_invalid_ht_lt(struct super_block *sb, u64 block, u64 hashname, u8 hlevel)
{
     cd0:	e8 00 00 00 00       	callq  cd5 <make_invalid_ht_lt+0x5>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     cd5:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     cdc:	49 89 f3             	mov    %rsi,%r11
     cdf:	49 89 d2             	mov    %rdx,%r10
    //block = nova_get_block_off(sb, blocknr, HTABLE_SIZE);
    ht = (struct hash_table_lt *)nova_get_block(sb, block);  
    buckets = 16383;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;
     ce2:	48 ba 01 01 40 00 10 	movabs $0x4001000400101,%rdx
     ce9:	00 04 00 
     cec:	4c 03 58 18          	add    0x18(%rax),%r11
     cf0:	48 85 f6             	test   %rsi,%rsi
     cf3:	b8 00 00 00 00       	mov    $0x0,%eax
     cf8:	4c 0f 44 d8          	cmove  %rax,%r11
     cfc:	4c 89 d0             	mov    %r10,%rax
{
    struct hash_table_lt *ht;
    struct hash_entry *he;
    u32 h_pos, buckets, offset;
    u64 tail;
    int i = 0, ret=0;
     cff:	45 31 c0             	xor    %r8d,%r8d
    //block = nova_get_block_off(sb, blocknr, HTABLE_SIZE);
    ht = (struct hash_table_lt *)nova_get_block(sb, block);  
    buckets = 16383;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;
     d02:	48 f7 e2             	mul    %rdx
     d05:	4c 89 d0             	mov    %r10,%rax
     d08:	48 29 d0             	sub    %rdx,%rax
     d0b:	48 d1 e8             	shr    %rax
     d0e:	48 01 c2             	add    %rax,%rdx
     d11:	48 c1 ea 0d          	shr    $0xd,%rdx
     d15:	48 89 d0             	mov    %rdx,%rax
     d18:	48 c1 e0 0e          	shl    $0xe,%rax
     d1c:	48 29 d0             	sub    %rdx,%rax
     d1f:	4c 89 d2             	mov    %r10,%rdx
     d22:	48 29 c2             	sub    %rax,%rdx
     d25:	8d 04 95 fc ff ff ff 	lea    -0x4(,%rdx,4),%eax
     d2c:	eb 0d                	jmp    d3b <make_invalid_ht_lt+0x6b>
        if(h_name==hashname){
            he->invalid = 0;
            ret = 1;
            goto out;
        } else {
            i++;
     d2e:	41 83 c0 01          	add    $0x1,%r8d
            h_pos++;
     d32:	83 c0 01             	add    $0x1,%eax
    buckets = 16383;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;

    while(i < offset) {
     d35:	41 83 f8 03          	cmp    $0x3,%r8d
     d39:	7f 34                	jg     d6f <make_invalid_ht_lt+0x9f>
     d3b:	41 89 c1             	mov    %eax,%r9d
     d3e:	4c 89 ce             	mov    %r9,%rsi
     d41:	48 c1 e6 04          	shl    $0x4,%rsi
     d45:	4c 01 de             	add    %r11,%rsi
        he = &ht->hash_entry[h_pos];
        valid_flag = ht->hash_entry[h_pos].invalid;
        if(!valid_flag){
     d48:	80 7e 43 00          	cmpb   $0x0,0x43(%rsi)
     d4c:	75 07                	jne    d55 <make_invalid_ht_lt+0x85>
            i++;
     d4e:	41 83 c0 01          	add    $0x1,%r8d
            h_pos++;
     d52:	83 c0 01             	add    $0x1,%eax
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
     d55:	4c 3b 56 48          	cmp    0x48(%rsi),%r10
     d59:	75 d3                	jne    d2e <make_invalid_ht_lt+0x5e>
            he->invalid = 0;
     d5b:	49 83 c1 04          	add    $0x4,%r9
            ret = 1;
     d5f:	b8 01 00 00 00       	mov    $0x1,%eax
            h_pos++;
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
            he->invalid = 0;
     d64:	49 c1 e1 04          	shl    $0x4,%r9
     d68:	43 c6 44 0b 03 00    	movb   $0x0,0x3(%r11,%r9,1)
        hlevel++;
        ret = make_invalid_ht_lf(sb, tail, hashname, hlevel);
    }
out: 
    return ret;
}
     d6e:	c3                   	retq   
            h_pos++;
        }
    }

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
     d6f:	49 8b 73 38          	mov    0x38(%r11),%rsi
{
    struct hash_table_lt *ht;
    struct hash_entry *he;
    u32 h_pos, buckets, offset;
    u64 tail;
    int i = 0, ret=0;
     d73:	31 c0                	xor    %eax,%eax
        }
    }

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
    if(tail) {
     d75:	48 85 f6             	test   %rsi,%rsi
     d78:	75 02                	jne    d7c <make_invalid_ht_lt+0xac>
        hlevel++;
        ret = make_invalid_ht_lf(sb, tail, hashname, hlevel);
    }
out: 
    return ret;
}
     d7a:	f3 c3                	repz retq 
out: 
    return ret;
}

int make_invalid_ht_lt(struct super_block *sb, u64 block, u64 hashname, u8 hlevel)
{
     d7c:	55                   	push   %rbp

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
    if(tail) {
        hlevel++;
        ret = make_invalid_ht_lf(sb, tail, hashname, hlevel);
     d7d:	83 c1 01             	add    $0x1,%ecx
     d80:	4c 89 d2             	mov    %r10,%rdx
     d83:	0f b6 c9             	movzbl %cl,%ecx
out: 
    return ret;
}

int make_invalid_ht_lt(struct super_block *sb, u64 block, u64 hashname, u8 hlevel)
{
     d86:	48 89 e5             	mov    %rsp,%rbp

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
    if(tail) {
        hlevel++;
        ret = make_invalid_ht_lf(sb, tail, hashname, hlevel);
     d89:	e8 00 00 00 00       	callq  d8e <make_invalid_ht_lt+0xbe>
    }
out: 
    return ret;
}
     d8e:	5d                   	pop    %rbp
     d8f:	c3                   	retq   

0000000000000d90 <make_invalid_ht_ls>:

int make_invalid_ht_ls(struct super_block *sb, u64 block, u64 hashname, u8 hlevel)
{
     d90:	e8 00 00 00 00       	callq  d95 <make_invalid_ht_ls+0x5>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     d95:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     d9c:	49 89 f3             	mov    %rsi,%r11
     d9f:	49 89 d2             	mov    %rdx,%r10
    //block = nova_get_block_off(sb, blocknr, HTABLE_SIZE);
    ht = (struct hash_table_ls *)nova_get_block(sb, block);  
    buckets = 32767;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;
     da2:	48 ba 11 00 08 00 04 	movabs $0x2000400080011,%rdx
     da9:	00 02 00 
     dac:	4c 03 58 18          	add    0x18(%rax),%r11
     db0:	48 85 f6             	test   %rsi,%rsi
     db3:	b8 00 00 00 00       	mov    $0x0,%eax
     db8:	4c 0f 44 d8          	cmove  %rax,%r11
     dbc:	4c 89 d0             	mov    %r10,%rax
{
    struct hash_table_ls *ht;
    struct hash_entry *he;
    u32 h_pos, buckets, offset;
    u64 tail;
    int i = 0, ret=0;
     dbf:	45 31 c0             	xor    %r8d,%r8d
    //block = nova_get_block_off(sb, blocknr, HTABLE_SIZE);
    ht = (struct hash_table_ls *)nova_get_block(sb, block);  
    buckets = 32767;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;
     dc2:	48 f7 e2             	mul    %rdx
     dc5:	4c 89 d0             	mov    %r10,%rax
     dc8:	48 29 d0             	sub    %rdx,%rax
     dcb:	48 d1 e8             	shr    %rax
     dce:	48 01 c2             	add    %rax,%rdx
     dd1:	48 c1 ea 0e          	shr    $0xe,%rdx
     dd5:	48 89 d0             	mov    %rdx,%rax
     dd8:	48 c1 e0 0f          	shl    $0xf,%rax
     ddc:	48 29 d0             	sub    %rdx,%rax
     ddf:	4c 89 d2             	mov    %r10,%rdx
     de2:	48 29 c2             	sub    %rax,%rdx
     de5:	8d 04 95 fc ff ff ff 	lea    -0x4(,%rdx,4),%eax
     dec:	eb 0d                	jmp    dfb <make_invalid_ht_ls+0x6b>
        if(h_name==hashname){
            he->invalid = 0;
            ret = 1;
            goto out;
        } else {
            i++;
     dee:	41 83 c0 01          	add    $0x1,%r8d
            h_pos++;
     df2:	83 c0 01             	add    $0x1,%eax
    buckets = 32767;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;

    while(i < offset) {
     df5:	41 83 f8 03          	cmp    $0x3,%r8d
     df9:	7f 34                	jg     e2f <make_invalid_ht_ls+0x9f>
     dfb:	41 89 c1             	mov    %eax,%r9d
     dfe:	4c 89 ce             	mov    %r9,%rsi
     e01:	48 c1 e6 04          	shl    $0x4,%rsi
     e05:	4c 01 de             	add    %r11,%rsi
        he = &ht->hash_entry[h_pos];
        valid_flag = ht->hash_entry[h_pos].invalid;
        if(!valid_flag){
     e08:	80 7e 43 00          	cmpb   $0x0,0x43(%rsi)
     e0c:	75 07                	jne    e15 <make_invalid_ht_ls+0x85>
            i++;
     e0e:	41 83 c0 01          	add    $0x1,%r8d
            h_pos++;
     e12:	83 c0 01             	add    $0x1,%eax
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
     e15:	4c 3b 56 48          	cmp    0x48(%rsi),%r10
     e19:	75 d3                	jne    dee <make_invalid_ht_ls+0x5e>
            he->invalid = 0;
     e1b:	49 83 c1 04          	add    $0x4,%r9
            ret = 1;
     e1f:	b8 01 00 00 00       	mov    $0x1,%eax
            h_pos++;
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
            he->invalid = 0;
     e24:	49 c1 e1 04          	shl    $0x4,%r9
     e28:	43 c6 44 0b 03 00    	movb   $0x0,0x3(%r11,%r9,1)
        hlevel++;
        ret = make_invalid_ht_lt(sb, tail, hashname, hlevel);
    }
out: 
    return ret;
}
     e2e:	c3                   	retq   
            h_pos++;
        }
    }

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
     e2f:	49 8b 73 38          	mov    0x38(%r11),%rsi
{
    struct hash_table_ls *ht;
    struct hash_entry *he;
    u32 h_pos, buckets, offset;
    u64 tail;
    int i = 0, ret=0;
     e33:	31 c0                	xor    %eax,%eax
        }
    }

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
    if(tail) {
     e35:	48 85 f6             	test   %rsi,%rsi
     e38:	75 02                	jne    e3c <make_invalid_ht_ls+0xac>
        hlevel++;
        ret = make_invalid_ht_lt(sb, tail, hashname, hlevel);
    }
out: 
    return ret;
}
     e3a:	f3 c3                	repz retq 
out: 
    return ret;
}

int make_invalid_ht_ls(struct super_block *sb, u64 block, u64 hashname, u8 hlevel)
{
     e3c:	55                   	push   %rbp

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
    if(tail) {
        hlevel++;
        ret = make_invalid_ht_lt(sb, tail, hashname, hlevel);
     e3d:	83 c1 01             	add    $0x1,%ecx
     e40:	4c 89 d2             	mov    %r10,%rdx
     e43:	0f b6 c9             	movzbl %cl,%ecx
out: 
    return ret;
}

int make_invalid_ht_ls(struct super_block *sb, u64 block, u64 hashname, u8 hlevel)
{
     e46:	48 89 e5             	mov    %rsp,%rbp

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
    if(tail) {
        hlevel++;
        ret = make_invalid_ht_lt(sb, tail, hashname, hlevel);
     e49:	e8 00 00 00 00       	callq  e4e <make_invalid_ht_ls+0xbe>
    }
out: 
    return ret;
}
     e4e:	5d                   	pop    %rbp
     e4f:	c3                   	retq   

0000000000000e50 <make_invalid_htable>:

/*make invalid 
 * return 1 for invalid successfully
 * return 0 for fail invalid*/
int make_invalid_htable(struct super_block *sb, u64 block, u64 hashname, u8 hlevel)
{
     e50:	e8 00 00 00 00       	callq  e55 <make_invalid_htable+0x5>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     e55:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     e5c:	49 89 f2             	mov    %rsi,%r10
     e5f:	49 89 d3             	mov    %rdx,%r11
    ht = (struct hash_table *)nova_get_block(sb, block);  

    buckets = 65535;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;
     e62:	48 ba 01 80 00 80 00 	movabs $0x8000800080008001,%rdx
     e69:	80 00 80 
     e6c:	4c 03 50 18          	add    0x18(%rax),%r10
     e70:	48 85 f6             	test   %rsi,%rsi
     e73:	b8 00 00 00 00       	mov    $0x0,%eax
     e78:	4c 0f 44 d0          	cmove  %rax,%r10
     e7c:	4c 89 d8             	mov    %r11,%rax
    struct hash_table *ht;
    struct hash_entry *he;
    //struct ht_ptr *ht_p;
    u32 h_pos, buckets, offset;
    u64 tail;
    int i = 0, ret=0;
     e7f:	45 31 c0             	xor    %r8d,%r8d
    ht = (struct hash_table *)nova_get_block(sb, block);  

    buckets = 65535;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;
     e82:	48 f7 e2             	mul    %rdx
     e85:	48 c1 ea 0f          	shr    $0xf,%rdx
     e89:	48 89 d0             	mov    %rdx,%rax
     e8c:	48 c1 e0 10          	shl    $0x10,%rax
     e90:	48 29 d0             	sub    %rdx,%rax
     e93:	4c 89 da             	mov    %r11,%rdx
     e96:	48 29 c2             	sub    %rax,%rdx
     e99:	8d 04 95 fc ff ff ff 	lea    -0x4(,%rdx,4),%eax
     ea0:	eb 0d                	jmp    eaf <make_invalid_htable+0x5f>
        if(h_name==hashname){
            he->invalid =0;
            ret = 1;
            goto out;
        } else {
            i++;
     ea2:	41 83 c0 01          	add    $0x1,%r8d
            h_pos++;
     ea6:	83 c0 01             	add    $0x1,%eax
    buckets = 65535;
    offset = 4;

    h_pos = ((hashname % buckets)-1) * offset;

    while(i < offset) {
     ea9:	41 83 f8 03          	cmp    $0x3,%r8d
     ead:	7f 34                	jg     ee3 <make_invalid_htable+0x93>
     eaf:	41 89 c1             	mov    %eax,%r9d
     eb2:	4c 89 ce             	mov    %r9,%rsi
     eb5:	48 c1 e6 04          	shl    $0x4,%rsi
     eb9:	4c 01 d6             	add    %r10,%rsi
        he = &ht->hash_entry[h_pos];
        valid_flag = ht->hash_entry[h_pos].invalid;
        if(!valid_flag){
     ebc:	80 7e 43 00          	cmpb   $0x0,0x43(%rsi)
     ec0:	75 07                	jne    ec9 <make_invalid_htable+0x79>
            i++;
     ec2:	41 83 c0 01          	add    $0x1,%r8d
            h_pos++;
     ec6:	83 c0 01             	add    $0x1,%eax
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
     ec9:	4c 3b 5e 48          	cmp    0x48(%rsi),%r11
     ecd:	75 d3                	jne    ea2 <make_invalid_htable+0x52>
            he->invalid =0;
     ecf:	49 83 c1 04          	add    $0x4,%r9
            ret = 1;
     ed3:	b8 01 00 00 00       	mov    $0x1,%eax
            h_pos++;
        }
        /*found valid pos*/
        h_name = le64_to_cpu(he->hd_name);
        if(h_name==hashname){
            he->invalid =0;
     ed8:	49 c1 e1 04          	shl    $0x4,%r9
     edc:	43 c6 44 0a 03 00    	movb   $0x0,0x3(%r10,%r9,1)
        ret = make_invalid_ht_ls(sb, tail, hashname, hlevel);
    }
out:
    //nova_dbg("%s end",__func__);
    return ret;
}
     ee2:	c3                   	retq   
            h_pos++;
        }
    }

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
     ee3:	49 8b 72 38          	mov    0x38(%r10),%rsi
    struct hash_table *ht;
    struct hash_entry *he;
    //struct ht_ptr *ht_p;
    u32 h_pos, buckets, offset;
    u64 tail;
    int i = 0, ret=0;
     ee7:	31 c0                	xor    %eax,%eax
        }
    }

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
    if(tail) {
     ee9:	48 85 f6             	test   %rsi,%rsi
     eec:	75 02                	jne    ef0 <make_invalid_htable+0xa0>
        ret = make_invalid_ht_ls(sb, tail, hashname, hlevel);
    }
out:
    //nova_dbg("%s end",__func__);
    return ret;
}
     eee:	f3 c3                	repz retq 

/*make invalid 
 * return 1 for invalid successfully
 * return 0 for fail invalid*/
int make_invalid_htable(struct super_block *sb, u64 block, u64 hashname, u8 hlevel)
{
     ef0:	55                   	push   %rbp

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
    if(tail) {
        hlevel++;
        ret = make_invalid_ht_ls(sb, tail, hashname, hlevel);
     ef1:	83 c1 01             	add    $0x1,%ecx
     ef4:	4c 89 da             	mov    %r11,%rdx
     ef7:	0f b6 c9             	movzbl %cl,%ecx

/*make invalid 
 * return 1 for invalid successfully
 * return 0 for fail invalid*/
int make_invalid_htable(struct super_block *sb, u64 block, u64 hashname, u8 hlevel)
{
     efa:	48 89 e5             	mov    %rsp,%rbp

    /*not found pos*/
    tail = le64_to_cpu(ht->hash_tail);
    if(tail) {
        hlevel++;
        ret = make_invalid_ht_ls(sb, tail, hashname, hlevel);
     efd:	e8 00 00 00 00       	callq  f02 <make_invalid_htable+0xb2>
    }
out:
    //nova_dbg("%s end",__func__);
    return ret;
}
     f02:	5d                   	pop    %rbp
     f03:	c3                   	retq   
     f04:	66 90                	xchg   %ax,%ax
     f06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     f0d:	00 00 00 

0000000000000f10 <free_htable>:

int free_htable(struct super_block *sb, u64 ht_addr, u8 hlevel)
{
     f10:	e8 00 00 00 00       	callq  f15 <free_htable+0x5>
    u64 tail, tem;
    unsigned short btype;

    //nova_dbg("%s start",__func__);
    tail = ht_addr;
    while(tail){
     f15:	48 85 f6             	test   %rsi,%rsi
     f18:	0f 84 47 01 00 00    	je     1065 <free_htable+0x155>
    //nova_dbg("%s end",__func__);
    return ret;
}

int free_htable(struct super_block *sb, u64 ht_addr, u8 hlevel)
{
     f1e:	55                   	push   %rbp
     f1f:	48 89 e5             	mov    %rsp,%rbp
     f22:	41 56                	push   %r14
     f24:	44 0f b6 f2          	movzbl %dl,%r14d
     f28:	41 55                	push   %r13
     f2a:	41 89 d5             	mov    %edx,%r13d
     f2d:	41 54                	push   %r12
     f2f:	49 89 fc             	mov    %rdi,%r12
     f32:	53                   	push   %rbx
     f33:	48 89 f3             	mov    %rsi,%rbx

    //nova_dbg("%s start",__func__);
    tail = ht_addr;
    while(tail){
        //nova_dbg("%s hash table addr %llu",__func__,tail);
        switch (hlevel) {
     f36:	41 80 fd 05          	cmp    $0x5,%r13b
     f3a:	0f 87 f8 00 00 00    	ja     1038 <free_htable+0x128>
     f40:	42 ff 24 f5 00 00 00 	jmpq   *0x0(,%r14,8)
     f47:	00 
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     f48:	49 8b 84 24 b0 03 00 	mov    0x3b0(%r12),%rax
     f4f:	00 
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     f50:	48 89 d9             	mov    %rbx,%rcx
            case 1:
                ht = (struct hash_table *)nova_get_block(sb, tail);
                tem = le64_to_cpu(ht->hash_tail);
                btype = HTABLE_DEF_SIZE;
                hlevel = 2;
                dafs_free_htable_blocks(sb, btype, tail>>PAGE_SHIFT,1);
     f53:	48 c1 eb 0c          	shr    $0xc,%rbx
     f57:	48 89 da             	mov    %rbx,%rdx
     f5a:	be 05 00 00 00       	mov    $0x5,%esi
     f5f:	4c 89 e7             	mov    %r12,%rdi
     f62:	48 03 48 18          	add    0x18(%rax),%rcx
    while(tail){
        //nova_dbg("%s hash table addr %llu",__func__,tail);
        switch (hlevel) {
            case 1:
                ht = (struct hash_table *)nova_get_block(sb, tail);
                tem = le64_to_cpu(ht->hash_tail);
     f66:	4c 8b 69 38          	mov    0x38(%rcx),%r13
                btype = HTABLE_DEF_SIZE;
                hlevel = 2;
                dafs_free_htable_blocks(sb, btype, tail>>PAGE_SHIFT,1);
     f6a:	b9 01 00 00 00       	mov    $0x1,%ecx
     f6f:	e8 00 00 00 00       	callq  f74 <free_htable+0x64>
                BUG_ON(tem == 0);
     f74:	4d 85 ed             	test   %r13,%r13
     f77:	0f 84 e6 00 00 00    	je     1063 <free_htable+0x153>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     f7d:	49 8b 84 24 b0 03 00 	mov    0x3b0(%r12),%rax
     f84:	00 
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     f85:	4c 89 ee             	mov    %r13,%rsi
            case 2:
                hts = (struct hash_table_ls *)nova_get_block(sb, tail);
                tem = le64_to_cpu(hts->hash_tail);
                btype = HTABLE_LS_SIZE;
                hlevel = 3;
                dafs_free_htable_blocks(sb, btype, tail>>PAGE_SHIFT, 1);
     f88:	4c 89 ea             	mov    %r13,%rdx
     f8b:	48 c1 ea 0c          	shr    $0xc,%rdx
     f8f:	b9 01 00 00 00       	mov    $0x1,%ecx
     f94:	4c 89 e7             	mov    %r12,%rdi
     f97:	48 03 70 18          	add    0x18(%rax),%rsi
                BUG_ON(tem == 0);
                tail = tem;
                continue;
            case 2:
                hts = (struct hash_table_ls *)nova_get_block(sb, tail);
                tem = le64_to_cpu(hts->hash_tail);
     f9b:	48 8b 5e 38          	mov    0x38(%rsi),%rbx
                btype = HTABLE_LS_SIZE;
                hlevel = 3;
                dafs_free_htable_blocks(sb, btype, tail>>PAGE_SHIFT, 1);
     f9f:	be 04 00 00 00       	mov    $0x4,%esi
     fa4:	e8 00 00 00 00       	callq  fa9 <free_htable+0x99>
                BUG_ON(tem == 0);
     fa9:	48 85 db             	test   %rbx,%rbx
     fac:	0f 84 ab 00 00 00    	je     105d <free_htable+0x14d>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     fb2:	49 8b 84 24 b0 03 00 	mov    0x3b0(%r12),%rax
     fb9:	00 
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     fba:	48 89 df             	mov    %rbx,%rdi
            case 3:
                htt = (struct hash_table_lt *)nova_get_block(sb, tail);
                tem = le64_to_cpu(htt->hash_tail);
                btype = HTABLE_LT_SIZE;
                hlevel = 4;
                dafs_free_htable_blocks(sb, btype,tail>>PAGE_SHIFT, 1);
     fbd:	48 c1 eb 0c          	shr    $0xc,%rbx
     fc1:	48 89 da             	mov    %rbx,%rdx
     fc4:	b9 01 00 00 00       	mov    $0x1,%ecx
     fc9:	be 03 00 00 00       	mov    $0x3,%esi
     fce:	48 03 78 18          	add    0x18(%rax),%rdi
                BUG_ON(tem == 0);
                tail = tem;
                continue;
            case 3:
                htt = (struct hash_table_lt *)nova_get_block(sb, tail);
                tem = le64_to_cpu(htt->hash_tail);
     fd2:	4c 8b 6f 38          	mov    0x38(%rdi),%r13
                btype = HTABLE_LT_SIZE;
                hlevel = 4;
                dafs_free_htable_blocks(sb, btype,tail>>PAGE_SHIFT, 1);
     fd6:	4c 89 e7             	mov    %r12,%rdi
     fd9:	e8 00 00 00 00       	callq  fde <free_htable+0xce>
                BUG_ON(tem == 0);
     fde:	4d 85 ed             	test   %r13,%r13
     fe1:	74 7e                	je     1061 <free_htable+0x151>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     fe3:	49 8b 84 24 b0 03 00 	mov    0x3b0(%r12),%rax
     fea:	00 
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     feb:	4c 89 e9             	mov    %r13,%rcx
            case 4:
                htf = (struct hash_table_lf *)nova_get_block(sb, tail);
                tem = le64_to_cpu(htf->hash_tail);
                btype = HTABLE_LF_SIZE;
                hlevel = 5;
                dafs_free_htable_blocks(sb, btype, tail>>PAGE_SHIFT, 1);
     fee:	4c 89 ea             	mov    %r13,%rdx
     ff1:	48 c1 ea 0c          	shr    $0xc,%rdx
     ff5:	be 02 00 00 00       	mov    $0x2,%esi
     ffa:	4c 89 e7             	mov    %r12,%rdi
     ffd:	48 03 48 18          	add    0x18(%rax),%rcx
                BUG_ON(tem == 0);
                tail = tem;
                continue;
            case 4:
                htf = (struct hash_table_lf *)nova_get_block(sb, tail);
                tem = le64_to_cpu(htf->hash_tail);
    1001:	48 8b 59 38          	mov    0x38(%rcx),%rbx
                btype = HTABLE_LF_SIZE;
                hlevel = 5;
                dafs_free_htable_blocks(sb, btype, tail>>PAGE_SHIFT, 1);
    1005:	b9 01 00 00 00       	mov    $0x1,%ecx
    100a:	e8 00 00 00 00       	callq  100f <free_htable+0xff>
                BUG_ON(tem == 0);
    100f:	48 85 db             	test   %rbx,%rbx
    1012:	74 4b                	je     105f <free_htable+0x14f>
                continue;
            case 5:
                hte = (struct hash_table_le *)nova_get_block(sb, tail);
                tem = 0;
                btype = HTABLE_LE_SIZE;
                dafs_free_htable_blocks(sb, btype, tail>>PAGE_SHIFT, 1);
    1014:	48 c1 eb 0c          	shr    $0xc,%rbx
    1018:	4c 89 e7             	mov    %r12,%rdi
    101b:	b9 01 00 00 00       	mov    $0x1,%ecx
    1020:	48 89 da             	mov    %rbx,%rdx
    1023:	be 01 00 00 00       	mov    $0x1,%esi
    1028:	e8 00 00 00 00       	callq  102d <free_htable+0x11d>
        }
    }

    //nova_dbg("%s end",__func__);
    return 0;
}
    102d:	5b                   	pop    %rbx
    102e:	31 c0                	xor    %eax,%eax
    1030:	41 5c                	pop    %r12
    1032:	41 5d                	pop    %r13
    1034:	41 5e                	pop    %r14
    1036:	5d                   	pop    %rbp
    1037:	c3                   	retq   
                btype = HTABLE_LE_SIZE;
                dafs_free_htable_blocks(sb, btype, tail>>PAGE_SHIFT, 1);
                tail = tem;
                continue;
            default:
                nova_dbg("%s wrong free",__func__);
    1038:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    103f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1046:	e8 00 00 00 00       	callq  104b <free_htable+0x13b>
    104b:	e9 e6 fe ff ff       	jmpq   f36 <free_htable+0x26>

    //nova_dbg("%s start",__func__);
    tail = ht_addr;
    while(tail){
        //nova_dbg("%s hash table addr %llu",__func__,tail);
        switch (hlevel) {
    1050:	49 89 dd             	mov    %rbx,%r13
    1053:	eb 8e                	jmp    fe3 <free_htable+0xd3>
    1055:	49 89 dd             	mov    %rbx,%r13
    1058:	e9 20 ff ff ff       	jmpq   f7d <free_htable+0x6d>
                hts = (struct hash_table_ls *)nova_get_block(sb, tail);
                tem = le64_to_cpu(hts->hash_tail);
                btype = HTABLE_LS_SIZE;
                hlevel = 3;
                dafs_free_htable_blocks(sb, btype, tail>>PAGE_SHIFT, 1);
                BUG_ON(tem == 0);
    105d:	0f 0b                	ud2    
                htf = (struct hash_table_lf *)nova_get_block(sb, tail);
                tem = le64_to_cpu(htf->hash_tail);
                btype = HTABLE_LF_SIZE;
                hlevel = 5;
                dafs_free_htable_blocks(sb, btype, tail>>PAGE_SHIFT, 1);
                BUG_ON(tem == 0);
    105f:	0f 0b                	ud2    
                htt = (struct hash_table_lt *)nova_get_block(sb, tail);
                tem = le64_to_cpu(htt->hash_tail);
                btype = HTABLE_LT_SIZE;
                hlevel = 4;
                dafs_free_htable_blocks(sb, btype,tail>>PAGE_SHIFT, 1);
                BUG_ON(tem == 0);
    1061:	0f 0b                	ud2    
                ht = (struct hash_table *)nova_get_block(sb, tail);
                tem = le64_to_cpu(ht->hash_tail);
                btype = HTABLE_DEF_SIZE;
                hlevel = 2;
                dafs_free_htable_blocks(sb, btype, tail>>PAGE_SHIFT,1);
                BUG_ON(tem == 0);
    1063:	0f 0b                	ud2    
        }
    }

    //nova_dbg("%s end",__func__);
    return 0;
}
    1065:	31 c0                	xor    %eax,%eax
    1067:	c3                   	retq   
