
dafs_dir.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <find_dzt>:
/* find currect zone
 * ph record file ful name
 * 反向查找
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
       0:	55                   	push   %rbp
       1:	48 89 e5             	mov    %rsp,%rbp
       4:	41 56                	push   %r14
       6:	41 55                	push   %r13
       8:	41 54                	push   %r12
       a:	53                   	push   %rbx
       b:	49 89 f5             	mov    %rsi,%r13
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
       e:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
/* find currect zone
 * ph record file ful name
 * 反向查找
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
      15:	49 89 d4             	mov    %rdx,%r12
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
      18:	48 89 f7             	mov    %rsi,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
      1b:	4c 8b b0 d8 01 00 00 	mov    0x1d8(%rax),%r14
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
      22:	e8 00 00 00 00       	callq  27 <find_dzt+0x27>
      27:	4c 89 ee             	mov    %r13,%rsi
      2a:	48 89 c2             	mov    %rax,%rdx
      2d:	4c 89 e7             	mov    %r12,%rdi
      30:	e8 00 00 00 00       	callq  35 <find_dzt+0x35>
    tlen = strlen(phstr);
      35:	4c 89 ef             	mov    %r13,%rdi
      38:	e8 00 00 00 00       	callq  3d <find_dzt+0x3d>
      3d:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
      40:	be 2f 00 00 00       	mov    $0x2f,%esi
      45:	4c 89 e7             	mov    %r12,%rdi
      48:	e8 00 00 00 00       	callq  4d <find_dzt+0x4d>
        phlen = tlen -strlen(tem);
      4d:	48 89 c7             	mov    %rax,%rdi
      50:	e8 00 00 00 00       	callq  55 <find_dzt+0x55>
        tlen = phlen;
        //bug
        if(phlen==0){
      55:	48 29 c3             	sub    %rax,%rbx
      58:	74 6d                	je     c7 <find_dzt+0xc7>
            break;
        }
        memcpy(ph,phstr,tlen);
      5a:	48 89 da             	mov    %rbx,%rdx
      5d:	4c 89 ee             	mov    %r13,%rsi
      60:	4c 89 e7             	mov    %r12,%rdi
      63:	e8 00 00 00 00       	callq  68 <find_dzt+0x68>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
      68:	85 db                	test   %ebx,%ebx
        ph[tlen]='\0';
      6a:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
      6f:	7e 41                	jle    b2 <find_dzt+0xb2>
      71:	8d 43 ff             	lea    -0x1(%rbx),%eax
      74:	4c 89 e2             	mov    %r12,%rdx
      77:	31 f6                	xor    %esi,%esi
      79:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
      7e:	48 89 f0             	mov    %rsi,%rax
      81:	48 83 c2 01          	add    $0x1,%rdx
      85:	48 c1 e0 05          	shl    $0x5,%rax
      89:	48 29 f0             	sub    %rsi,%rax
      8c:	48 89 c6             	mov    %rax,%rsi
      8f:	48 0f be 42 ff       	movsbq -0x1(%rdx),%rax
      94:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
      97:	48 39 ca             	cmp    %rcx,%rdx
      9a:	75 e2                	jne    7e <find_dzt+0x7e>
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
      9c:	4c 89 f7             	mov    %r14,%rdi
      9f:	e8 00 00 00 00       	callq  a4 <find_dzt+0xa4>
        if(dzt_ei){
      a4:	48 85 c0             	test   %rax,%rax
      a7:	74 97                	je     40 <find_dzt+0x40>
    }

END:
    //nova_dbg("dafs finish finding dzt:%d, zone addr 0x%llu",dzt_ei->dzt_eno, dzt_ei->dz_addr);
    return dzt_ei;
}
      a9:	5b                   	pop    %rbx
      aa:	41 5c                	pop    %r12
      ac:	41 5d                	pop    %r13
      ae:	41 5e                	pop    %r14
      b0:	5d                   	pop    %rbp
      b1:	c3                   	retq   
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
      b2:	31 f6                	xor    %esi,%esi
        memcpy(ph,phstr,tlen);
        ph[tlen]='\0';
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
      b4:	4c 89 f7             	mov    %r14,%rdi
      b7:	e8 00 00 00 00       	callq  bc <find_dzt+0xbc>
        if(dzt_ei){
      bc:	48 85 c0             	test   %rax,%rax
      bf:	0f 84 7b ff ff ff    	je     40 <find_dzt+0x40>
      c5:	eb e2                	jmp    a9 <find_dzt+0xa9>
            return dzt_ei;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
      c7:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    ph[1]='\0';
      cc:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
      d2:	be 2f 00 00 00       	mov    $0x2f,%esi
      d7:	4c 89 f7             	mov    %r14,%rdi
      da:	e8 00 00 00 00       	callq  df <find_dzt+0xdf>
    if(!dzt_ei){
      df:	48 85 c0             	test   %rax,%rax
      e2:	75 c5                	jne    a9 <find_dzt+0xa9>
      e4:	e8 00 00 00 00       	callq  e9 <find_dzt+0xe9>
      e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000000f0 <kzalloc.constprop.9>:
/**
 * kzalloc - allocate memory. The memory is set to zero.
 * @size: how many bytes of memory are required.
 * @flags: the type of memory to allocate (see kmalloc).
 */
static inline void *kzalloc(size_t size, gfp_t flags)
      f0:	55                   	push   %rbp
			return kmem_cache_alloc_trace(kmalloc_caches[index],
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
      f1:	be d0 80 00 00       	mov    $0x80d0,%esi
/**
 * kzalloc - allocate memory. The memory is set to zero.
 * @size: how many bytes of memory are required.
 * @flags: the type of memory to allocate (see kmalloc).
 */
static inline void *kzalloc(size_t size, gfp_t flags)
      f6:	48 89 e5             	mov    %rsp,%rbp
			return kmem_cache_alloc_trace(kmalloc_caches[index],
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
      f9:	e8 00 00 00 00       	callq  fe <kzalloc.constprop.9+0xe>
 * @flags: the type of memory to allocate (see kmalloc).
 */
static inline void *kzalloc(size_t size, gfp_t flags)
{
	return kmalloc(size, flags | __GFP_ZERO);
}
      fe:	5d                   	pop    %rbp
      ff:	c3                   	retq   

0000000000000100 <get_dentry_path.isra.4>:
    return 0;

}

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
     100:	55                   	push   %rbp
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
     101:	ba 00 04 00 00       	mov    $0x400,%edx
     106:	be d0 80 00 00       	mov    $0x80d0,%esi

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
     10b:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
     112:	00 00 
     114:	48 89 e5             	mov    %rsp,%rbp
     117:	41 57                	push   %r15
     119:	41 56                	push   %r14
     11b:	41 55                	push   %r13
     11d:	41 54                	push   %r12
     11f:	49 89 fd             	mov    %rdi,%r13
     122:	53                   	push   %rbx
     123:	48 83 ec 10          	sub    $0x10,%rsp
     127:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 12e <get_dentry_path.isra.4+0x2e>
{
    char *ph=NULL, *buf=NULL, *tem=NULL, *mntchar= "/mnt/ramdisk", *end="", *ppath=NULL;
    struct fs_struct *fs = current->fs;
     12e:	4c 8b b0 30 06 00 00 	mov    0x630(%rax),%r14
     135:	e8 00 00 00 00       	callq  13a <get_dentry_path.isra.4+0x3a>
     13a:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 141 <get_dentry_path.isra.4+0x41>
     141:	ba 00 04 00 00       	mov    $0x400,%edx
     146:	be d0 80 00 00       	mov    $0x80d0,%esi
     14b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     14f:	e8 00 00 00 00       	callq  154 <get_dentry_path.isra.4+0x54>
     154:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 15b <get_dentry_path.isra.4+0x5b>
     15b:	48 89 c3             	mov    %rax,%rbx
     15e:	ba 00 04 00 00       	mov    $0x400,%edx
     163:	be d0 80 00 00       	mov    $0x80d0,%esi
     168:	e8 00 00 00 00       	callq  16d <get_dentry_path.isra.4+0x6d>

    //nova_dbg("%s:dafs get dentry path",__func__);
    ph = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    buf = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    tem = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    if(!buf)
     16d:	48 85 db             	test   %rbx,%rbx
     170:	0f 84 2b 01 00 00    	je     2a1 <get_dentry_path.isra.4+0x1a1>
        goto ERR;

    read_lock(&fs->lock);
     176:	49 8d 7e 04          	lea    0x4(%r14),%rdi
     17a:	49 89 c4             	mov    %rax,%r12
     17d:	e8 00 00 00 00       	callq  182 <get_dentry_path.isra.4+0x82>
    vfsmnt = mntget(fs->pwd.mnt);
     182:	49 8b 7e 28          	mov    0x28(%r14),%rdi
     186:	e8 00 00 00 00       	callq  18b <get_dentry_path.isra.4+0x8b>
    if(!vfsmnt){
     18b:	48 85 c0             	test   %rax,%rax
    tem = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    if(!buf)
        goto ERR;

    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
     18e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    if(!vfsmnt){
     192:	0f 84 09 01 00 00    	je     2a1 <get_dentry_path.isra.4+0x1a1>
 *
 * Atomically adds @i to @v and returns @i + @v
 */
static __always_inline int atomic_add_return(int i, atomic_t *v)
{
	return i + xadd(&v->counter, i);
     198:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
     19d:	f0 41 0f c1 46 04    	lock xadd %eax,0x4(%r14)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
     1a3:	49 8b 75 28          	mov    0x28(%r13),%rsi
     1a7:	49 c7 c6 00 00 00 00 	mov    $0x0,%r14
     1ae:	b9 02 00 00 00       	mov    $0x2,%ecx
     1b3:	4c 89 f7             	mov    %r14,%rdi
     1b6:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
     1b8:	0f 84 f8 00 00 00    	je     2b6 <get_dentry_path.isra.4+0x1b6>
        strcat(buf,"/");
     1be:	48 89 df             	mov    %rbx,%rdi
     1c1:	e8 00 00 00 00       	callq  1c6 <get_dentry_path.isra.4+0xc6>
     1c6:	b9 2f 00 00 00       	mov    $0x2f,%ecx
     1cb:	66 89 0c 03          	mov    %cx,(%rbx,%rax,1)
        ph[1]='\0';
        return ph;
    }

    do{
        strcat(buf, "/");
     1cf:	48 89 df             	mov    %rbx,%rdi
     1d2:	e8 00 00 00 00       	callq  1d7 <get_dentry_path.isra.4+0xd7>
     1d7:	ba 2f 00 00 00       	mov    $0x2f,%edx
        strcat(buf, tem_dentry->d_name.name);
     1dc:	48 8d 7c 03 01       	lea    0x1(%rbx,%rax,1),%rdi
        ph[1]='\0';
        return ph;
    }

    do{
        strcat(buf, "/");
     1e1:	66 89 14 03          	mov    %dx,(%rbx,%rax,1)
        strcat(buf, tem_dentry->d_name.name);
     1e5:	49 8b 75 28          	mov    0x28(%r13),%rsi
     1e9:	e8 00 00 00 00       	callq  1ee <get_dentry_path.isra.4+0xee>
        p_dentry = tem_dentry->d_parent;
     1ee:	4d 8b 6d 18          	mov    0x18(%r13),%r13
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
     1f2:	b9 02 00 00 00       	mov    $0x2,%ecx
     1f7:	4c 89 f7             	mov    %r14,%rdi
     1fa:	49 8b 75 28          	mov    0x28(%r13),%rsi
     1fe:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
     200:	75 cd                	jne    1cf <get_dentry_path.isra.4+0xcf>
     202:	49 8b 45 30          	mov    0x30(%r13),%rax
     206:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
     20b:	75 c2                	jne    1cf <get_dentry_path.isra.4+0xcf>
            break;
    }while(1);

    BUG_ON(buf==NULL);
    //nova_dbg("%s buf is %s",__func__, buf);
    memcpy(tem, buf, strlen(buf));
     20d:	48 89 df             	mov    %rbx,%rdi
     210:	e8 00 00 00 00       	callq  215 <get_dentry_path.isra.4+0x115>
     215:	48 89 de             	mov    %rbx,%rsi
     218:	48 89 c2             	mov    %rax,%rdx
     21b:	4c 89 e7             	mov    %r12,%rdi
     21e:	e8 00 00 00 00       	callq  223 <get_dentry_path.isra.4+0x123>
    tlen = strlen(buf);
     223:	48 89 df             	mov    %rbx,%rdi
     226:	e8 00 00 00 00       	callq  22b <get_dentry_path.isra.4+0x12b>
     22b:	49 89 c5             	mov    %rax,%r13
    do{
        ppath = strrchr(tem, '/');
     22e:	be 2f 00 00 00       	mov    $0x2f,%esi
     233:	4c 89 e7             	mov    %r12,%rdi
     236:	e8 00 00 00 00       	callq  23b <get_dentry_path.isra.4+0x13b>
        phlen = tlen - strlen(ppath);
     23b:	48 89 c7             	mov    %rax,%rdi
    BUG_ON(buf==NULL);
    //nova_dbg("%s buf is %s",__func__, buf);
    memcpy(tem, buf, strlen(buf));
    tlen = strlen(buf);
    do{
        ppath = strrchr(tem, '/');
     23e:	49 89 c7             	mov    %rax,%r15
        phlen = tlen - strlen(ppath);
     241:	e8 00 00 00 00       	callq  246 <get_dentry_path.isra.4+0x146>
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        strcat(ph, ppath);
     246:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    //nova_dbg("%s buf is %s",__func__, buf);
    memcpy(tem, buf, strlen(buf));
    tlen = strlen(buf);
    do{
        ppath = strrchr(tem, '/');
        phlen = tlen - strlen(ppath);
     24a:	49 29 c5             	sub    %rax,%r13
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        strcat(ph, ppath);
     24d:	4c 89 fe             	mov    %r15,%rsi
     250:	e8 00 00 00 00       	callq  255 <get_dentry_path.isra.4+0x155>
        memcpy(tem, buf, tlen);
     255:	48 89 de             	mov    %rbx,%rsi
     258:	4c 89 e7             	mov    %r12,%rdi
     25b:	4c 89 ea             	mov    %r13,%rdx
     25e:	e8 00 00 00 00       	callq  263 <get_dentry_path.isra.4+0x163>
        tem[tlen]='\0';
     263:	43 c6 04 2c 00       	movb   $0x0,(%r12,%r13,1)
        //memcpy(tem+tlen, end, 1);
        if(!strcmp(tem,"/"))
     268:	b9 02 00 00 00       	mov    $0x2,%ecx
     26d:	4c 89 e6             	mov    %r12,%rsi
     270:	4c 89 f7             	mov    %r14,%rdi
     273:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
     275:	75 b7                	jne    22e <get_dentry_path.isra.4+0x12e>
            break;
    }while(1);

    BUG_ON(strlen(ph)==1024);
     277:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
     27b:	e8 00 00 00 00       	callq  280 <get_dentry_path.isra.4+0x180>
     280:	48 3d 00 04 00 00    	cmp    $0x400,%rax
     286:	74 2c                	je     2b4 <get_dentry_path.isra.4+0x1b4>
    //nova_dbg("%s ful ph is %s",__func__,ph);
    
    mntput(vfsmnt);
     288:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
     28c:	e8 00 00 00 00       	callq  291 <get_dentry_path.isra.4+0x191>
    
    kfree(buf);
     291:	48 89 df             	mov    %rbx,%rdi
     294:	e8 00 00 00 00       	callq  299 <get_dentry_path.isra.4+0x199>
    kfree(tem);
     299:	4c 89 e7             	mov    %r12,%rdi
     29c:	e8 00 00 00 00       	callq  2a1 <get_dentry_path.isra.4+0x1a1>
    //nova_dbg("dafs finish get dentry path");
ERR:
    return ph;
}
     2a1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
     2a5:	48 83 c4 10          	add    $0x10,%rsp
     2a9:	5b                   	pop    %rbx
     2aa:	41 5c                	pop    %r12
     2ac:	41 5d                	pop    %r13
     2ae:	41 5e                	pop    %r14
     2b0:	41 5f                	pop    %r15
     2b2:	5d                   	pop    %rbp
     2b3:	c3                   	retq   
        //memcpy(tem+tlen, end, 1);
        if(!strcmp(tem,"/"))
            break;
    }while(1);

    BUG_ON(strlen(ph)==1024);
     2b4:	0f 0b                	ud2    
    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
        strcat(buf,"/");
    else{
        nova_dbg("%s root dentry",__func__);
     2b6:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     2bd:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     2c4:	e8 00 00 00 00       	callq  2c9 <get_dentry_path.isra.4+0x1c9>
        memcpy(ph, "/", 1);
     2c9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
     2cd:	c6 00 2f             	movb   $0x2f,(%rax)
        ph[1]='\0';
     2d0:	c6 40 01 00          	movb   $0x0,0x1(%rax)
     2d4:	eb cb                	jmp    2a1 <get_dentry_path.isra.4+0x1a1>
     2d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     2dd:	00 00 00 

00000000000002e0 <tes_empty_zone>:

#define DT2IF(dt) (((dt) << 12) & S_IFMT)
#define IF2DT(sif) (((sif) & S_IFMT) >> 12)

void tes_empty_zone(struct super_block *sb, struct zone_ptr *z_p)
{
     2e0:	e8 00 00 00 00       	callq  2e5 <tes_empty_zone+0x5>
     2e5:	55                   	push   %rbp
     2e6:	48 89 e5             	mov    %rsp,%rbp
     2e9:	41 56                	push   %r14
     2eb:	49 89 f6             	mov    %rsi,%r14
     2ee:	41 55                	push   %r13
     2f0:	41 bd 01 00 00 00    	mov    $0x1,%r13d
     2f6:	41 54                	push   %r12
    u32 pos = 0, epos = 0;
     2f8:	45 31 e4             	xor    %r12d,%r12d

#define DT2IF(dt) (((dt) << 12) & S_IFMT)
#define IF2DT(sif) (((sif) & S_IFMT) >> 12)

void tes_empty_zone(struct super_block *sb, struct zone_ptr *z_p)
{
     2fb:	53                   	push   %rbx
     2fc:	31 db                	xor    %ebx,%ebx
    u32 pos = 0, epos = 0;
    u32 bitpos = 0;

    while(pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
     2fe:	49 8b 16             	mov    (%r14),%rdx

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
     301:	48 0f a3 1a          	bt     %rbx,(%rdx)
     305:	19 c0                	sbb    %eax,%eax
     307:	85 c0                	test   %eax,%eax
     309:	75 42                	jne    34d <tes_empty_zone+0x6d>
     30b:	48 8d 43 01          	lea    0x1(%rbx),%rax
     30f:	48 0f a3 02          	bt     %rax,(%rdx)
     313:	19 c0                	sbb    %eax,%eax
     315:	85 c0                	test   %eax,%eax
     317:	75 34                	jne    34d <tes_empty_zone+0x6d>
            pos++;
            nova_dbg("%s: valid pos %d", __func__, pos);
        } else {
            bitpos+=2;
            pos++;
            epos++;
     319:	41 83 c4 01          	add    $0x1,%r12d
     31d:	48 83 c3 02          	add    $0x2,%rbx
     321:	41 83 c5 01          	add    $0x1,%r13d
void tes_empty_zone(struct super_block *sb, struct zone_ptr *z_p)
{
    u32 pos = 0, epos = 0;
    u32 bitpos = 0;

    while(pos<NR_DENTRY_IN_ZONE){
     325:	48 81 fb fe ff 01 00 	cmp    $0x1fffe,%rbx
     32c:	75 d0                	jne    2fe <tes_empty_zone+0x1e>
            bitpos+=2;
            pos++;
            epos++;
        }
    }
    nova_dbg("%s: empty pos num %d",__func__, epos);
     32e:	44 89 e2             	mov    %r12d,%edx
     331:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     338:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     33f:	e8 00 00 00 00       	callq  344 <tes_empty_zone+0x64>
}
     344:	5b                   	pop    %rbx
     345:	41 5c                	pop    %r12
     347:	41 5d                	pop    %r13
     349:	41 5e                	pop    %r14
     34b:	5d                   	pop    %rbp
     34c:	c3                   	retq   

    while(pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
            bitpos+=2;
            pos++;
            nova_dbg("%s: valid pos %d", __func__, pos);
     34d:	44 89 ea             	mov    %r13d,%edx
     350:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     357:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     35e:	e8 00 00 00 00       	callq  363 <tes_empty_zone+0x83>
     363:	eb b8                	jmp    31d <tes_empty_zone+0x3d>
     365:	90                   	nop
     366:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     36d:	00 00 00 

0000000000000370 <delete_dir_info>:
    nova_dbg("%s: empty pos num %d",__func__, epos);
}

/*delete dir_info entry*/
int delete_dir_info(struct dzt_entry_info *ei, u64 hashname)
{
     370:	e8 00 00 00 00       	callq  375 <delete_dir_info+0x5>
     375:	55                   	push   %rbp
    struct dir_info *dir_i;
    struct file_p *o_sf;
    struct list_head *this=NULL, *head=NULL, *next=NULL;

    //nova_dbg("%s start",__func__);
    dir_i = radix_tree_delete(&ei->dir_tree, hashname);
     376:	48 83 c7 38          	add    $0x38,%rdi
    nova_dbg("%s: empty pos num %d",__func__, epos);
}

/*delete dir_info entry*/
int delete_dir_info(struct dzt_entry_info *ei, u64 hashname)
{
     37a:	48 89 e5             	mov    %rsp,%rbp
     37d:	41 55                	push   %r13
     37f:	41 54                	push   %r12
     381:	53                   	push   %rbx
    struct dir_info *dir_i;
    struct file_p *o_sf;
    struct list_head *this=NULL, *head=NULL, *next=NULL;

    //nova_dbg("%s start",__func__);
    dir_i = radix_tree_delete(&ei->dir_tree, hashname);
     382:	e8 00 00 00 00       	callq  387 <delete_dir_info+0x17>
    if(!dir_i){
     387:	48 85 c0             	test   %rax,%rax
     38a:	74 59                	je     3e5 <delete_dir_info+0x75>
        //nova_dbg("dir info not found");
        goto OUT;
    }
    //nova_dbg("dir sub num is %llu",dir_i->sub_num);
    head = &dir_i->sub_file;
    list_for_each_safe(this, next, head) {
     38c:	48 8b 78 18          	mov    0x18(%rax),%rdi
    if(!dir_i){
        //nova_dbg("dir info not found");
        goto OUT;
    }
    //nova_dbg("dir sub num is %llu",dir_i->sub_num);
    head = &dir_i->sub_file;
     390:	4c 8d 60 18          	lea    0x18(%rax),%r12
     394:	49 89 c5             	mov    %rax,%r13
    list_for_each_safe(this, next, head) {
     397:	48 8b 1f             	mov    (%rdi),%rbx
     39a:	49 39 fc             	cmp    %rdi,%r12
     39d:	48 89 d8             	mov    %rbx,%rax
     3a0:	75 05                	jne    3a7 <delete_dir_info+0x37>
     3a2:	eb 39                	jmp    3dd <delete_dir_info+0x6d>
     3a4:	48 89 c3             	mov    %rax,%rbx
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
     3a7:	48 8b 57 08          	mov    0x8(%rdi),%rdx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
     3ab:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = next;
     3af:	48 89 02             	mov    %rax,(%rdx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
     3b2:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
     3b9:	00 ad de 
     3bc:	48 89 07             	mov    %rax,(%rdi)
	entry->prev = LIST_POISON2;
     3bf:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
     3c6:	00 ad de 
     3c9:	48 89 47 08          	mov    %rax,0x8(%rdi)
        o_sf = list_entry(this, struct file_p, list);
        //nova_dbg("list pos %d",o_sf->pos);
        //find bug
        list_del(&o_sf->list);
        kfree(o_sf);
     3cd:	e8 00 00 00 00       	callq  3d2 <delete_dir_info+0x62>
        //nova_dbg("dir info not found");
        goto OUT;
    }
    //nova_dbg("dir sub num is %llu",dir_i->sub_num);
    head = &dir_i->sub_file;
    list_for_each_safe(this, next, head) {
     3d2:	49 39 dc             	cmp    %rbx,%r12
     3d5:	48 8b 03             	mov    (%rbx),%rax
     3d8:	48 89 df             	mov    %rbx,%rdi
     3db:	75 c7                	jne    3a4 <delete_dir_info+0x34>
        //find bug
        list_del(&o_sf->list);
        kfree(o_sf);
    }

    kfree(dir_i);
     3dd:	4c 89 ef             	mov    %r13,%rdi
     3e0:	e8 00 00 00 00       	callq  3e5 <delete_dir_info+0x75>
OUT:
    //nova_dbg("%s end",__func__);
    return 0;
}
     3e5:	5b                   	pop    %rbx
     3e6:	31 c0                	xor    %eax,%eax
     3e8:	41 5c                	pop    %r12
     3ea:	41 5d                	pop    %r13
     3ec:	5d                   	pop    %rbp
     3ed:	c3                   	retq   
     3ee:	66 90                	xchg   %ax,%ax

00000000000003f0 <delete_dir_tree>:

/*delete dir_info tree*/
int delete_dir_tree(struct dzt_entry_info *ei)
{
     3f0:	e8 00 00 00 00       	callq  3f5 <delete_dir_tree+0x5>
     3f5:	55                   	push   %rbp
    struct dir_info *dir_i;
    struct dir_info *entries[FREE_BATCH];
    struct file_p *o_sf;
    struct list_head *head, *this, *next;
    u64 key, dir_index=0;
     3f6:	31 d2                	xor    %edx,%edx
    return 0;
}

/*delete dir_info tree*/
int delete_dir_tree(struct dzt_entry_info *ei)
{
     3f8:	48 89 e5             	mov    %rsp,%rbp
     3fb:	41 57                	push   %r15
     3fd:	41 56                	push   %r14
     3ff:	41 55                	push   %r13
     401:	41 54                	push   %r12
     403:	53                   	push   %rbx
     404:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
     40b:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     412:	00 00 
     414:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     418:	31 c0                	xor    %eax,%eax
     41a:	48 8d 47 38          	lea    0x38(%rdi),%rax
     41e:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    u64 key, dir_index=0;
    int nr, i;
    void *ret;

    do {
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
     425:	48 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%rdi
     42c:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
     433:	b9 10 00 00 00       	mov    $0x10,%ecx
     438:	e8 00 00 00 00       	callq  43d <delete_dir_tree+0x4d>
        for(i=0; i<nr; i++) {
     43d:	85 c0                	test   %eax,%eax
    u64 key, dir_index=0;
    int nr, i;
    void *ret;

    do {
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
     43f:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
        for(i=0; i<nr; i++) {
     445:	0f 8e c6 00 00 00    	jle    511 <delete_dir_tree+0x121>
     44b:	83 e8 01             	sub    $0x1,%eax
     44e:	4c 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%r14
     455:	48 8d 84 c5 58 ff ff 	lea    -0xa8(%rbp,%rax,8),%rax
     45c:	ff 
     45d:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
            dir_i = entries[i];
     464:	4d 8b 2e             	mov    (%r14),%r13
            key = dir_i->dir_hash;
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
     467:	48 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%rdi

    do {
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
        for(i=0; i<nr; i++) {
            dir_i = entries[i];
            key = dir_i->dir_hash;
     46e:	49 8b 45 10          	mov    0x10(%r13),%rax
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
            head = &dir_i->sub_file;
     472:	4d 8d 65 18          	lea    0x18(%r13),%r12
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
        for(i=0; i<nr; i++) {
            dir_i = entries[i];
            key = dir_i->dir_hash;
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
     476:	48 89 c6             	mov    %rax,%rsi

    do {
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
        for(i=0; i<nr; i++) {
            dir_i = entries[i];
            key = dir_i->dir_hash;
     479:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
     480:	e8 00 00 00 00       	callq  485 <delete_dir_tree+0x95>
            head = &dir_i->sub_file;
            list_for_each_safe(this, next, head) {
     485:	49 8b 7d 18          	mov    0x18(%r13),%rdi
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
        for(i=0; i<nr; i++) {
            dir_i = entries[i];
            key = dir_i->dir_hash;
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
     489:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
            head = &dir_i->sub_file;
            list_for_each_safe(this, next, head) {
     490:	4c 8b 3f             	mov    (%rdi),%r15
     493:	49 39 fc             	cmp    %rdi,%r12
     496:	4c 89 fb             	mov    %r15,%rbx
     499:	75 05                	jne    4a0 <delete_dir_tree+0xb0>
     49b:	eb 39                	jmp    4d6 <delete_dir_tree+0xe6>
     49d:	4c 89 fb             	mov    %r15,%rbx
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
     4a0:	48 8b 57 08          	mov    0x8(%rdi),%rdx
	entry->next = LIST_POISON1;
     4a4:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
     4ab:	00 ad de 
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
     4ae:	49 89 57 08          	mov    %rdx,0x8(%r15)
	prev->next = next;
     4b2:	4c 89 3a             	mov    %r15,(%rdx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
     4b5:	48 89 07             	mov    %rax,(%rdi)
	entry->prev = LIST_POISON2;
     4b8:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
     4bf:	00 ad de 
     4c2:	48 89 47 08          	mov    %rax,0x8(%rdi)
                o_sf = list_entry(this, struct file_p, list);
                list_del(&o_sf->list);
                kfree(o_sf);
     4c6:	e8 00 00 00 00       	callq  4cb <delete_dir_tree+0xdb>
            dir_i = entries[i];
            key = dir_i->dir_hash;
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
            head = &dir_i->sub_file;
            list_for_each_safe(this, next, head) {
     4cb:	49 39 dc             	cmp    %rbx,%r12
     4ce:	4d 8b 3f             	mov    (%r15),%r15
     4d1:	48 89 df             	mov    %rbx,%rdi
     4d4:	75 c7                	jne    49d <delete_dir_tree+0xad>
                o_sf = list_entry(this, struct file_p, list);
                list_del(&o_sf->list);
                kfree(o_sf);
            }
            if(!ret)
     4d6:	48 83 bd 48 ff ff ff 	cmpq   $0x0,-0xb8(%rbp)
     4dd:	00 
     4de:	74 35                	je     515 <delete_dir_tree+0x125>
                return -EINVAL;
                //nova_dbg("ret is NULL\n");
            kfree(dir_i);
     4e0:	4c 89 ef             	mov    %r13,%rdi
     4e3:	49 83 c6 08          	add    $0x8,%r14
     4e7:	e8 00 00 00 00       	callq  4ec <delete_dir_tree+0xfc>
    int nr, i;
    void *ret;

    do {
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
        for(i=0; i<nr; i++) {
     4ec:	4c 3b b5 30 ff ff ff 	cmp    -0xd0(%rbp),%r14
     4f3:	0f 85 6b ff ff ff    	jne    464 <delete_dir_tree+0x74>
            if(!ret)
                return -EINVAL;
                //nova_dbg("ret is NULL\n");
            kfree(dir_i);
        }
        dir_index ++;
     4f9:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
     500:	48 83 c2 01          	add    $0x1,%rdx
    } while (nr==FREE_BATCH);
     504:	83 bd 2c ff ff ff 10 	cmpl   $0x10,-0xd4(%rbp)
     50b:	0f 84 14 ff ff ff    	je     425 <delete_dir_tree+0x35>

    return 0;
     511:	31 c0                	xor    %eax,%eax
     513:	eb 05                	jmp    51a <delete_dir_tree+0x12a>
                o_sf = list_entry(this, struct file_p, list);
                list_del(&o_sf->list);
                kfree(o_sf);
            }
            if(!ret)
                return -EINVAL;
     515:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
        }
        dir_index ++;
    } while (nr==FREE_BATCH);

    return 0;
}
     51a:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
     51e:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
     525:	00 00 
     527:	75 12                	jne    53b <delete_dir_tree+0x14b>
     529:	48 81 c4 b0 00 00 00 	add    $0xb0,%rsp
     530:	5b                   	pop    %rbx
     531:	41 5c                	pop    %r12
     533:	41 5d                	pop    %r13
     535:	41 5e                	pop    %r14
     537:	41 5f                	pop    %r15
     539:	5d                   	pop    %rbp
     53a:	c3                   	retq   
     53b:	e8 00 00 00 00       	callq  540 <add_dir_info>

0000000000000540 <add_dir_info>:

}*/

/*add dir_info_entry in dir_info_tree*/
struct dir_info *add_dir_info(struct dzt_entry_info *ei, u64 hash_name, u32 pos)
{
     540:	e8 00 00 00 00       	callq  545 <add_dir_info+0x5>
     545:	55                   	push   %rbp
     546:	48 89 e5             	mov    %rsp,%rbp
     549:	41 56                	push   %r14
     54b:	41 55                	push   %r13
     54d:	41 54                	push   %r12
     54f:	49 89 fc             	mov    %rdi,%r12
     552:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 559 <add_dir_info+0x19>
     559:	53                   	push   %rbx
     55a:	49 89 f5             	mov    %rsi,%r13
     55d:	41 89 d6             	mov    %edx,%r14d
     560:	be d0 80 00 00       	mov    $0x80d0,%esi
     565:	ba 28 00 00 00       	mov    $0x28,%edx
     56a:	e8 00 00 00 00       	callq  56f <add_dir_info+0x2f>
     56f:	48 89 c3             	mov    %rax,%rbx
    new_dir->r_f = 0;
    new_dir->sub_s = 0;
    new_dir->f_s = 0;
    new_dir->prio = LEVEL_0;
    new_dir->sub_num = 0;
    new_dir->dir_hash = hash_name;
     572:	4c 89 68 10          	mov    %r13,0x10(%rax)
    new_dir->dir_pos = pos;
     576:	44 89 70 04          	mov    %r14d,0x4(%rax)
{
    struct dir_info *new_dir;

    //nova_dbg("dafs add dir info in radix tree");
    new_dir = kzalloc(sizeof(struct dir_info), GFP_KERNEL);
    new_dir->r_f = 0;
     57a:	c6 00 00             	movb   $0x0,(%rax)
    new_dir->sub_s = 0;
     57d:	c6 40 01 00          	movb   $0x0,0x1(%rax)
    new_dir->prio = LEVEL_0;
    new_dir->sub_num = 0;
    new_dir->dir_hash = hash_name;
    new_dir->dir_pos = pos;
    //nova_dbg("dir hash name is %llu", hash_name);
    INIT_LIST_HEAD(&new_dir->sub_file);
     581:	48 8d 40 18          	lea    0x18(%rax),%rax

    //nova_dbg("dafs add dir info in radix tree");
    new_dir = kzalloc(sizeof(struct dir_info), GFP_KERNEL);
    new_dir->r_f = 0;
    new_dir->sub_s = 0;
    new_dir->f_s = 0;
     585:	c6 40 ea 00          	movb   $0x0,-0x16(%rax)
    new_dir->prio = LEVEL_0;
     589:	c6 40 eb 00          	movb   $0x0,-0x15(%rax)
    new_dir->sub_num = 0;
    new_dir->dir_hash = hash_name;
    new_dir->dir_pos = pos;
    //nova_dbg("dir hash name is %llu", hash_name);
    INIT_LIST_HEAD(&new_dir->sub_file);
    radix_tree_insert(&ei->dir_tree, hash_name, new_dir);
     58d:	49 8d 7c 24 38       	lea    0x38(%r12),%rdi
    new_dir = kzalloc(sizeof(struct dir_info), GFP_KERNEL);
    new_dir->r_f = 0;
    new_dir->sub_s = 0;
    new_dir->f_s = 0;
    new_dir->prio = LEVEL_0;
    new_dir->sub_num = 0;
     592:	48 c7 40 f0 00 00 00 	movq   $0x0,-0x10(%rax)
     599:	00 
    new_dir->dir_hash = hash_name;
    new_dir->dir_pos = pos;
    //nova_dbg("dir hash name is %llu", hash_name);
    INIT_LIST_HEAD(&new_dir->sub_file);
    radix_tree_insert(&ei->dir_tree, hash_name, new_dir);
     59a:	48 89 da             	mov    %rbx,%rdx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
     59d:	48 89 43 18          	mov    %rax,0x18(%rbx)
	list->prev = list;
     5a1:	48 89 43 20          	mov    %rax,0x20(%rbx)
     5a5:	4c 89 ee             	mov    %r13,%rsi
     5a8:	e8 00 00 00 00       	callq  5ad <add_dir_info+0x6d>
    return new_dir;
}
     5ad:	48 89 d8             	mov    %rbx,%rax
     5b0:	5b                   	pop    %rbx
     5b1:	41 5c                	pop    %r12
     5b3:	41 5d                	pop    %r13
     5b5:	41 5e                	pop    %r14
     5b7:	5d                   	pop    %rbp
     5b8:	c3                   	retq   
     5b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000005c0 <update_read_hot>:

/*update read frequency when read happens*/
int update_read_hot(struct dzt_entry_info *dzt_ei, u64 hn)
{
     5c0:	e8 00 00 00 00       	callq  5c5 <update_read_hot+0x5>
     5c5:	55                   	push   %rbp
    struct dir_info *dir_info;
    dir_info = radix_tree_lookup(&dzt_ei->dir_tree, hn);
     5c6:	48 83 c7 38          	add    $0x38,%rdi
    return new_dir;
}

/*update read frequency when read happens*/
int update_read_hot(struct dzt_entry_info *dzt_ei, u64 hn)
{
     5ca:	48 89 e5             	mov    %rsp,%rbp
    struct dir_info *dir_info;
    dir_info = radix_tree_lookup(&dzt_ei->dir_tree, hn);
     5cd:	e8 00 00 00 00       	callq  5d2 <update_read_hot+0x12>
    if(!dir_info)
     5d2:	48 85 c0             	test   %rax,%rax
     5d5:	74 07                	je     5de <update_read_hot+0x1e>
        BUG();
    dir_info->r_f++;
     5d7:	80 00 01             	addb   $0x1,(%rax)

    return 0;
}
     5da:	31 c0                	xor    %eax,%eax
     5dc:	5d                   	pop    %rbp
     5dd:	c3                   	retq   
int update_read_hot(struct dzt_entry_info *dzt_ei, u64 hn)
{
    struct dir_info *dir_info;
    dir_info = radix_tree_lookup(&dzt_ei->dir_tree, hn);
    if(!dir_info)
        BUG();
     5de:	0f 0b                	ud2    

00000000000005e0 <dafs_readdir>:
    
}

/*遍历文件夹，dir_emit填充到用户空间*/
static int dafs_readdir(struct file *file, struct dir_context *ctx)
{
     5e0:	e8 00 00 00 00       	callq  5e5 <dafs_readdir+0x5>
     5e5:	55                   	push   %rbp
     5e6:	48 89 e5             	mov    %rsp,%rbp
     5e9:	41 57                	push   %r15
     5eb:	41 56                	push   %r14
     5ed:	41 55                	push   %r13
     5ef:	41 54                	push   %r12
     5f1:	53                   	push   %rbx
     5f2:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
    u32 de_pos;
    timing_t readdir_time;

    //nova_dbg("%s: inode ino %llu, dentry ino %llu",__func__, inode->i_ino, dentry->d_inode->i_ino);

    NOVA_START_TIMING(readdir_t, readdir_time);
     5f9:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 5ff <dafs_readdir+0x1f>
    
}

/*遍历文件夹，dir_emit填充到用户空间*/
static int dafs_readdir(struct file *file, struct dir_context *ctx)
{
     5ff:	48 89 75 98          	mov    %rsi,-0x68(%rbp)
     603:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     60a:	00 00 
     60c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     610:	31 c0                	xor    %eax,%eax
     612:	48 8b 47 20          	mov    0x20(%rdi),%rax
    struct inode *inode = file_inode(file);
    struct super_block *sb = inode->i_sb;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct nova_inode *pidir;
    struct nova_inode *child_pi;
    struct dentry *dentry = file->f_path.dentry; 
     616:	48 8b 5f 18          	mov    0x18(%rdi),%rbx
    u32 de_pos;
    timing_t readdir_time;

    //nova_dbg("%s: inode ino %llu, dentry ino %llu",__func__, inode->i_ino, dentry->d_inode->i_ino);

    NOVA_START_TIMING(readdir_t, readdir_time);
     61a:	85 d2                	test   %edx,%edx
     61c:	48 89 45 80          	mov    %rax,-0x80(%rbp)

/*遍历文件夹，dir_emit填充到用户空间*/
static int dafs_readdir(struct file *file, struct dir_context *ctx)
{
    struct inode *inode = file_inode(file);
    struct super_block *sb = inode->i_sb;
     620:	48 8b 40 28          	mov    0x28(%rax),%rax
     624:	48 89 45 90          	mov    %rax,-0x70(%rbp)
     628:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
     62f:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    u32 de_pos;
    timing_t readdir_time;

    //nova_dbg("%s: inode ino %llu, dentry ino %llu",__func__, inode->i_ino, dentry->d_inode->i_ino);

    NOVA_START_TIMING(readdir_t, readdir_time);
     636:	0f 85 77 03 00 00    	jne    9b3 <dafs_readdir+0x3d3>
    
    pidir = nova_get_inode(sb ,inode);
    pos = ctx->pos;
     63c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
     640:	4c 8b 78 08          	mov    0x8(%rax),%r15

    if(pos == READDIR_END){
     644:	49 83 ff ff          	cmp    $0xffffffffffffffff,%r15
     648:	0f 84 1e 03 00 00    	je     96c <dafs_readdir+0x38c>
    //buf = kzalloc(sizeof(char)*SMALL_NAME_LEN,GFP_ATOMIC);
    //
    path.mnt = file->f_path.mnt;
    path.dentry = file->f_path.dentry;
    //ppath = d_path(&path, ppath,SMALL_NAME_LEN);
    ppath = get_dentry_path(dentry, 1);
     64e:	48 89 df             	mov    %rbx,%rdi
     651:	e8 aa fa ff ff       	callq  100 <get_dentry_path.isra.4>
    //nova_dbg("%s file get path innitial is %s",__func__,ppath);
     
    phlen = strlen(ppath);
     656:	48 89 c7             	mov    %rax,%rdi
    //buf = kzalloc(sizeof(char)*SMALL_NAME_LEN,GFP_ATOMIC);
    //
    path.mnt = file->f_path.mnt;
    path.dentry = file->f_path.dentry;
    //ppath = d_path(&path, ppath,SMALL_NAME_LEN);
    ppath = get_dentry_path(dentry, 1);
     659:	49 89 c6             	mov    %rax,%r14
     65c:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
    //nova_dbg("%s file get path innitial is %s",__func__,ppath);
     
    phlen = strlen(ppath);
     663:	e8 00 00 00 00       	callq  668 <dafs_readdir+0x88>
    phn = kzalloc(sizeof(char)*phlen, GFP_KERNEL);
     668:	48 89 c7             	mov    %rax,%rdi
     66b:	e8 80 fa ff ff       	callq  f0 <kzalloc.constprop.9>
     670:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 677 <dafs_readdir+0x97>
     677:	ba 70 00 00 00       	mov    $0x70,%edx
     67c:	be d0 80 00 00       	mov    $0x80d0,%esi
     681:	49 89 c4             	mov    %rax,%r12
     684:	e8 00 00 00 00       	callq  689 <dafs_readdir+0xa9>
     689:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
     690:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
     694:	4c 89 f7             	mov    %r14,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
     697:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
     69e:	4c 8b a8 d8 01 00 00 	mov    0x1d8(%rax),%r13
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
     6a5:	e8 00 00 00 00       	callq  6aa <dafs_readdir+0xca>
     6aa:	4c 89 f6             	mov    %r14,%rsi
     6ad:	48 89 c2             	mov    %rax,%rdx
     6b0:	4c 89 e7             	mov    %r12,%rdi
     6b3:	e8 00 00 00 00       	callq  6b8 <dafs_readdir+0xd8>
    tlen = strlen(phstr);
     6b8:	4c 89 f7             	mov    %r14,%rdi
     6bb:	e8 00 00 00 00       	callq  6c0 <dafs_readdir+0xe0>
     6c0:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
     6c3:	be 2f 00 00 00       	mov    $0x2f,%esi
     6c8:	4c 89 e7             	mov    %r12,%rdi
     6cb:	e8 00 00 00 00       	callq  6d0 <dafs_readdir+0xf0>
        phlen = tlen -strlen(tem);
     6d0:	48 89 c7             	mov    %rax,%rdi
     6d3:	e8 00 00 00 00       	callq  6d8 <dafs_readdir+0xf8>
        tlen = phlen;
        //bug
        if(phlen==0){
     6d8:	48 29 c3             	sub    %rax,%rbx
     6db:	0f 84 f2 02 00 00    	je     9d3 <dafs_readdir+0x3f3>
            break;
        }
        memcpy(ph,phstr,tlen);
     6e1:	48 89 da             	mov    %rbx,%rdx
     6e4:	4c 89 f6             	mov    %r14,%rsi
     6e7:	4c 89 e7             	mov    %r12,%rdi
     6ea:	e8 00 00 00 00       	callq  6ef <dafs_readdir+0x10f>
	int i;

	for (i = 0; i < length; i++) {
     6ef:	85 db                	test   %ebx,%ebx
        ph[tlen]='\0';
     6f1:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
     6f6:	0f 8e 9f 02 00 00    	jle    99b <dafs_readdir+0x3bb>
     6fc:	8d 43 ff             	lea    -0x1(%rbx),%eax
     6ff:	4c 89 e2             	mov    %r12,%rdx
     702:	31 f6                	xor    %esi,%esi
     704:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
     709:	48 89 f0             	mov    %rsi,%rax
     70c:	48 83 c2 01          	add    $0x1,%rdx
     710:	48 c1 e0 05          	shl    $0x5,%rax
     714:	48 29 f0             	sub    %rsi,%rax
     717:	48 89 c6             	mov    %rax,%rsi
     71a:	48 0f be 42 ff       	movsbq -0x1(%rdx),%rax
     71f:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     722:	48 39 ca             	cmp    %rcx,%rdx
     725:	75 e2                	jne    709 <dafs_readdir+0x129>
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
     727:	4c 89 ef             	mov    %r13,%rdi
     72a:	e8 00 00 00 00       	callq  72f <dafs_readdir+0x14f>
        if(dzt_ei){
     72f:	48 85 c0             	test   %rax,%rax
     732:	74 8f                	je     6c3 <dafs_readdir+0xe3>
     734:	49 89 c6             	mov    %rax,%r14
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     737:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx

    ei = find_dzt(sb, ppath, phn);
    if(!ei){
        BUG();
    }
    ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->dz_addr);
     73b:	49 8b 46 10          	mov    0x10(%r14),%rax
     73f:	48 8b 93 b0 03 00 00 	mov    0x3b0(%rbx),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     746:	48 89 c7             	mov    %rax,%rdi
     749:	48 03 7a 18          	add    0x18(%rdx),%rdi
     74d:	48 85 c0             	test   %rax,%rax
     750:	b8 00 00 00 00       	mov    $0x0,%eax
     755:	48 0f 45 c7          	cmovne %rdi,%rax
    phlen = strlen(phn);
     759:	4c 89 e7             	mov    %r12,%rdi
     75c:	48 89 45 88          	mov    %rax,-0x78(%rbp)
     760:	e8 00 00 00 00       	callq  765 <dafs_readdir+0x185>
    if(phlen==1){
     765:	48 83 f8 01          	cmp    $0x1,%rax
    ei = find_dzt(sb, ppath, phn);
    if(!ei){
        BUG();
    }
    ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->dz_addr);
    phlen = strlen(phn);
     769:	49 89 c5             	mov    %rax,%r13
    if(phlen==1){
     76c:	0f 84 db 04 00 00    	je     c4d <dafs_readdir+0x66d>
        flen = strlen(ppath);
        memcpy(phname, ppath, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ppath)-phlen;
     772:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
     779:	e8 00 00 00 00       	callq  77e <dafs_readdir+0x19e>
     77e:	4c 29 e8             	sub    %r13,%rax
     781:	48 89 c3             	mov    %rax,%rbx
        memcpy(phname, ppath+phlen, flen);
     784:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
     78b:	48 89 da             	mov    %rbx,%rdx
     78e:	4a 8d 34 28          	lea    (%rax,%r13,1),%rsi
     792:	4c 8b ad 50 ff ff ff 	mov    -0xb0(%rbp),%r13
     799:	4c 89 ef             	mov    %r13,%rdi
     79c:	e8 00 00 00 00       	callq  7a1 <dafs_readdir+0x1c1>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     7a1:	85 db                	test   %ebx,%ebx
        phname[flen]='\0';
     7a3:	41 c6 44 1d 00 00    	movb   $0x0,0x0(%r13,%rbx,1)
     7a9:	0f 8e cf 04 00 00    	jle    c7e <dafs_readdir+0x69e>
     7af:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
     7b6:	8d 43 ff             	lea    -0x1(%rbx),%eax
     7b9:	45 31 ed             	xor    %r13d,%r13d
     7bc:	48 8d 4c 07 01       	lea    0x1(%rdi,%rax,1),%rcx
     7c1:	48 89 f8             	mov    %rdi,%rax
		hash = hash * seed + (*str++);
     7c4:	4c 89 ea             	mov    %r13,%rdx
     7c7:	48 83 c0 01          	add    $0x1,%rax
     7cb:	48 c1 e2 05          	shl    $0x5,%rdx
     7cf:	4c 29 ea             	sub    %r13,%rdx
     7d2:	49 89 d5             	mov    %rdx,%r13
     7d5:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
     7da:	49 01 d5             	add    %rdx,%r13
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     7dd:	48 39 c8             	cmp    %rcx,%rax
     7e0:	75 e2                	jne    7c4 <dafs_readdir+0x1e4>
    }
    ph_hash = BKDRHash(phname, flen);
    ht_head = ei->ht_head;
    ret = lookup_in_hashtable(sb, ht_head, ph_hash, 1, &de_pos);
     7e2:	49 8b 76 18          	mov    0x18(%r14),%rsi
     7e6:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
     7ea:	4c 8d 45 a4          	lea    -0x5c(%rbp),%r8
     7ee:	b9 01 00 00 00       	mov    $0x1,%ecx
     7f3:	4c 89 ea             	mov    %r13,%rdx
     7f6:	e8 00 00 00 00       	callq  7fb <dafs_readdir+0x21b>
    if(!ret){
     7fb:	85 c0                	test   %eax,%eax
     7fd:	0f 84 f3 04 00 00    	je     cf6 <dafs_readdir+0x716>
        //nova_dbg("%s not find dentry in nvm",__func__);
        BUG();
    }
    
    f_de = &ze->dentry[de_pos];
    ino = le64_to_cpu(f_de->ino);
     803:	8b 55 a4             	mov    -0x5c(%rbp),%edx
    if(ino!=inode->i_ino){
     806:	48 8b 45 80          	mov    -0x80(%rbp),%rax
        //nova_dbg("%s not find dentry in nvm",__func__);
        BUG();
    }
    
    f_de = &ze->dentry[de_pos];
    ino = le64_to_cpu(f_de->ino);
     80a:	48 89 d3             	mov    %rdx,%rbx
     80d:	48 c1 e3 07          	shl    $0x7,%rbx
     811:	48 03 5d 88          	add    -0x78(%rbp),%rbx
     815:	48 8b 8b 98 40 00 00 	mov    0x4098(%rbx),%rcx
    if(ino!=inode->i_ino){
     81c:	48 3b 48 40          	cmp    0x40(%rax),%rcx
     820:	0f 85 d2 04 00 00    	jne    cf8 <dafs_readdir+0x718>
          
        f_de = &ze->dentry[de_pos];
    }

    hashname = ph_hash;
    dir = radix_tree_lookup(&ei->dir_tree, hashname);
     826:	49 8d 7e 38          	lea    0x38(%r14),%rdi
     82a:	4c 89 ee             	mov    %r13,%rsi
     82d:	48 89 95 70 ff ff ff 	mov    %rdx,-0x90(%rbp)
     834:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
     838:	e8 00 00 00 00       	callq  83d <dafs_readdir+0x25d>
    BUG_ON(dir==NULL);
     83d:	48 85 c0             	test   %rax,%rax
          
        f_de = &ze->dentry[de_pos];
    }

    hashname = ph_hash;
    dir = radix_tree_lookup(&ei->dir_tree, hashname);
     840:	49 89 c5             	mov    %rax,%r13
    BUG_ON(dir==NULL);
     843:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
     847:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
     84e:	0f 84 16 04 00 00    	je     c6a <dafs_readdir+0x68a>
    if(f_de->file_type==ROOT_DIRECTORY && (ino!=NOVA_ROOT_INO)){
     854:	48 8b 45 88          	mov    -0x78(%rbp),%rax
     858:	48 81 c2 81 00 00 00 	add    $0x81,%rdx
     85f:	48 c1 e2 07          	shl    $0x7,%rdx
     863:	80 7c 10 02 02       	cmpb   $0x2,0x2(%rax,%rdx,1)
     868:	0f 85 8e 01 00 00    	jne    9fc <dafs_readdir+0x41c>
     86e:	48 83 f9 01          	cmp    $0x1,%rcx
     872:	0f 84 84 01 00 00    	je     9fc <dafs_readdir+0x41c>
        isroot = 1;
        ei_hn = f_de->dzt_hn;
        dzt_m = sbi->dzt_m_info;
        sei = radix_tree_lookup(&dzt_m->dzt_root, ei_hn);
     878:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
     87f:	48 8b b3 a8 40 00 00 	mov    0x40a8(%rbx),%rsi
     886:	48 89 4d 88          	mov    %rcx,-0x78(%rbp)
     88a:	48 8b b8 d8 01 00 00 	mov    0x1d8(%rax),%rdi
     891:	e8 00 00 00 00       	callq  896 <dafs_readdir+0x2b6>
     896:	49 89 c6             	mov    %rax,%r14
        //nova_dbg("%s:new root zone addr is %llu",__func__, sei->dz_addr);
        /*update ze*/
        ze = (struct dafs_zone_entry *)nova_get_block(sb, sei->dz_addr);
     899:	48 8b 40 10          	mov    0x10(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     89d:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
     8a1:	48 85 c0             	test   %rax,%rax
     8a4:	0f 84 c2 03 00 00    	je     c6c <dafs_readdir+0x68c>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     8aa:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
     8ae:	48 8b 93 b0 03 00 00 	mov    0x3b0(%rbx),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     8b5:	48 03 42 18          	add    0x18(%rdx),%rax
     8b9:	48 89 45 88          	mov    %rax,-0x78(%rbp)

    hashname = ph_hash;
    dir = radix_tree_lookup(&ei->dir_tree, hashname);
    BUG_ON(dir==NULL);
    if(f_de->file_type==ROOT_DIRECTORY && (ino!=NOVA_ROOT_INO)){
        isroot = 1;
     8bd:	b8 01 00 00 00       	mov    $0x1,%eax
     8c2:	e9 37 01 00 00       	jmpq   9fe <dafs_readdir+0x41e>

        }
        ctx->pos = pos;
        //n++
    }
	if (prev_de &&!dir_emit(ctx, prev_de->name, prev_de->name_len, 
     8c7:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
     8ce:	4c 8b a5 38 ff ff ff 	mov    -0xc8(%rbp),%r12
     8d5:	48 85 c0             	test   %rax,%rax
     8d8:	74 34                	je     90e <dafs_readdir+0x32e>

static inline bool dir_emit(struct dir_context *ctx,
			    const char *name, int namelen,
			    u64 ino, unsigned type)
{
	return ctx->actor(ctx, name, namelen, ctx->pos, ino, type) == 0;
     8da:	48 8b 9d 60 ff ff ff 	mov    -0xa0(%rbp),%rbx
     8e1:	0f b6 50 01          	movzbl 0x1(%rax),%edx
     8e5:	48 8d 70 30          	lea    0x30(%rax),%rsi
     8e9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
     8ed:	49 89 c8             	mov    %rcx,%r8
     8f0:	4c 89 f9             	mov    %r15,%rcx
     8f3:	44 0f b7 4b 1c       	movzwl 0x1c(%rbx),%r9d
     8f8:	48 89 c7             	mov    %rax,%rdi
     8fb:	66 41 c1 e9 0c       	shr    $0xc,%r9w
     900:	41 83 e1 0f          	and    $0xf,%r9d
     904:	ff 10                	callq  *(%rax)
     906:	85 c0                	test   %eax,%eax
     908:	0f 85 78 03 00 00    	jne    c86 <dafs_readdir+0x6a6>
                ino, IF2DT(le16_to_cpu(prev_child_pi->i_mode)))) {
			//nova_dbg("Here: pos %llu\n", ctx->pos);
            BUG();
			return 0;
	}
    ctx->pos = READDIR_END;
     90e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    //nova_dbg("dafs ctx pos is %llx", ctx->pos);
FREE:
    kfree(phname);
     912:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
                ino, IF2DT(le16_to_cpu(prev_child_pi->i_mode)))) {
			//nova_dbg("Here: pos %llu\n", ctx->pos);
            BUG();
			return 0;
	}
    ctx->pos = READDIR_END;
     919:	48 c7 40 08 ff ff ff 	movq   $0xffffffffffffffff,0x8(%rax)
     920:	ff 
    //nova_dbg("dafs ctx pos is %llx", ctx->pos);
FREE:
    kfree(phname);
     921:	e8 00 00 00 00       	callq  926 <dafs_readdir+0x346>
    //kfree(tem);
    kfree(phn);
     926:	4c 89 e7             	mov    %r12,%rdi
     929:	e8 00 00 00 00       	callq  92e <dafs_readdir+0x34e>
    //kfree(buf);
    kfree(ppath);
     92e:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
     935:	e8 00 00 00 00       	callq  93a <dafs_readdir+0x35a>
OUT:
	NOVA_END_TIMING(readdir_t, readdir_time);
     93a:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 940 <dafs_readdir+0x360>
     940:	85 c0                	test   %eax,%eax
     942:	74 28                	je     96c <dafs_readdir+0x38c>
	getnstimeofday64(ts);
}

static inline void getrawmonotonic(struct timespec *ts)
{
	getrawmonotonic64(ts);
     944:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
     948:	e8 00 00 00 00       	callq  94d <dafs_readdir+0x36d>
     94d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
     951:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
     955:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
     95c:	48 2b 45 b8          	sub    -0x48(%rbp),%rax
     960:	48 03 45 c8          	add    -0x38(%rbp),%rax
     964:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 96c <dafs_readdir+0x38c>
     96b:	00 
     96c:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 974 <dafs_readdir+0x394>
     973:	00 
	//nova_dbg("%s readdir return", __func__);
	return 0;

}
     974:	31 c0                	xor    %eax,%eax
     976:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
     97a:	65 48 33 3c 25 28 00 	xor    %gs:0x28,%rdi
     981:	00 00 
     983:	0f 85 5a 03 00 00    	jne    ce3 <dafs_readdir+0x703>
     989:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
     990:	5b                   	pop    %rbx
     991:	41 5c                	pop    %r12
     993:	41 5d                	pop    %r13
     995:	41 5e                	pop    %r14
     997:	41 5f                	pop    %r15
     999:	5d                   	pop    %rbp
     99a:	c3                   	retq   
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
     99b:	31 f6                	xor    %esi,%esi
        memcpy(ph,phstr,tlen);
        ph[tlen]='\0';
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
     99d:	4c 89 ef             	mov    %r13,%rdi
     9a0:	e8 00 00 00 00       	callq  9a5 <dafs_readdir+0x3c5>
        if(dzt_ei){
     9a5:	48 85 c0             	test   %rax,%rax
     9a8:	0f 84 15 fd ff ff    	je     6c3 <dafs_readdir+0xe3>
     9ae:	e9 81 fd ff ff       	jmpq   734 <dafs_readdir+0x154>
     9b3:	48 8d 7d b0          	lea    -0x50(%rbp),%rdi
     9b7:	e8 00 00 00 00       	callq  9bc <dafs_readdir+0x3dc>
    //nova_dbg("%s: inode ino %llu, dentry ino %llu",__func__, inode->i_ino, dentry->d_inode->i_ino);

    NOVA_START_TIMING(readdir_t, readdir_time);
    
    pidir = nova_get_inode(sb ,inode);
    pos = ctx->pos;
     9bc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
     9c0:	4c 8b 78 08          	mov    0x8(%rax),%r15

    if(pos == READDIR_END){
     9c4:	49 83 ff ff          	cmp    $0xffffffffffffffff,%r15
     9c8:	0f 85 80 fc ff ff    	jne    64e <dafs_readdir+0x6e>
     9ce:	e9 67 ff ff ff       	jmpq   93a <dafs_readdir+0x35a>
            return dzt_ei;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
     9d3:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    ph[1]='\0';
     9d8:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
     9de:	be 2f 00 00 00       	mov    $0x2f,%esi
     9e3:	4c 89 ef             	mov    %r13,%rdi
     9e6:	e8 00 00 00 00       	callq  9eb <dafs_readdir+0x40b>
    if(!dzt_ei){
     9eb:	48 85 c0             	test   %rax,%rax
    /*root dir*/
    memcpy(ph, "/", 1);
    ph[1]='\0';
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
     9ee:	49 89 c6             	mov    %rax,%r14
    if(!dzt_ei){
     9f1:	0f 85 40 fd ff ff    	jne    737 <dafs_readdir+0x157>
     9f7:	e8 00 00 00 00       	callq  9fc <dafs_readdir+0x41c>
    u64 pi_addr, hashname, ei_hn, dir_hn;
    u32 f_pos;
    u64 pos;
    ino_t ino;
    u8 type;
    int ret, isroot=0, i=0;
     9fc:	31 c0                	xor    %eax,%eax
        ei = sei;
    }

    head = &dir->sub_file;
    //nova_dbg("%s:dir_subfile num is%d, zone addr is %llu",__func__,dir->sub_num, ei->dz_addr);
    list_for_each(this, head){
     9fe:	49 8b 5d 18          	mov    0x18(%r13),%rbx
        /*update ze*/
        ze = (struct dafs_zone_entry *)nova_get_block(sb, sei->dz_addr);
        ei = sei;
    }

    head = &dir->sub_file;
     a02:	49 8d 7d 18          	lea    0x18(%r13),%rdi
     a06:	48 89 7d 80          	mov    %rdi,-0x80(%rbp)
    //nova_dbg("%s:dir_subfile num is%d, zone addr is %llu",__func__,dir->sub_num, ei->dz_addr);
    list_for_each(this, head){
     a0a:	48 39 df             	cmp    %rbx,%rdi
     a0d:	0f 84 fb fe ff ff    	je     90e <dafs_readdir+0x32e>
        tem_sf = list_entry(this, struct file_p, list);
        BUG_ON(tem_sf==NULL);
     a13:	48 85 db             	test   %rbx,%rbx
     a16:	0f 84 27 02 00 00    	je     c43 <dafs_readdir+0x663>
        f_pos = tem_sf->pos;
     a1c:	44 8b 5b 10          	mov    0x10(%rbx),%r11d
        if(!f_pos && !isroot){
     a20:	83 f0 01             	xor    $0x1,%eax
     a23:	83 e0 01             	and    $0x1,%eax
     a26:	88 85 5f ff ff ff    	mov    %al,-0xa1(%rbp)
     a2c:	45 85 db             	test   %r11d,%r11d
     a2f:	75 08                	jne    a39 <dafs_readdir+0x459>
     a31:	84 c0                	test   %al,%al
     a33:	0f 85 af 02 00 00    	jne    ce8 <dafs_readdir+0x708>
            ctx->pos = READDIR_END;
            BUG();
            goto FREE;
        }

        de = &ze->dentry[f_pos];
     a39:	45 89 dd             	mov    %r11d,%r13d
     a3c:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
     a40:	49 8d 85 81 00 00 00 	lea    0x81(%r13),%rax
     a47:	48 c1 e0 07          	shl    $0x7,%rax
     a4b:	48 01 f8             	add    %rdi,%rax
        //nova_dbg("%s:list subfile name:%s, pos id %d",__func__, de->name,f_pos);
        type = nova_get_entry_type((void *)de);
        if(type != DAFS_DIR_ENTRY){
     a4e:	80 38 06             	cmpb   $0x6,(%rax)
            ctx->pos = READDIR_END;
            BUG();
            goto FREE;
        }

        de = &ze->dentry[f_pos];
     a51:	48 89 45 88          	mov    %rax,-0x78(%rbp)
        //nova_dbg("%s:list subfile name:%s, pos id %d",__func__, de->name,f_pos);
        type = nova_get_entry_type((void *)de);
        if(type != DAFS_DIR_ENTRY){
     a55:	0f 85 b2 01 00 00    	jne    c0d <dafs_readdir+0x62d>
     a5b:	4c 89 a5 38 ff ff ff 	mov    %r12,-0xc8(%rbp)
     a62:	4c 89 b5 40 ff ff ff 	mov    %r14,-0xc0(%rbp)
     a69:	49 89 fc             	mov    %rdi,%r12
     a6c:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
     a73:	00 00 00 00 
     a77:	48 c7 85 78 ff ff ff 	movq   $0x0,-0x88(%rbp)
     a7e:	00 00 00 00 
     a82:	45 89 de             	mov    %r11d,%r14d
     a85:	4d 89 e8             	mov    %r13,%r8
     a88:	49 c1 e0 07          	shl    $0x7,%r8
     a8c:	4d 01 e0             	add    %r12,%r8
            //nova_dbg ("unknown type\n");
            BUG();
            return -EINVAL;
        }

        if(de->file_type == NORMAL_DIRECTORY){
     a8f:	41 80 b8 82 40 00 00 	cmpb   $0x1,0x4082(%r8)
     a96:	01 
     a97:	0f 84 72 01 00 00    	je     c0f <dafs_readdir+0x62f>
			"name %s, namelen %u, rec len %u\n", f_pos,
			de->entry_type, le64_to_cpu(de->ino),
			de->name, de->name_len,
			DAFS_DEF_DENTRY_SIZE);*/

        if(de->ino>0){
     a9d:	4c 89 e8             	mov    %r13,%rax
     aa0:	48 c1 e0 07          	shl    $0x7,%rax
     aa4:	4d 8b ac 04 98 40 00 	mov    0x4098(%r12,%rax,1),%r13
     aab:	00 
     aac:	4d 85 ed             	test   %r13,%r13
     aaf:	0f 84 0a 01 00 00    	je     bbf <dafs_readdir+0x5df>
            ino = __le64_to_cpu(de->ino);
            pos = BKDRHash(de->name, de->name_len);
     ab5:	41 0f b6 90 81 40 00 	movzbl 0x4081(%r8),%edx
     abc:	00 
     abd:	4d 8d 9c 04 b0 40 00 	lea    0x40b0(%r12,%rax,1),%r11
     ac4:	00 
	int i;

	for (i = 0; i < length; i++) {
     ac5:	84 d2                	test   %dl,%dl
     ac7:	0f 84 78 01 00 00    	je     c45 <dafs_readdir+0x665>
     acd:	8d 42 ff             	lea    -0x1(%rdx),%eax
     ad0:	45 31 ff             	xor    %r15d,%r15d
     ad3:	49 8d 4c 03 01       	lea    0x1(%r11,%rax,1),%rcx
     ad8:	4c 89 d8             	mov    %r11,%rax
		hash = hash * seed + (*str++);
     adb:	4c 89 fa             	mov    %r15,%rdx
     ade:	48 83 c0 01          	add    $0x1,%rax
     ae2:	48 c1 e2 05          	shl    $0x5,%rdx
     ae6:	4c 29 fa             	sub    %r15,%rdx
     ae9:	49 89 d7             	mov    %rdx,%r15
     aec:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
     af1:	49 01 d7             	add    %rdx,%r15
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     af4:	48 39 c1             	cmp    %rax,%rcx
     af7:	75 e2                	jne    adb <dafs_readdir+0x4fb>
            //BUG();
            ret = nova_get_inode_address(sb, ino, &pi_addr, 0);
     af9:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
     afd:	48 8d 55 a8          	lea    -0x58(%rbp),%rdx
     b01:	31 c9                	xor    %ecx,%ecx
     b03:	4c 89 ee             	mov    %r13,%rsi
     b06:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)
     b0d:	4c 89 9d 70 ff ff ff 	mov    %r11,-0x90(%rbp)
     b14:	e8 00 00 00 00       	callq  b19 <dafs_readdir+0x539>
            //BUG_ON(ret==0);
            if(ret){
     b19:	85 c0                	test   %eax,%eax
     b1b:	4c 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%r11
     b22:	4c 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%r8
     b29:	0f 85 91 01 00 00    	jne    cc0 <dafs_readdir+0x6e0>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     b2f:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
                BUG();
				ctx->pos = READDIR_END;
				return ret;
            }

            child_pi = nova_get_block(sb, pi_addr);
     b33:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
     b37:	48 8b 97 b0 03 00 00 	mov    0x3b0(%rdi),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     b3e:	49 89 c2             	mov    %rax,%r10
     b41:	4c 03 52 18          	add    0x18(%rdx),%r10
     b45:	48 85 c0             	test   %rax,%rax
     b48:	b8 00 00 00 00       	mov    $0x0,%eax
     b4d:	4c 0f 44 d0          	cmove  %rax,%r10
			nova_dbgv("ctx: pos %d ino %llu, name %s, "
     b51:	f6 05 00 00 00 00 10 	testb  $0x10,0x0(%rip)        # b58 <dafs_readdir+0x578>
     b58:	0f 85 2a 01 00 00    	jne    c88 <dafs_readdir+0x6a8>
				"name_len %u, de_len %u\n", f_pos,
				(u64)ino, de->name, de->name_len,
				DAFS_DEF_DENTRY_SIZE);
			if (prev_de &&!dir_emit(ctx, prev_de->name,
     b5e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
     b65:	48 85 c0             	test   %rax,%rax
     b68:	74 40                	je     baa <dafs_readdir+0x5ca>
     b6a:	48 8b bd 60 ff ff ff 	mov    -0xa0(%rbp),%rdi
     b71:	0f b6 50 01          	movzbl 0x1(%rax),%edx
     b75:	48 8d 70 30          	lea    0x30(%rax),%rsi
     b79:	4c 89 95 78 ff ff ff 	mov    %r10,-0x88(%rbp)
     b80:	4d 89 e8             	mov    %r13,%r8
     b83:	44 0f b7 4f 1c       	movzwl 0x1c(%rdi),%r9d
     b88:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
     b8c:	48 8b 4f 08          	mov    0x8(%rdi),%rcx
     b90:	66 41 c1 e9 0c       	shr    $0xc,%r9w
     b95:	41 83 e1 0f          	and    $0xf,%r9d
     b99:	ff 17                	callq  *(%rdi)
     b9b:	85 c0                	test   %eax,%eax
     b9d:	4c 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10
     ba4:	0f 85 14 01 00 00    	jne    cbe <dafs_readdir+0x6de>
     baa:	48 8b 45 88          	mov    -0x78(%rbp),%rax
     bae:	4c 89 e9             	mov    %r13,%rcx
				//nova_dbg("Here: pos %llu\n", ctx->pos);
                BUG();
				return 0;
			}
            prev_de = de;
            prev_child_pi = child_pi;
     bb1:	4c 89 95 60 ff ff ff 	mov    %r10,-0xa0(%rbp)
     bb8:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)

        }
        ctx->pos = pos;
     bbf:	48 8b 45 98          	mov    -0x68(%rbp),%rax
     bc3:	4c 89 78 08          	mov    %r15,0x8(%rax)
        ei = sei;
    }

    head = &dir->sub_file;
    //nova_dbg("%s:dir_subfile num is%d, zone addr is %llu",__func__,dir->sub_num, ei->dz_addr);
    list_for_each(this, head){
     bc7:	48 8b 1b             	mov    (%rbx),%rbx
     bca:	48 39 5d 80          	cmp    %rbx,-0x80(%rbp)
     bce:	0f 84 f3 fc ff ff    	je     8c7 <dafs_readdir+0x2e7>
        tem_sf = list_entry(this, struct file_p, list);
        BUG_ON(tem_sf==NULL);
     bd4:	48 85 db             	test   %rbx,%rbx
     bd7:	74 6a                	je     c43 <dafs_readdir+0x663>
        f_pos = tem_sf->pos;
     bd9:	44 8b 73 10          	mov    0x10(%rbx),%r14d
        if(!f_pos && !isroot){
     bdd:	45 85 f6             	test   %r14d,%r14d
     be0:	75 0d                	jne    bef <dafs_readdir+0x60f>
     be2:	80 bd 5f ff ff ff 00 	cmpb   $0x0,-0xa1(%rbp)
     be9:	0f 85 f9 00 00 00    	jne    ce8 <dafs_readdir+0x708>
            ctx->pos = READDIR_END;
            BUG();
            goto FREE;
        }

        de = &ze->dentry[f_pos];
     bef:	45 89 f5             	mov    %r14d,%r13d
     bf2:	49 8d 85 81 00 00 00 	lea    0x81(%r13),%rax
     bf9:	48 c1 e0 07          	shl    $0x7,%rax
     bfd:	4c 01 e0             	add    %r12,%rax
        //nova_dbg("%s:list subfile name:%s, pos id %d",__func__, de->name,f_pos);
        type = nova_get_entry_type((void *)de);
        if(type != DAFS_DIR_ENTRY){
     c00:	80 38 06             	cmpb   $0x6,(%rax)
            ctx->pos = READDIR_END;
            BUG();
            goto FREE;
        }

        de = &ze->dentry[f_pos];
     c03:	48 89 45 88          	mov    %rax,-0x78(%rbp)
        //nova_dbg("%s:list subfile name:%s, pos id %d",__func__, de->name,f_pos);
        type = nova_get_entry_type((void *)de);
        if(type != DAFS_DIR_ENTRY){
     c07:	0f 84 78 fe ff ff    	je     a85 <dafs_readdir+0x4a5>
            //nova_dbg ("unknown type\n");
            BUG();
     c0d:	0f 0b                	ud2    
            return -EINVAL;
        }

        if(de->file_type == NORMAL_DIRECTORY){
            dir_hn = le64_to_cpu(de->hname);
            update_read_hot(ei, dir_hn);
     c0f:	49 8b b0 a8 40 00 00 	mov    0x40a8(%r8),%rsi
     c16:	48 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%rdi
     c1d:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
     c24:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
     c2b:	e8 00 00 00 00       	callq  c30 <dafs_readdir+0x650>
     c30:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
     c37:	4c 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%r8
     c3e:	e9 5a fe ff ff       	jmpq   a9d <dafs_readdir+0x4bd>

    head = &dir->sub_file;
    //nova_dbg("%s:dir_subfile num is%d, zone addr is %llu",__func__,dir->sub_num, ei->dz_addr);
    list_for_each(this, head){
        tem_sf = list_entry(this, struct file_p, list);
        BUG_ON(tem_sf==NULL);
     c43:	0f 0b                	ud2    
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
     c45:	45 31 ff             	xor    %r15d,%r15d
     c48:	e9 ac fe ff ff       	jmpq   af9 <dafs_readdir+0x519>
        BUG();
    }
    ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ppath);
     c4d:	4c 8b ad 48 ff ff ff 	mov    -0xb8(%rbp),%r13
     c54:	4c 89 ef             	mov    %r13,%rdi
     c57:	e8 00 00 00 00       	callq  c5c <dafs_readdir+0x67c>
        memcpy(phname, ppath, flen);
     c5c:	4c 89 ee             	mov    %r13,%rsi
        BUG();
    }
    ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ppath);
     c5f:	48 89 c3             	mov    %rax,%rbx
        memcpy(phname, ppath, flen);
     c62:	48 89 c2             	mov    %rax,%rdx
     c65:	e9 28 fb ff ff       	jmpq   792 <dafs_readdir+0x1b2>
        f_de = &ze->dentry[de_pos];
    }

    hashname = ph_hash;
    dir = radix_tree_lookup(&ei->dir_tree, hashname);
    BUG_ON(dir==NULL);
     c6a:	0f 0b                	ud2    
    if(f_de->file_type==ROOT_DIRECTORY && (ino!=NOVA_ROOT_INO)){
        isroot = 1;
     c6c:	b8 01 00 00 00       	mov    $0x1,%eax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     c71:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
     c78:	00 
     c79:	e9 80 fd ff ff       	jmpq   9fe <dafs_readdir+0x41e>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
     c7e:	45 31 ed             	xor    %r13d,%r13d
     c81:	e9 5c fb ff ff       	jmpq   7e2 <dafs_readdir+0x202>
        //n++
    }
	if (prev_de &&!dir_emit(ctx, prev_de->name, prev_de->name_len, 
                ino, IF2DT(le16_to_cpu(prev_child_pi->i_mode)))) {
			//nova_dbg("Here: pos %llu\n", ctx->pos);
            BUG();
     c86:	0f 0b                	ud2    
				ctx->pos = READDIR_END;
				return ret;
            }

            child_pi = nova_get_block(sb, pi_addr);
			nova_dbgv("ctx: pos %d ino %llu, name %s, "
     c88:	45 0f b6 80 81 40 00 	movzbl 0x4081(%r8),%r8d
     c8f:	00 
     c90:	41 b9 80 00 00 00    	mov    $0x80,%r9d
     c96:	4c 89 d9             	mov    %r11,%rcx
     c99:	4c 89 ea             	mov    %r13,%rdx
     c9c:	44 89 f6             	mov    %r14d,%esi
     c9f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     ca6:	4c 89 95 70 ff ff ff 	mov    %r10,-0x90(%rbp)
     cad:	e8 00 00 00 00       	callq  cb2 <dafs_readdir+0x6d2>
     cb2:	4c 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10
     cb9:	e9 a0 fe ff ff       	jmpq   b5e <dafs_readdir+0x57e>
				DAFS_DEF_DENTRY_SIZE);
			if (prev_de &&!dir_emit(ctx, prev_de->name,
				prev_de->name_len, ino,
				IF2DT(le16_to_cpu(prev_child_pi->i_mode)))) {
				//nova_dbg("Here: pos %llu\n", ctx->pos);
                BUG();
     cbe:	0f 0b                	ud2    
            pos = BKDRHash(de->name, de->name_len);
            //BUG();
            ret = nova_get_inode_address(sb, ino, &pi_addr, 0);
            //BUG_ON(ret==0);
            if(ret){
				nova_dbgv("%s: get child inode %lu address "
     cc0:	f6 05 00 00 00 00 10 	testb  $0x10,0x0(%rip)        # cc7 <dafs_readdir+0x6e7>
     cc7:	74 18                	je     ce1 <dafs_readdir+0x701>
     cc9:	89 c1                	mov    %eax,%ecx
     ccb:	4c 89 ea             	mov    %r13,%rdx
     cce:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     cd5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     cdc:	e8 00 00 00 00       	callq  ce1 <dafs_readdir+0x701>
					"failed %d\n", __func__, ino, ret);
                BUG();
     ce1:	0f 0b                	ud2    
OUT:
	NOVA_END_TIMING(readdir_t, readdir_time);
	//nova_dbg("%s readdir return", __func__);
	return 0;

}
     ce3:	e8 00 00 00 00       	callq  ce8 <dafs_readdir+0x708>
    list_for_each(this, head){
        tem_sf = list_entry(this, struct file_p, list);
        BUG_ON(tem_sf==NULL);
        f_pos = tem_sf->pos;
        if(!f_pos && !isroot){
            ctx->pos = READDIR_END;
     ce8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
     cec:	48 c7 40 08 ff ff ff 	movq   $0xffffffffffffffff,0x8(%rax)
     cf3:	ff 
            BUG();
     cf4:	0f 0b                	ud2    
    ph_hash = BKDRHash(phname, flen);
    ht_head = ei->ht_head;
    ret = lookup_in_hashtable(sb, ht_head, ph_hash, 1, &de_pos);
    if(!ret){
        //nova_dbg("%s not find dentry in nvm",__func__);
        BUG();
     cf6:	0f 0b                	ud2    
    }
    
    f_de = &ze->dentry[de_pos];
    ino = le64_to_cpu(f_de->ino);
    if(ino!=inode->i_ino){
        BUG();
     cf8:	0f 0b                	ud2    
     cfa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000000d00 <dafs_rebuild_dir_time_and_size>:
    return dzt_ei;
}

void dafs_rebuild_dir_time_and_size(struct super_block *sb,
	struct nova_inode *pi, int link_change, struct inode *dir)
{
     d00:	e8 00 00 00 00       	callq  d05 <dafs_rebuild_dir_time_and_size+0x5>
    unsigned short links_count;

	if (!pi)
     d05:	48 85 f6             	test   %rsi,%rsi
     d08:	74 46                	je     d50 <dafs_rebuild_dir_time_and_size+0x50>
    return dzt_ei;
}

void dafs_rebuild_dir_time_and_size(struct super_block *sb,
	struct nova_inode *pi, int link_change, struct inode *dir)
{
     d0a:	55                   	push   %rbp
     d0b:	48 89 e5             	mov    %rsp,%rbp
     d0e:	41 55                	push   %r13
     d10:	41 54                	push   %r12
     d12:	53                   	push   %rbx
     d13:	48 89 f3             	mov    %rsi,%rbx
     d16:	49 89 cc             	mov    %rcx,%r12
     d19:	41 89 d5             	mov    %edx,%r13d
    unsigned short links_count;

	if (!pi)
		return;

	pi->i_ctime = CURRENT_TIME_SEC.tv_sec;
     d1c:	e8 00 00 00 00       	callq  d21 <dafs_rebuild_dir_time_and_size+0x21>
     d21:	89 43 10             	mov    %eax,0x10(%rbx)
	pi->i_mtime = CURRENT_TIME_SEC.tv_sec;
     d24:	e8 00 00 00 00       	callq  d29 <dafs_rebuild_dir_time_and_size+0x29>
	pi->i_size = DAFS_DEF_DENTRY_SIZE;
     d29:	48 c7 43 08 80 00 00 	movq   $0x80,0x8(%rbx)
     d30:	00 

	if (!pi)
		return;

	pi->i_ctime = CURRENT_TIME_SEC.tv_sec;
	pi->i_mtime = CURRENT_TIME_SEC.tv_sec;
     d31:	89 43 14             	mov    %eax,0x14(%rbx)
	pi->i_size = DAFS_DEF_DENTRY_SIZE;
    links_count = cpu_to_le16(dir->i_nlink);
     d34:	41 8b 44 24 48       	mov    0x48(%r12),%eax
    //nova_dbg("%s dir links is %d", __func__, links_count);
	if (links_count == 0 && link_change == -1)
     d39:	66 85 c0             	test   %ax,%ax
     d3c:	75 14                	jne    d52 <dafs_rebuild_dir_time_and_size+0x52>
		links_count = 0;
     d3e:	31 d2                	xor    %edx,%edx
	pi->i_ctime = CURRENT_TIME_SEC.tv_sec;
	pi->i_mtime = CURRENT_TIME_SEC.tv_sec;
	pi->i_size = DAFS_DEF_DENTRY_SIZE;
    links_count = cpu_to_le16(dir->i_nlink);
    //nova_dbg("%s dir links is %d", __func__, links_count);
	if (links_count == 0 && link_change == -1)
     d40:	41 83 fd ff          	cmp    $0xffffffff,%r13d
     d44:	75 0c                	jne    d52 <dafs_rebuild_dir_time_and_size+0x52>
		links_count = 0;
	else
		links_count += link_change;
	pi->i_links_count = links_count;
     d46:	66 89 53 1e          	mov    %dx,0x1e(%rbx)
}
     d4a:	5b                   	pop    %rbx
     d4b:	41 5c                	pop    %r12
     d4d:	41 5d                	pop    %r13
     d4f:	5d                   	pop    %rbp
     d50:	f3 c3                	repz retq 
    links_count = cpu_to_le16(dir->i_nlink);
    //nova_dbg("%s dir links is %d", __func__, links_count);
	if (links_count == 0 && link_change == -1)
		links_count = 0;
	else
		links_count += link_change;
     d52:	42 8d 14 28          	lea    (%rax,%r13,1),%edx
	pi->i_links_count = links_count;
     d56:	66 89 53 1e          	mov    %dx,0x1e(%rbx)
}
     d5a:	5b                   	pop    %rbx
     d5b:	41 5c                	pop    %r12
     d5d:	41 5d                	pop    %r13
     d5f:	5d                   	pop    %rbp
     d60:	eb ee                	jmp    d50 <dafs_rebuild_dir_time_and_size+0x50>
     d62:	0f 1f 40 00          	nopl   0x0(%rax)
     d66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     d6d:	00 00 00 

0000000000000d70 <record_dir_log>:

/*record dir operation in logs*/
void record_dir_log(struct super_block *sb, struct dentry *src, struct dentry *des, int type)
{
     d70:	e8 00 00 00 00       	callq  d75 <record_dir_log+0x5>
     d75:	55                   	push   %rbp
     d76:	48 89 e5             	mov    %rsp,%rbp
     d79:	41 57                	push   %r15
     d7b:	41 56                	push   %r14
     d7d:	41 55                	push   %r13
     d7f:	41 54                	push   %r12
     d81:	49 89 fd             	mov    %rdi,%r13
     d84:	53                   	push   %rbx
     d85:	49 89 d7             	mov    %rdx,%r15
     d88:	48 83 ec 40          	sub    $0x40,%rsp
     d8c:	48 89 7d b0          	mov    %rdi,-0x50(%rbp)
    //nova_dbg("record dir log");
//debug
	cpu = smp_processor_id();
	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    src_pn = get_dentry_path(src,0);
     d90:	48 89 f7             	mov    %rsi,%rdi
	pi->i_links_count = links_count;
}

/*record dir operation in logs*/
void record_dir_log(struct super_block *sb, struct dentry *src, struct dentry *des, int type)
{
     d93:	89 4d a4             	mov    %ecx,-0x5c(%rbp)
     d96:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     d9d:	00 00 
     d9f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     da3:	31 c0                	xor    %eax,%eax
    //nova_dbg("record dir log");
//debug
	cpu = smp_processor_id();
	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    src_pn = get_dentry_path(src,0);
     da5:	e8 56 f3 ff ff       	callq  100 <get_dentry_path.isra.4>
    phname = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
     daa:	48 89 c7             	mov    %rax,%rdi
    //nova_dbg("record dir log");
//debug
	cpu = smp_processor_id();
	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    src_pn = get_dentry_path(src,0);
     dad:	49 89 c6             	mov    %rax,%r14
    phname = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
     db0:	e8 00 00 00 00       	callq  db5 <record_dir_log+0x45>
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
     db5:	48 8d 78 01          	lea    0x1(%rax),%rdi
     db9:	be d0 80 00 00       	mov    $0x80d0,%esi
     dbe:	e8 00 00 00 00       	callq  dc3 <record_dir_log+0x53>
    phn = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
     dc3:	4c 89 f7             	mov    %r14,%rdi
     dc6:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
     dca:	e8 00 00 00 00       	callq  dcf <record_dir_log+0x5f>
     dcf:	48 8d 78 01          	lea    0x1(%rax),%rdi
     dd3:	be d0 80 00 00       	mov    $0x80d0,%esi
     dd8:	e8 00 00 00 00       	callq  ddd <record_dir_log+0x6d>
     ddd:	48 89 c3             	mov    %rax,%rbx
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
     de0:	49 8b 85 b0 03 00 00 	mov    0x3b0(%r13),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
     de7:	4c 89 f7             	mov    %r14,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
     dea:	4c 8b a8 d8 01 00 00 	mov    0x1d8(%rax),%r13
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
     df1:	e8 00 00 00 00       	callq  df6 <record_dir_log+0x86>
     df6:	4c 89 f6             	mov    %r14,%rsi
     df9:	48 89 c2             	mov    %rax,%rdx
     dfc:	48 89 df             	mov    %rbx,%rdi
     dff:	e8 00 00 00 00       	callq  e04 <record_dir_log+0x94>
    tlen = strlen(phstr);
     e04:	4c 89 f7             	mov    %r14,%rdi
     e07:	e8 00 00 00 00       	callq  e0c <record_dir_log+0x9c>
     e0c:	49 89 c4             	mov    %rax,%r12
    do{
        tem = strrchr(ph, '/');
     e0f:	be 2f 00 00 00       	mov    $0x2f,%esi
     e14:	48 89 df             	mov    %rbx,%rdi
     e17:	e8 00 00 00 00       	callq  e1c <record_dir_log+0xac>
        phlen = tlen -strlen(tem);
     e1c:	48 89 c7             	mov    %rax,%rdi
     e1f:	e8 00 00 00 00       	callq  e24 <record_dir_log+0xb4>
        tlen = phlen;
        //bug
        if(phlen==0){
     e24:	49 29 c4             	sub    %rax,%r12
     e27:	0f 84 fa 02 00 00    	je     1127 <record_dir_log+0x3b7>
            break;
        }
        memcpy(ph,phstr,tlen);
     e2d:	4c 89 e2             	mov    %r12,%rdx
     e30:	4c 89 f6             	mov    %r14,%rsi
     e33:	48 89 df             	mov    %rbx,%rdi
     e36:	e8 00 00 00 00       	callq  e3b <record_dir_log+0xcb>
	int i;

	for (i = 0; i < length; i++) {
     e3b:	45 85 e4             	test   %r12d,%r12d
        ph[tlen]='\0';
     e3e:	42 c6 04 23 00       	movb   $0x0,(%rbx,%r12,1)
     e43:	0f 8e ad 02 00 00    	jle    10f6 <record_dir_log+0x386>
     e49:	41 8d 44 24 ff       	lea    -0x1(%r12),%eax
     e4e:	48 89 da             	mov    %rbx,%rdx
     e51:	31 f6                	xor    %esi,%esi
     e53:	48 8d 4c 03 01       	lea    0x1(%rbx,%rax,1),%rcx
		hash = hash * seed + (*str++);
     e58:	48 89 f0             	mov    %rsi,%rax
     e5b:	48 83 c2 01          	add    $0x1,%rdx
     e5f:	48 c1 e0 05          	shl    $0x5,%rax
     e63:	48 29 f0             	sub    %rsi,%rax
     e66:	48 89 c6             	mov    %rax,%rsi
     e69:	48 0f be 42 ff       	movsbq -0x1(%rdx),%rax
     e6e:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     e71:	48 39 ca             	cmp    %rcx,%rdx
     e74:	75 e2                	jne    e58 <record_dir_log+0xe8>
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
     e76:	4c 89 ef             	mov    %r13,%rdi
     e79:	e8 00 00 00 00       	callq  e7e <record_dir_log+0x10e>
        if(dzt_ei){
     e7e:	48 85 c0             	test   %rax,%rax
     e81:	74 8c                	je     e0f <record_dir_log+0x9f>
    src_pn = get_dentry_path(src,0);
    phname = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    //memcpy(phname, src_pn, strlen(src_pn));
    src_ei = find_dzt(sb, src_pn, phn);
    phlen = strlen(phn);
     e83:	48 89 df             	mov    %rbx,%rdi
    memcpy(ph, "/", 1);
    ph[1]='\0';
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    if(!dzt_ei){
     e86:	49 89 c4             	mov    %rax,%r12
    src_pn = get_dentry_path(src,0);
    phname = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    //memcpy(phname, src_pn, strlen(src_pn));
    src_ei = find_dzt(sb, src_pn, phn);
    phlen = strlen(phn);
     e89:	e8 00 00 00 00       	callq  e8e <record_dir_log+0x11e>
    if(phlen==1){
     e8e:	48 83 f8 01          	cmp    $0x1,%rax
     e92:	0f 84 e1 02 00 00    	je     1179 <record_dir_log+0x409>
        flen = strlen(src_pn);
        memcpy(phname, src_pn, flen);
        phname[flen]='\0';
        //memcpy(phname+flen, end, 1);
    } else {
        flen = strlen(src_pn)-phlen;
     e98:	4c 89 f7             	mov    %r14,%rdi
     e9b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
     e9f:	e8 00 00 00 00       	callq  ea4 <record_dir_log+0x134>
     ea4:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
        memcpy(phname, src_pn+phlen, flen);
     ea8:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
        flen = strlen(src_pn);
        memcpy(phname, src_pn, flen);
        phname[flen]='\0';
        //memcpy(phname+flen, end, 1);
    } else {
        flen = strlen(src_pn)-phlen;
     eac:	48 29 d0             	sub    %rdx,%rax
        memcpy(phname, src_pn+phlen, flen);
     eaf:	49 8d 34 16          	lea    (%r14,%rdx,1),%rsi
     eb3:	48 89 c2             	mov    %rax,%rdx
        flen = strlen(src_pn);
        memcpy(phname, src_pn, flen);
        phname[flen]='\0';
        //memcpy(phname+flen, end, 1);
    } else {
        flen = strlen(src_pn)-phlen;
     eb6:	49 89 c5             	mov    %rax,%r13
        memcpy(phname, src_pn+phlen, flen);
     eb9:	e8 00 00 00 00       	callq  ebe <record_dir_log+0x14e>
        phname[flen]='\0';
     ebe:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
     ec2:	42 c6 04 28 00       	movb   $0x0,(%rax,%r13,1)
     ec7:	45 85 ed             	test   %r13d,%r13d
     eca:	0f 8e f9 02 00 00    	jle    11c9 <record_dir_log+0x459>
     ed0:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
     ed4:	41 8d 45 ff          	lea    -0x1(%r13),%eax
     ed8:	45 31 ed             	xor    %r13d,%r13d
     edb:	48 8d 4c 07 01       	lea    0x1(%rdi,%rax,1),%rcx
     ee0:	48 89 f8             	mov    %rdi,%rax
		hash = hash * seed + (*str++);
     ee3:	4c 89 ea             	mov    %r13,%rdx
     ee6:	48 83 c0 01          	add    $0x1,%rax
     eea:	48 c1 e2 05          	shl    $0x5,%rdx
     eee:	4c 29 ea             	sub    %r13,%rdx
     ef1:	49 89 d5             	mov    %rdx,%r13
     ef4:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
     ef9:	49 01 d5             	add    %rdx,%r13
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     efc:	48 39 c8             	cmp    %rcx,%rax
     eff:	75 e2                	jne    ee3 <record_dir_log+0x173>
        //memcpy(phname+flen,end,1);
    }
    src_hn = BKDRHash(phname, flen);
    sdz_hn = src_ei->hash_name;
     f01:	49 8b 44 24 30       	mov    0x30(%r12),%rax

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    if(!des) {
     f06:	4d 85 ff             	test   %r15,%r15
        memcpy(phname, src_pn+phlen, flen);
        phname[flen]='\0';
        //memcpy(phname+flen,end,1);
    }
    src_hn = BKDRHash(phname, flen);
    sdz_hn = src_ei->hash_name;
     f09:	48 89 45 a8          	mov    %rax,-0x58(%rbp)

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    if(!des) {
     f0d:	0f 84 56 02 00 00    	je     1169 <record_dir_log+0x3f9>
        des_hn = 0;
        des_dz_hn = 0;
    }
    else {
        ph = get_dentry_path(des,0);
     f13:	4c 89 ff             	mov    %r15,%rdi
     f16:	e8 e5 f1 ff ff       	callq  100 <get_dentry_path.isra.4>
     f1b:	49 89 c7             	mov    %rax,%r15
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
     f1e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
     f22:	4c 89 ff             	mov    %r15,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
     f25:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
     f2c:	48 8b 80 d8 01 00 00 	mov    0x1d8(%rax),%rax
     f33:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
     f37:	e8 00 00 00 00       	callq  f3c <record_dir_log+0x1cc>
     f3c:	4c 89 fe             	mov    %r15,%rsi
     f3f:	48 89 c2             	mov    %rax,%rdx
     f42:	48 89 df             	mov    %rbx,%rdi
     f45:	e8 00 00 00 00       	callq  f4a <record_dir_log+0x1da>
    tlen = strlen(phstr);
     f4a:	4c 89 ff             	mov    %r15,%rdi
     f4d:	e8 00 00 00 00       	callq  f52 <record_dir_log+0x1e2>
     f52:	49 89 c4             	mov    %rax,%r12
    do{
        tem = strrchr(ph, '/');
     f55:	be 2f 00 00 00       	mov    $0x2f,%esi
     f5a:	48 89 df             	mov    %rbx,%rdi
     f5d:	e8 00 00 00 00       	callq  f62 <record_dir_log+0x1f2>
        phlen = tlen -strlen(tem);
     f62:	48 89 c7             	mov    %rax,%rdi
     f65:	e8 00 00 00 00       	callq  f6a <record_dir_log+0x1fa>
        tlen = phlen;
        //bug
        if(phlen==0){
     f6a:	49 29 c4             	sub    %rax,%r12
     f6d:	0f 84 d6 01 00 00    	je     1149 <record_dir_log+0x3d9>
            break;
        }
        memcpy(ph,phstr,tlen);
     f73:	4c 89 e2             	mov    %r12,%rdx
     f76:	4c 89 fe             	mov    %r15,%rsi
     f79:	48 89 df             	mov    %rbx,%rdi
     f7c:	e8 00 00 00 00       	callq  f81 <record_dir_log+0x211>
     f81:	45 85 e4             	test   %r12d,%r12d
        ph[tlen]='\0';
     f84:	42 c6 04 23 00       	movb   $0x0,(%rbx,%r12,1)
     f89:	0f 8e 7f 01 00 00    	jle    110e <record_dir_log+0x39e>
     f8f:	41 8d 44 24 ff       	lea    -0x1(%r12),%eax
     f94:	48 89 da             	mov    %rbx,%rdx
     f97:	31 f6                	xor    %esi,%esi
     f99:	48 8d 4c 03 01       	lea    0x1(%rbx,%rax,1),%rcx
		hash = hash * seed + (*str++);
     f9e:	48 89 f0             	mov    %rsi,%rax
     fa1:	48 83 c2 01          	add    $0x1,%rdx
     fa5:	48 c1 e0 05          	shl    $0x5,%rax
     fa9:	48 29 f0             	sub    %rsi,%rax
     fac:	48 89 c6             	mov    %rax,%rsi
     faf:	48 0f be 42 ff       	movsbq -0x1(%rdx),%rax
     fb4:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     fb7:	48 39 ca             	cmp    %rcx,%rdx
     fba:	75 e2                	jne    f9e <record_dir_log+0x22e>
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
     fbc:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
     fc0:	e8 00 00 00 00       	callq  fc5 <record_dir_log+0x255>
        if(dzt_ei){
     fc5:	48 85 c0             	test   %rax,%rax
     fc8:	74 8b                	je     f55 <record_dir_log+0x1e5>
    }
    else {
        ph = get_dentry_path(des,0);
        //memcpy(phname, ph, strlen(ph)+1);
        dzt_ei = find_dzt(sb, ph, phn);
        des_dz_hn = dzt_ei->hash_name;
     fca:	48 8b 40 30          	mov    0x30(%rax),%rax
        phlen = strlen(phn);
     fce:	48 89 df             	mov    %rbx,%rdi
    }
    else {
        ph = get_dentry_path(des,0);
        //memcpy(phname, ph, strlen(ph)+1);
        dzt_ei = find_dzt(sb, ph, phn);
        des_dz_hn = dzt_ei->hash_name;
     fd1:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        phlen = strlen(phn);
     fd5:	e8 00 00 00 00       	callq  fda <record_dir_log+0x26a>
        if(phlen==1){
     fda:	48 83 f8 01          	cmp    $0x1,%rax
     fde:	0f 84 bd 01 00 00    	je     11a1 <record_dir_log+0x431>
            flen = strlen(ph);
            memcpy(phname, ph, flen);
            phname[flen]='\0';
            //memcpy(phname+flen, end, 1);
        } else {
            flen = strlen(ph)-phlen;
     fe4:	4c 89 ff             	mov    %r15,%rdi
     fe7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
     feb:	e8 00 00 00 00       	callq  ff0 <record_dir_log+0x280>
     ff0:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
            memcpy(phname, ph+phlen, flen);
     ff4:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
            flen = strlen(ph);
            memcpy(phname, ph, flen);
            phname[flen]='\0';
            //memcpy(phname+flen, end, 1);
        } else {
            flen = strlen(ph)-phlen;
     ff8:	48 29 d0             	sub    %rdx,%rax
            memcpy(phname, ph+phlen, flen);
     ffb:	49 8d 34 17          	lea    (%r15,%rdx,1),%rsi
     fff:	48 89 c2             	mov    %rax,%rdx
            flen = strlen(ph);
            memcpy(phname, ph, flen);
            phname[flen]='\0';
            //memcpy(phname+flen, end, 1);
        } else {
            flen = strlen(ph)-phlen;
    1002:	49 89 c4             	mov    %rax,%r12
            memcpy(phname, ph+phlen, flen);
    1005:	e8 00 00 00 00       	callq  100a <record_dir_log+0x29a>
            phname[flen]='\0';
    100a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    100e:	42 c6 04 20 00       	movb   $0x0,(%rax,%r12,1)
    1013:	45 85 e4             	test   %r12d,%r12d
    1016:	0f 8e b5 01 00 00    	jle    11d1 <record_dir_log+0x461>
    101c:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    1020:	41 8d 44 24 ff       	lea    -0x1(%r12),%eax
    1025:	45 31 e4             	xor    %r12d,%r12d
    1028:	48 8d 74 07 01       	lea    0x1(%rdi,%rax,1),%rsi
    102d:	48 89 f8             	mov    %rdi,%rax
		hash = hash * seed + (*str++);
    1030:	4c 89 e1             	mov    %r12,%rcx
    1033:	48 83 c0 01          	add    $0x1,%rax
    1037:	48 c1 e1 05          	shl    $0x5,%rcx
    103b:	4c 29 e1             	sub    %r12,%rcx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    103e:	48 39 f0             	cmp    %rsi,%rax
		hash = hash * seed + (*str++);
    1041:	48 89 ca             	mov    %rcx,%rdx
    1044:	48 0f be 48 ff       	movsbq -0x1(%rax),%rcx
    1049:	4c 8d 24 11          	lea    (%rcx,%rdx,1),%r12
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    104d:	75 e1                	jne    1030 <record_dir_log+0x2c0>
            //memcpy(phname+flen,end,1);
        }
        des_hn = BKDRHash(phname, flen);
        kfree(ph);
    104f:	4c 89 ff             	mov    %r15,%rdi
    1052:	e8 00 00 00 00       	callq  1057 <record_dir_log+0x2e7>
    }

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    dzt_blk = dafs_get_dzt_block(sb);
    1057:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    105b:	e8 00 00 00 00       	callq  1060 <record_dir_log+0x2f0>
    make_dzt_ptr(sb, &dzt_p);
    1060:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    1064:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
        kfree(ph);
    }

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    dzt_blk = dafs_get_dzt_block(sb);
    1068:	49 89 c7             	mov    %rax,%r15
    make_dzt_ptr(sb, &dzt_p);
    106b:	e8 00 00 00 00       	callq  1070 <record_dir_log+0x300>
    dlog = (struct direntry_log*)&dzt_blk->dzt_entry[DAFS_DZT_ENTRIES_IN_BLOCK];
    test_and_set_bit_le(bitpos, (void *)dzt_p->bitmap);
    1070:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    1074:	b9 48 00 00 00       	mov    $0x48,%ecx
    1079:	48 8b 00             	mov    (%rax),%rax
    107c:	f0 48 0f ab 08       	lock bts %rcx,(%rax)
    1081:	72 00                	jb     1083 <record_dir_log+0x313>

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    /*not decided*/
    dlog->type_d = type;
    1083:	0f b6 45 a4          	movzbl -0x5c(%rbp),%eax
    dlog->src_dz_hn = cpu_to_le64(sdz_hn);
    dlog->src_hashname = cpu_to_le64(src_hn);
    dlog->des_dz_hn = cpu_to_le64(des_dz_hn);
    dlog->des_hashname = cpu_to_le64(des_hn);

    kfree(src_pn);
    1087:	4c 89 f7             	mov    %r14,%rdi
	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    /*not decided*/
    dlog->type_d = type;
    dlog->src_dz_hn = cpu_to_le64(sdz_hn);
    dlog->src_hashname = cpu_to_le64(src_hn);
    108a:	4d 89 af 28 10 00 00 	mov    %r13,0x1028(%r15)
    dlog->des_dz_hn = cpu_to_le64(des_dz_hn);
    dlog->des_hashname = cpu_to_le64(des_hn);
    1091:	4d 89 a7 20 10 00 00 	mov    %r12,0x1020(%r15)
    test_and_set_bit_le(bitpos, (void *)dzt_p->bitmap);

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    /*not decided*/
    dlog->type_d = type;
    1098:	41 88 87 08 10 00 00 	mov    %al,0x1008(%r15)
    dlog->src_dz_hn = cpu_to_le64(sdz_hn);
    109f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    10a3:	49 89 87 10 10 00 00 	mov    %rax,0x1010(%r15)
    dlog->src_hashname = cpu_to_le64(src_hn);
    dlog->des_dz_hn = cpu_to_le64(des_dz_hn);
    10aa:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    10ae:	49 89 87 18 10 00 00 	mov    %rax,0x1018(%r15)
    dlog->des_hashname = cpu_to_le64(des_hn);

    kfree(src_pn);
    10b5:	e8 00 00 00 00       	callq  10ba <record_dir_log+0x34a>
    kfree(phname);
    10ba:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    10be:	e8 00 00 00 00       	callq  10c3 <record_dir_log+0x353>
    kfree(phn);
    10c3:	48 89 df             	mov    %rbx,%rdi
    10c6:	e8 00 00 00 00       	callq  10cb <record_dir_log+0x35b>
    kfree(dzt_p);
    10cb:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    10cf:	e8 00 00 00 00       	callq  10d4 <record_dir_log+0x364>
    //nova_dbg("%s end record log",__func__);
}
    10d4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    10d8:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    10df:	00 00 
    10e1:	0f 85 f2 00 00 00    	jne    11d9 <record_dir_log+0x469>
    10e7:	48 83 c4 40          	add    $0x40,%rsp
    10eb:	5b                   	pop    %rbx
    10ec:	41 5c                	pop    %r12
    10ee:	41 5d                	pop    %r13
    10f0:	41 5e                	pop    %r14
    10f2:	41 5f                	pop    %r15
    10f4:	5d                   	pop    %rbp
    10f5:	c3                   	retq   
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    10f6:	31 f6                	xor    %esi,%esi
        memcpy(ph,phstr,tlen);
        ph[tlen]='\0';
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    10f8:	4c 89 ef             	mov    %r13,%rdi
    10fb:	e8 00 00 00 00       	callq  1100 <record_dir_log+0x390>
        if(dzt_ei){
    1100:	48 85 c0             	test   %rax,%rax
    1103:	0f 84 06 fd ff ff    	je     e0f <record_dir_log+0x9f>
    1109:	e9 75 fd ff ff       	jmpq   e83 <record_dir_log+0x113>
        memcpy(ph,phstr,tlen);
        ph[tlen]='\0';
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    110e:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    1112:	31 f6                	xor    %esi,%esi
    1114:	e8 00 00 00 00       	callq  1119 <record_dir_log+0x3a9>
        if(dzt_ei){
    1119:	48 85 c0             	test   %rax,%rax
    111c:	0f 84 33 fe ff ff    	je     f55 <record_dir_log+0x1e5>
    1122:	e9 a3 fe ff ff       	jmpq   fca <record_dir_log+0x25a>
            return dzt_ei;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    1127:	c6 03 2f             	movb   $0x2f,(%rbx)
    ph[1]='\0';
    112a:	c6 43 01 00          	movb   $0x0,0x1(%rbx)
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    112e:	be 2f 00 00 00       	mov    $0x2f,%esi
    1133:	4c 89 ef             	mov    %r13,%rdi
    1136:	e8 00 00 00 00       	callq  113b <record_dir_log+0x3cb>
    if(!dzt_ei){
    113b:	48 85 c0             	test   %rax,%rax
    113e:	0f 85 3f fd ff ff    	jne    e83 <record_dir_log+0x113>
    1144:	e8 00 00 00 00       	callq  1149 <record_dir_log+0x3d9>
    /*root dir*/
    memcpy(ph, "/", 1);
    ph[1]='\0';
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    1149:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
            return dzt_ei;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    114d:	c6 03 2f             	movb   $0x2f,(%rbx)
    ph[1]='\0';
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    1150:	be 2f 00 00 00       	mov    $0x2f,%esi
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    ph[1]='\0';
    1155:	c6 43 01 00          	movb   $0x0,0x1(%rbx)
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    1159:	e8 00 00 00 00       	callq  115e <record_dir_log+0x3ee>
    if(!dzt_ei){
    115e:	48 85 c0             	test   %rax,%rax
    1161:	0f 85 63 fe ff ff    	jne    fca <record_dir_log+0x25a>
    1167:	eb db                	jmp    1144 <record_dir_log+0x3d4>
    sdz_hn = src_ei->hash_name;

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    if(!des) {
        des_hn = 0;
    1169:	45 31 e4             	xor    %r12d,%r12d
        des_dz_hn = 0;
    116c:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    1173:	00 
    1174:	e9 de fe ff ff       	jmpq   1057 <record_dir_log+0x2e7>
    phn = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    //memcpy(phname, src_pn, strlen(src_pn));
    src_ei = find_dzt(sb, src_pn, phn);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(src_pn);
    1179:	4c 89 f7             	mov    %r14,%rdi
    117c:	e8 00 00 00 00       	callq  1181 <record_dir_log+0x411>
        memcpy(phname, src_pn, flen);
    1181:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    1185:	48 89 c2             	mov    %rax,%rdx
    1188:	4c 89 f6             	mov    %r14,%rsi
    phn = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    //memcpy(phname, src_pn, strlen(src_pn));
    src_ei = find_dzt(sb, src_pn, phn);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(src_pn);
    118b:	49 89 c5             	mov    %rax,%r13
        memcpy(phname, src_pn, flen);
    118e:	e8 00 00 00 00       	callq  1193 <record_dir_log+0x423>
        phname[flen]='\0';
    1193:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    1197:	42 c6 04 28 00       	movb   $0x0,(%rax,%r13,1)
    119c:	e9 26 fd ff ff       	jmpq   ec7 <record_dir_log+0x157>
        //memcpy(phname, ph, strlen(ph)+1);
        dzt_ei = find_dzt(sb, ph, phn);
        des_dz_hn = dzt_ei->hash_name;
        phlen = strlen(phn);
        if(phlen==1){
            flen = strlen(ph);
    11a1:	4c 89 ff             	mov    %r15,%rdi
    11a4:	e8 00 00 00 00       	callq  11a9 <record_dir_log+0x439>
            memcpy(phname, ph, flen);
    11a9:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    11ad:	48 89 c2             	mov    %rax,%rdx
    11b0:	4c 89 fe             	mov    %r15,%rsi
        //memcpy(phname, ph, strlen(ph)+1);
        dzt_ei = find_dzt(sb, ph, phn);
        des_dz_hn = dzt_ei->hash_name;
        phlen = strlen(phn);
        if(phlen==1){
            flen = strlen(ph);
    11b3:	49 89 c4             	mov    %rax,%r12
            memcpy(phname, ph, flen);
    11b6:	e8 00 00 00 00       	callq  11bb <record_dir_log+0x44b>
            phname[flen]='\0';
    11bb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    11bf:	42 c6 04 20 00       	movb   $0x0,(%rax,%r12,1)
    11c4:	e9 4a fe ff ff       	jmpq   1013 <record_dir_log+0x2a3>
    11c9:	45 31 ed             	xor    %r13d,%r13d
    11cc:	e9 30 fd ff ff       	jmpq   f01 <record_dir_log+0x191>
    11d1:	45 31 e4             	xor    %r12d,%r12d
    11d4:	e9 76 fe ff ff       	jmpq   104f <record_dir_log+0x2df>
    kfree(src_pn);
    kfree(phname);
    kfree(phn);
    kfree(dzt_p);
    //nova_dbg("%s end record log",__func__);
}
    11d9:	e8 00 00 00 00       	callq  11de <record_dir_log+0x46e>
    11de:	66 90                	xchg   %ax,%ax

00000000000011e0 <delete_dir_log>:

/*delete dir operation log*/
void delete_dir_log(struct super_block *sb)
{
    11e0:	e8 00 00 00 00       	callq  11e5 <delete_dir_log+0x5>
    11e5:	55                   	push   %rbp
    11e6:	48 89 e5             	mov    %rsp,%rbp
    11e9:	48 83 ec 10          	sub    $0x10,%rsp
    //struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_ptr *dzt_p;
    u32 bitpos = DAFS_DZT_ENTRIES_IN_BLOCK;

    //nova_dbg("%s start",__func__);
    make_dzt_ptr(sb, &dzt_p);
    11ed:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
    //nova_dbg("%s end record log",__func__);
}

/*delete dir operation log*/
void delete_dir_log(struct super_block *sb)
{
    11f1:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    11f8:	00 00 
    11fa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    11fe:	31 c0                	xor    %eax,%eax
    //struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_ptr *dzt_p;
    u32 bitpos = DAFS_DZT_ENTRIES_IN_BLOCK;

    //nova_dbg("%s start",__func__);
    make_dzt_ptr(sb, &dzt_p);
    1200:	e8 00 00 00 00       	callq  1205 <delete_dir_log+0x25>
    test_and_clear_bit_le(bitpos, (void *)dzt_p->bitmap);
    1205:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_clear_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "btr", *addr, "Ir", nr, "%0", "c");
    1209:	ba 48 00 00 00       	mov    $0x48,%edx
    120e:	48 8b 00             	mov    (%rax),%rax
    1211:	f0 48 0f b3 10       	lock btr %rdx,(%rax)
    1216:	72 00                	jb     1218 <delete_dir_log+0x38>
    kfree(dzt_p);
    1218:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
    121c:	e8 00 00 00 00       	callq  1221 <delete_dir_log+0x41>
}
    1221:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1225:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    122c:	00 00 
    122e:	75 02                	jne    1232 <delete_dir_log+0x52>
    1230:	c9                   	leaveq 
    1231:	c3                   	retq   
    1232:	e8 00 00 00 00       	callq  1237 <delete_dir_log+0x57>
    1237:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    123e:	00 00 

0000000000001240 <ext_de_name>:
* nameflag = 0 => name
* nameflag = 1==> fulname*/
void ext_de_name(struct super_block *sb, struct dzt_entry_info *ei, struct dafs_zone_entry *ze,\
        struct zone_ptr *p, int cur_pos, int name_len, const char *name, int name_flag)

{
    1240:	e8 00 00 00 00       	callq  1245 <ext_de_name+0x5>
    1245:	55                   	push   %rbp
    1246:	48 89 e5             	mov    %rsp,%rbp
    1249:	41 57                	push   %r15
    124b:	41 56                	push   %r14
    124d:	41 55                	push   %r13
    124f:	41 54                	push   %r12
    1251:	53                   	push   %rbx
    1252:	48 83 ec 18          	sub    $0x18,%rsp
    //struct dzt_entry_info *ei;
    u64 ext_len;
    u32 bitpos, ext_pos, ext_num;
  
    //nova_dbg("%s start, dentry pos %d",__func__, cur_pos);
    BUG_ON(ze==NULL);
    1256:	48 85 d2             	test   %rdx,%rdx
* nameflag = 0 => name
* nameflag = 1==> fulname*/
void ext_de_name(struct super_block *sb, struct dzt_entry_info *ei, struct dafs_zone_entry *ze,\
        struct zone_ptr *p, int cur_pos, int name_len, const char *name, int name_flag)

{
    1259:	4c 8b 7d 10          	mov    0x10(%rbp),%r15
    //struct dzt_entry_info *ei;
    u64 ext_len;
    u32 bitpos, ext_pos, ext_num;
  
    //nova_dbg("%s start, dentry pos %d",__func__, cur_pos);
    BUG_ON(ze==NULL);
    125d:	0f 84 47 05 00 00    	je     17aa <ext_de_name+0x56a>
    1263:	49 63 d9             	movslq %r9d,%rbx
    de = &ze->dentry[cur_pos];
    BUG_ON(de==NULL);
    //nova_dbg("%s: dentry %s: cur_pos %d", __func__, name, cur_pos);
    cur_pos ++;
    if(name_flag == 0){
    1266:	44 8b 4d 18          	mov    0x18(%rbp),%r9d
    126a:	49 89 ce             	mov    %rcx,%r14
    126d:	49 89 d4             	mov    %rdx,%r12
    1270:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    1274:	49 89 fd             	mov    %rdi,%r13
    //nova_dbg("%s start, dentry pos %d",__func__, cur_pos);
    BUG_ON(ze==NULL);
    de = &ze->dentry[cur_pos];
    BUG_ON(de==NULL);
    //nova_dbg("%s: dentry %s: cur_pos %d", __func__, name, cur_pos);
    cur_pos ++;
    1277:	41 8d 48 01          	lea    0x1(%r8),%ecx
    127b:	44 89 45 c8          	mov    %r8d,-0x38(%rbp)
    if(name_flag == 0){
    127f:	45 85 c9             	test   %r9d,%r9d
    1282:	0f 85 2f 02 00 00    	jne    14b7 <ext_de_name+0x277>
        /*judge name len && set dentry name*/
        if(name_len <= LARGE_NAME_LEN){
    1288:	83 fb 70             	cmp    $0x70,%ebx
    128b:	0f 8f a4 00 00 00    	jg     1335 <ext_de_name+0xf5>
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    1291:	4c 89 f2             	mov    %r14,%rdx
    1294:	e8 00 00 00 00       	callq  1299 <ext_de_name+0x59>
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de->next = de_ext;
    1299:	4c 63 45 c8          	movslq -0x38(%rbp),%r8
        /*judge name len && set dentry name*/
        if(name_len <= LARGE_NAME_LEN){
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
    129d:	89 c2                	mov    %eax,%edx
    129f:	48 81 c2 81 00 00 00 	add    $0x81,%rdx
    12a6:	48 c1 e2 07          	shl    $0x7,%rdx
    12aa:	4c 01 e2             	add    %r12,%rdx
            de->next = de_ext;
    12ad:	49 c1 e0 07          	shl    $0x7,%r8
            memcpy(de_ext->name, name, name_len);
    12b1:	48 83 fb 08          	cmp    $0x8,%rbx
    12b5:	48 8d 4a 10          	lea    0x10(%rdx),%rcx
        if(name_len <= LARGE_NAME_LEN){
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de->next = de_ext;
    12b9:	4b 89 94 04 b0 40 00 	mov    %rdx,0x40b0(%r12,%r8,1)
    12c0:	00 
            memcpy(de_ext->name, name, name_len);
    12c1:	0f 83 60 04 00 00    	jae    1727 <ext_de_name+0x4e7>
    12c7:	f6 c3 04             	test   $0x4,%bl
    12ca:	0f 85 0a 05 00 00    	jne    17da <ext_de_name+0x59a>
    12d0:	48 85 db             	test   %rbx,%rbx
    12d3:	74 11                	je     12e6 <ext_de_name+0xa6>
    12d5:	41 0f b6 37          	movzbl (%r15),%esi
    12d9:	f6 c3 02             	test   $0x2,%bl
    12dc:	40 88 72 10          	mov    %sil,0x10(%rdx)
    12e0:	0f 85 14 05 00 00    	jne    17fa <ext_de_name+0x5ba>
            de_ext->name[name_len]='\0';
    12e6:	c6 44 1a 10 00       	movb   $0x0,0x10(%rdx,%rbx,1)
            de_ext->ext_pos = cpu_to_le32(ext_pos);
    12eb:	89 42 04             	mov    %eax,0x4(%rdx)
	__clear_bit(nr ^ BITOP_LE_SWIZZLE, addr);
}

static inline int test_and_set_bit_le(int nr, void *addr)
{
	return test_and_set_bit(nr ^ BITOP_LE_SWIZZLE, addr);
    12ee:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax
            //de_ext->next = NULL;
            bitpos = ext_pos*2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
    12f2:	49 8b 0e             	mov    (%r14),%rcx
    12f5:	48 98                	cltq   
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    12f7:	f0 48 0f ab 01       	lock bts %rax,(%rcx)
    12fc:	72 00                	jb     12fe <ext_de_name+0xbe>

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
    12fe:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # 1304 <ext_de_name+0xc4>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    1304:	89 d6                	mov    %edx,%esi
	if (support_clwb) {
    1306:	31 c9                	xor    %ecx,%ecx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    1308:	83 e6 3f             	and    $0x3f,%esi
    130b:	83 ee 80             	sub    $0xffffff80,%esi
	if (support_clwb) {
    130e:	85 ff                	test   %edi,%edi
    1310:	0f 84 fd 03 00 00    	je     1713 <ext_de_name+0x4d3>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    1316:	89 c8                	mov    %ecx,%eax
    1318:	48 01 d0             	add    %rdx,%rax
    131b:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    131f:	83 c1 40             	add    $0x40,%ecx
    1322:	39 ce                	cmp    %ecx,%esi
    1324:	77 f0                	ja     1316 <ext_de_name+0xd6>
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
        }
    }
    //nova_dbg("%s end",__func__);
}
    1326:	48 83 c4 18          	add    $0x18,%rsp
    132a:	5b                   	pop    %rbx
    132b:	41 5c                	pop    %r12
    132d:	41 5d                	pop    %r13
    132f:	41 5e                	pop    %r14
    1331:	41 5f                	pop    %r15
    1333:	5d                   	pop    %rbp
    1334:	c3                   	retq   
            test_and_set_bit_le(bitpos, (void *)p->statemap);
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
        } else {
            //de->ext_flag = 1;
            ext_len = name_len - LARGE_NAME_LEN -1;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    1335:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
            bitpos = ext_pos*2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
        } else {
            //de->ext_flag = 1;
            ext_len = name_len - LARGE_NAME_LEN -1;
    1339:	83 eb 71             	sub    $0x71,%ebx
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    133c:	4c 89 f2             	mov    %r14,%rdx
            bitpos = ext_pos*2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
        } else {
            //de->ext_flag = 1;
            ext_len = name_len - LARGE_NAME_LEN -1;
    133f:	48 63 c3             	movslq %ebx,%rax
    1342:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    1346:	e8 00 00 00 00       	callq  134b <ext_de_name+0x10b>
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
    134b:	41 89 c0             	mov    %eax,%r8d
            memcpy(de_ext->name, name, LARGE_NAME_LEN+1);
    134e:	49 8b 0f             	mov    (%r15),%rcx
    1351:	8d 54 00 01          	lea    0x1(%rax,%rax,1),%edx
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
        } else {
            //de->ext_flag = 1;
            ext_len = name_len - LARGE_NAME_LEN -1;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
    1355:	49 81 c0 81 00 00 00 	add    $0x81,%r8
    135c:	49 c1 e0 07          	shl    $0x7,%r8
    1360:	48 63 d2             	movslq %edx,%rdx
    1363:	4b 8d 1c 04          	lea    (%r12,%r8,1),%rbx
            memcpy(de_ext->name, name, LARGE_NAME_LEN+1);
    1367:	48 89 4b 10          	mov    %rcx,0x10(%rbx)
    136b:	49 8b 4f 08          	mov    0x8(%r15),%rcx
    136f:	48 89 4b 18          	mov    %rcx,0x18(%rbx)
    1373:	49 8b 4f 10          	mov    0x10(%r15),%rcx
    1377:	48 89 4b 20          	mov    %rcx,0x20(%rbx)
    137b:	49 8b 4f 18          	mov    0x18(%r15),%rcx
    137f:	48 89 4b 28          	mov    %rcx,0x28(%rbx)
    1383:	49 8b 4f 20          	mov    0x20(%r15),%rcx
    1387:	48 89 4b 30          	mov    %rcx,0x30(%rbx)
    138b:	49 8b 4f 28          	mov    0x28(%r15),%rcx
    138f:	48 89 4b 38          	mov    %rcx,0x38(%rbx)
    1393:	49 8b 4f 30          	mov    0x30(%r15),%rcx
    1397:	48 89 4b 40          	mov    %rcx,0x40(%rbx)
    139b:	49 8b 4f 38          	mov    0x38(%r15),%rcx
    139f:	48 89 4b 48          	mov    %rcx,0x48(%rbx)
    13a3:	49 8b 4f 40          	mov    0x40(%r15),%rcx
    13a7:	48 89 4b 50          	mov    %rcx,0x50(%rbx)
    13ab:	49 8b 4f 48          	mov    0x48(%r15),%rcx
    13af:	48 89 4b 58          	mov    %rcx,0x58(%rbx)
    13b3:	49 8b 4f 50          	mov    0x50(%r15),%rcx
    13b7:	48 89 4b 60          	mov    %rcx,0x60(%rbx)
    13bb:	49 8b 4f 58          	mov    0x58(%r15),%rcx
    13bf:	48 89 4b 68          	mov    %rcx,0x68(%rbx)
    13c3:	49 8b 4f 60          	mov    0x60(%r15),%rcx
    13c7:	48 89 4b 70          	mov    %rcx,0x70(%rbx)
    13cb:	49 8b 4f 68          	mov    0x68(%r15),%rcx
    13cf:	48 89 4b 78          	mov    %rcx,0x78(%rbx)
    13d3:	41 0f b6 4f 70       	movzbl 0x70(%r15),%ecx
            de_ext->ext_pos = cpu_to_le32(ext_pos);
    13d8:	89 43 04             	mov    %eax,0x4(%rbx)
        } else {
            //de->ext_flag = 1;
            ext_len = name_len - LARGE_NAME_LEN -1;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            memcpy(de_ext->name, name, LARGE_NAME_LEN+1);
    13db:	88 8b 80 00 00 00    	mov    %cl,0x80(%rbx)
            de_ext->ext_pos = cpu_to_le32(ext_pos);
            bitpos = ext_pos*2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
    13e1:	49 8b 0e             	mov    (%r14),%rcx
    13e4:	f0 48 0f ab 11       	lock bts %rdx,(%rcx)
    13e9:	72 00                	jb     13eb <ext_de_name+0x1ab>

            //de_ext->name[name_len]="/0";
            /*at most 2 extend dentry*/
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
    13eb:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    13ef:	4c 89 ef             	mov    %r13,%rdi
    13f2:	89 c1                	mov    %eax,%ecx
    13f4:	4c 89 f2             	mov    %r14,%rdx
    13f7:	e8 00 00 00 00       	callq  13fc <ext_de_name+0x1bc>
    13fc:	89 c2                	mov    %eax,%edx
            //de_ext->next = cpu_to_le64(ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de_ext->next = tem_ext;
            memcpy(tem_ext->name, name + LARGE_NAME_LEN + 1, ext_len);
    13fe:	49 8d 77 71          	lea    0x71(%r15),%rsi
    1402:	4c 8b 7d c8          	mov    -0x38(%rbp),%r15
            bitpos = ext_pos*2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);

            //de_ext->name[name_len]="/0";
            /*at most 2 extend dentry*/
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
    1406:	49 89 d5             	mov    %rdx,%r13
            //de_ext->next = cpu_to_le64(ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
    1409:	48 81 c2 81 00 00 00 	add    $0x81,%rdx
    1410:	48 c1 e2 07          	shl    $0x7,%rdx
    1414:	49 01 d4             	add    %rdx,%r12
            de_ext->next = tem_ext;
            memcpy(tem_ext->name, name + LARGE_NAME_LEN + 1, ext_len);
    1417:	4c 89 fa             	mov    %r15,%rdx
    141a:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
            //de_ext->name[name_len]="/0";
            /*at most 2 extend dentry*/
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
            //de_ext->next = cpu_to_le64(ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de_ext->next = tem_ext;
    141f:	4c 89 63 08          	mov    %r12,0x8(%rbx)
            memcpy(tem_ext->name, name + LARGE_NAME_LEN + 1, ext_len);
    1423:	e8 00 00 00 00       	callq  1428 <ext_de_name+0x1e8>
    1428:	43 8d 44 2d 01       	lea    0x1(%r13,%r13,1),%eax
            tem_ext->name[ext_len]='\0';
    142d:	43 c6 44 3c 10 00    	movb   $0x0,0x10(%r12,%r15,1)
            //tem_ext->next = NULL;
            tem_ext->ext_pos = cpu_to_le32(ext_pos);
    1433:	45 89 6c 24 04       	mov    %r13d,0x4(%r12)
            bitpos = ext_pos *2 +1;
            test_and_set_bit_le(bitpos,(void *)p->statemap);
    1438:	49 8b 16             	mov    (%r14),%rdx
    143b:	48 98                	cltq   
    143d:	f0 48 0f ab 02       	lock bts %rax,(%rdx)
    1442:	72 00                	jb     1444 <ext_de_name+0x204>

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
    1444:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 144a <ext_de_name+0x20a>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    144a:	89 d9                	mov    %ebx,%ecx
	if (support_clwb) {
    144c:	31 d2                	xor    %edx,%edx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    144e:	83 e1 3f             	and    $0x3f,%ecx
    1451:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    1454:	85 f6                	test   %esi,%esi
    1456:	74 3a                	je     1492 <ext_de_name+0x252>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    1458:	89 d0                	mov    %edx,%eax
    145a:	48 01 d8             	add    %rbx,%rax
    145d:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    1461:	83 c2 40             	add    $0x40,%edx
    1464:	39 d1                	cmp    %edx,%ecx
    1466:	77 f0                	ja     1458 <ext_de_name+0x218>

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
    1468:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 146e <ext_de_name+0x22e>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    146e:	44 89 e1             	mov    %r12d,%ecx
	if (support_clwb) {
    1471:	31 d2                	xor    %edx,%edx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    1473:	83 e1 3f             	and    $0x3f,%ecx
    1476:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    1479:	85 c0                	test   %eax,%eax
    147b:	74 26                	je     14a3 <ext_de_name+0x263>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    147d:	89 d0                	mov    %edx,%eax
    147f:	4c 01 e0             	add    %r12,%rax
    1482:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    1486:	83 c2 40             	add    $0x40,%edx
    1489:	39 d1                	cmp    %edx,%ecx
    148b:	77 f0                	ja     147d <ext_de_name+0x23d>
    148d:	e9 94 fe ff ff       	jmpq   1326 <ext_de_name+0xe6>
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    1492:	89 d0                	mov    %edx,%eax
    1494:	48 01 d8             	add    %rbx,%rax
    1497:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    149a:	83 c2 40             	add    $0x40,%edx
    149d:	39 d1                	cmp    %edx,%ecx
    149f:	77 f1                	ja     1492 <ext_de_name+0x252>
    14a1:	eb c5                	jmp    1468 <ext_de_name+0x228>
			_mm_clflush(buf + i);
    14a3:	89 d0                	mov    %edx,%eax
    14a5:	4c 01 e0             	add    %r12,%rax
    14a8:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    14ab:	83 c2 40             	add    $0x40,%edx
    14ae:	39 d1                	cmp    %edx,%ecx
    14b0:	77 f1                	ja     14a3 <ext_de_name+0x263>
    14b2:	e9 6f fe ff ff       	jmpq   1326 <ext_de_name+0xe6>
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
            nova_flush_buffer(tem_ext, DAFS_DEF_DENTRY_SIZE, 0);
        }
    } else {
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    14b7:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    14bb:	4c 89 f2             	mov    %r14,%rdx
    14be:	e8 00 00 00 00       	callq  14c3 <ext_de_name+0x283>
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
        de->ful_name.fn_ext = de_ext;
    14c3:	4c 63 45 c8          	movslq -0x38(%rbp),%r8
            test_and_set_bit_le(bitpos,(void *)p->statemap);
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
            nova_flush_buffer(tem_ext, DAFS_DEF_DENTRY_SIZE, 0);
        }
    } else {
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    14c7:	41 89 c1             	mov    %eax,%r9d
    14ca:	4d 89 cb             	mov    %r9,%r11
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
    14cd:	49 81 c1 81 00 00 00 	add    $0x81,%r9
    14d4:	49 c1 e1 07          	shl    $0x7,%r9
    14d8:	4d 01 e1             	add    %r12,%r9
        de->ful_name.fn_ext = de_ext;
    14db:	49 c1 e0 07          	shl    $0x7,%r8

        if(name_len <= (LARGE_NAME_LEN)){
    14df:	83 fb 70             	cmp    $0x70,%ebx
            nova_flush_buffer(tem_ext, DAFS_DEF_DENTRY_SIZE, 0);
        }
    } else {
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
        de->ful_name.fn_ext = de_ext;
    14e2:	4f 89 8c 04 d8 40 00 	mov    %r9,0x40d8(%r12,%r8,1)
    14e9:	00 

        if(name_len <= (LARGE_NAME_LEN)){
    14ea:	0f 8e 68 02 00 00    	jle    1758 <ext_de_name+0x518>
            //de_ext->next = NULL;
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
        }else {
            ext_len = 0;
            ext_num = name_len/(LARGE_NAME_LEN);
    14f0:	89 d8                	mov    %ebx,%eax
    14f2:	ba 93 24 49 92       	mov    $0x92492493,%edx
    14f7:	f7 ea                	imul   %edx
    14f9:	89 d8                	mov    %ebx,%eax
    14fb:	c1 f8 1f             	sar    $0x1f,%eax
    14fe:	01 da                	add    %ebx,%edx
    1500:	c1 fa 06             	sar    $0x6,%edx
    1503:	29 c2                	sub    %eax,%edx
    1505:	43 8d 44 1b 01       	lea    0x1(%r11,%r11,1),%eax
    150a:	89 55 c0             	mov    %edx,-0x40(%rbp)
            ext_num++;
            //ext_pos = cur_pos;
            //if(name_len%(LARGE_NAME_LEN)>ext_num)
                //ext_num++;
            memcpy(de_ext->name, name, LARGE_NAME_LEN);
    150d:	49 8b 17             	mov    (%r15),%rdx
    1510:	48 98                	cltq   
    1512:	49 89 51 10          	mov    %rdx,0x10(%r9)
    1516:	49 8b 57 08          	mov    0x8(%r15),%rdx
    151a:	49 89 51 18          	mov    %rdx,0x18(%r9)
    151e:	49 8b 57 10          	mov    0x10(%r15),%rdx
    1522:	49 89 51 20          	mov    %rdx,0x20(%r9)
    1526:	49 8b 57 18          	mov    0x18(%r15),%rdx
    152a:	49 89 51 28          	mov    %rdx,0x28(%r9)
    152e:	49 8b 57 20          	mov    0x20(%r15),%rdx
    1532:	49 89 51 30          	mov    %rdx,0x30(%r9)
    1536:	49 8b 57 28          	mov    0x28(%r15),%rdx
    153a:	49 89 51 38          	mov    %rdx,0x38(%r9)
    153e:	49 8b 57 30          	mov    0x30(%r15),%rdx
    1542:	49 89 51 40          	mov    %rdx,0x40(%r9)
    1546:	49 8b 57 38          	mov    0x38(%r15),%rdx
    154a:	49 89 51 48          	mov    %rdx,0x48(%r9)
    154e:	49 8b 57 40          	mov    0x40(%r15),%rdx
    1552:	49 89 51 50          	mov    %rdx,0x50(%r9)
    1556:	49 8b 57 48          	mov    0x48(%r15),%rdx
    155a:	49 89 51 58          	mov    %rdx,0x58(%r9)
    155e:	49 8b 57 50          	mov    0x50(%r15),%rdx
    1562:	49 89 51 60          	mov    %rdx,0x60(%r9)
    1566:	49 8b 57 58          	mov    0x58(%r15),%rdx
    156a:	49 89 51 68          	mov    %rdx,0x68(%r9)
    156e:	49 8b 57 60          	mov    0x60(%r15),%rdx
    1572:	49 89 51 70          	mov    %rdx,0x70(%r9)
    1576:	49 8b 57 68          	mov    0x68(%r15),%rdx
            de_ext->name[LARGE_NAME_LEN]='\0';
    157a:	41 c6 81 80 00 00 00 	movb   $0x0,0x80(%r9)
    1581:	00 
            de_ext->ext_pos = cpu_to_le32(ext_pos);
    1582:	45 89 59 04          	mov    %r11d,0x4(%r9)
            ext_num = name_len/(LARGE_NAME_LEN);
            ext_num++;
            //ext_pos = cur_pos;
            //if(name_len%(LARGE_NAME_LEN)>ext_num)
                //ext_num++;
            memcpy(de_ext->name, name, LARGE_NAME_LEN);
    1586:	49 89 51 78          	mov    %rdx,0x78(%r9)
            de_ext->name[LARGE_NAME_LEN]='\0';
            de_ext->ext_pos = cpu_to_le32(ext_pos);
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
    158a:	49 8b 16             	mov    (%r14),%rdx
    158d:	f0 48 0f ab 02       	lock bts %rax,(%rdx)
    1592:	72 00                	jb     1594 <ext_de_name+0x354>
            ext_num--;
            ext_len += LARGE_NAME_LEN;
            name_len -= LARGE_NAME_LEN;
    1594:	8d 43 90             	lea    -0x70(%rbx),%eax
    1597:	89 45 c4             	mov    %eax,-0x3c(%rbp)
            while(ext_num > 1) {
    159a:	8b 45 c0             	mov    -0x40(%rbp),%eax
    159d:	83 f8 01             	cmp    $0x1,%eax
    15a0:	0f 84 48 02 00 00    	je     17ee <ext_de_name+0x5ae>
    15a6:	83 e8 02             	sub    $0x2,%eax
    15a9:	49 8d 5f 70          	lea    0x70(%r15),%rbx
    15ad:	48 89 c2             	mov    %rax,%rdx
    15b0:	48 c1 e0 07          	shl    $0x7,%rax
    15b4:	48 c1 e2 04          	shl    $0x4,%rdx
    15b8:	48 29 d0             	sub    %rdx,%rax
    15bb:	4d 8d bc 07 e0 00 00 	lea    0xe0(%r15,%rax,1),%r15
    15c2:	00 
                ext_pos =  find_invalid_id(sb, ei, p, ext_pos);
    15c3:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    15c7:	44 89 d9             	mov    %r11d,%ecx
    15ca:	4c 89 f2             	mov    %r14,%rdx
    15cd:	4c 89 ef             	mov    %r13,%rdi
    15d0:	4c 89 4d c8          	mov    %r9,-0x38(%rbp)
    15d4:	e8 00 00 00 00       	callq  15d9 <ext_de_name+0x399>
    15d9:	41 89 c0             	mov    %eax,%r8d
                tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
                de_ext->next = tem_ext;
    15dc:	4c 8b 4d c8          	mov    -0x38(%rbp),%r9
            test_and_set_bit_le(bitpos, (void *)p->statemap);
            ext_num--;
            ext_len += LARGE_NAME_LEN;
            name_len -= LARGE_NAME_LEN;
            while(ext_num > 1) {
                ext_pos =  find_invalid_id(sb, ei, p, ext_pos);
    15e0:	4d 89 c3             	mov    %r8,%r11
                tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
    15e3:	49 81 c0 81 00 00 00 	add    $0x81,%r8
    15ea:	49 c1 e0 07          	shl    $0x7,%r8
    15ee:	43 8d 44 1b 01       	lea    0x1(%r11,%r11,1),%eax
    15f3:	4d 01 e0             	add    %r12,%r8
                de_ext->next = tem_ext;
    15f6:	4d 89 41 08          	mov    %r8,0x8(%r9)
                memcpy(tem_ext->name, name + ext_len, LARGE_NAME_LEN);
    15fa:	48 8b 13             	mov    (%rbx),%rdx
    15fd:	48 98                	cltq   
    15ff:	49 89 50 10          	mov    %rdx,0x10(%r8)
    1603:	48 8b 53 08          	mov    0x8(%rbx),%rdx
    1607:	49 89 50 18          	mov    %rdx,0x18(%r8)
    160b:	48 8b 53 10          	mov    0x10(%rbx),%rdx
    160f:	49 89 50 20          	mov    %rdx,0x20(%r8)
    1613:	48 8b 53 18          	mov    0x18(%rbx),%rdx
    1617:	49 89 50 28          	mov    %rdx,0x28(%r8)
    161b:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    161f:	49 89 50 30          	mov    %rdx,0x30(%r8)
    1623:	48 8b 53 28          	mov    0x28(%rbx),%rdx
    1627:	49 89 50 38          	mov    %rdx,0x38(%r8)
    162b:	48 8b 53 30          	mov    0x30(%rbx),%rdx
    162f:	49 89 50 40          	mov    %rdx,0x40(%r8)
    1633:	48 8b 53 38          	mov    0x38(%rbx),%rdx
    1637:	49 89 50 48          	mov    %rdx,0x48(%r8)
    163b:	48 8b 53 40          	mov    0x40(%rbx),%rdx
    163f:	49 89 50 50          	mov    %rdx,0x50(%r8)
    1643:	48 8b 53 48          	mov    0x48(%rbx),%rdx
    1647:	49 89 50 58          	mov    %rdx,0x58(%r8)
    164b:	48 8b 53 50          	mov    0x50(%rbx),%rdx
    164f:	49 89 50 60          	mov    %rdx,0x60(%r8)
    1653:	48 8b 53 58          	mov    0x58(%rbx),%rdx
    1657:	49 89 50 68          	mov    %rdx,0x68(%r8)
    165b:	48 8b 53 60          	mov    0x60(%rbx),%rdx
    165f:	49 89 50 70          	mov    %rdx,0x70(%r8)
    1663:	48 8b 53 68          	mov    0x68(%rbx),%rdx
                tem_ext->name[LARGE_NAME_LEN]='\0';
    1667:	41 c6 80 80 00 00 00 	movb   $0x0,0x80(%r8)
    166e:	00 
                tem_ext->ext_pos = cpu_to_le32(ext_pos);
    166f:	45 89 58 04          	mov    %r11d,0x4(%r8)
            name_len -= LARGE_NAME_LEN;
            while(ext_num > 1) {
                ext_pos =  find_invalid_id(sb, ei, p, ext_pos);
                tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
                de_ext->next = tem_ext;
                memcpy(tem_ext->name, name + ext_len, LARGE_NAME_LEN);
    1673:	49 89 50 78          	mov    %rdx,0x78(%r8)
                tem_ext->name[LARGE_NAME_LEN]='\0';
                tem_ext->ext_pos = cpu_to_le32(ext_pos);
                bitpos = ext_pos *2+1;
                test_and_set_bit_le(bitpos, (void *)p->statemap);
    1677:	49 8b 16             	mov    (%r14),%rdx
    167a:	f0 48 0f ab 02       	lock bts %rax,(%rdx)
    167f:	72 00                	jb     1681 <ext_de_name+0x441>
    1681:	48 83 c3 70          	add    $0x70,%rbx
            ext_num--;
            ext_len += LARGE_NAME_LEN;
            name_len -= LARGE_NAME_LEN;
            while(ext_num > 1) {
                ext_pos =  find_invalid_id(sb, ei, p, ext_pos);
                tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
    1685:	4d 89 c1             	mov    %r8,%r9
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
            ext_num--;
            ext_len += LARGE_NAME_LEN;
            name_len -= LARGE_NAME_LEN;
            while(ext_num > 1) {
    1688:	4c 39 fb             	cmp    %r15,%rbx
    168b:	0f 85 32 ff ff ff    	jne    15c3 <ext_de_name+0x383>
    1691:	6b 45 c0 90          	imul   $0xffffff90,-0x40(%rbp),%eax
    1695:	8b 7d c4             	mov    -0x3c(%rbp),%edi
    1698:	8d 44 07 70          	lea    0x70(%rdi,%rax,1),%eax
    169c:	89 45 c4             	mov    %eax,-0x3c(%rbp)
                de_ext = tem_ext;
                name_len -= LARGE_NAME_LEN;
                ext_len += LARGE_NAME_LEN;
                ext_num--;
            }
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
    169f:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    16a3:	4c 89 ef             	mov    %r13,%rdi
    16a6:	44 89 d9             	mov    %r11d,%ecx
    16a9:	4c 89 f2             	mov    %r14,%rdx
    16ac:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
    16b0:	e8 00 00 00 00       	callq  16b5 <ext_de_name+0x475>
    16b5:	89 c2                	mov    %eax,%edx
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de_ext->next = tem_ext;
            memcpy(tem_ext->name, name+ext_len, name_len);
    16b7:	48 63 5d c4          	movslq -0x3c(%rbp),%rbx
                ext_len += LARGE_NAME_LEN;
                ext_num--;
            }
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de_ext->next = tem_ext;
    16bb:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
                de_ext = tem_ext;
                name_len -= LARGE_NAME_LEN;
                ext_len += LARGE_NAME_LEN;
                ext_num--;
            }
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
    16bf:	49 89 d5             	mov    %rdx,%r13
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
    16c2:	48 81 c2 81 00 00 00 	add    $0x81,%rdx
            de_ext->next = tem_ext;
            memcpy(tem_ext->name, name+ext_len, name_len);
    16c9:	4c 89 fe             	mov    %r15,%rsi
                name_len -= LARGE_NAME_LEN;
                ext_len += LARGE_NAME_LEN;
                ext_num--;
            }
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
    16cc:	48 c1 e2 07          	shl    $0x7,%rdx
    16d0:	49 01 d4             	add    %rdx,%r12
            de_ext->next = tem_ext;
            memcpy(tem_ext->name, name+ext_len, name_len);
    16d3:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
    16d8:	48 89 da             	mov    %rbx,%rdx
                ext_len += LARGE_NAME_LEN;
                ext_num--;
            }
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de_ext->next = tem_ext;
    16db:	4d 89 60 08          	mov    %r12,0x8(%r8)
            memcpy(tem_ext->name, name+ext_len, name_len);
    16df:	e8 00 00 00 00       	callq  16e4 <ext_de_name+0x4a4>
    16e4:	43 8d 44 2d 01       	lea    0x1(%r13,%r13,1),%eax
            tem_ext->ext_pos = cpu_to_le32(ext_pos);
    16e9:	45 89 6c 24 04       	mov    %r13d,0x4(%r12)
            tem_ext->name[name_len] = '\0';
    16ee:	41 c6 44 1c 10 00    	movb   $0x0,0x10(%r12,%rbx,1)
            //tem_ext->next = NULL;
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
    16f4:	49 8b 16             	mov    (%r14),%rdx
    16f7:	48 98                	cltq   
    16f9:	f0 48 0f ab 02       	lock bts %rax,(%rdx)
    16fe:	0f 82 22 fc ff ff    	jb     1326 <ext_de_name+0xe6>
        }
    }
    //nova_dbg("%s end",__func__);
}
    1704:	48 83 c4 18          	add    $0x18,%rsp
    1708:	5b                   	pop    %rbx
    1709:	41 5c                	pop    %r12
    170b:	41 5d                	pop    %r13
    170d:	41 5e                	pop    %r14
    170f:	41 5f                	pop    %r15
    1711:	5d                   	pop    %rbp
    1712:	c3                   	retq   
			_mm_clflush(buf + i);
    1713:	89 c8                	mov    %ecx,%eax
    1715:	48 01 d0             	add    %rdx,%rax
    1718:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    171b:	83 c1 40             	add    $0x40,%ecx
    171e:	39 ce                	cmp    %ecx,%esi
    1720:	77 f1                	ja     1713 <ext_de_name+0x4d3>
    1722:	e9 ff fb ff ff       	jmpq   1326 <ext_de_name+0xe6>
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de->next = de_ext;
            memcpy(de_ext->name, name, name_len);
    1727:	49 8b 37             	mov    (%r15),%rsi
    172a:	48 8d 7a 18          	lea    0x18(%rdx),%rdi
    172e:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    1732:	48 89 72 10          	mov    %rsi,0x10(%rdx)
    1736:	49 8b 74 1f f8       	mov    -0x8(%r15,%rbx,1),%rsi
    173b:	48 89 74 19 f8       	mov    %rsi,-0x8(%rcx,%rbx,1)
    1740:	48 29 f9             	sub    %rdi,%rcx
    1743:	4c 89 fe             	mov    %r15,%rsi
    1746:	48 29 ce             	sub    %rcx,%rsi
    1749:	48 01 d9             	add    %rbx,%rcx
    174c:	48 c1 e9 03          	shr    $0x3,%rcx
    1750:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    1753:	e9 8e fb ff ff       	jmpq   12e6 <ext_de_name+0xa6>
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
        de->ful_name.fn_ext = de_ext;

        if(name_len <= (LARGE_NAME_LEN)){
            memcpy(de_ext->name, name, name_len);
    1758:	48 83 fb 08          	cmp    $0x8,%rbx
    175c:	49 8d 49 10          	lea    0x10(%r9),%rcx
    1760:	73 4a                	jae    17ac <ext_de_name+0x56c>
    1762:	f6 c3 04             	test   $0x4,%bl
    1765:	0f 85 9f 00 00 00    	jne    180a <ext_de_name+0x5ca>
    176b:	48 85 db             	test   %rbx,%rbx
    176e:	74 16                	je     1786 <ext_de_name+0x546>
    1770:	41 0f b6 07          	movzbl (%r15),%eax
    1774:	f6 c3 02             	test   $0x2,%bl
    1777:	88 01                	mov    %al,(%rcx)
    1779:	74 0b                	je     1786 <ext_de_name+0x546>
    177b:	41 0f b7 44 1f fe    	movzwl -0x2(%r15,%rbx,1),%eax
    1781:	66 89 44 19 fe       	mov    %ax,-0x2(%rcx,%rbx,1)
    1786:	43 8d 44 1b 01       	lea    0x1(%r11,%r11,1),%eax
            de_ext->name[name_len]='\0';
    178b:	41 c6 44 19 10 00    	movb   $0x0,0x10(%r9,%rbx,1)
            de_ext->ext_pos = cpu_to_le32(ext_pos);
    1791:	45 89 59 04          	mov    %r11d,0x4(%r9)
            //de_ext->next = NULL;
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
    1795:	49 8b 16             	mov    (%r14),%rdx
    1798:	48 98                	cltq   
    179a:	f0 48 0f ab 02       	lock bts %rax,(%rdx)
    179f:	0f 82 81 fb ff ff    	jb     1326 <ext_de_name+0xe6>
    17a5:	e9 5a ff ff ff       	jmpq   1704 <ext_de_name+0x4c4>
    //struct dzt_entry_info *ei;
    u64 ext_len;
    u32 bitpos, ext_pos, ext_num;
  
    //nova_dbg("%s start, dentry pos %d",__func__, cur_pos);
    BUG_ON(ze==NULL);
    17aa:	0f 0b                	ud2    
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
        de->ful_name.fn_ext = de_ext;

        if(name_len <= (LARGE_NAME_LEN)){
            memcpy(de_ext->name, name, name_len);
    17ac:	49 8b 07             	mov    (%r15),%rax
    17af:	49 8d 79 18          	lea    0x18(%r9),%rdi
    17b3:	4c 89 fe             	mov    %r15,%rsi
    17b6:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    17ba:	49 89 41 10          	mov    %rax,0x10(%r9)
    17be:	49 8b 44 1f f8       	mov    -0x8(%r15,%rbx,1),%rax
    17c3:	48 89 44 19 f8       	mov    %rax,-0x8(%rcx,%rbx,1)
    17c8:	48 29 f9             	sub    %rdi,%rcx
    17cb:	48 29 ce             	sub    %rcx,%rsi
    17ce:	48 01 d9             	add    %rbx,%rcx
    17d1:	48 c1 e9 03          	shr    $0x3,%rcx
    17d5:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    17d8:	eb ac                	jmp    1786 <ext_de_name+0x546>
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de->next = de_ext;
            memcpy(de_ext->name, name, name_len);
    17da:	41 8b 37             	mov    (%r15),%esi
    17dd:	89 72 10             	mov    %esi,0x10(%rdx)
    17e0:	41 8b 74 1f fc       	mov    -0x4(%r15,%rbx,1),%esi
    17e5:	89 74 19 fc          	mov    %esi,-0x4(%rcx,%rbx,1)
    17e9:	e9 f8 fa ff ff       	jmpq   12e6 <ext_de_name+0xa6>
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
            nova_flush_buffer(tem_ext, DAFS_DEF_DENTRY_SIZE, 0);
        }
    } else {
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
    17ee:	4d 89 c8             	mov    %r9,%r8
    17f1:	49 83 c7 70          	add    $0x70,%r15
    17f5:	e9 a5 fe ff ff       	jmpq   169f <ext_de_name+0x45f>
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de->next = de_ext;
            memcpy(de_ext->name, name, name_len);
    17fa:	41 0f b7 74 1f fe    	movzwl -0x2(%r15,%rbx,1),%esi
    1800:	66 89 74 19 fe       	mov    %si,-0x2(%rcx,%rbx,1)
    1805:	e9 dc fa ff ff       	jmpq   12e6 <ext_de_name+0xa6>
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
        de->ful_name.fn_ext = de_ext;

        if(name_len <= (LARGE_NAME_LEN)){
            memcpy(de_ext->name, name, name_len);
    180a:	41 8b 07             	mov    (%r15),%eax
    180d:	89 01                	mov    %eax,(%rcx)
    180f:	41 8b 44 1f fc       	mov    -0x4(%r15,%rbx,1),%eax
    1814:	89 44 19 fc          	mov    %eax,-0x4(%rcx,%rbx,1)
    1818:	e9 69 ff ff ff       	jmpq   1786 <ext_de_name+0x546>
    181d:	0f 1f 00             	nopl   (%rax)

0000000000001820 <get_ext_name>:
}

/*get ext name
* fulname & name*/
void get_ext_name(struct name_ext *de_ext, char *name)
{
    1820:	e8 00 00 00 00       	callq  1825 <get_ext_name+0x5>
    1825:	55                   	push   %rbp
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    1826:	ba 70 00 00 00       	mov    $0x70,%edx
    182b:	48 89 e5             	mov    %rsp,%rbp
    182e:	41 57                	push   %r15
    1830:	41 56                	push   %r14
    1832:	41 55                	push   %r13
    1834:	41 54                	push   %r12
    1836:	49 89 fc             	mov    %rdi,%r12
    1839:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 1840 <get_ext_name+0x20>
    1840:	53                   	push   %rbx
    1841:	49 89 f6             	mov    %rsi,%r14
    1844:	be d0 80 00 00       	mov    $0x80d0,%esi
    1849:	e8 00 00 00 00       	callq  184e <get_ext_name+0x2e>
    184e:	49 89 c5             	mov    %rax,%r13
    char *end = "";
    u32 slen;

    tem_ext = de_ext;
    do{
        len =strlen(tem_ext->name);
    1851:	4d 8d 7c 24 10       	lea    0x10(%r12),%r15
    1856:	4c 89 ff             	mov    %r15,%rdi
    1859:	e8 00 00 00 00       	callq  185e <get_ext_name+0x3e>
    185e:	0f b7 d8             	movzwl %ax,%ebx
        memcpy(tem, tem_ext->name, len);
    1861:	4c 89 fe             	mov    %r15,%rsi
    1864:	4c 89 ef             	mov    %r13,%rdi
    1867:	48 89 da             	mov    %rbx,%rdx
    186a:	e8 00 00 00 00       	callq  186f <get_ext_name+0x4f>
        tem[len]='\0';
    186f:	41 c6 44 1d 00 00    	movb   $0x0,0x0(%r13,%rbx,1)
        //memcpy(tem+len, end, 1);
        strcat(name, tem);
    1875:	4c 89 ee             	mov    %r13,%rsi
    1878:	4c 89 f7             	mov    %r14,%rdi
    187b:	e8 00 00 00 00       	callq  1880 <get_ext_name+0x60>
        tem_ext = tem_ext->next; 
    1880:	4d 8b 64 24 08       	mov    0x8(%r12),%r12
    }while(tem_ext);
    1885:	4d 85 e4             	test   %r12,%r12
    1888:	75 c7                	jne    1851 <get_ext_name+0x31>
    
    //strcat(name,"/0");
    kfree(tem);
    188a:	4c 89 ef             	mov    %r13,%rdi
    188d:	e8 00 00 00 00       	callq  1892 <get_ext_name+0x72>
}
    1892:	5b                   	pop    %rbx
    1893:	41 5c                	pop    %r12
    1895:	41 5d                	pop    %r13
    1897:	41 5e                	pop    %r14
    1899:	41 5f                	pop    %r15
    189b:	5d                   	pop    %rbp
    189c:	c3                   	retq   
    189d:	0f 1f 00             	nopl   (%rax)

00000000000018a0 <get_de_name>:

/*get dentry name
 * name_type 0 for name, 1 for fulname*/
void get_de_name(struct dafs_dentry *de, struct dafs_zone_entry *ze, char *name, int name_type)
{
    18a0:	e8 00 00 00 00       	callq  18a5 <get_de_name+0x5>
    18a5:	55                   	push   %rbp
    u32 par_pos;

    nlen = de->name_len;
    flen = de->fname_len;

    if(name_type == 0){
    18a6:	85 c9                	test   %ecx,%ecx
}

/*get dentry name
 * name_type 0 for name, 1 for fulname*/
void get_de_name(struct dafs_dentry *de, struct dafs_zone_entry *ze, char *name, int name_type)
{
    18a8:	48 89 e5             	mov    %rsp,%rbp
    18ab:	41 57                	push   %r15
    18ad:	41 56                	push   %r14
    18af:	41 55                	push   %r13
    18b1:	49 89 d5             	mov    %rdx,%r13
    18b4:	41 54                	push   %r12
    18b6:	53                   	push   %rbx
    18b7:	48 89 fb             	mov    %rdi,%rbx
    u64 flen;
    char *end = "";
    char *tem;
    u32 par_pos;

    nlen = de->name_len;
    18ba:	0f b6 47 01          	movzbl 0x1(%rdi),%eax
    flen = de->fname_len;

    if(name_type == 0){
    18be:	75 41                	jne    1901 <get_de_name+0x61>
        if(de->ext_flag==1){
    18c0:	66 83 7f 04 01       	cmpw   $0x1,0x4(%rdi)
    18c5:	0f 84 97 00 00 00    	je     1962 <get_de_name+0xc2>
            get_ext_name(de->next, name);
        } else {
            memcpy(name, de->name, nlen);
    18cb:	83 f8 08             	cmp    $0x8,%eax
    18ce:	48 8d 77 30          	lea    0x30(%rdi),%rsi
    18d2:	73 5f                	jae    1933 <get_de_name+0x93>
    18d4:	a8 04                	test   $0x4,%al
    18d6:	0f 85 a1 01 00 00    	jne    1a7d <get_de_name+0x1dd>
    18dc:	85 c0                	test   %eax,%eax
    18de:	74 10                	je     18f0 <get_de_name+0x50>
    18e0:	0f b6 57 30          	movzbl 0x30(%rdi),%edx
    18e4:	a8 02                	test   $0x2,%al
    18e6:	41 88 55 00          	mov    %dl,0x0(%r13)
    18ea:	0f 85 a4 01 00 00    	jne    1a94 <get_de_name+0x1f4>
                }
            }
        }
    }

}
    18f0:	5b                   	pop    %rbx
    if(name_type == 0){
        if(de->ext_flag==1){
            get_ext_name(de->next, name);
        } else {
            memcpy(name, de->name, nlen);
            name[nlen]='\0';
    18f1:	41 c6 44 05 00 00    	movb   $0x0,0x0(%r13,%rax,1)
                }
            }
        }
    }

}
    18f7:	41 5c                	pop    %r12
    18f9:	41 5d                	pop    %r13
    18fb:	41 5e                	pop    %r14
    18fd:	41 5f                	pop    %r15
    18ff:	5d                   	pop    %rbp
    1900:	c3                   	retq   
            memcpy(name, de->name, nlen);
            name[nlen]='\0';
            //memcpy(name+nlen, end ,1);
        }
    } else {
        if(de->isr_sf==1){
    1901:	80 7f 03 01          	cmpb   $0x1,0x3(%rdi)
    char *end = "";
    char *tem;
    u32 par_pos;

    nlen = de->name_len;
    flen = de->fname_len;
    1905:	4c 8b 67 10          	mov    0x10(%rdi),%r12
            memcpy(name, de->name, nlen);
            name[nlen]='\0';
            //memcpy(name+nlen, end ,1);
        }
    } else {
        if(de->isr_sf==1){
    1909:	74 0a                	je     1915 <get_de_name+0x75>
                //memcpy(name+flen, end, 1);
            } else {
                get_ext_name(de->ful_name.fn_ext, name);
            }
        } else {
            if(de->file_type==NORMAL_FILE){
    190b:	80 7f 02 00          	cmpb   $0x0,0x2(%rdi)
    190f:	0f 84 84 00 00 00    	je     1999 <get_de_name+0xf9>

                strcat(name, "/");
                strcat(name, tem);
                kfree(tem);
            } else {
                if(de->ext_flag == 0){
    1915:	66 83 7b 04 00       	cmpw   $0x0,0x4(%rbx)
    191a:	74 5d                	je     1979 <get_de_name+0xd9>
            if(de->ext_flag==0){
                memcpy(name, de->ful_name.f_name, flen);
                name[flen] = '\0';
                //memcpy(name+flen, end, 1);
            } else {
                get_ext_name(de->ful_name.fn_ext, name);
    191c:	48 8b 7b 58          	mov    0x58(%rbx),%rdi
    1920:	4c 89 ee             	mov    %r13,%rsi
    1923:	e8 00 00 00 00       	callq  1928 <get_de_name+0x88>
                }
            }
        }
    }

}
    1928:	5b                   	pop    %rbx
    1929:	41 5c                	pop    %r12
    192b:	41 5d                	pop    %r13
    192d:	41 5e                	pop    %r14
    192f:	41 5f                	pop    %r15
    1931:	5d                   	pop    %rbp
    1932:	c3                   	retq   

    if(name_type == 0){
        if(de->ext_flag==1){
            get_ext_name(de->next, name);
        } else {
            memcpy(name, de->name, nlen);
    1933:	48 8b 57 30          	mov    0x30(%rdi),%rdx
    1937:	49 8d 7d 08          	lea    0x8(%r13),%rdi
    193b:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    193f:	49 89 55 00          	mov    %rdx,0x0(%r13)
    1943:	89 c2                	mov    %eax,%edx
    1945:	48 8b 4c 16 f8       	mov    -0x8(%rsi,%rdx,1),%rcx
    194a:	49 89 4c 15 f8       	mov    %rcx,-0x8(%r13,%rdx,1)
    194f:	4c 89 e9             	mov    %r13,%rcx
    1952:	48 29 f9             	sub    %rdi,%rcx
    1955:	48 29 ce             	sub    %rcx,%rsi
    1958:	01 c1                	add    %eax,%ecx
    195a:	c1 e9 03             	shr    $0x3,%ecx
    195d:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    1960:	eb 8e                	jmp    18f0 <get_de_name+0x50>
    nlen = de->name_len;
    flen = de->fname_len;

    if(name_type == 0){
        if(de->ext_flag==1){
            get_ext_name(de->next, name);
    1962:	48 8b 7f 30          	mov    0x30(%rdi),%rdi
    1966:	48 89 d6             	mov    %rdx,%rsi
    1969:	e8 00 00 00 00       	callq  196e <get_de_name+0xce>
                }
            }
        }
    }

}
    196e:	5b                   	pop    %rbx
    196f:	41 5c                	pop    %r12
    1971:	41 5d                	pop    %r13
    1973:	41 5e                	pop    %r14
    1975:	41 5f                	pop    %r15
    1977:	5d                   	pop    %rbp
    1978:	c3                   	retq   
                strcat(name, "/");
                strcat(name, tem);
                kfree(tem);
            } else {
                if(de->ext_flag == 0){
                    memcpy(name, de->ful_name.f_name, flen);
    1979:	48 8d 73 58          	lea    0x58(%rbx),%rsi
    197d:	4c 89 e2             	mov    %r12,%rdx
    1980:	4c 89 ef             	mov    %r13,%rdi
    1983:	e8 00 00 00 00       	callq  1988 <get_de_name+0xe8>
                }
            }
        }
    }

}
    1988:	5b                   	pop    %rbx
                strcat(name, tem);
                kfree(tem);
            } else {
                if(de->ext_flag == 0){
                    memcpy(name, de->ful_name.f_name, flen);
                    name[flen]='\0';
    1989:	43 c6 44 25 00 00    	movb   $0x0,0x0(%r13,%r12,1)
                }
            }
        }
    }

}
    198f:	41 5c                	pop    %r12
    1991:	41 5d                	pop    %r13
    1993:	41 5e                	pop    %r14
    1995:	41 5f                	pop    %r15
    1997:	5d                   	pop    %rbp
    1998:	c3                   	retq   
                get_ext_name(de->ful_name.fn_ext, name);
            }
        } else {
            if(de->file_type==NORMAL_FILE){
                /*get name*/
                tem = kzalloc(sizeof(char)*nlen, GFP_KERNEL);
    1999:	44 0f b6 e0          	movzbl %al,%r12d
    199d:	49 89 f6             	mov    %rsi,%r14
    19a0:	4c 89 e7             	mov    %r12,%rdi
    19a3:	e8 48 e7 ff ff       	callq  f0 <kzalloc.constprop.9>
                if(de->ext_flag==1){
    19a8:	66 83 7b 04 01       	cmpw   $0x1,0x4(%rbx)
                get_ext_name(de->ful_name.fn_ext, name);
            }
        } else {
            if(de->file_type==NORMAL_FILE){
                /*get name*/
                tem = kzalloc(sizeof(char)*nlen, GFP_KERNEL);
    19ad:	49 89 c7             	mov    %rax,%r15
                if(de->ext_flag==1){
    19b0:	0f 84 b6 00 00 00    	je     1a6c <get_de_name+0x1cc>
                    get_ext_name(de->next, tem);
                } else {
                    memcpy(tem, de->name, nlen);
    19b6:	41 83 fc 08          	cmp    $0x8,%r12d
    19ba:	48 8d 73 30          	lea    0x30(%rbx),%rsi
    19be:	73 74                	jae    1a34 <get_de_name+0x194>
    19c0:	41 f6 c4 04          	test   $0x4,%r12b
    19c4:	0f 85 dc 00 00 00    	jne    1aa6 <get_de_name+0x206>
    19ca:	45 85 e4             	test   %r12d,%r12d
    19cd:	74 11                	je     19e0 <get_de_name+0x140>
    19cf:	0f b6 43 30          	movzbl 0x30(%rbx),%eax
    19d3:	41 f6 c4 02          	test   $0x2,%r12b
    19d7:	41 88 07             	mov    %al,(%r15)
    19da:	0f 85 dd 00 00 00    	jne    1abd <get_de_name+0x21d>
                    tem[nlen]='\0';
    19e0:	43 c6 04 27 00       	movb   $0x0,(%r15,%r12,1)
                    //memcpy(tem+nlen, end, 1);
                }

                /*get par fulname*/
                par_pos = le32_to_cpu(de->par_pos);
                par_de = &ze->dentry[par_pos];
    19e5:	8b 7b 0c             	mov    0xc(%rbx),%edi
                get_de_name(par_de, ze, name, 1);
    19e8:	4c 89 ea             	mov    %r13,%rdx
    19eb:	b9 01 00 00 00       	mov    $0x1,%ecx
    19f0:	4c 89 f6             	mov    %r14,%rsi
                    //memcpy(tem+nlen, end, 1);
                }

                /*get par fulname*/
                par_pos = le32_to_cpu(de->par_pos);
                par_de = &ze->dentry[par_pos];
    19f3:	48 81 c7 81 00 00 00 	add    $0x81,%rdi
    19fa:	48 c1 e7 07          	shl    $0x7,%rdi
    19fe:	4c 01 f7             	add    %r14,%rdi
                get_de_name(par_de, ze, name, 1);
    1a01:	e8 00 00 00 00       	callq  1a06 <get_de_name+0x166>

                strcat(name, "/");
    1a06:	4c 89 ef             	mov    %r13,%rdi
    1a09:	e8 00 00 00 00       	callq  1a0e <get_de_name+0x16e>
                strcat(name, tem);
    1a0e:	49 8d 7c 05 01       	lea    0x1(%r13,%rax,1),%rdi
    1a13:	4c 89 fe             	mov    %r15,%rsi
                /*get par fulname*/
                par_pos = le32_to_cpu(de->par_pos);
                par_de = &ze->dentry[par_pos];
                get_de_name(par_de, ze, name, 1);

                strcat(name, "/");
    1a16:	41 c6 44 05 00 2f    	movb   $0x2f,0x0(%r13,%rax,1)
                strcat(name, tem);
    1a1c:	e8 00 00 00 00       	callq  1a21 <get_de_name+0x181>
                kfree(tem);
    1a21:	4c 89 ff             	mov    %r15,%rdi
    1a24:	e8 00 00 00 00       	callq  1a29 <get_de_name+0x189>
                }
            }
        }
    }

}
    1a29:	5b                   	pop    %rbx
    1a2a:	41 5c                	pop    %r12
    1a2c:	41 5d                	pop    %r13
    1a2e:	41 5e                	pop    %r14
    1a30:	41 5f                	pop    %r15
    1a32:	5d                   	pop    %rbp
    1a33:	c3                   	retq   
                /*get name*/
                tem = kzalloc(sizeof(char)*nlen, GFP_KERNEL);
                if(de->ext_flag==1){
                    get_ext_name(de->next, tem);
                } else {
                    memcpy(tem, de->name, nlen);
    1a34:	48 8b 43 30          	mov    0x30(%rbx),%rax
    1a38:	49 8d 7f 08          	lea    0x8(%r15),%rdi
    1a3c:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    1a40:	49 89 07             	mov    %rax,(%r15)
    1a43:	44 89 e0             	mov    %r12d,%eax
    1a46:	48 8b 54 06 f8       	mov    -0x8(%rsi,%rax,1),%rdx
    1a4b:	49 89 54 07 f8       	mov    %rdx,-0x8(%r15,%rax,1)
    1a50:	4c 89 f8             	mov    %r15,%rax
    1a53:	48 29 f8             	sub    %rdi,%rax
    1a56:	41 8d 0c 04          	lea    (%r12,%rax,1),%ecx
    1a5a:	48 29 c6             	sub    %rax,%rsi
    1a5d:	89 c8                	mov    %ecx,%eax
    1a5f:	c1 e8 03             	shr    $0x3,%eax
    1a62:	89 c1                	mov    %eax,%ecx
    1a64:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    1a67:	e9 74 ff ff ff       	jmpq   19e0 <get_de_name+0x140>
        } else {
            if(de->file_type==NORMAL_FILE){
                /*get name*/
                tem = kzalloc(sizeof(char)*nlen, GFP_KERNEL);
                if(de->ext_flag==1){
                    get_ext_name(de->next, tem);
    1a6c:	48 8b 7b 30          	mov    0x30(%rbx),%rdi
    1a70:	48 89 c6             	mov    %rax,%rsi
    1a73:	e8 00 00 00 00       	callq  1a78 <get_de_name+0x1d8>
    1a78:	e9 68 ff ff ff       	jmpq   19e5 <get_de_name+0x145>

    if(name_type == 0){
        if(de->ext_flag==1){
            get_ext_name(de->next, name);
        } else {
            memcpy(name, de->name, nlen);
    1a7d:	8b 57 30             	mov    0x30(%rdi),%edx
    1a80:	41 89 55 00          	mov    %edx,0x0(%r13)
    1a84:	89 c2                	mov    %eax,%edx
    1a86:	8b 4c 16 fc          	mov    -0x4(%rsi,%rdx,1),%ecx
    1a8a:	41 89 4c 15 fc       	mov    %ecx,-0x4(%r13,%rdx,1)
    1a8f:	e9 5c fe ff ff       	jmpq   18f0 <get_de_name+0x50>
    1a94:	89 c2                	mov    %eax,%edx
    1a96:	0f b7 4c 16 fe       	movzwl -0x2(%rsi,%rdx,1),%ecx
    1a9b:	66 41 89 4c 15 fe    	mov    %cx,-0x2(%r13,%rdx,1)
    1aa1:	e9 4a fe ff ff       	jmpq   18f0 <get_de_name+0x50>
                /*get name*/
                tem = kzalloc(sizeof(char)*nlen, GFP_KERNEL);
                if(de->ext_flag==1){
                    get_ext_name(de->next, tem);
                } else {
                    memcpy(tem, de->name, nlen);
    1aa6:	8b 43 30             	mov    0x30(%rbx),%eax
    1aa9:	41 89 07             	mov    %eax,(%r15)
    1aac:	44 89 e0             	mov    %r12d,%eax
    1aaf:	8b 54 06 fc          	mov    -0x4(%rsi,%rax,1),%edx
    1ab3:	41 89 54 07 fc       	mov    %edx,-0x4(%r15,%rax,1)
    1ab8:	e9 23 ff ff ff       	jmpq   19e0 <get_de_name+0x140>
    1abd:	44 89 e0             	mov    %r12d,%eax
    1ac0:	0f b7 54 06 fe       	movzwl -0x2(%rsi,%rax,1),%edx
    1ac5:	66 41 89 54 07 fe    	mov    %dx,-0x2(%r15,%rax,1)
    1acb:	e9 10 ff ff ff       	jmpq   19e0 <get_de_name+0x140>

0000000000001ad0 <get_zone_path>:
/*update sub files numbers*/

/*get zone path through root dentry
 * we get charpath when use this function*/
int get_zone_path(struct super_block *sb, struct dzt_entry_info *ei, char *pname, const char *dename)
{
    1ad0:	e8 00 00 00 00       	callq  1ad5 <get_zone_path+0x5>
    1ad5:	55                   	push   %rbp
    1ad6:	48 89 e5             	mov    %rsp,%rbp
    1ad9:	41 57                	push   %r15
    1adb:	41 56                	push   %r14
    1add:	41 55                	push   %r13
    1adf:	41 54                	push   %r12
    1ae1:	49 89 fd             	mov    %rdi,%r13
    1ae4:	53                   	push   %rbx
    1ae5:	48 83 ec 28          	sub    $0x28,%rsp
    struct dafs_zone_entry *ze;
    struct dafs_dentry *de;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    1ae9:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
/*update sub files numbers*/

/*get zone path through root dentry
 * we get charpath when use this function*/
int get_zone_path(struct super_block *sb, struct dzt_entry_info *ei, char *pname, const char *dename)
{
    1af0:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
    1af4:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
    1af8:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    struct dafs_zone_entry *ze;
    struct dafs_dentry *de;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    1afc:	48 8b 80 d8 01 00 00 	mov    0x1d8(%rax),%rax
    1b03:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    struct dafs_dzt_block *dzt_blk = dafs_get_dzt_block(sb); 
    1b07:	e8 00 00 00 00       	callq  1b0c <get_zone_path+0x3c>
    u32 num = ei->dzt_eno, slen;
    1b0c:	4c 8b 55 b8          	mov    -0x48(%rbp),%r10
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    1b10:	be d0 80 00 00       	mov    $0x80d0,%esi
{
    struct dafs_zone_entry *ze;
    struct dafs_dentry *de;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    struct dafs_dzt_block *dzt_blk = dafs_get_dzt_block(sb); 
    1b15:	49 89 c6             	mov    %rax,%r14
    u32 de_pos;
    u64 phlen, hashname;
    char *path, *name;

    //nova_dbg("%s start",__func__);
    phlen = ei->root_len;
    1b18:	49 8b 5a 28          	mov    0x28(%r10),%rbx
    struct dafs_zone_entry *ze;
    struct dafs_dentry *de;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    struct dafs_dzt_block *dzt_blk = dafs_get_dzt_block(sb); 
    u32 num = ei->dzt_eno, slen;
    1b1c:	41 8b 52 08          	mov    0x8(%r10),%edx
    1b20:	48 89 df             	mov    %rbx,%rdi
    1b23:	89 55 b4             	mov    %edx,-0x4c(%rbp)
    1b26:	e8 00 00 00 00       	callq  1b2b <get_zone_path+0x5b>
    1b2b:	48 89 df             	mov    %rbx,%rdi
    1b2e:	be d0 80 00 00       	mov    $0x80d0,%esi
    1b33:	49 89 c4             	mov    %rax,%r12
    1b36:	e8 00 00 00 00       	callq  1b3b <get_zone_path+0x6b>

    //nova_dbg("%s start",__func__);
    phlen = ei->root_len;
    path = kzalloc((sizeof(char )*phlen), GFP_KERNEL);
    name = kzalloc((sizeof(char)*phlen), GFP_KERNEL);
    while(num!=0){
    1b3b:	8b 55 b4             	mov    -0x4c(%rbp),%edx
    1b3e:	48 89 c3             	mov    %rax,%rbx
    1b41:	4c 8b 55 b8          	mov    -0x48(%rbp),%r10
    1b45:	85 d2                	test   %edx,%edx
    1b47:	0f 84 96 00 00 00    	je     1be3 <get_zone_path+0x113>
        ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->pdz_addr);
    1b4d:	49 8b 42 20          	mov    0x20(%r10),%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    1b51:	49 8b 95 b0 03 00 00 	mov    0x3b0(%r13),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    1b58:	41 bf 00 00 00 00    	mov    $0x0,%r15d
        de_pos = ei->rden_pos;
        de = &ze->dentry[de_pos];
    1b5e:	41 8b 7a 0c          	mov    0xc(%r10),%edi
        get_de_name(de, ze, name, 1);
    1b62:	b9 01 00 00 00       	mov    $0x1,%ecx
    1b67:	49 89 c0             	mov    %rax,%r8
    1b6a:	4c 03 42 18          	add    0x18(%rdx),%r8
    1b6e:	48 85 c0             	test   %rax,%rax
    1b71:	48 89 da             	mov    %rbx,%rdx
    1b74:	4d 0f 45 f8          	cmovne %r8,%r15
    path = kzalloc((sizeof(char )*phlen), GFP_KERNEL);
    name = kzalloc((sizeof(char)*phlen), GFP_KERNEL);
    while(num!=0){
        ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->pdz_addr);
        de_pos = ei->rden_pos;
        de = &ze->dentry[de_pos];
    1b78:	48 81 c7 81 00 00 00 	add    $0x81,%rdi
    1b7f:	48 c1 e7 07          	shl    $0x7,%rdi
        get_de_name(de, ze, name, 1);
    1b83:	4c 89 fe             	mov    %r15,%rsi
    path = kzalloc((sizeof(char )*phlen), GFP_KERNEL);
    name = kzalloc((sizeof(char)*phlen), GFP_KERNEL);
    while(num!=0){
        ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->pdz_addr);
        de_pos = ei->rden_pos;
        de = &ze->dentry[de_pos];
    1b86:	4c 01 ff             	add    %r15,%rdi
        get_de_name(de, ze, name, 1);
    1b89:	e8 00 00 00 00       	callq  1b8e <get_zone_path+0xbe>
        strcat(name,path);
    1b8e:	4c 89 e6             	mov    %r12,%rsi
    1b91:	48 89 df             	mov    %rbx,%rdi
    1b94:	e8 00 00 00 00       	callq  1b99 <get_zone_path+0xc9>
        memcpy(path, name, strlen(name)+1);
    1b99:	48 89 df             	mov    %rbx,%rdi
    1b9c:	e8 00 00 00 00       	callq  1ba1 <get_zone_path+0xd1>
    1ba1:	48 8d 50 01          	lea    0x1(%rax),%rdx
    1ba5:	48 89 de             	mov    %rbx,%rsi
    1ba8:	4c 89 e7             	mov    %r12,%rdi
    1bab:	e8 00 00 00 00       	callq  1bb0 <get_zone_path+0xe0>
        num = le64_to_cpu(ze->dz_no);
    1bb0:	41 8b 87 7c 40 00 00 	mov    0x407c(%r15),%eax
        hashname = le64_to_cpu(dzt_blk->dzt_entry[num].hash_name);
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    1bb7:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
        de = &ze->dentry[de_pos];
        get_de_name(de, ze, name, 1);
        strcat(name,path);
        memcpy(path, name, strlen(name)+1);
        num = le64_to_cpu(ze->dz_no);
        hashname = le64_to_cpu(dzt_blk->dzt_entry[num].hash_name);
    1bbb:	48 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%rcx
    1bc2:	00 
        de_pos = ei->rden_pos;
        de = &ze->dentry[de_pos];
        get_de_name(de, ze, name, 1);
        strcat(name,path);
        memcpy(path, name, strlen(name)+1);
        num = le64_to_cpu(ze->dz_no);
    1bc3:	49 89 c7             	mov    %rax,%r15
        hashname = le64_to_cpu(dzt_blk->dzt_entry[num].hash_name);
    1bc6:	48 c1 e0 06          	shl    $0x6,%rax
    1bca:	48 29 c8             	sub    %rcx,%rax
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    1bcd:	49 8b 74 06 78       	mov    0x78(%r14,%rax,1),%rsi
    1bd2:	e8 00 00 00 00       	callq  1bd7 <get_zone_path+0x107>

    //nova_dbg("%s start",__func__);
    phlen = ei->root_len;
    path = kzalloc((sizeof(char )*phlen), GFP_KERNEL);
    name = kzalloc((sizeof(char)*phlen), GFP_KERNEL);
    while(num!=0){
    1bd7:	45 85 ff             	test   %r15d,%r15d
        get_de_name(de, ze, name, 1);
        strcat(name,path);
        memcpy(path, name, strlen(name)+1);
        num = le64_to_cpu(ze->dz_no);
        hashname = le64_to_cpu(dzt_blk->dzt_entry[num].hash_name);
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    1bda:	49 89 c2             	mov    %rax,%r10

    //nova_dbg("%s start",__func__);
    phlen = ei->root_len;
    path = kzalloc((sizeof(char )*phlen), GFP_KERNEL);
    name = kzalloc((sizeof(char)*phlen), GFP_KERNEL);
    while(num!=0){
    1bdd:	0f 85 6a ff ff ff    	jne    1b4d <get_zone_path+0x7d>
        memcpy(path, name, strlen(name)+1);
        num = le64_to_cpu(ze->dz_no);
        hashname = le64_to_cpu(dzt_blk->dzt_entry[num].hash_name);
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    }
    strcat(path, dename);
    1be3:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    1be7:	4c 89 e7             	mov    %r12,%rdi
    1bea:	e8 00 00 00 00       	callq  1bef <get_zone_path+0x11f>
    slen = strlen(path);
    1bef:	4c 89 e7             	mov    %r12,%rdi
    1bf2:	e8 00 00 00 00       	callq  1bf7 <get_zone_path+0x127>
    memcpy(pname, path, slen);
    1bf7:	4c 8b 75 c8          	mov    -0x38(%rbp),%r14
    1bfb:	41 89 c5             	mov    %eax,%r13d
    1bfe:	4c 89 e6             	mov    %r12,%rsi
    1c01:	4c 89 ea             	mov    %r13,%rdx
    1c04:	4c 89 f7             	mov    %r14,%rdi
    1c07:	e8 00 00 00 00       	callq  1c0c <get_zone_path+0x13c>
    pname[slen]= '\0';
    1c0c:	43 c6 04 2e 00       	movb   $0x0,(%r14,%r13,1)
    //memcpy(pname+strlen(path),end,1);
    kfree(path);
    1c11:	4c 89 e7             	mov    %r12,%rdi
    1c14:	e8 00 00 00 00       	callq  1c19 <get_zone_path+0x149>
    kfree(name);
    1c19:	48 89 df             	mov    %rbx,%rdi
    1c1c:	e8 00 00 00 00       	callq  1c21 <get_zone_path+0x151>
    //nova_dbg("%s end get name %s",__func__,pname);
    return 0;

}
    1c21:	48 83 c4 28          	add    $0x28,%rsp
    1c25:	31 c0                	xor    %eax,%eax
    1c27:	5b                   	pop    %rbx
    1c28:	41 5c                	pop    %r12
    1c2a:	41 5d                	pop    %r13
    1c2c:	41 5e                	pop    %r14
    1c2e:	41 5f                	pop    %r15
    1c30:	5d                   	pop    %rbp
    1c31:	c3                   	retq   
    1c32:	0f 1f 40 00          	nopl   0x0(%rax)
    1c36:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1c3d:	00 00 00 

0000000000001c40 <clear_ext>:

}

/*clear ext bit*/
void clear_ext(struct zone_ptr *p, struct name_ext *de_ext)
{
    1c40:	e8 00 00 00 00       	callq  1c45 <clear_ext+0x5>
}

static inline int test_and_clear_bit_le(int nr, void *addr)
{
	return test_and_clear_bit(nr ^ BITOP_LE_SWIZZLE, addr);
    1c45:	8b 46 04             	mov    0x4(%rsi),%eax
    u32 ext_pos, bitpos;
    
    ext_pos = le32_to_cpu(de_ext->ext_pos);
    bitpos = ext_pos*2+1;
    test_and_clear_bit_le(bitpos, (void *)p->statemap);
    1c48:	48 8b 17             	mov    (%rdi),%rdx
    1c4b:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax
    1c4f:	48 98                	cltq   
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_clear_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "btr", *addr, "Ir", nr, "%0", "c");
    1c51:	f0 48 0f b3 02       	lock btr %rax,(%rdx)
    1c56:	72 00                	jb     1c58 <clear_ext+0x18>
    if(de_ext->next)
    1c58:	48 8b 76 08          	mov    0x8(%rsi),%rsi
    1c5c:	48 85 f6             	test   %rsi,%rsi
    1c5f:	74 0a                	je     1c6b <clear_ext+0x2b>

}

/*clear ext bit*/
void clear_ext(struct zone_ptr *p, struct name_ext *de_ext)
{
    1c61:	55                   	push   %rbp
    1c62:	48 89 e5             	mov    %rsp,%rbp
    
    ext_pos = le32_to_cpu(de_ext->ext_pos);
    bitpos = ext_pos*2+1;
    test_and_clear_bit_le(bitpos, (void *)p->statemap);
    if(de_ext->next)
        clear_ext(p, de_ext->next);
    1c65:	e8 00 00 00 00       	callq  1c6a <clear_ext+0x2a>
}
    1c6a:	5d                   	pop    %rbp
    1c6b:	f3 c3                	repz retq 
    1c6d:	0f 1f 00             	nopl   (%rax)

0000000000001c70 <delete_ext>:

/*test and delete ext name entry*/
int delete_ext(struct zone_ptr *p, struct dafs_dentry *de)
{
    1c70:	e8 00 00 00 00       	callq  1c75 <delete_ext+0x5>
    1c75:	55                   	push   %rbp
    1c76:	48 89 e5             	mov    %rsp,%rbp
    1c79:	41 54                	push   %r12
    1c7b:	53                   	push   %rbx
    unsigned short ext_flag;
    //struct name_ext *de_ext;

    //nova_dbg("%s start",__func__);
    ext_flag = le16_to_cpu(de->ext_flag);
    switch(ext_flag) {
    1c7c:	0f b7 46 04          	movzwl 0x4(%rsi),%eax
        clear_ext(p, de_ext->next);
}

/*test and delete ext name entry*/
int delete_ext(struct zone_ptr *p, struct dafs_dentry *de)
{
    1c80:	49 89 fc             	mov    %rdi,%r12
    1c83:	48 89 f3             	mov    %rsi,%rbx
    unsigned short ext_flag;
    //struct name_ext *de_ext;

    //nova_dbg("%s start",__func__);
    ext_flag = le16_to_cpu(de->ext_flag);
    switch(ext_flag) {
    1c86:	66 83 f8 01          	cmp    $0x1,%ax
    1c8a:	74 16                	je     1ca2 <delete_ext+0x32>
    1c8c:	66 83 f8 02          	cmp    $0x2,%ax
    1c90:	75 09                	jne    1c9b <delete_ext+0x2b>
    case 1:
        clear_ext(p, de->next);
        clear_ext(p, de->ful_name.fn_ext);
        break;
    case 2:
        clear_ext(p, de->ful_name.fn_ext);
    1c92:	48 8b 76 58          	mov    0x58(%rsi),%rsi
    1c96:	e8 00 00 00 00       	callq  1c9b <delete_ext+0x2b>
        break;
    }
OUT:
    //nova_dbg("%s end",__func__);
    return 0;
}
    1c9b:	5b                   	pop    %rbx
    1c9c:	31 c0                	xor    %eax,%eax
    1c9e:	41 5c                	pop    %r12
    1ca0:	5d                   	pop    %rbp
    1ca1:	c3                   	retq   
    ext_flag = le16_to_cpu(de->ext_flag);
    switch(ext_flag) {
    case 0:
        goto OUT;
    case 1:
        clear_ext(p, de->next);
    1ca2:	48 8b 76 30          	mov    0x30(%rsi),%rsi
    1ca6:	e8 00 00 00 00       	callq  1cab <delete_ext+0x3b>
        clear_ext(p, de->ful_name.fn_ext);
    1cab:	48 8b 73 58          	mov    0x58(%rbx),%rsi
    1caf:	4c 89 e7             	mov    %r12,%rdi
    1cb2:	e8 00 00 00 00       	callq  1cb7 <delete_ext+0x47>
        break;
    }
OUT:
    //nova_dbg("%s end",__func__);
    return 0;
}
    1cb7:	5b                   	pop    %rbx
    1cb8:	31 c0                	xor    %eax,%eax
    1cba:	41 5c                	pop    %r12
    1cbc:	5d                   	pop    %rbp
    1cbd:	c3                   	retq   
    1cbe:	66 90                	xchg   %ax,%ax

0000000000001cc0 <__remove_direntry>:
}

/**递归删除dentry*/
static int __remove_direntry(struct super_block *sb, struct dafs_dentry *dafs_de,\
        struct dafs_zone_entry *dafs_ze, struct dzt_entry_info *dzt_ei, u32 de_pos)
{
    1cc0:	e8 00 00 00 00       	callq  1cc5 <__remove_direntry+0x5>
    1cc5:	55                   	push   %rbp
    1cc6:	48 89 e5             	mov    %rsp,%rbp
    1cc9:	41 57                	push   %r15
    1ccb:	41 56                	push   %r14
    1ccd:	41 55                	push   %r13
    1ccf:	41 54                	push   %r12
    1cd1:	49 89 fd             	mov    %rdi,%r13
    1cd4:	53                   	push   %rbx
    1cd5:	49 89 f4             	mov    %rsi,%r12
    1cd8:	48 89 d3             	mov    %rdx,%rbx
    1cdb:	49 89 ce             	mov    %rcx,%r14
    1cde:	45 89 c7             	mov    %r8d,%r15d
    1ce1:	48 83 ec 38          	sub    $0x38,%rsp
    1ce5:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    1cec:	00 00 
    1cee:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    1cf2:	31 c0                	xor    %eax,%eax
    struct zone_ptr *z_p;
    struct dzt_ptr *dzt_p;
    struct dir_info *old_dir, *par_dir;
    struct list_head *this, *head, *next;
    struct file_p *tem_sf;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    1cf4:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
    //d_hn = BKDRHash(dafs_de->ful_name->f_name,d_hlen);
    //temlen = d_hlen - le64_to_cpu(dafs_de->name_len);
    //nova_dbg("%s start",__func__);
    isr_sf = le64_to_cpu(dafs_de->isr_sf);
    
    if(isr_sf!=1){
    1cfb:	80 7e 03 01          	cmpb   $0x1,0x3(%rsi)
    struct zone_ptr *z_p;
    struct dzt_ptr *dzt_p;
    struct dir_info *old_dir, *par_dir;
    struct list_head *this, *head, *next;
    struct file_p *tem_sf;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    1cff:	48 8b 80 d8 01 00 00 	mov    0x1d8(%rax),%rax
    1d06:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    isr_sf = le64_to_cpu(dafs_de->isr_sf);
    
    if(isr_sf!=1){
        par_id = le64_to_cpu(dafs_de->par_pos);
        pde = &dafs_ze->dentry[par_id];
        par_hn = le64_to_cpu(pde->hname);
    1d0a:	8b 46 0c             	mov    0xc(%rsi),%eax
    //d_hn = BKDRHash(dafs_de->ful_name->f_name,d_hlen);
    //temlen = d_hlen - le64_to_cpu(dafs_de->name_len);
    //nova_dbg("%s start",__func__);
    isr_sf = le64_to_cpu(dafs_de->isr_sf);
    
    if(isr_sf!=1){
    1d0d:	0f 84 f1 00 00 00    	je     1e04 <__remove_direntry+0x144>
        par_id = le64_to_cpu(dafs_de->par_pos);
        pde = &dafs_ze->dentry[par_id];
        par_hn = le64_to_cpu(pde->hname);
    1d13:	48 c1 e0 07          	shl    $0x7,%rax

        /*delete pos in its pardir*/
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    1d17:	48 8d 79 38          	lea    0x38(%rcx),%rdi
    1d1b:	48 8b b4 02 a8 40 00 	mov    0x40a8(%rdx,%rax,1),%rsi
    1d22:	00 
    1d23:	e8 00 00 00 00       	callq  1d28 <__remove_direntry+0x68>
        head = &par_dir->sub_file;
        list_for_each_safe(this, next, head) {
    1d28:	48 8b 70 18          	mov    0x18(%rax),%rsi
        pde = &dafs_ze->dentry[par_id];
        par_hn = le64_to_cpu(pde->hname);

        /*delete pos in its pardir*/
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
        head = &par_dir->sub_file;
    1d2c:	48 8d 48 18          	lea    0x18(%rax),%rcx
        list_for_each_safe(this, next, head) {
    1d30:	48 39 f1             	cmp    %rsi,%rcx
    1d33:	48 8b 3e             	mov    (%rsi),%rdi
    1d36:	74 20                	je     1d58 <__remove_direntry+0x98>
            tem_sf = list_entry(this, struct file_p, list);
            if(tem_sf->pos == de_pos){
    1d38:	44 3b 7e 10          	cmp    0x10(%rsi),%r15d
    1d3c:	75 12                	jne    1d50 <__remove_direntry+0x90>
    1d3e:	e9 18 01 00 00       	jmpq   1e5b <__remove_direntry+0x19b>
    1d43:	44 39 7f 10          	cmp    %r15d,0x10(%rdi)
    1d47:	0f 84 14 01 00 00    	je     1e61 <__remove_direntry+0x1a1>
        par_hn = le64_to_cpu(pde->hname);

        /*delete pos in its pardir*/
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
        head = &par_dir->sub_file;
        list_for_each_safe(this, next, head) {
    1d4d:	48 89 d7             	mov    %rdx,%rdi
    1d50:	48 39 f9             	cmp    %rdi,%rcx
    1d53:	48 8b 17             	mov    (%rdi),%rdx
    1d56:	75 eb                	jne    1d43 <__remove_direntry+0x83>
    }
    head = next = this =NULL;

NEXT:    
    //strcat(tem, dafs_ze->root_path);
    if(dafs_de->file_type == ROOT_DIRECTORY){
    1d58:	41 0f b6 44 24 02    	movzbl 0x2(%r12),%eax
    1d5e:	3c 02                	cmp    $0x2,%al
    1d60:	0f 84 41 01 00 00    	je     1ea7 <__remove_direntry+0x1e7>
        dafs_free_zone_blocks(sb, ei, ei->dz_addr >> PAGE_SHIFT, 1);
        kfree(pname);
        kfree(ei);
        kfree(z_p);
        kfree(dzt_p);
    }else if(dafs_de->file_type == NORMAL_DIRECTORY){
    1d66:	3c 01                	cmp    $0x1,%al

        /* delete sub files*/
        //nova_dbg("%s remove dir",__func__);
        d_hn = le64_to_cpu(dafs_de->hname);
    1d68:	49 8b 44 24 28       	mov    0x28(%r12),%rax
        dafs_free_zone_blocks(sb, ei, ei->dz_addr >> PAGE_SHIFT, 1);
        kfree(pname);
        kfree(ei);
        kfree(z_p);
        kfree(dzt_p);
    }else if(dafs_de->file_type == NORMAL_DIRECTORY){
    1d6d:	0f 84 97 02 00 00    	je     200a <__remove_direntry+0x34a>
        d_hn = le64_to_cpu(dafs_de->hname);
        
        /*delete dir itself*/
        bitpos = de_pos * 2;
        
        make_zone_ptr(&z_p, dafs_ze);
    1d73:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
    1d77:	48 89 de             	mov    %rbx,%rsi
        if(!ret)
            return -EINVAL;
    
        kfree(z_p);
    }else{
        d_hn = le64_to_cpu(dafs_de->hname);
    1d7a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        
        /*delete dir itself*/
        bitpos = de_pos * 2;
    1d7e:	45 01 ff             	add    %r15d,%r15d
        
        make_zone_ptr(&z_p, dafs_ze);
    1d81:	e8 00 00 00 00       	callq  1d86 <__remove_direntry+0xc6>
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    1d86:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    1d8a:	49 63 d7             	movslq %r15d,%rdx
    1d8d:	48 8b 00             	mov    (%rax),%rax
    1d90:	f0 48 0f b3 10       	lock btr %rdx,(%rax)
    1d95:	72 00                	jb     1d97 <__remove_direntry+0xd7>
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    1d97:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    1d9b:	45 8d 4f 01          	lea    0x1(%r15),%r9d
    1d9f:	4d 63 c9             	movslq %r9d,%r9
    1da2:	48 8b 00             	mov    (%rax),%rax
    1da5:	f0 4c 0f b3 08       	lock btr %r9,(%rax)
    1daa:	72 00                	jb     1dac <__remove_direntry+0xec>
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn, 1);
    1dac:	49 8b 76 18          	mov    0x18(%r14),%rsi
    1db0:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    1db4:	b9 01 00 00 00       	mov    $0x1,%ecx
    1db9:	4c 89 ef             	mov    %r13,%rdi
    1dbc:	e8 00 00 00 00       	callq  1dc1 <__remove_direntry+0x101>
        delete_ext(z_p, dafs_de);
    1dc1:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
        
        make_zone_ptr(&z_p, dafs_ze);
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn, 1);
    1dc5:	89 c3                	mov    %eax,%ebx
        delete_ext(z_p, dafs_de);
    1dc7:	4c 89 e6             	mov    %r12,%rsi
    1dca:	e8 00 00 00 00       	callq  1dcf <__remove_direntry+0x10f>
        /*free rf_entry*/
        //delete_rf_entry(dzt_ei, d_hn);
        if(!ret){
    1dcf:	85 db                	test   %ebx,%ebx
    1dd1:	0f 84 23 03 00 00    	je     20fa <__remove_direntry+0x43a>
            //nova_dbg("%s make invalid fail",__func__);
            return -EINVAL;
        }
        /*delete in par de*/

        kfree(z_p);
    1dd7:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    1ddb:	e8 00 00 00 00       	callq  1de0 <__remove_direntry+0x120>
    }
    //nova_dbg("%s end",__func__);
    return 0;
    1de0:	31 c0                	xor    %eax,%eax
}
    1de2:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    1de6:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    1ded:	00 00 
    1def:	0f 85 17 03 00 00    	jne    210c <__remove_direntry+0x44c>
    1df5:	48 83 c4 38          	add    $0x38,%rsp
    1df9:	5b                   	pop    %rbx
    1dfa:	41 5c                	pop    %r12
    1dfc:	41 5d                	pop    %r13
    1dfe:	41 5e                	pop    %r14
    1e00:	41 5f                	pop    %r15
    1e02:	5d                   	pop    %rbp
    1e03:	c3                   	retq   
        }
        //kfree(par_name);
    }else{
        par_id = le64_to_cpu(dafs_de->par_pos);
        pde = &dafs_ze->dentry[par_id];
        ino = le64_to_cpu(pde->ino);
    1e04:	48 c1 e0 07          	shl    $0x7,%rax
    1e08:	48 01 d0             	add    %rdx,%rax
        if(ino==NOVA_ROOT_INO){
    1e0b:	48 83 b8 98 40 00 00 	cmpq   $0x1,0x4098(%rax)
    1e12:	01 
    1e13:	0f 85 3f ff ff ff    	jne    1d58 <__remove_direntry+0x98>
            par_hn = le64_to_cpu(pde->hname);
            par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    1e19:	48 8b b0 a8 40 00 00 	mov    0x40a8(%rax),%rsi
    1e20:	48 8d 79 38          	lea    0x38(%rcx),%rdi
    1e24:	e8 00 00 00 00       	callq  1e29 <__remove_direntry+0x169>
            head = &par_dir->sub_file;
            list_for_each_safe(this, next, head) {
    1e29:	48 8b 70 18          	mov    0x18(%rax),%rsi
        pde = &dafs_ze->dentry[par_id];
        ino = le64_to_cpu(pde->ino);
        if(ino==NOVA_ROOT_INO){
            par_hn = le64_to_cpu(pde->hname);
            par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
            head = &par_dir->sub_file;
    1e2d:	48 8d 48 18          	lea    0x18(%rax),%rcx
            list_for_each_safe(this, next, head) {
    1e31:	48 39 f1             	cmp    %rsi,%rcx
    1e34:	48 8b 3e             	mov    (%rsi),%rdi
    1e37:	0f 84 1b ff ff ff    	je     1d58 <__remove_direntry+0x98>
                tem_sf = list_entry(this, struct file_p, list);
                if(tem_sf->pos == de_pos){
    1e3d:	44 3b 7e 10          	cmp    0x10(%rsi),%r15d
    1e41:	75 0b                	jne    1e4e <__remove_direntry+0x18e>
    1e43:	eb 16                	jmp    1e5b <__remove_direntry+0x19b>
    1e45:	44 3b 7f 10          	cmp    0x10(%rdi),%r15d
    1e49:	74 16                	je     1e61 <__remove_direntry+0x1a1>
        ino = le64_to_cpu(pde->ino);
        if(ino==NOVA_ROOT_INO){
            par_hn = le64_to_cpu(pde->hname);
            par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
            head = &par_dir->sub_file;
            list_for_each_safe(this, next, head) {
    1e4b:	48 89 d7             	mov    %rdx,%rdi
    1e4e:	48 39 f9             	cmp    %rdi,%rcx
    1e51:	48 8b 17             	mov    (%rdi),%rdx
    1e54:	75 ef                	jne    1e45 <__remove_direntry+0x185>
    1e56:	e9 fd fe ff ff       	jmpq   1d58 <__remove_direntry+0x98>
                tem_sf = list_entry(this, struct file_p, list);
                if(tem_sf->pos == de_pos){
    1e5b:	48 89 fa             	mov    %rdi,%rdx
    1e5e:	48 89 f7             	mov    %rsi,%rdi
    1e61:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1e65:	48 8b 4f 08          	mov    0x8(%rdi),%rcx
	entry->next = LIST_POISON1;
    1e69:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
    1e70:	00 ad de 
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1e73:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
	prev->next = next;
    1e77:	48 89 11             	mov    %rdx,(%rcx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    1e7a:	48 89 07             	mov    %rax,(%rdi)
	entry->prev = LIST_POISON2;
    1e7d:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
    1e84:	00 ad de 
    1e87:	48 89 47 08          	mov    %rax,0x8(%rdi)
                    list_del(&tem_sf->list);
                    kfree(tem_sf);
    1e8b:	e8 00 00 00 00       	callq  1e90 <__remove_direntry+0x1d0>
                    par_dir->sub_num--;
    1e90:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    1e94:	48 83 68 08 01       	subq   $0x1,0x8(%rax)
    }
    head = next = this =NULL;

NEXT:    
    //strcat(tem, dafs_ze->root_path);
    if(dafs_de->file_type == ROOT_DIRECTORY){
    1e99:	41 0f b6 44 24 02    	movzbl 0x2(%r12),%eax
    1e9f:	3c 02                	cmp    $0x2,%al
    1ea1:	0f 85 bf fe ff ff    	jne    1d66 <__remove_direntry+0xa6>

        /*delete dir*/
        bitpos = de_pos * 2;

        plen = le64_to_cpu(dafs_de->fname_len);
    1ea7:	4d 8b 44 24 10       	mov    0x10(%r12),%r8
NEXT:    
    //strcat(tem, dafs_ze->root_path);
    if(dafs_de->file_type == ROOT_DIRECTORY){

        /*delete dir*/
        bitpos = de_pos * 2;
    1eac:	43 8d 04 3f          	lea    (%r15,%r15,1),%eax
    1eb0:	89 45 b0             	mov    %eax,-0x50(%rbp)

        plen = le64_to_cpu(dafs_de->fname_len);
        pname = kzalloc(sizeof(char)*(plen+1), GFP_KERNEL);
    1eb3:	49 8d 78 01          	lea    0x1(%r8),%rdi
    1eb7:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
    1ebb:	e8 30 e2 ff ff       	callq  f0 <kzalloc.constprop.9>
        get_de_name(dafs_de, dafs_ze, pname, 1);
    1ec0:	b9 01 00 00 00       	mov    $0x1,%ecx
    1ec5:	48 89 c2             	mov    %rax,%rdx
    1ec8:	48 89 de             	mov    %rbx,%rsi
    1ecb:	4c 89 e7             	mov    %r12,%rdi

        /*delete dir*/
        bitpos = de_pos * 2;

        plen = le64_to_cpu(dafs_de->fname_len);
        pname = kzalloc(sizeof(char)*(plen+1), GFP_KERNEL);
    1ece:	49 89 c7             	mov    %rax,%r15
        get_de_name(dafs_de, dafs_ze, pname, 1);
    1ed1:	e8 00 00 00 00       	callq  1ed6 <__remove_direntry+0x216>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    1ed6:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
    1eda:	45 85 c0             	test   %r8d,%r8d
    1edd:	0f 8e 21 02 00 00    	jle    2104 <__remove_direntry+0x444>
    1ee3:	41 8d 40 ff          	lea    -0x1(%r8),%eax
    1ee7:	45 31 c0             	xor    %r8d,%r8d
    1eea:	49 8d 4c 07 01       	lea    0x1(%r15,%rax,1),%rcx
    1eef:	4c 89 f8             	mov    %r15,%rax
		hash = hash * seed + (*str++);
    1ef2:	4c 89 c2             	mov    %r8,%rdx
    1ef5:	48 83 c0 01          	add    $0x1,%rax
    1ef9:	48 c1 e2 05          	shl    $0x5,%rdx
    1efd:	4c 29 c2             	sub    %r8,%rdx
    1f00:	49 89 d0             	mov    %rdx,%r8
    1f03:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    1f08:	49 01 d0             	add    %rdx,%r8
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    1f0b:	48 39 c1             	cmp    %rax,%rcx
    1f0e:	75 e2                	jne    1ef2 <__remove_direntry+0x232>
        d_hn = BKDRHash(pname, plen);
        
        make_zone_ptr(&z_p, dafs_ze);
    1f10:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
    1f14:	48 89 de             	mov    %rbx,%rsi
    1f17:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
    1f1b:	e8 00 00 00 00       	callq  1f20 <__remove_direntry+0x260>
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    1f20:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    1f24:	48 63 55 b0          	movslq -0x50(%rbp),%rdx
    1f28:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
    1f2c:	48 8b 00             	mov    (%rax),%rax
    1f2f:	f0 48 0f b3 10       	lock btr %rdx,(%rax)
    1f34:	72 00                	jb     1f36 <__remove_direntry+0x276>
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    1f36:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    1f3a:	48 8b 10             	mov    (%rax),%rdx
    1f3d:	8b 45 b0             	mov    -0x50(%rbp),%eax
    1f40:	83 c0 01             	add    $0x1,%eax
    1f43:	48 98                	cltq   
    1f45:	f0 48 0f b3 02       	lock btr %rax,(%rdx)
    1f4a:	72 00                	jb     1f4c <__remove_direntry+0x28c>
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn,  1);
    1f4c:	49 8b 76 18          	mov    0x18(%r14),%rsi
    1f50:	4c 89 c2             	mov    %r8,%rdx
    1f53:	b9 01 00 00 00       	mov    $0x1,%ecx
    1f58:	4c 89 ef             	mov    %r13,%rdi
    1f5b:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
    1f5f:	e8 00 00 00 00       	callq  1f64 <__remove_direntry+0x2a4>
        delete_ext(z_p, dafs_de);
    1f64:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    1f68:	4c 89 e6             	mov    %r12,%rsi
        
        make_zone_ptr(&z_p, dafs_ze);
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn,  1);
    1f6b:	89 c3                	mov    %eax,%ebx
        delete_ext(z_p, dafs_de);
    1f6d:	e8 00 00 00 00       	callq  1f72 <__remove_direntry+0x2b2>
        /*free dir_entry*/
        delete_dir_info(dzt_ei, d_hn);
    1f72:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
    1f76:	4c 89 f7             	mov    %r14,%rdi
    1f79:	4c 89 c6             	mov    %r8,%rsi
    1f7c:	e8 00 00 00 00       	callq  1f81 <__remove_direntry+0x2c1>
        
        if(!ret)
    1f81:	85 db                	test   %ebx,%ebx
    1f83:	0f 84 71 01 00 00    	je     20fa <__remove_direntry+0x43a>
         * ei free zone
         * free hash table
         * free zone
         * free ei*/
        hashname = le64_to_cpu(dafs_de->dzt_hn);
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    1f89:	49 8b 74 24 28       	mov    0x28(%r12),%rsi
    1f8e:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    1f92:	e8 00 00 00 00       	callq  1f97 <__remove_direntry+0x2d7>
        dzt_rno = ei->dzt_eno;
        tail = le64_to_cpu(ei->ht_head);
        free_htable(sb, tail, 1);
    1f97:	48 8b 70 18          	mov    0x18(%rax),%rsi
    1f9b:	ba 01 00 00 00       	mov    $0x1,%edx
    1fa0:	4c 89 ef             	mov    %r13,%rdi
         * ei free zone
         * free hash table
         * free zone
         * free ei*/
        hashname = le64_to_cpu(dafs_de->dzt_hn);
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    1fa3:	48 89 c3             	mov    %rax,%rbx
        dzt_rno = ei->dzt_eno;
    1fa6:	4c 63 60 08          	movslq 0x8(%rax),%r12
        tail = le64_to_cpu(ei->ht_head);
        free_htable(sb, tail, 1);
    1faa:	e8 00 00 00 00       	callq  1faf <__remove_direntry+0x2ef>
        make_dzt_ptr(sb, &dzt_p);
    1faf:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
    1fb3:	4c 89 ef             	mov    %r13,%rdi
    1fb6:	e8 00 00 00 00       	callq  1fbb <__remove_direntry+0x2fb>
        test_and_clear_bit_le(dzt_rno, (void *)dzt_p->bitmap);
    1fbb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    1fbf:	48 8b 00             	mov    (%rax),%rax
    1fc2:	f0 4c 0f b3 20       	lock btr %r12,(%rax)
    1fc7:	72 00                	jb     1fc9 <__remove_direntry+0x309>
        //delete_rf_tree(ei);
        dafs_free_zone_blocks(sb, ei, ei->dz_addr >> PAGE_SHIFT, 1);
    1fc9:	48 8b 53 10          	mov    0x10(%rbx),%rdx
    1fcd:	b9 01 00 00 00       	mov    $0x1,%ecx
    1fd2:	48 89 de             	mov    %rbx,%rsi
    1fd5:	4c 89 ef             	mov    %r13,%rdi
    1fd8:	48 c1 ea 0c          	shr    $0xc,%rdx
    1fdc:	e8 00 00 00 00       	callq  1fe1 <__remove_direntry+0x321>
        kfree(pname);
    1fe1:	4c 89 ff             	mov    %r15,%rdi
    1fe4:	e8 00 00 00 00       	callq  1fe9 <__remove_direntry+0x329>
        kfree(ei);
    1fe9:	48 89 df             	mov    %rbx,%rdi
    1fec:	e8 00 00 00 00       	callq  1ff1 <__remove_direntry+0x331>
        kfree(z_p);
    1ff1:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    1ff5:	e8 00 00 00 00       	callq  1ffa <__remove_direntry+0x33a>
        kfree(dzt_p);
    1ffa:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    1ffe:	e8 00 00 00 00       	callq  2003 <__remove_direntry+0x343>
        /*delete in par de*/

        kfree(z_p);
    }
    //nova_dbg("%s end",__func__);
    return 0;
    2003:	31 c0                	xor    %eax,%eax
    2005:	e9 d8 fd ff ff       	jmpq   1de2 <__remove_direntry+0x122>
    }else if(dafs_de->file_type == NORMAL_DIRECTORY){

        /* delete sub files*/
        //nova_dbg("%s remove dir",__func__);
        d_hn = le64_to_cpu(dafs_de->hname);
        old_dir = radix_tree_lookup(&dzt_ei->dir_tree, d_hn);
    200a:	49 8d 4e 38          	lea    0x38(%r14),%rcx
    200e:	48 89 c6             	mov    %rax,%rsi
        kfree(dzt_p);
    }else if(dafs_de->file_type == NORMAL_DIRECTORY){

        /* delete sub files*/
        //nova_dbg("%s remove dir",__func__);
        d_hn = le64_to_cpu(dafs_de->hname);
    2011:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
        old_dir = radix_tree_lookup(&dzt_ei->dir_tree, d_hn);
    2015:	48 89 cf             	mov    %rcx,%rdi
    2018:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    201c:	e8 00 00 00 00       	callq  2021 <__remove_direntry+0x361>
        if(!old_dir){
    2021:	48 85 c0             	test   %rax,%rax
    2024:	0f 84 d0 00 00 00    	je     20fa <__remove_direntry+0x43a>
            //nova_dbg("%s not find dir_info",__func__);
            return -EINVAL;
        }
        head = &old_dir->sub_file;
    202a:	48 8d 48 18          	lea    0x18(%rax),%rcx
        list_for_each_safe(this, next, head) {
    202e:	48 8b 40 18          	mov    0x18(%rax),%rax
        old_dir = radix_tree_lookup(&dzt_ei->dir_tree, d_hn);
        if(!old_dir){
            //nova_dbg("%s not find dir_info",__func__);
            return -EINVAL;
        }
        head = &old_dir->sub_file;
    2032:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
        list_for_each_safe(this, next, head) {
    2036:	48 39 c1             	cmp    %rax,%rcx
    2039:	4c 8b 10             	mov    (%rax),%r10
    203c:	75 05                	jne    2043 <__remove_direntry+0x383>
    203e:	eb 39                	jmp    2079 <__remove_direntry+0x3b9>
    2040:	49 89 d2             	mov    %rdx,%r10
            tem_sf = list_entry(this, struct file_p, list);
            sub_id = tem_sf->pos;
    2043:	8b 70 10             	mov    0x10(%rax),%esi
            sde= &dafs_ze->dentry[sub_id];
            //nova_dbg("%s start to delete de %s",__func__, sde->name);
            ret = __remove_direntry(sb, sde, dafs_ze, dzt_ei, sub_id);
    2046:	48 89 da             	mov    %rbx,%rdx
    2049:	4c 89 f1             	mov    %r14,%rcx
    204c:	4c 89 ef             	mov    %r13,%rdi
    204f:	4c 89 55 b8          	mov    %r10,-0x48(%rbp)
            return -EINVAL;
        }
        head = &old_dir->sub_file;
        list_for_each_safe(this, next, head) {
            tem_sf = list_entry(this, struct file_p, list);
            sub_id = tem_sf->pos;
    2053:	49 89 f0             	mov    %rsi,%r8
            sde= &dafs_ze->dentry[sub_id];
    2056:	48 81 c6 81 00 00 00 	add    $0x81,%rsi
    205d:	48 c1 e6 07          	shl    $0x7,%rsi
    2061:	48 01 de             	add    %rbx,%rsi
            //nova_dbg("%s start to delete de %s",__func__, sde->name);
            ret = __remove_direntry(sb, sde, dafs_ze, dzt_ei, sub_id);
    2064:	e8 57 fc ff ff       	callq  1cc0 <__remove_direntry>
        if(!old_dir){
            //nova_dbg("%s not find dir_info",__func__);
            return -EINVAL;
        }
        head = &old_dir->sub_file;
        list_for_each_safe(this, next, head) {
    2069:	4c 8b 55 b8          	mov    -0x48(%rbp),%r10
    206d:	4c 39 55 b0          	cmp    %r10,-0x50(%rbp)
    2071:	49 8b 12             	mov    (%r10),%rdx
    2074:	4c 89 d0             	mov    %r10,%rax
    2077:	75 c7                	jne    2040 <__remove_direntry+0x380>
        }

        /*delete dir itself*/
        bitpos = de_pos * 2;
        
        make_zone_ptr(&z_p, dafs_ze);
    2079:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
    207d:	48 89 de             	mov    %rbx,%rsi
            //old_dir->sub_num--;
            //kfree(tem_sf);
        }

        /*delete dir itself*/
        bitpos = de_pos * 2;
    2080:	45 01 ff             	add    %r15d,%r15d
        
        make_zone_ptr(&z_p, dafs_ze);
    2083:	e8 00 00 00 00       	callq  2088 <__remove_direntry+0x3c8>
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    2088:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    208c:	49 63 d7             	movslq %r15d,%rdx
    208f:	48 8b 00             	mov    (%rax),%rax
    2092:	f0 48 0f b3 10       	lock btr %rdx,(%rax)
    2097:	72 00                	jb     2099 <__remove_direntry+0x3d9>
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    2099:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    209d:	45 8d 4f 01          	lea    0x1(%r15),%r9d
    20a1:	4d 63 c9             	movslq %r9d,%r9
    20a4:	48 8b 00             	mov    (%rax),%rax
    20a7:	f0 4c 0f b3 08       	lock btr %r9,(%rax)
    20ac:	72 00                	jb     20ae <__remove_direntry+0x3ee>
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn, 1);
    20ae:	49 8b 76 18          	mov    0x18(%r14),%rsi
    20b2:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
    20b6:	b9 01 00 00 00       	mov    $0x1,%ecx
    20bb:	4c 89 ef             	mov    %r13,%rdi
    20be:	e8 00 00 00 00       	callq  20c3 <__remove_direntry+0x403>
        delete_ext(z_p, dafs_de);
    20c3:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
        
        make_zone_ptr(&z_p, dafs_ze);
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn, 1);
    20c7:	89 c3                	mov    %eax,%ebx
        delete_ext(z_p, dafs_de);
    20c9:	4c 89 e6             	mov    %r12,%rsi
    20cc:	e8 00 00 00 00       	callq  20d1 <__remove_direntry+0x411>

        if(!ret)
    20d1:	85 db                	test   %ebx,%ebx
    20d3:	74 25                	je     20fa <__remove_direntry+0x43a>
            return -EINVAL;
        
        /*free dir_info_entry*/
        old_dir = radix_tree_lookup(&dzt_ei->dir_tree, d_hn);
    20d5:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    20d9:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    20dd:	e8 00 00 00 00       	callq  20e2 <__remove_direntry+0x422>
        kfree(old_dir);
    20e2:	48 89 c7             	mov    %rax,%rdi
    20e5:	e8 00 00 00 00       	callq  20ea <__remove_direntry+0x42a>

        if(!ret)
            return -EINVAL;
    
        kfree(z_p);
    20ea:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    20ee:	e8 00 00 00 00       	callq  20f3 <__remove_direntry+0x433>
        /*delete in par de*/

        kfree(z_p);
    }
    //nova_dbg("%s end",__func__);
    return 0;
    20f3:	31 c0                	xor    %eax,%eax
    20f5:	e9 e8 fc ff ff       	jmpq   1de2 <__remove_direntry+0x122>
        delete_ext(z_p, dafs_de);
        /*free dir_entry*/
        delete_dir_info(dzt_ei, d_hn);
        
        if(!ret)
            return -EINVAL;
    20fa:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    20ff:	e9 de fc ff ff       	jmpq   1de2 <__remove_direntry+0x122>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    2104:	45 31 c0             	xor    %r8d,%r8d
    2107:	e9 04 fe ff ff       	jmpq   1f10 <__remove_direntry+0x250>

        kfree(z_p);
    }
    //nova_dbg("%s end",__func__);
    return 0;
}
    210c:	e8 00 00 00 00       	callq  2111 <__remove_direntry+0x451>
    2111:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    2116:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    211d:	00 00 00 

0000000000002120 <dafs_add_dentry>:
}

/*dafs add dentry in the zone
* and initialize direntry without name*/
int dafs_add_dentry(struct dentry *dentry, u64 ino, int link_change, int file_type)
{
    2120:	e8 00 00 00 00       	callq  2125 <dafs_add_dentry+0x5>
    2125:	55                   	push   %rbp
    2126:	49 89 f1             	mov    %rsi,%r9
    2129:	41 89 d0             	mov    %edx,%r8d
    212c:	48 89 e5             	mov    %rsp,%rbp
    212f:	41 57                	push   %r15
    2131:	41 56                	push   %r14
    2133:	41 55                	push   %r13
    2135:	41 54                	push   %r12
    2137:	41 89 cf             	mov    %ecx,%r15d
    213a:	53                   	push   %rbx
    213b:	48 89 fb             	mov    %rdi,%rbx
    213e:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
    struct nova_inode *pidir;
    unsigned short  namelen = dentry->d_name.len;
    2145:	44 8b 77 24          	mov    0x24(%rdi),%r14d
}

/*dafs add dentry in the zone
* and initialize direntry without name*/
int dafs_add_dentry(struct dentry *dentry, u64 ino, int link_change, int file_type)
{
    2149:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    2150:	00 00 
    2152:	48 89 84 24 a0 00 00 	mov    %rax,0xa0(%rsp)
    2159:	00 
    215a:	31 c0                	xor    %eax,%eax
    struct inode *dir = dentry->d_parent->d_inode;
    215c:	48 8b 47 18          	mov    0x18(%rdi),%rax
    2160:	4c 8b 60 30          	mov    0x30(%rax),%r12
    
	/*nova_dbg_verbose("%s: dir %lu new inode %llu\n",
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
    2164:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 216a <dafs_add_dentry+0x4a>
    216a:	85 c0                	test   %eax,%eax
/*dafs add dentry in the zone
* and initialize direntry without name*/
int dafs_add_dentry(struct dentry *dentry, u64 ino, int link_change, int file_type)
{
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
    216c:	4d 8b 6c 24 28       	mov    0x28(%r12),%r13
    
	/*nova_dbg_verbose("%s: dir %lu new inode %llu\n",
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
    2171:	75 30                	jne    21a3 <dafs_add_dentry+0x83>
	if (namelen == 0)
    2173:	66 45 85 f6          	test   %r14w,%r14w
    2177:	75 51                	jne    21ca <dafs_add_dentry+0xaa>
		return -EINVAL;
    2179:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    kfree(phn);
    kfree(zone_p);
    //nova_dbg("%s: finish, ino %llu, parent name %s",
    //     __func__, dafs_de->ino, dentry->d_parent->d_name.name);
    return ret;
}
    217e:	48 8b b4 24 a0 00 00 	mov    0xa0(%rsp),%rsi
    2185:	00 
    2186:	65 48 33 34 25 28 00 	xor    %gs:0x28,%rsi
    218d:	00 00 
    218f:	75 34                	jne    21c5 <dafs_add_dentry+0xa5>
    2191:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
    2198:	5b                   	pop    %rbx
    2199:	41 5c                	pop    %r12
    219b:	41 5d                	pop    %r13
    219d:	41 5e                	pop    %r14
    219f:	41 5f                	pop    %r15
    21a1:	5d                   	pop    %rbp
    21a2:	c3                   	retq   
    21a3:	48 8d bc 24 80 00 00 	lea    0x80(%rsp),%rdi
    21aa:	00 
    21ab:	89 54 24 60          	mov    %edx,0x60(%rsp)
    21af:	48 89 74 24 68       	mov    %rsi,0x68(%rsp)
    21b4:	e8 00 00 00 00       	callq  21b9 <dafs_add_dentry+0x99>
    21b9:	44 8b 44 24 60       	mov    0x60(%rsp),%r8d
    21be:	4c 8b 4c 24 68       	mov    0x68(%rsp),%r9
    21c3:	eb ae                	jmp    2173 <dafs_add_dentry+0x53>
    21c5:	e8 00 00 00 00       	callq  21ca <dafs_add_dentry+0xaa>
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
	if (namelen == 0)
		return -EINVAL;
    nova_dbg("%s:dafs start to add dentry",__func__);
    21ca:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    21d1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    21d8:	44 89 44 24 50       	mov    %r8d,0x50(%rsp)
    21dd:	4c 89 4c 24 58       	mov    %r9,0x58(%rsp)
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    21e2:	45 31 f6             	xor    %r14d,%r14d
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
	if (namelen == 0)
		return -EINVAL;
    nova_dbg("%s:dafs start to add dentry",__func__);
    21e5:	e8 00 00 00 00       	callq  21ea <dafs_add_dentry+0xca>
    ph = get_dentry_path(dentry,0);
    21ea:	48 89 df             	mov    %rbx,%rdi
    21ed:	e8 0e df ff ff       	callq  100 <get_dentry_path.isra.4>
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    21f2:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
	if (namelen == 0)
		return -EINVAL;
    nova_dbg("%s:dafs start to add dentry",__func__);
    ph = get_dentry_path(dentry,0);
    21f6:	48 89 c7             	mov    %rax,%rdi
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    21f9:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
    21fe:	48 89 d1             	mov    %rdx,%rcx
    2201:	48 89 54 24 68       	mov    %rdx,0x68(%rsp)
    2206:	44 89 f0             	mov    %r14d,%eax
    2209:	f2 ae                	repnz scas %es:(%rdi),%al
    220b:	48 f7 d1             	not    %rcx
    220e:	48 8d 3c 11          	lea    (%rcx,%rdx,1),%rdi
    2212:	e8 d9 de ff ff       	callq  f0 <kzalloc.constprop.9>
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    2217:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
    221c:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
	if (namelen == 0)
		return -EINVAL;
    nova_dbg("%s:dafs start to add dentry",__func__);
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    2221:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    2226:	44 89 f0             	mov    %r14d,%eax
    2229:	48 89 d1             	mov    %rdx,%rcx
    222c:	f2 ae                	repnz scas %es:(%rdi),%al
    222e:	48 f7 d1             	not    %rcx
    2231:	48 89 cf             	mov    %rcx,%rdi
    2234:	e8 b7 de ff ff       	callq  f0 <kzalloc.constprop.9>
    dzt_ei = find_dzt(sb, ph, phn);
    2239:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
    223e:	48 89 c2             	mov    %rax,%rdx
    2241:	4c 89 ef             	mov    %r13,%rdi
	if (namelen == 0)
		return -EINVAL;
    nova_dbg("%s:dafs start to add dentry",__func__);
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    2244:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    dzt_ei = find_dzt(sb, ph, phn);
    2249:	e8 b2 dd ff ff       	callq  0 <find_dzt>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    224e:	49 8b 95 b0 03 00 00 	mov    0x3b0(%r13),%rdx
    2255:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb,dzt_ei->dz_addr);
    make_zone_ptr(&zone_p, dafs_ze);
    225a:	48 8d 7c 24 78       	lea    0x78(%rsp),%rdi
    nova_dbg("%s:dafs start to add dentry",__func__);
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb,dzt_ei->dz_addr);
    225f:	48 8b 40 10          	mov    0x10(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    2263:	48 89 c1             	mov    %rax,%rcx
    2266:	48 03 4a 18          	add    0x18(%rdx),%rcx
    226a:	48 85 c0             	test   %rax,%rax
    226d:	b8 00 00 00 00       	mov    $0x0,%eax
    2272:	48 0f 45 c1          	cmovne %rcx,%rax
    struct file_p *tem_sf;
    //struct name_ext *de_ext;
    char *phname, *ph, *phn, *tem;
    unsigned long phlen, temlen, flen, tm_len;
    unsigned short links_count;
    u32 bitpos = 0, cur_pos = 0, par_pos, tem_pos;
    2276:	45 31 f6             	xor    %r14d,%r14d
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb,dzt_ei->dz_addr);
    make_zone_ptr(&zone_p, dafs_ze);
    2279:	48 89 c6             	mov    %rax,%rsi
    227c:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    2281:	e8 00 00 00 00       	callq  2286 <dafs_add_dentry+0x166>
    2286:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
    struct file_p *tem_sf;
    //struct name_ext *de_ext;
    char *phname, *ph, *phn, *tem;
    unsigned long phlen, temlen, flen, tm_len;
    unsigned short links_count;
    u32 bitpos = 0, cur_pos = 0, par_pos, tem_pos;
    228b:	45 31 db             	xor    %r11d,%r11d
    228e:	4c 8b 4c 24 58       	mov    0x58(%rsp),%r9
    2293:	44 8b 44 24 50       	mov    0x50(%rsp),%r8d
    2298:	48 8b 08             	mov    (%rax),%rcx
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb,dzt_ei->dz_addr);
    make_zone_ptr(&zone_p, dafs_ze);
    229b:	31 c0                	xor    %eax,%eax
    229d:	eb 19                	jmp    22b8 <dafs_add_dentry+0x198>
    //nova_dbg("%s zone beginning",__func__);
    //tes_empty_zone(sb, zone_p);
    while(cur_pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
            bitpos+=2;
    229f:	41 83 c3 02          	add    $0x2,%r11d
            cur_pos++;
    22a3:	41 83 c6 01          	add    $0x1,%r14d
    22a7:	48 83 c0 02          	add    $0x2,%rax
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb,dzt_ei->dz_addr);
    make_zone_ptr(&zone_p, dafs_ze);
    //nova_dbg("%s zone beginning",__func__);
    //tes_empty_zone(sb, zone_p);
    while(cur_pos<NR_DENTRY_IN_ZONE){
    22ab:	41 81 fb fe ff 01 00 	cmp    $0x1fffe,%r11d
    22b2:	0f 84 d8 05 00 00    	je     2890 <dafs_add_dentry+0x770>

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    22b8:	48 0f a3 01          	bt     %rax,(%rcx)
    22bc:	19 d2                	sbb    %edx,%edx
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
    22be:	85 d2                	test   %edx,%edx
    22c0:	75 dd                	jne    229f <dafs_add_dentry+0x17f>
    22c2:	48 8d 50 01          	lea    0x1(%rax),%rdx
    22c6:	48 0f a3 11          	bt     %rdx,(%rcx)
    22ca:	19 d2                	sbb    %edx,%edx
    22cc:	85 d2                	test   %edx,%edx
    22ce:	75 cf                	jne    229f <dafs_add_dentry+0x17f>
    if(cur_pos==NR_DENTRY_IN_ZONE){
        BUG();
        dafs_split_zone(sb, NULL, 0, NEGTIVE_SPLIT);
    }*/

    phlen = strlen(phn); 
    22d0:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    22d5:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
    22d9:	31 c0                	xor    %eax,%eax
    22db:	48 89 f1             	mov    %rsi,%rcx
    22de:	f2 ae                	repnz scas %es:(%rdi),%al
    22e0:	48 f7 d1             	not    %rcx
    22e3:	48 89 ca             	mov    %rcx,%rdx
    22e6:	48 01 f2             	add    %rsi,%rdx
    if(phlen==1){
    22e9:	48 83 fa 01          	cmp    $0x1,%rdx
    22ed:	0f 84 3e 05 00 00    	je     2831 <dafs_add_dentry+0x711>
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    22f3:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
    22f8:	44 89 44 24 30       	mov    %r8d,0x30(%rsp)
    22fd:	48 89 f1             	mov    %rsi,%rcx
    2300:	4c 89 4c 24 38       	mov    %r9,0x38(%rsp)
    2305:	44 89 5c 24 50       	mov    %r11d,0x50(%rsp)
    230a:	f2 ae                	repnz scas %es:(%rdi),%al
        memcpy(phname, ph+phlen, flen);
    230c:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    2311:	48 89 c8             	mov    %rcx,%rax
    2314:	48 f7 d0             	not    %rax
        memcpy(phname, ph+phlen, flen);
    2317:	48 8d 34 17          	lea    (%rdi,%rdx,1),%rsi
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    231b:	48 83 e8 01          	sub    $0x1,%rax
        memcpy(phname, ph+phlen, flen);
    231f:	48 8b 7c 24 60       	mov    0x60(%rsp),%rdi
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    2324:	48 29 d0             	sub    %rdx,%rax
        memcpy(phname, ph+phlen, flen);
    2327:	48 89 c2             	mov    %rax,%rdx
    232a:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
    232f:	e8 00 00 00 00       	callq  2334 <dafs_add_dentry+0x214>
        phname[flen]='\0';
    2334:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
    2339:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
    233e:	44 8b 44 24 30       	mov    0x30(%rsp),%r8d
    2343:	4c 8b 4c 24 38       	mov    0x38(%rsp),%r9
    2348:	44 8b 5c 24 50       	mov    0x50(%rsp),%r11d
    234d:	c6 04 01 00          	movb   $0x0,(%rcx,%rax,1)
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
    2351:	49 8b 54 24 c8       	mov    -0x38(%r12),%rdx
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    2356:	49 8b 85 b0 03 00 00 	mov    0x3b0(%r13),%rax
    235d:	44 89 44 24 10       	mov    %r8d,0x10(%rsp)
    2362:	4c 89 4c 24 18       	mov    %r9,0x18(%rsp)
    2367:	44 89 5c 24 30       	mov    %r11d,0x30(%rsp)
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    236c:	48 89 d1             	mov    %rdx,%rcx
    236f:	48 03 48 18          	add    0x18(%rax),%rcx
    2373:	48 85 d2             	test   %rdx,%rdx
    2376:	48 89 c8             	mov    %rcx,%rax
    2379:	b9 00 00 00 00       	mov    $0x0,%ecx
    237e:	48 0f 45 c8          	cmovne %rax,%rcx
    2382:	48 89 4c 24 50       	mov    %rcx,0x50(%rsp)
    }

    pidir = nova_get_inode(sb, dir);
    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    2387:	e8 00 00 00 00       	callq  238c <dafs_add_dentry+0x26c>
    238c:	49 c7 84 24 80 00 00 	movq   $0x0,0x80(%r12)
    2393:	00 00 00 00 00 
    2398:	49 89 44 24 78       	mov    %rax,0x78(%r12)
    239d:	49 8b 94 24 80 00 00 	mov    0x80(%r12),%rdx
    23a4:	00 
    23a5:	49 8b 44 24 78       	mov    0x78(%r12),%rax
    dir->i_blocks = pidir->i_blocks;
    23aa:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = dentry->d_name.len;
    //dafs_de->file_type = NORMAL_DIRECTORY;       

    links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
    23af:	44 8b 5c 24 30       	mov    0x30(%rsp),%r11d
    23b4:	4c 8b 4c 24 18       	mov    0x18(%rsp),%r9
    23b9:	44 8b 44 24 10       	mov    0x10(%rsp),%r8d
        memcpy(phname, ph+phlen, flen);
        phname[flen]='\0';
    }

    pidir = nova_get_inode(sb, dir);
    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    23be:	49 89 54 24 70       	mov    %rdx,0x70(%r12)
    23c3:	49 89 44 24 68       	mov    %rax,0x68(%r12)
    dir->i_blocks = pidir->i_blocks;
    23c8:	48 8b 41 20          	mov    0x20(%rcx),%rax

    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    23cc:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
        phname[flen]='\0';
    }

    pidir = nova_get_inode(sb, dir);
    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    dir->i_blocks = pidir->i_blocks;
    23d1:	49 89 84 24 98 00 00 	mov    %rax,0x98(%r12)
    23d8:	00 

    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    23d9:	44 89 f0             	mov    %r14d,%eax
    23dc:	48 89 c1             	mov    %rax,%rcx
    23df:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    23e4:	48 05 81 00 00 00    	add    $0x81,%rax
    23ea:	48 c1 e0 07          	shl    $0x7,%rax
    23ee:	48 01 d0             	add    %rdx,%rax
    23f1:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    23f6:	48 89 c8             	mov    %rcx,%rax
    23f9:	48 c1 e0 07          	shl    $0x7,%rax
    23fd:	48 01 d0             	add    %rdx,%rax
    tem_pos = cur_pos;
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    2400:	c6 80 80 40 00 00 06 	movb   $0x6,0x4080(%rax)
    2407:	48 89 c1             	mov    %rax,%rcx
    240a:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
    dafs_de->name_len = dentry->d_name.len;
    240f:	8b 43 24             	mov    0x24(%rbx),%eax
    2412:	88 81 81 40 00 00    	mov    %al,0x4081(%rcx)
    //dafs_de->file_type = NORMAL_DIRECTORY;       

    links_count = cpu_to_le16(dir->i_nlink);
    2418:	41 8b 54 24 48       	mov    0x48(%r12),%edx
	if (links_count == 0 && link_change == -1)
    241d:	66 85 d2             	test   %dx,%dx
    2420:	0f 85 02 04 00 00    	jne    2828 <dafs_add_dentry+0x708>
		links_count = 0;
    2426:	31 c0                	xor    %eax,%eax
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = dentry->d_name.len;
    //dafs_de->file_type = NORMAL_DIRECTORY;       

    links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
    2428:	41 83 f8 ff          	cmp    $0xffffffff,%r8d
    242c:	0f 85 f6 03 00 00    	jne    2828 <dafs_add_dentry+0x708>
		links_count = 0;
	else
		links_count += link_change;
	dafs_de->links_count = cpu_to_le16(links_count);
    2432:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
    2437:	66 89 81 86 40 00 00 	mov    %ax,0x4086(%rcx)
    dafs_de->mtime = cpu_to_le32(dir->i_mtime.tv_sec);
    243e:	49 8b 44 24 68       	mov    0x68(%r12),%rax
    2443:	89 81 88 40 00 00    	mov    %eax,0x4088(%rcx)
    dafs_de->ino = cpu_to_le64(ino);
    2449:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    244e:	48 c1 e0 07          	shl    $0x7,%rax
    2452:	48 03 44 24 68       	add    0x68(%rsp),%rax
    2457:	4c 89 88 98 40 00 00 	mov    %r9,0x4098(%rax)
    dafs_de->size = cpu_to_le64(dir->i_size);
    245e:	49 8b 54 24 50       	mov    0x50(%r12),%rdx
    2463:	48 89 90 a0 40 00 00 	mov    %rdx,0x40a0(%rax)

    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    246a:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
	__clear_bit(nr ^ BITOP_LE_SWIZZLE, addr);
}

static inline int test_and_set_bit_le(int nr, void *addr)
{
	return test_and_set_bit(nr ^ BITOP_LE_SWIZZLE, addr);
    246f:	41 8d 53 01          	lea    0x1(%r11),%edx
    2473:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    2476:	f0 48 0f ab 10       	lock bts %rdx,(%rax)
    247b:	72 00                	jb     247d <dafs_add_dentry+0x35d>
    /*judge name len && set dentry name*/
    if(dentry->d_name.len <= SMALL_NAME_LEN){
    247d:	83 7b 24 27          	cmpl   $0x27,0x24(%rbx)
    2481:	0f 87 4d 03 00 00    	ja     27d4 <dafs_add_dentry+0x6b4>
        nova_dbg("dentry not need extension");
    2487:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    248e:	e8 00 00 00 00       	callq  2493 <dafs_add_dentry+0x373>
        dafs_de->ext_flag = 0;
    2493:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
    2498:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    /*judge name len && set dentry name*/
    if(dentry->d_name.len <= SMALL_NAME_LEN){
        nova_dbg("dentry not need extension");
        dafs_de->ext_flag = 0;
    249d:	66 c7 80 84 40 00 00 	movw   $0x0,0x4084(%rax)
    24a4:	00 00 
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
    24a6:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
    24ab:	48 c1 e1 07          	shl    $0x7,%rcx
    24af:	8b 53 24             	mov    0x24(%rbx),%edx
    24b2:	48 8b 73 28          	mov    0x28(%rbx),%rsi
    24b6:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
    24bb:	48 8d bc 08 b0 40 00 	lea    0x40b0(%rax,%rcx,1),%rdi
    24c2:	00 
    24c3:	e8 00 00 00 00       	callq  24c8 <dafs_add_dentry+0x3a8>
        //nova_dbg("dentry name is %s", dafs_de->name);
        dafs_de->name[dentry->d_name.len] = '\0'; 
    24c8:	8b 43 24             	mov    0x24(%rbx),%eax
    24cb:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
    24d0:	48 03 4c 24 68       	add    0x68(%rsp),%rcx
    24d5:	c6 84 08 b0 40 00 00 	movb   $0x0,0x40b0(%rax,%rcx,1)
    24dc:	00 
        nova_dbg("%s dentry need extend name entry",__func__);
        dafs_de->ext_flag = 1;
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, dentry->d_name.len, dentry->d_name.name, 0);
    }

    dafs_de->fname_len = cpu_to_le64(flen);
    24dd:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    24e2:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
    24e7:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
    24ec:	48 c1 e2 07          	shl    $0x7,%rdx
    24f0:	48 01 d0             	add    %rdx,%rax
    24f3:	48 89 c7             	mov    %rax,%rdi
    24f6:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    24fb:	48 89 8f 90 40 00 00 	mov    %rcx,0x4090(%rdi)
    /*set fulname
    * use temlen to find par de*/
    temlen = flen - dentry->d_name.len;
    2502:	8b 43 24             	mov    0x24(%rbx),%eax
    2505:	48 29 c1             	sub    %rax,%rcx
    2508:	48 89 c8             	mov    %rcx,%rax
    250b:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
    tm_len = temlen;
    if(temlen ==1){
    2510:	48 83 e8 01          	sub    $0x1,%rax
    2514:	0f 84 60 04 00 00    	je     297a <dafs_add_dentry+0x85a>
        }
        dafs_de->par_pos = cpu_to_le32(par_pos);
    } else {
        /*get par de pos*/
        //nova_dbg("dentry is not root subfile");
        tem = kzalloc((temlen+1)*sizeof(char), GFP_KERNEL);
    251a:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
    251f:	48 8d 7b 01          	lea    0x1(%rbx),%rdi
    2523:	e8 c8 db ff ff       	callq  f0 <kzalloc.constprop.9>
        temlen--;
    2528:	48 89 5c 24 30       	mov    %rbx,0x30(%rsp)
        memcpy(tem, phname, temlen);
    252d:	48 8b 74 24 60       	mov    0x60(%rsp),%rsi
        dafs_de->par_pos = cpu_to_le32(par_pos);
    } else {
        /*get par de pos*/
        //nova_dbg("dentry is not root subfile");
        tem = kzalloc((temlen+1)*sizeof(char), GFP_KERNEL);
        temlen--;
    2532:	48 8d 5b ff          	lea    -0x1(%rbx),%rbx
        memcpy(tem, phname, temlen);
    2536:	48 89 c7             	mov    %rax,%rdi
    2539:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    253e:	48 89 da             	mov    %rbx,%rdx
    2541:	e8 00 00 00 00       	callq  2546 <dafs_add_dentry+0x426>
        tem[temlen]='\0';
    2546:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    254b:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    2550:	85 db                	test   %ebx,%ebx
    2552:	c6 44 11 ff 00       	movb   $0x0,-0x1(%rcx,%rdx,1)
    2557:	0f 8e 16 04 00 00    	jle    2973 <dafs_add_dentry+0x853>
    255d:	8d 43 ff             	lea    -0x1(%rbx),%eax
    2560:	48 89 ca             	mov    %rcx,%rdx
    2563:	31 db                	xor    %ebx,%ebx
    2565:	48 8d 4c 01 01       	lea    0x1(%rcx,%rax,1),%rcx
    256a:	48 89 d0             	mov    %rdx,%rax
		hash = hash * seed + (*str++);
    256d:	48 89 da             	mov    %rbx,%rdx
    2570:	48 83 c0 01          	add    $0x1,%rax
    2574:	48 c1 e2 05          	shl    $0x5,%rdx
    2578:	48 29 da             	sub    %rbx,%rdx
    257b:	48 89 d3             	mov    %rdx,%rbx
    257e:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    2583:	48 01 d3             	add    %rdx,%rbx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    2586:	48 39 c1             	cmp    %rax,%rcx
    2589:	75 e2                	jne    256d <dafs_add_dentry+0x44d>
        //memcpy(tem+temlen, end, 1);
        par_hn = BKDRHash(tem, temlen);
        
        //nova_dbg("%s par name %s",__func__,tem);
        //nova_dbg("%s full name %s",__func__,phname);
        dafs_de->isr_sf = 0;
    258b:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
        if(file_type == 1){
    2590:	41 83 ff 01          	cmp    $0x1,%r15d
        //memcpy(tem+temlen, end, 1);
        par_hn = BKDRHash(tem, temlen);
        
        //nova_dbg("%s par name %s",__func__,tem);
        //nova_dbg("%s full name %s",__func__,phname);
        dafs_de->isr_sf = 0;
    2594:	c6 80 83 40 00 00 00 	movb   $0x0,0x4083(%rax)
        if(file_type == 1){
    259b:	0f 84 0e 03 00 00    	je     28af <dafs_add_dentry+0x78f>
                }
            } else {
                ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, flen, phname, 1);
            }
        } else {
            dafs_de->ful_name.f_name[0]= '\0';
    25a1:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    25a6:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
    25ab:	48 c1 e0 07          	shl    $0x7,%rax
    25af:	c6 84 01 d8 40 00 00 	movb   $0x0,0x40d8(%rcx,%rax,1)
    25b6:	00 
        }
        
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hn, 1, &par_pos);
    25b7:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    25bc:	4c 8d 44 24 74       	lea    0x74(%rsp),%r8
    25c1:	b9 01 00 00 00       	mov    $0x1,%ecx
    25c6:	4c 89 ef             	mov    %r13,%rdi
    25c9:	48 89 da             	mov    %rbx,%rdx
    25cc:	48 8b 70 18          	mov    0x18(%rax),%rsi
    25d0:	e8 00 00 00 00       	callq  25d5 <dafs_add_dentry+0x4b5>
        //nova_dbg("set par_pos %d", par_pos);
        dafs_de->par_pos = cpu_to_le32(par_pos);
    25d5:	8b 44 24 74          	mov    0x74(%rsp),%eax
    25d9:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
        kfree(tem); 
    25de:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
            dafs_de->ful_name.f_name[0]= '\0';
        }
        
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hn, 1, &par_pos);
        //nova_dbg("set par_pos %d", par_pos);
        dafs_de->par_pos = cpu_to_le32(par_pos);
    25e3:	89 81 8c 40 00 00    	mov    %eax,0x408c(%rcx)
        kfree(tem); 
    25e9:	e8 00 00 00 00       	callq  25ee <dafs_add_dentry+0x4ce>
    }

    /*debug*/
    par_de = &dafs_ze->dentry[par_pos];
    //nova_dbg("%s par name %s",__func__,tem);
    BUG_ON(le64_to_cpu(par_de->ino)!=dir->i_ino);
    25ee:	8b 44 24 74          	mov    0x74(%rsp),%eax
    25f2:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
    25f7:	49 8b 54 24 40       	mov    0x40(%r12),%rdx
    25fc:	48 c1 e0 07          	shl    $0x7,%rax
    2600:	48 39 94 01 98 40 00 	cmp    %rdx,0x4098(%rcx,%rax,1)
    2607:	00 
    2608:	0f 85 63 03 00 00    	jne    2971 <dafs_add_dentry+0x851>
    260e:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
    2613:	85 c0                	test   %eax,%eax
    2615:	0f 8e 4e 03 00 00    	jle    2969 <dafs_add_dentry+0x849>
    261b:	48 8b 54 24 60       	mov    0x60(%rsp),%rdx
    2620:	83 e8 01             	sub    $0x1,%eax
    2623:	45 31 e4             	xor    %r12d,%r12d
    2626:	48 8d 4c 02 01       	lea    0x1(%rdx,%rax,1),%rcx
    262b:	48 89 d0             	mov    %rdx,%rax
		hash = hash * seed + (*str++);
    262e:	4c 89 e2             	mov    %r12,%rdx
    2631:	48 83 c0 01          	add    $0x1,%rax
    2635:	48 c1 e2 05          	shl    $0x5,%rdx
    2639:	4c 29 e2             	sub    %r12,%rdx
    263c:	49 89 d4             	mov    %rdx,%r12
    263f:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    2644:	49 01 d4             	add    %rdx,%r12
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    2647:	48 39 c8             	cmp    %rcx,%rax
    264a:	75 e2                	jne    262e <dafs_add_dentry+0x50e>
 
    hashname = BKDRHash(phname, flen);
    ht_addr = dzt_ei->ht_head;
    ret = record_pos_htable(sb, ht_addr, hashname, tem_pos, 1);
    264c:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    2651:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    2657:	44 89 f1             	mov    %r14d,%ecx
    265a:	4c 89 e2             	mov    %r12,%rdx
    265d:	4c 89 ef             	mov    %r13,%rdi
    2660:	48 8b 70 18          	mov    0x18(%rax),%rsi
    2664:	e8 00 00 00 00       	callq  2669 <dafs_add_dentry+0x549>
    //nova_dbg("%s hash value is %llu, name is %s",__func__,hashname, phname);
    if(tm_len>1 || dzt_ei->dzt_eno==0){
    2669:	48 83 7c 24 30 01    	cmpq   $0x1,0x30(%rsp)
    //nova_dbg("%s par name %s",__func__,tem);
    BUG_ON(le64_to_cpu(par_de->ino)!=dir->i_ino);
 
    hashname = BKDRHash(phname, flen);
    ht_addr = dzt_ei->ht_head;
    ret = record_pos_htable(sb, ht_addr, hashname, tem_pos, 1);
    266f:	89 c3                	mov    %eax,%ebx
    //nova_dbg("%s hash value is %llu, name is %s",__func__,hashname, phname);
    if(tm_len>1 || dzt_ei->dzt_eno==0){
    2671:	0f 86 24 02 00 00    	jbe    289b <dafs_add_dentry+0x77b>
        if(par_pos==0){
    2677:	8b 44 24 74          	mov    0x74(%rsp),%eax
		hash = hash * seed + (*str++);
    267b:	be 2f 00 00 00       	mov    $0x2f,%esi
    2680:	85 c0                	test   %eax,%eax
    2682:	74 11                	je     2695 <dafs_add_dentry+0x575>
            par_hn = BKDRHash("/",1);
        } else {
            par_de = &dafs_ze->dentry[par_pos];
            par_hn = le64_to_cpu(par_de->hname);
    2684:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
    2689:	48 c1 e0 07          	shl    $0x7,%rax
    268d:	48 8b b4 01 a8 40 00 	mov    0x40a8(%rcx,%rax,1),%rsi
    2694:	00 
        }
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    2695:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    269a:	48 8d 78 38          	lea    0x38(%rax),%rdi
    269e:	e8 00 00 00 00       	callq  26a3 <dafs_add_dentry+0x583>
        if(!par_dir){
    26a3:	48 85 c0             	test   %rax,%rax
            par_hn = BKDRHash("/",1);
        } else {
            par_de = &dafs_ze->dentry[par_pos];
            par_hn = le64_to_cpu(par_de->hname);
        }
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    26a6:	49 89 c5             	mov    %rax,%r13
        if(!par_dir){
    26a9:	0f 84 75 02 00 00    	je     2924 <dafs_add_dentry+0x804>
            BUG();
            goto OUT;

        }
        par_dir->sub_num++;
    26af:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
    26b4:	bf 14 00 00 00       	mov    $0x14,%edi
        tem_sf->pos = tem_pos;
        list_add_tail(&tem_sf->list, &par_dir->sub_file);
    26b9:	49 83 c5 18          	add    $0x18,%r13
            BUG();
            goto OUT;

        }
        par_dir->sub_num++;
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
    26bd:	e8 2e da ff ff       	callq  f0 <kzalloc.constprop.9>
        tem_sf->pos = tem_pos;
    26c2:	44 89 70 10          	mov    %r14d,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    26c6:	49 8b 55 08          	mov    0x8(%r13),%rdx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    26ca:	49 89 45 08          	mov    %rax,0x8(%r13)
        list_add_tail(&tem_sf->list, &par_dir->sub_file);
    26ce:	4c 89 28             	mov    %r13,(%rax)
	new->next = next;
	new->prev = prev;
    26d1:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    26d5:	48 89 02             	mov    %rax,(%rdx)
    }

    dafs_de->hname = cpu_to_le64(hashname);
    26d8:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    26dd:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
    26e2:	48 c1 e0 07          	shl    $0x7,%rax
    /*add dir info if dentry is dir*/
    if(file_type==1){
    26e6:	41 83 ef 01          	sub    $0x1,%r15d
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = tem_pos;
        list_add_tail(&tem_sf->list, &par_dir->sub_file);
    }

    dafs_de->hname = cpu_to_le64(hashname);
    26ea:	4c 89 a4 01 a8 40 00 	mov    %r12,0x40a8(%rcx,%rax,1)
    26f1:	00 
    /*add dir info if dentry is dir*/
    if(file_type==1){
        dafs_de->file_type = NORMAL_DIRECTORY;
    26f2:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
        list_add_tail(&tem_sf->list, &par_dir->sub_file);
    }

    dafs_de->hname = cpu_to_le64(hashname);
    /*add dir info if dentry is dir*/
    if(file_type==1){
    26f7:	0f 84 0b 02 00 00    	je     2908 <dafs_add_dentry+0x7e8>
        dafs_de->file_type = NORMAL_DIRECTORY;
        add_dir_info(dzt_ei, hashname, tem_pos);
        //dafs_append_dir_init_entries(sb, tem_pos, dzt_ei, ino, dir->i_ino, phname);
    } else {
        dafs_de->file_type = NORMAL_FILE;
    26fd:	c6 80 82 40 00 00 00 	movb   $0x0,0x4082(%rax)
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    2704:	8b 54 24 28          	mov    0x28(%rsp),%edx
	if (support_clwb) {
    2708:	31 c0                	xor    %eax,%eax
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    270a:	83 e2 3f             	and    $0x3f,%edx
    270d:	83 ea 80             	sub    $0xffffff80,%edx
	if (support_clwb) {
    2710:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 2717 <dafs_add_dentry+0x5f7>
    2717:	0f 84 a1 00 00 00    	je     27be <dafs_add_dentry+0x69e>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    271d:	89 c1                	mov    %eax,%ecx
    271f:	48 03 4c 24 28       	add    0x28(%rsp),%rcx
    2724:	66 0f ae 31          	clwb   (%rcx)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    2728:	83 c0 40             	add    $0x40,%eax
    272b:	39 c2                	cmp    %eax,%edx
    272d:	77 ee                	ja     271d <dafs_add_dentry+0x5fd>
    }

    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);

    nova_dbg("%s end",__func__);
    272f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    2736:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    273d:	e8 00 00 00 00       	callq  2742 <dafs_add_dentry+0x622>
    //tes_empty_zone(sb, zone_p);
OUT:
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    2742:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 2749 <dafs_add_dentry+0x629>
    2749:	74 3c                	je     2787 <dafs_add_dentry+0x667>
    274b:	48 8d bc 24 90 00 00 	lea    0x90(%rsp),%rdi
    2752:	00 
    2753:	e8 00 00 00 00       	callq  2758 <dafs_add_dentry+0x638>
    2758:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
    275f:	00 
    2760:	48 2b 84 24 80 00 00 	sub    0x80(%rsp),%rax
    2767:	00 
    2768:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    276f:	48 2b 84 24 88 00 00 	sub    0x88(%rsp),%rax
    2776:	00 
    2777:	48 03 84 24 98 00 00 	add    0x98(%rsp),%rax
    277e:	00 
    277f:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 2787 <dafs_add_dentry+0x667>
    2786:	00 
    kfree(phname);
    2787:	48 8b 7c 24 60       	mov    0x60(%rsp),%rdi
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);

    nova_dbg("%s end",__func__);
    //tes_empty_zone(sb, zone_p);
OUT:
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    278c:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 2794 <dafs_add_dentry+0x674>
    2793:	00 
    kfree(phname);
    2794:	e8 00 00 00 00       	callq  2799 <dafs_add_dentry+0x679>
    kfree(ph);
    2799:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
    279e:	e8 00 00 00 00       	callq  27a3 <dafs_add_dentry+0x683>
    kfree(phn);
    27a3:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    27a8:	e8 00 00 00 00       	callq  27ad <dafs_add_dentry+0x68d>
    kfree(zone_p);
    27ad:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    27b2:	e8 00 00 00 00       	callq  27b7 <dafs_add_dentry+0x697>
    //nova_dbg("%s: finish, ino %llu, parent name %s",
    //     __func__, dafs_de->ino, dentry->d_parent->d_name.name);
    return ret;
    27b7:	89 d8                	mov    %ebx,%eax
    27b9:	e9 c0 f9 ff ff       	jmpq   217e <dafs_add_dentry+0x5e>
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    27be:	89 c1                	mov    %eax,%ecx
    27c0:	48 03 4c 24 28       	add    0x28(%rsp),%rcx
    27c5:	0f ae 39             	clflush (%rcx)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    27c8:	83 c0 40             	add    $0x40,%eax
    27cb:	39 c2                	cmp    %eax,%edx
    27cd:	77 ef                	ja     27be <dafs_add_dentry+0x69e>
    27cf:	e9 5b ff ff ff       	jmpq   272f <dafs_add_dentry+0x60f>
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
        //nova_dbg("dentry name is %s", dafs_de->name);
        dafs_de->name[dentry->d_name.len] = '\0'; 

    } else {
        nova_dbg("%s dentry need extend name entry",__func__);
    27d4:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    27db:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    27e2:	e8 00 00 00 00       	callq  27e7 <dafs_add_dentry+0x6c7>
        dafs_de->ext_flag = 1;
    27e7:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, dentry->d_name.len, dentry->d_name.name, 0);
    27ec:	48 8b 4c 24 78       	mov    0x78(%rsp),%rcx
    27f1:	45 89 f0             	mov    %r14d,%r8d
    27f4:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
    27f9:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
    27fe:	4c 89 ef             	mov    %r13,%rdi
        //nova_dbg("dentry name is %s", dafs_de->name);
        dafs_de->name[dentry->d_name.len] = '\0'; 

    } else {
        nova_dbg("%s dentry need extend name entry",__func__);
        dafs_de->ext_flag = 1;
    2801:	66 c7 80 84 40 00 00 	movw   $0x1,0x4084(%rax)
    2808:	01 00 
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, dentry->d_name.len, dentry->d_name.name, 0);
    280a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
    2811:	00 
    2812:	48 8b 43 28          	mov    0x28(%rbx),%rax
    2816:	48 89 04 24          	mov    %rax,(%rsp)
    281a:	44 8b 4b 24          	mov    0x24(%rbx),%r9d
    281e:	e8 00 00 00 00       	callq  2823 <dafs_add_dentry+0x703>
    2823:	e9 b5 fc ff ff       	jmpq   24dd <dafs_add_dentry+0x3bd>

    links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
		links_count = 0;
	else
		links_count += link_change;
    2828:	42 8d 04 02          	lea    (%rdx,%r8,1),%eax
    282c:	e9 01 fc ff ff       	jmpq   2432 <dafs_add_dentry+0x312>
        dafs_split_zone(sb, NULL, 0, NEGTIVE_SPLIT);
    }*/

    phlen = strlen(phn); 
    if(phlen==1){
        flen = strlen(ph);
    2831:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
    2836:	44 89 44 24 28       	mov    %r8d,0x28(%rsp)
    283b:	48 89 f1             	mov    %rsi,%rcx
    283e:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
    2843:	44 89 5c 24 38       	mov    %r11d,0x38(%rsp)
    2848:	f2 ae                	repnz scas %es:(%rdi),%al
        memcpy(phname, ph, flen);
    284a:	48 8b 7c 24 60       	mov    0x60(%rsp),%rdi
        dafs_split_zone(sb, NULL, 0, NEGTIVE_SPLIT);
    }*/

    phlen = strlen(phn); 
    if(phlen==1){
        flen = strlen(ph);
    284f:	48 f7 d1             	not    %rcx
    2852:	48 8d 04 31          	lea    (%rcx,%rsi,1),%rax
        memcpy(phname, ph, flen);
    2856:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
        dafs_split_zone(sb, NULL, 0, NEGTIVE_SPLIT);
    }*/

    phlen = strlen(phn); 
    if(phlen==1){
        flen = strlen(ph);
    285b:	48 89 4c 24 50       	mov    %rcx,0x50(%rsp)
        memcpy(phname, ph, flen);
    2860:	48 89 c2             	mov    %rax,%rdx
        dafs_split_zone(sb, NULL, 0, NEGTIVE_SPLIT);
    }*/

    phlen = strlen(phn); 
    if(phlen==1){
        flen = strlen(ph);
    2863:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
        memcpy(phname, ph, flen);
    2868:	e8 00 00 00 00       	callq  286d <dafs_add_dentry+0x74d>
        phname[flen]='\0';
    286d:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
    2872:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
    2877:	44 8b 5c 24 38       	mov    0x38(%rsp),%r11d
    287c:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
    2881:	44 8b 44 24 28       	mov    0x28(%rsp),%r8d
    2886:	c6 44 08 ff 00       	movb   $0x0,-0x1(%rax,%rcx,1)
    288b:	e9 c1 fa ff ff       	jmpq   2351 <dafs_add_dentry+0x231>
    2890:	41 be ff ff 00 00    	mov    $0xffff,%r14d
    2896:	e9 35 fa ff ff       	jmpq   22d0 <dafs_add_dentry+0x1b0>
 
    hashname = BKDRHash(phname, flen);
    ht_addr = dzt_ei->ht_head;
    ret = record_pos_htable(sb, ht_addr, hashname, tem_pos, 1);
    //nova_dbg("%s hash value is %llu, name is %s",__func__,hashname, phname);
    if(tm_len>1 || dzt_ei->dzt_eno==0){
    289b:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    28a0:	83 78 08 00          	cmpl   $0x0,0x8(%rax)
    28a4:	0f 84 cd fd ff ff    	je     2677 <dafs_add_dentry+0x557>
    28aa:	e9 29 fe ff ff       	jmpq   26d8 <dafs_add_dentry+0x5b8>
        
        //nova_dbg("%s par name %s",__func__,tem);
        //nova_dbg("%s full name %s",__func__,phname);
        dafs_de->isr_sf = 0;
        if(file_type == 1){
           if(dafs_de->ext_flag==0){
    28af:	66 83 b8 84 40 00 00 	cmpw   $0x0,0x4084(%rax)
    28b6:	00 
    28b7:	75 7b                	jne    2934 <dafs_add_dentry+0x814>
                if(flen<=SMALL_NAME_LEN){
    28b9:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
    28be:	48 83 f8 27          	cmp    $0x27,%rax
    28c2:	77 62                	ja     2926 <dafs_add_dentry+0x806>
                    //nova_dbg("dafs not need extend fulname");
                    memcpy(dafs_de->ful_name.f_name, phname, flen);
    28c4:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    28c9:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
    28ce:	48 8b 74 24 60       	mov    0x60(%rsp),%rsi
    28d3:	48 c1 e1 07          	shl    $0x7,%rcx
    28d7:	48 8d bc 0a d8 40 00 	lea    0x40d8(%rdx,%rcx,1),%rdi
    28de:	00 
    28df:	48 89 c2             	mov    %rax,%rdx
    28e2:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
    28e7:	e8 00 00 00 00       	callq  28ec <dafs_add_dentry+0x7cc>
                    dafs_de->ful_name.f_name[flen]='\0';
    28ec:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
    28f1:	48 03 4c 24 68       	add    0x68(%rsp),%rcx
    28f6:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
    28fb:	c6 84 08 d8 40 00 00 	movb   $0x0,0x40d8(%rax,%rcx,1)
    2902:	00 
    2903:	e9 af fc ff ff       	jmpq   25b7 <dafs_add_dentry+0x497>

    dafs_de->hname = cpu_to_le64(hashname);
    /*add dir info if dentry is dir*/
    if(file_type==1){
        dafs_de->file_type = NORMAL_DIRECTORY;
        add_dir_info(dzt_ei, hashname, tem_pos);
    2908:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    290d:	44 89 f2             	mov    %r14d,%edx
    2910:	4c 89 e6             	mov    %r12,%rsi
    }

    dafs_de->hname = cpu_to_le64(hashname);
    /*add dir info if dentry is dir*/
    if(file_type==1){
        dafs_de->file_type = NORMAL_DIRECTORY;
    2913:	c6 80 82 40 00 00 01 	movb   $0x1,0x4082(%rax)
        add_dir_info(dzt_ei, hashname, tem_pos);
    291a:	e8 00 00 00 00       	callq  291f <dafs_add_dentry+0x7ff>
    291f:	e9 e0 fd ff ff       	jmpq   2704 <dafs_add_dentry+0x5e4>
            par_de = &dafs_ze->dentry[par_pos];
            par_hn = le64_to_cpu(par_de->hname);
        }
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
        if(!par_dir){
            BUG();
    2924:	0f 0b                	ud2    
                    //nova_dbg("dafs not need extend fulname");
                    memcpy(dafs_de->ful_name.f_name, phname, flen);
                    dafs_de->ful_name.f_name[flen]='\0';
                } else {
                    //nova_dbg("%s extend ful name %s ino %llu", __func__, phname, ino);
                    dafs_de->ext_flag = 2;
    2926:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
    292b:	66 c7 80 84 40 00 00 	movw   $0x2,0x4084(%rax)
    2932:	02 00 
                    ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, flen, phname, 1);
                }
            } else {
                ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, flen, phname, 1);
    2934:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
    2939:	44 8b 4c 24 58       	mov    0x58(%rsp),%r9d
    293e:	45 89 f0             	mov    %r14d,%r8d
    2941:	48 8b 4c 24 78       	mov    0x78(%rsp),%rcx
    2946:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
    294b:	4c 89 ef             	mov    %r13,%rdi
    294e:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
    2953:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    295a:	00 
    295b:	48 89 04 24          	mov    %rax,(%rsp)
    295f:	e8 00 00 00 00       	callq  2964 <dafs_add_dentry+0x844>
    2964:	e9 4e fc ff ff       	jmpq   25b7 <dafs_add_dentry+0x497>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    2969:	45 31 e4             	xor    %r12d,%r12d
    296c:	e9 db fc ff ff       	jmpq   264c <dafs_add_dentry+0x52c>
    }

    /*debug*/
    par_de = &dafs_ze->dentry[par_pos];
    //nova_dbg("%s par name %s",__func__,tem);
    BUG_ON(le64_to_cpu(par_de->ino)!=dir->i_ino);
    2971:	0f 0b                	ud2    
    2973:	31 db                	xor    %ebx,%ebx
    2975:	e9 11 fc ff ff       	jmpq   258b <dafs_add_dentry+0x46b>
    /*set fulname
    * use temlen to find par de*/
    temlen = flen - dentry->d_name.len;
    tm_len = temlen;
    if(temlen ==1){
        dafs_de->isr_sf = 1;
    297a:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
        nova_dbg("dentry is root subfile");
    297f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2986:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
    /*set fulname
    * use temlen to find par de*/
    temlen = flen - dentry->d_name.len;
    tm_len = temlen;
    if(temlen ==1){
        dafs_de->isr_sf = 1;
    298b:	c6 83 83 40 00 00 01 	movb   $0x1,0x4083(%rbx)
        nova_dbg("dentry is root subfile");
    2992:	e8 00 00 00 00       	callq  2997 <dafs_add_dentry+0x877>
        par_pos =0;
        if(dafs_de->ext_flag==0){
    2997:	66 83 bb 84 40 00 00 	cmpw   $0x0,0x4084(%rbx)
    299e:	00 
    temlen = flen - dentry->d_name.len;
    tm_len = temlen;
    if(temlen ==1){
        dafs_de->isr_sf = 1;
        nova_dbg("dentry is root subfile");
        par_pos =0;
    299f:	c7 44 24 74 00 00 00 	movl   $0x0,0x74(%rsp)
    29a6:	00 
        if(dafs_de->ext_flag==0){
    29a7:	75 4b                	jne    29f4 <dafs_add_dentry+0x8d4>
            //re_len = SMALL_NAME_LEN - dentry->d_name.len;
            if(flen<SMALL_NAME_LEN){
    29a9:	48 8b 5c 24 58       	mov    0x58(%rsp),%rbx
    29ae:	48 83 fb 26          	cmp    $0x26,%rbx
    29b2:	77 72                	ja     2a26 <dafs_add_dentry+0x906>
                memcpy(dafs_de->ful_name.f_name, phname, flen);
    29b4:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
    29b9:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
    29be:	48 8b 74 24 60       	mov    0x60(%rsp),%rsi
    29c3:	48 8d bc 11 d8 40 00 	lea    0x40d8(%rcx,%rdx,1),%rdi
    29ca:	00 
    29cb:	48 89 da             	mov    %rbx,%rdx
    29ce:	e8 00 00 00 00       	callq  29d3 <dafs_add_dentry+0x8b3>
                dafs_de->ful_name.f_name[flen]= '\0';
    29d3:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    29d8:	c6 84 0b d8 40 00 00 	movb   $0x0,0x40d8(%rbx,%rcx,1)
    29df:	00 
                ext_de_name(sb ,dzt_ei, dafs_ze, zone_p, tem_pos, flen, phname, 1);
            }
        } else{
            ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos,flen, phname, 1);
        }
        dafs_de->par_pos = cpu_to_le32(par_pos);
    29e0:	8b 44 24 74          	mov    0x74(%rsp),%eax
    29e4:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
    29e9:	89 81 8c 40 00 00    	mov    %eax,0x408c(%rcx)
    29ef:	e9 fa fb ff ff       	jmpq   25ee <dafs_add_dentry+0x4ce>
                BUG();
                dafs_de->ext_flag = 2;
                ext_de_name(sb ,dzt_ei, dafs_ze, zone_p, tem_pos, flen, phname, 1);
            }
        } else{
            ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos,flen, phname, 1);
    29f4:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
    29f9:	44 8b 4c 24 58       	mov    0x58(%rsp),%r9d
    29fe:	45 89 f0             	mov    %r14d,%r8d
    2a01:	48 8b 4c 24 78       	mov    0x78(%rsp),%rcx
    2a06:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
    2a0b:	4c 89 ef             	mov    %r13,%rdi
    2a0e:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
    2a13:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    2a1a:	00 
    2a1b:	48 89 04 24          	mov    %rax,(%rsp)
    2a1f:	e8 00 00 00 00       	callq  2a24 <dafs_add_dentry+0x904>
    2a24:	eb ba                	jmp    29e0 <dafs_add_dentry+0x8c0>
            if(flen<SMALL_NAME_LEN){
                memcpy(dafs_de->ful_name.f_name, phname, flen);
                dafs_de->ful_name.f_name[flen]= '\0';
            } else {
                //nova_dbg("%s ful name %s", __func__, phname);
                BUG();
    2a26:	0f 0b                	ud2    
    2a28:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    2a2f:	00 

0000000000002a30 <dafs_find_direntry>:
 * phname full name
 * update flag for whether update
 * ISREAD for readdir flag in get path*/
struct dafs_dentry *dafs_find_direntry(struct super_block *sb, const struct dentry *dentry, int update_flag,
        u32 ISREAD)
{
    2a30:	e8 00 00 00 00       	callq  2a35 <dafs_find_direntry+0x5>
    2a35:	55                   	push   %rbp
    2a36:	49 89 f0             	mov    %rsi,%r8
    char *phname, *ph, *phn, *dot=".", *pdot = "..";
    char *end = "";
    int ret;

    //nova_dbg("%s:dafs start to find direntry",__func__);
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
    2a39:	b9 02 00 00 00       	mov    $0x2,%ecx
 * phname full name
 * update flag for whether update
 * ISREAD for readdir flag in get path*/
struct dafs_dentry *dafs_find_direntry(struct super_block *sb, const struct dentry *dentry, int update_flag,
        u32 ISREAD)
{
    2a3e:	48 89 e5             	mov    %rsp,%rbp
    2a41:	41 57                	push   %r15
    2a43:	41 56                	push   %r14
    2a45:	41 55                	push   %r13
    2a47:	41 54                	push   %r12
    2a49:	49 89 ff             	mov    %rdi,%r15
    2a4c:	53                   	push   %rbx
    char *phname, *ph, *phn, *dot=".", *pdot = "..";
    char *end = "";
    int ret;

    //nova_dbg("%s:dafs start to find direntry",__func__);
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
    2a4d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 * phname full name
 * update flag for whether update
 * ISREAD for readdir flag in get path*/
struct dafs_dentry *dafs_find_direntry(struct super_block *sb, const struct dentry *dentry, int update_flag,
        u32 ISREAD)
{
    2a54:	48 83 ec 30          	sub    $0x30,%rsp
    2a58:	89 55 ac             	mov    %edx,-0x54(%rbp)
    2a5b:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    2a62:	00 00 
    2a64:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    2a68:	31 c0                	xor    %eax,%eax
    char *phname, *ph, *phn, *dot=".", *pdot = "..";
    char *end = "";
    int ret;

    //nova_dbg("%s:dafs start to find direntry",__func__);
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
    2a6a:	48 8b 46 28          	mov    0x28(%rsi),%rax
    2a6e:	48 89 c6             	mov    %rax,%rsi
    2a71:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    2a73:	0f 84 c1 02 00 00    	je     2d3a <dafs_find_direntry+0x30a>
    2a79:	b9 03 00 00 00       	mov    $0x3,%ecx
    2a7e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2a85:	48 89 c6             	mov    %rax,%rsi
    2a88:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    2a8a:	0f 84 aa 02 00 00    	je     2d3a <dafs_find_direntry+0x30a>
        //nova_dbg("%s init dentry . and ..",__func__);
        return direntry;
    }
    ph = get_dentry_path(dentry,ISREAD);
    2a90:	4c 89 c7             	mov    %r8,%rdi
    2a93:	e8 68 d6 ff ff       	callq  100 <get_dentry_path.isra.4>
    //nova_dbg("%s ph is %s",__func__, ph);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    2a98:	48 89 c7             	mov    %rax,%rdi
    //nova_dbg("%s:dafs start to find direntry",__func__);
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
        //nova_dbg("%s init dentry . and ..",__func__);
        return direntry;
    }
    ph = get_dentry_path(dentry,ISREAD);
    2a9b:	49 89 c5             	mov    %rax,%r13
    //nova_dbg("%s ph is %s",__func__, ph);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    2a9e:	e8 00 00 00 00       	callq  2aa3 <dafs_find_direntry+0x73>
    2aa3:	48 89 c7             	mov    %rax,%rdi
    2aa6:	e8 45 d6 ff ff       	callq  f0 <kzalloc.constprop.9>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    2aab:	4c 89 ef             	mov    %r13,%rdi
        //nova_dbg("%s init dentry . and ..",__func__);
        return direntry;
    }
    ph = get_dentry_path(dentry,ISREAD);
    //nova_dbg("%s ph is %s",__func__, ph);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    2aae:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    2ab2:	e8 00 00 00 00       	callq  2ab7 <dafs_find_direntry+0x87>
    2ab7:	48 89 c7             	mov    %rax,%rdi
    2aba:	e8 31 d6 ff ff       	callq  f0 <kzalloc.constprop.9>
    2abf:	49 89 c4             	mov    %rax,%r12
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    2ac2:	49 8b 87 b0 03 00 00 	mov    0x3b0(%r15),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    2ac9:	4c 89 ef             	mov    %r13,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    2acc:	4c 8b b0 d8 01 00 00 	mov    0x1d8(%rax),%r14
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    2ad3:	e8 00 00 00 00       	callq  2ad8 <dafs_find_direntry+0xa8>
    2ad8:	4c 89 ee             	mov    %r13,%rsi
    2adb:	48 89 c2             	mov    %rax,%rdx
    2ade:	4c 89 e7             	mov    %r12,%rdi
    2ae1:	e8 00 00 00 00       	callq  2ae6 <dafs_find_direntry+0xb6>
    tlen = strlen(phstr);
    2ae6:	4c 89 ef             	mov    %r13,%rdi
    2ae9:	e8 00 00 00 00       	callq  2aee <dafs_find_direntry+0xbe>
    2aee:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
    2af1:	be 2f 00 00 00       	mov    $0x2f,%esi
    2af6:	4c 89 e7             	mov    %r12,%rdi
    2af9:	e8 00 00 00 00       	callq  2afe <dafs_find_direntry+0xce>
        phlen = tlen -strlen(tem);
    2afe:	48 89 c7             	mov    %rax,%rdi
    2b01:	e8 00 00 00 00       	callq  2b06 <dafs_find_direntry+0xd6>
        tlen = phlen;
        //bug
        if(phlen==0){
    2b06:	48 29 c3             	sub    %rax,%rbx
    2b09:	0f 84 05 02 00 00    	je     2d14 <dafs_find_direntry+0x2e4>
            break;
        }
        memcpy(ph,phstr,tlen);
    2b0f:	48 89 da             	mov    %rbx,%rdx
    2b12:	4c 89 ee             	mov    %r13,%rsi
    2b15:	4c 89 e7             	mov    %r12,%rdi
    2b18:	e8 00 00 00 00       	callq  2b1d <dafs_find_direntry+0xed>
	int i;

	for (i = 0; i < length; i++) {
    2b1d:	85 db                	test   %ebx,%ebx
        ph[tlen]='\0';
    2b1f:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
    2b24:	0f 8e 59 01 00 00    	jle    2c83 <dafs_find_direntry+0x253>
    2b2a:	8d 43 ff             	lea    -0x1(%rbx),%eax
    2b2d:	4c 89 e2             	mov    %r12,%rdx
    2b30:	31 f6                	xor    %esi,%esi
    2b32:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
    2b37:	48 89 f0             	mov    %rsi,%rax
    2b3a:	48 83 c2 01          	add    $0x1,%rdx
    2b3e:	48 c1 e0 05          	shl    $0x5,%rax
    2b42:	48 29 f0             	sub    %rsi,%rax
    2b45:	48 89 c6             	mov    %rax,%rsi
    2b48:	48 0f be 42 ff       	movsbq -0x1(%rdx),%rax
    2b4d:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    2b50:	48 39 ca             	cmp    %rcx,%rdx
    2b53:	75 e2                	jne    2b37 <dafs_find_direntry+0x107>
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    2b55:	4c 89 f7             	mov    %r14,%rdi
    2b58:	e8 00 00 00 00       	callq  2b5d <dafs_find_direntry+0x12d>
        if(dzt_ei){
    2b5d:	48 85 c0             	test   %rax,%rax
    2b60:	74 8f                	je     2af1 <dafs_find_direntry+0xc1>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    2b62:	49 8b 97 b0 03 00 00 	mov    0x3b0(%r15),%rdx
    memcpy(ph, "/", 1);
    ph[1]='\0';
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    if(!dzt_ei){
    2b69:	48 89 c3             	mov    %rax,%rbx
    //nova_dbg("%s ph is %s",__func__, ph);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    dzt_ei = find_dzt(sb, ph, phn);
    //nova_dbg("%s phn is %s",__func__, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    2b6c:	48 8b 40 10          	mov    0x10(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    2b70:	48 89 c7             	mov    %rax,%rdi
    2b73:	48 03 7a 18          	add    0x18(%rdx),%rdi
    2b77:	48 85 c0             	test   %rax,%rax
    2b7a:	b8 00 00 00 00       	mov    $0x0,%eax
    2b7f:	48 0f 45 c7          	cmovne %rdi,%rax
    //nova_dbg("the ze addr is %llu", dzt_ei->dz_addr);
    
    phlen = strlen(phn);
    2b83:	4c 89 e7             	mov    %r12,%rdi
    2b86:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    2b8a:	e8 00 00 00 00       	callq  2b8f <dafs_find_direntry+0x15f>
    //nova_dbg("full path  length is %llu", phlen);
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
    2b8f:	48 83 f8 01          	cmp    $0x1,%rax
    dzt_ei = find_dzt(sb, ph, phn);
    //nova_dbg("%s phn is %s",__func__, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    //nova_dbg("the ze addr is %llu", dzt_ei->dz_addr);
    
    phlen = strlen(phn);
    2b93:	49 89 c6             	mov    %rax,%r14
    //nova_dbg("full path  length is %llu", phlen);
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
    2b96:	0f 84 a6 01 00 00    	je     2d42 <dafs_find_direntry+0x312>
        //memcpy(phname, ph, strlen(ph));
        strcat(phname, ph);
    } else {
        flen = strlen(ph)-phlen;
    2b9c:	4c 89 ef             	mov    %r13,%rdi
    2b9f:	e8 00 00 00 00       	callq  2ba4 <dafs_find_direntry+0x174>
        memcpy(phname, ph+phlen, flen);
    2ba4:	4b 8d 74 35 00       	lea    0x0(%r13,%r14,1),%rsi
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
        //memcpy(phname, ph, strlen(ph));
        strcat(phname, ph);
    } else {
        flen = strlen(ph)-phlen;
    2ba9:	4c 29 f0             	sub    %r14,%rax
        memcpy(phname, ph+phlen, flen);
    2bac:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
    2bb0:	48 89 c2             	mov    %rax,%rdx
    2bb3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    2bb7:	4c 89 f7             	mov    %r14,%rdi
    2bba:	e8 00 00 00 00       	callq  2bbf <dafs_find_direntry+0x18f>
        phname[flen]='\0';
    2bbf:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
    2bc3:	41 c6 04 0e 00       	movb   $0x0,(%r14,%rcx,1)
        //memcpy(phname+flen, end, 1);
    }
    
    ph_hash = BKDRHash(phname, strlen(phname));
    2bc8:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
    2bcc:	4c 89 f7             	mov    %r14,%rdi
    2bcf:	e8 00 00 00 00       	callq  2bd4 <dafs_find_direntry+0x1a4>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    2bd4:	85 c0                	test   %eax,%eax
    2bd6:	0f 8e 77 01 00 00    	jle    2d53 <dafs_find_direntry+0x323>
    2bdc:	83 e8 01             	sub    $0x1,%eax
    2bdf:	45 31 c9             	xor    %r9d,%r9d
    2be2:	49 8d 4c 06 01       	lea    0x1(%r14,%rax,1),%rcx
    2be7:	4c 89 f0             	mov    %r14,%rax
		hash = hash * seed + (*str++);
    2bea:	4c 89 ca             	mov    %r9,%rdx
    2bed:	48 83 c0 01          	add    $0x1,%rax
    2bf1:	48 c1 e2 05          	shl    $0x5,%rdx
    2bf5:	4c 29 ca             	sub    %r9,%rdx
    2bf8:	49 89 d1             	mov    %rdx,%r9
    2bfb:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    2c00:	49 01 d1             	add    %rdx,%r9
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    2c03:	48 39 c8             	cmp    %rcx,%rax
    2c06:	75 e2                	jne    2bea <dafs_find_direntry+0x1ba>

    /*lookup in hash table*/
    ht_addr = dzt_ei->ht_head;
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    2c08:	48 8b 73 18          	mov    0x18(%rbx),%rsi
    2c0c:	4c 8d 45 cc          	lea    -0x34(%rbp),%r8
    2c10:	4c 89 ca             	mov    %r9,%rdx
    2c13:	b9 01 00 00 00       	mov    $0x1,%ecx
    2c18:	4c 89 ff             	mov    %r15,%rdi
    2c1b:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
    2c1f:	e8 00 00 00 00       	callq  2c24 <dafs_find_direntry+0x1f4>
    if(!ret){
    2c24:	85 c0                	test   %eax,%eax
    2c26:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
    2c2a:	75 6f                	jne    2c9b <dafs_find_direntry+0x26b>
        nova_dbg("%s not found dentry in hash table value is %llu",__func__, ph_hash);
    2c2c:	4c 89 ca             	mov    %r9,%rdx
    2c2f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    2c36:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 * update flag for whether update
 * ISREAD for readdir flag in get path*/
struct dafs_dentry *dafs_find_direntry(struct super_block *sb, const struct dentry *dentry, int update_flag,
        u32 ISREAD)
{
    struct dafs_dentry *direntry=NULL;
    2c3d:	45 31 f6             	xor    %r14d,%r14d

    /*lookup in hash table*/
    ht_addr = dzt_ei->ht_head;
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    if(!ret){
        nova_dbg("%s not found dentry in hash table value is %llu",__func__, ph_hash);
    2c40:	e8 00 00 00 00       	callq  2c45 <dafs_find_direntry+0x215>
            ph_hash = le64_to_cpu(&dafs_ze->dentry[par_pos].hname);
            update_read_hot(dzt_ei, ph_hash);
        }
    }
OUT:
    kfree(phname);
    2c45:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    2c49:	e8 00 00 00 00       	callq  2c4e <dafs_find_direntry+0x21e>
    kfree(ph);
    2c4e:	4c 89 ef             	mov    %r13,%rdi
    2c51:	e8 00 00 00 00       	callq  2c56 <dafs_find_direntry+0x226>
    kfree(phn);
    2c56:	4c 89 e7             	mov    %r12,%rdi
    2c59:	e8 00 00 00 00       	callq  2c5e <dafs_find_direntry+0x22e>
    //nova_dbg("%s:dafs finish find direntry",__func__);
    return direntry;
}
    2c5e:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    2c62:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    2c69:	00 00 
    2c6b:	4c 89 f0             	mov    %r14,%rax
    2c6e:	0f 85 f7 00 00 00    	jne    2d6b <dafs_find_direntry+0x33b>
    2c74:	48 83 c4 30          	add    $0x30,%rsp
    2c78:	5b                   	pop    %rbx
    2c79:	41 5c                	pop    %r12
    2c7b:	41 5d                	pop    %r13
    2c7d:	41 5e                	pop    %r14
    2c7f:	41 5f                	pop    %r15
    2c81:	5d                   	pop    %rbp
    2c82:	c3                   	retq   
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    2c83:	31 f6                	xor    %esi,%esi
        memcpy(ph,phstr,tlen);
        ph[tlen]='\0';
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    2c85:	4c 89 f7             	mov    %r14,%rdi
    2c88:	e8 00 00 00 00       	callq  2c8d <dafs_find_direntry+0x25d>
        if(dzt_ei){
    2c8d:	48 85 c0             	test   %rax,%rax
    2c90:	0f 84 5b fe ff ff    	je     2af1 <dafs_find_direntry+0xc1>
    2c96:	e9 c7 fe ff ff       	jmpq   2b62 <dafs_find_direntry+0x132>
    if(!ret){
        nova_dbg("%s not found dentry in hash table value is %llu",__func__, ph_hash);
        goto OUT;
        //goto OUT;
    }
    direntry = &dafs_ze->dentry[de_pos];
    2c9b:	44 8b 7d cc          	mov    -0x34(%rbp),%r15d
    nova_dbg("dir entry pos is %d", de_pos);
    2c9f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2ca6:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
    if(!ret){
        nova_dbg("%s not found dentry in hash table value is %llu",__func__, ph_hash);
        goto OUT;
        //goto OUT;
    }
    direntry = &dafs_ze->dentry[de_pos];
    2caa:	4d 8d b7 81 00 00 00 	lea    0x81(%r15),%r14
    2cb1:	4c 89 fe             	mov    %r15,%rsi
    2cb4:	49 c1 e6 07          	shl    $0x7,%r14
    2cb8:	4c 03 75 b0          	add    -0x50(%rbp),%r14
    nova_dbg("dir entry pos is %d", de_pos);
    2cbc:	e8 00 00 00 00       	callq  2cc1 <dafs_find_direntry+0x291>
    
    if(update_flag){
    2cc1:	8b 45 ac             	mov    -0x54(%rbp),%eax
    2cc4:	85 c0                	test   %eax,%eax
    2cc6:	0f 84 79 ff ff ff    	je     2c45 <dafs_find_direntry+0x215>
    2ccc:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    2cd0:	49 c1 e7 07          	shl    $0x7,%r15
        if(direntry->file_type == NORMAL_DIRECTORY)
    2cd4:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
    2cd8:	4c 01 f8             	add    %r15,%rax
    2cdb:	80 b8 82 40 00 00 01 	cmpb   $0x1,0x4082(%rax)
    2ce2:	74 77                	je     2d5b <dafs_find_direntry+0x32b>
            update_read_hot(dzt_ei, ph_hash);
        else if(direntry->isr_sf!=1){
    2ce4:	80 b8 83 40 00 00 01 	cmpb   $0x1,0x4083(%rax)
    2ceb:	0f 84 54 ff ff ff    	je     2c45 <dafs_find_direntry+0x215>
            par_pos = le64_to_cpu(direntry->par_pos);
            ph_hash = le64_to_cpu(&dafs_ze->dentry[par_pos].hname);
    2cf1:	8b 80 8c 40 00 00    	mov    0x408c(%rax),%eax
    2cf7:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    2cfb:	48 c1 e0 07          	shl    $0x7,%rax
    2cff:	48 8d b4 07 a8 40 00 	lea    0x40a8(%rdi,%rax,1),%rsi
    2d06:	00 
            update_read_hot(dzt_ei, ph_hash);
    2d07:	48 89 df             	mov    %rbx,%rdi
    2d0a:	e8 00 00 00 00       	callq  2d0f <dafs_find_direntry+0x2df>
    2d0f:	e9 31 ff ff ff       	jmpq   2c45 <dafs_find_direntry+0x215>
            return dzt_ei;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    2d14:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    ph[1]='\0';
    2d19:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    2d1f:	be 2f 00 00 00       	mov    $0x2f,%esi
    2d24:	4c 89 f7             	mov    %r14,%rdi
    2d27:	e8 00 00 00 00       	callq  2d2c <dafs_find_direntry+0x2fc>
    if(!dzt_ei){
    2d2c:	48 85 c0             	test   %rax,%rax
    2d2f:	0f 85 2d fe ff ff    	jne    2b62 <dafs_find_direntry+0x132>
    2d35:	e8 00 00 00 00       	callq  2d3a <dafs_find_direntry+0x30a>
    int ret;

    //nova_dbg("%s:dafs start to find direntry",__func__);
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
        //nova_dbg("%s init dentry . and ..",__func__);
        return direntry;
    2d3a:	45 31 f6             	xor    %r14d,%r14d
    2d3d:	e9 1c ff ff ff       	jmpq   2c5e <dafs_find_direntry+0x22e>
    phlen = strlen(phn);
    //nova_dbg("full path  length is %llu", phlen);
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
        //memcpy(phname, ph, strlen(ph));
        strcat(phname, ph);
    2d42:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    2d46:	4c 89 ee             	mov    %r13,%rsi
    2d49:	e8 00 00 00 00       	callq  2d4e <dafs_find_direntry+0x31e>
    2d4e:	e9 75 fe ff ff       	jmpq   2bc8 <dafs_find_direntry+0x198>
    2d53:	45 31 c9             	xor    %r9d,%r9d
    2d56:	e9 ad fe ff ff       	jmpq   2c08 <dafs_find_direntry+0x1d8>
    direntry = &dafs_ze->dentry[de_pos];
    nova_dbg("dir entry pos is %d", de_pos);
    
    if(update_flag){
        if(direntry->file_type == NORMAL_DIRECTORY)
            update_read_hot(dzt_ei, ph_hash);
    2d5b:	4c 89 ce             	mov    %r9,%rsi
    2d5e:	48 89 df             	mov    %rbx,%rdi
    2d61:	e8 00 00 00 00       	callq  2d66 <dafs_find_direntry+0x336>
    2d66:	e9 da fe ff ff       	jmpq   2c45 <dafs_find_direntry+0x215>
    kfree(phname);
    kfree(ph);
    kfree(phn);
    //nova_dbg("%s:dafs finish find direntry",__func__);
    return direntry;
}
    2d6b:	e8 00 00 00 00       	callq  2d70 <dafs_rebuild_dir_inode_tree>

0000000000002d70 <dafs_rebuild_dir_inode_tree>:

int dafs_rebuild_dir_inode_tree(struct super_block *sb, struct nova_inode *pi, u64 pi_addr,
	struct nova_inode_info_header *sih)
{
    2d70:	e8 00 00 00 00       	callq  2d75 <dafs_rebuild_dir_inode_tree+0x5>
    2d75:	55                   	push   %rbp
    2d76:	48 89 e5             	mov    %rsp,%rbp
    2d79:	53                   	push   %rbx
    2d7a:	48 89 fb             	mov    %rdi,%rbx
    2d7d:	48 83 ec 40          	sub    $0x40,%rsp
	u64 curr_p;
	//u64 next;
	u8 type;
	//int ret;

	NOVA_START_TIMING(rebuild_dir_t, rebuild_time);
    2d81:	44 8b 0d 00 00 00 00 	mov    0x0(%rip),%r9d        # 2d88 <dafs_rebuild_dir_inode_tree+0x18>
    return direntry;
}

int dafs_rebuild_dir_inode_tree(struct super_block *sb, struct nova_inode *pi, u64 pi_addr,
	struct nova_inode_info_header *sih)
{
    2d88:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    2d8f:	00 00 
    2d91:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    2d95:	31 c0                	xor    %eax,%eax
	u64 curr_p;
	//u64 next;
	u8 type;
	//int ret;

	NOVA_START_TIMING(rebuild_dir_t, rebuild_time);
    2d97:	45 85 c9             	test   %r9d,%r9d
    2d9a:	0f 85 b7 00 00 00    	jne    2e57 <dafs_rebuild_dir_inode_tree+0xe7>
	//nova_dbg("Rebuild dir %llu tree\n", ino);

	sih->pi_addr = pi_addr;
    2da0:	48 89 51 40          	mov    %rdx,0x40(%rcx)

	curr_p = pi->log_head;
    2da4:	48 8b 46 48          	mov    0x48(%rsi),%rax
	}*/

	//nova_dbg("Log head 0x%llx, tail 0x%llx\n",
	//			curr_p, pi->log_tail);

    if(!curr_p){
    2da8:	48 85 c0             	test   %rax,%rax
    2dab:	0f 85 85 00 00 00    	jne    2e36 <dafs_rebuild_dir_inode_tree+0xc6>
        sih->log_pages = 0;
    2db1:	48 c7 41 28 00 00 00 	movq   $0x0,0x28(%rcx)
    2db8:	00 
		//curr_p += de_len;
	//}
DIR_TYPE:
    //nova_dbg("%s: it is dir type",__func__);
    //dafs_rebuild_dir_time_and_size(sb, pi, entry);
	sih->i_size = le64_to_cpu(pi->i_size);
    2db9:	48 8b 46 08          	mov    0x8(%rsi),%rax
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    2dbd:	89 f7                	mov    %esi,%edi
	if (support_clwb) {
    2dbf:	44 8b 05 00 00 00 00 	mov    0x0(%rip),%r8d        # 2dc6 <dafs_rebuild_dir_inode_tree+0x56>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    2dc6:	83 e7 3f             	and    $0x3f,%edi
	if (support_clwb) {
    2dc9:	31 d2                	xor    %edx,%edx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    2dcb:	83 c7 5c             	add    $0x5c,%edi
    2dce:	48 89 41 30          	mov    %rax,0x30(%rcx)
	sih->i_mode = le64_to_cpu(pi->i_mode);
    2dd2:	0f b7 46 1c          	movzwl 0x1c(%rsi),%eax
	if (support_clwb) {
    2dd6:	45 85 c0             	test   %r8d,%r8d
    2dd9:	66 89 41 20          	mov    %ax,0x20(%rcx)
    2ddd:	74 46                	je     2e25 <dafs_rebuild_dir_inode_tree+0xb5>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    2ddf:	89 d0                	mov    %edx,%eax
    2de1:	48 01 f0             	add    %rsi,%rax
    2de4:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    2de8:	83 c2 40             	add    $0x40,%edx
    2deb:	39 d7                	cmp    %edx,%edi
    2ded:	77 f0                	ja     2ddf <dafs_rebuild_dir_inode_tree+0x6f>
        curr_p = next;
        curr_page = (struct nova_inode_log_page *)
        nova_get_block(sb, curr_p);
    }
    */
    pi->i_blocks = sih->log_pages;
    2def:	48 8b 41 28          	mov    0x28(%rcx),%rax
    2df3:	48 89 46 20          	mov    %rax,0x20(%rsi)

//	nova_print_dir_tree(sb, sih, ino);
    //dafs_rebuild_dir_time_and_size(sb, pi, entry);
	//nova_dbg("%s:dafs finish rebuild dir inode",__func__);
    NOVA_END_TIMING(rebuild_dir_t, rebuild_time);
    2df7:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 2dfd <dafs_rebuild_dir_inode_tree+0x8d>
    2dfd:	85 c0                	test   %eax,%eax
    2dff:	75 7c                	jne    2e7d <dafs_rebuild_dir_inode_tree+0x10d>
    2e01:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 2e09 <dafs_rebuild_dir_inode_tree+0x99>
    2e08:	00 
    return 0;
}
    2e09:	31 c0                	xor    %eax,%eax
    2e0b:	48 8b 5d f0          	mov    -0x10(%rbp),%rbx
    2e0f:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    2e16:	00 00 
    2e18:	0f 85 90 00 00 00    	jne    2eae <dafs_rebuild_dir_inode_tree+0x13e>
    2e1e:	48 83 c4 40          	add    $0x40,%rsp
    2e22:	5b                   	pop    %rbx
    2e23:	5d                   	pop    %rbp
    2e24:	c3                   	retq   
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    2e25:	89 d0                	mov    %edx,%eax
    2e27:	48 01 f0             	add    %rsi,%rax
    2e2a:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    2e2d:	83 c2 40             	add    $0x40,%edx
    2e30:	39 d7                	cmp    %edx,%edi
    2e32:	77 f1                	ja     2e25 <dafs_rebuild_dir_inode_tree+0xb5>
    2e34:	eb b9                	jmp    2def <dafs_rebuild_dir_inode_tree+0x7f>
    if(!curr_p){
        sih->log_pages = 0;
        goto DIR_TYPE;
    }

	sih->log_pages = 1;
    2e36:	48 c7 41 28 01 00 00 	movq   $0x1,0x28(%rcx)
    2e3d:	00 
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    2e3e:	48 8b 93 b0 03 00 00 	mov    0x3b0(%rbx),%rdx
    DAFS_DIR_ENTRY,
};

static inline u8 nova_get_entry_type(void *p)
{
	return *(u8 *)p;
    2e45:	48 8b 52 18          	mov    0x18(%rdx),%rdx
		}*/

	addr = (void *)nova_get_block(sb, curr_p);
    //find bug
    type = nova_get_entry_type(addr);
	switch (type) {
    2e49:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
    2e4d:	3c 03                	cmp    $0x3,%al
    2e4f:	74 5b                	je     2eac <dafs_rebuild_dir_inode_tree+0x13c>
    2e51:	3c 04                	cmp    $0x4,%al
    2e53:	75 55                	jne    2eaa <dafs_rebuild_dir_inode_tree+0x13a>
			sih->last_setattr = curr_p;
			curr_p += sizeof(struct nova_setattr_logentry);
				//continue;
                break;
		case LINK_CHANGE:
            BUG();
    2e55:	0f 0b                	ud2    
    2e57:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
    2e5b:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
    2e5f:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
    2e63:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
    2e67:	e8 00 00 00 00       	callq  2e6c <dafs_rebuild_dir_inode_tree+0xfc>
    2e6c:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
    2e70:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
    2e74:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    2e78:	e9 23 ff ff ff       	jmpq   2da0 <dafs_rebuild_dir_inode_tree+0x30>
    2e7d:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
    2e81:	e8 00 00 00 00       	callq  2e86 <dafs_rebuild_dir_inode_tree+0x116>
    pi->i_blocks = sih->log_pages;

//	nova_print_dir_tree(sb, sih, ino);
    //dafs_rebuild_dir_time_and_size(sb, pi, entry);
	//nova_dbg("%s:dafs finish rebuild dir inode",__func__);
    NOVA_END_TIMING(rebuild_dir_t, rebuild_time);
    2e86:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    2e8a:	48 2b 45 d0          	sub    -0x30(%rbp),%rax
    2e8e:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    2e95:	48 2b 45 d8          	sub    -0x28(%rbp),%rax
    2e99:	48 03 45 e8          	add    -0x18(%rbp),%rax
    2e9d:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 2ea5 <dafs_rebuild_dir_inode_tree+0x135>
    2ea4:	00 
    2ea5:	e9 57 ff ff ff       	jmpq   2e01 <dafs_rebuild_dir_inode_tree+0x91>
            break;
				//continue;
			//case DIR_LOG:
				//break;
		default:
            BUG();
    2eaa:	0f 0b                	ud2    
	addr = (void *)nova_get_block(sb, curr_p);
    //find bug
    type = nova_get_entry_type(addr);
	switch (type) {
		case SET_ATTR:
            BUG();
    2eac:	0f 0b                	ud2    
//	nova_print_dir_tree(sb, sih, ino);
    //dafs_rebuild_dir_time_and_size(sb, pi, entry);
	//nova_dbg("%s:dafs finish rebuild dir inode",__func__);
    NOVA_END_TIMING(rebuild_dir_t, rebuild_time);
    return 0;
}
    2eae:	e8 00 00 00 00       	callq  2eb3 <dafs_rebuild_dir_inode_tree+0x143>
    2eb3:	0f 1f 00             	nopl   (%rax)
    2eb6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    2ebd:	00 00 00 

0000000000002ec0 <dafs_rm_dir>:
 * 只是先将对应的状态表显示无效
 * 检查是不是根节点
 * 并不含有link的变化
 */
int dafs_rm_dir(struct dentry *dentry, int link_change)
{
    2ec0:	e8 00 00 00 00       	callq  2ec5 <dafs_rm_dir+0x5>
    2ec5:	55                   	push   %rbp
    2ec6:	48 89 e5             	mov    %rsp,%rbp
    2ec9:	41 57                	push   %r15
    2ecb:	41 56                	push   %r14
    2ecd:	41 55                	push   %r13
    2ecf:	41 54                	push   %r12
    2ed1:	49 89 fc             	mov    %rdi,%r12
    2ed4:	53                   	push   %rbx
    2ed5:	41 89 f7             	mov    %esi,%r15d
    2ed8:	48 83 ec 78          	sub    $0x78,%rsp
    u64 ph_hash, ei_hash, par_hash, sub_hash;
    char *phname, *ph, *phn;
    int ret;
	timing_t remove_dentry_time;

	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    2edc:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 2ee2 <dafs_rm_dir+0x22>
 * 只是先将对应的状态表显示无效
 * 检查是不是根节点
 * 并不含有link的变化
 */
int dafs_rm_dir(struct dentry *dentry, int link_change)
{
    2ee2:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    2ee9:	00 00 
    2eeb:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
    2ef0:	31 c0                	xor    %eax,%eax
    struct inode *dir = dentry->d_parent->d_inode;
    2ef2:	48 8b 47 18          	mov    0x18(%rdi),%rax
    u64 ph_hash, ei_hash, par_hash, sub_hash;
    char *phname, *ph, *phn;
    int ret;
	timing_t remove_dentry_time;

	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    2ef6:	85 d2                	test   %edx,%edx
 * 检查是不是根节点
 * 并不含有link的变化
 */
int dafs_rm_dir(struct dentry *dentry, int link_change)
{
    struct inode *dir = dentry->d_parent->d_inode;
    2ef8:	4c 8b 68 30          	mov    0x30(%rax),%r13
    struct super_block *sb = dir->i_sb;
    2efc:	49 8b 5d 28          	mov    0x28(%r13),%rbx
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dafs_dentry *dafs_de, *par_de,*sub_de;
    struct dzt_entry_info *dzt_ei, *sub_ei;
    struct dafs_zone_entry *dafs_ze;
    struct zone_ptr *z_p;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    2f00:	48 8b 83 b0 03 00 00 	mov    0x3b0(%rbx),%rax
    2f07:	4c 8b b0 d8 01 00 00 	mov    0x1d8(%rax),%r14
    u64 ph_hash, ei_hash, par_hash, sub_hash;
    char *phname, *ph, *phn;
    int ret;
	timing_t remove_dentry_time;

	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    2f0e:	75 2d                	jne    2f3d <dafs_rm_dir+0x7d>

	if (!dentry->d_name.len)
    2f10:	41 8b 44 24 24       	mov    0x24(%r12),%eax
    2f15:	85 c0                	test   %eax,%eax
    2f17:	75 35                	jne    2f4e <dafs_rm_dir+0x8e>
		return -EINVAL;
    2f19:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    kfree(z_p);
    //nova_dbg("%s end",__func__);
	return 0;
}
    2f1e:	48 8b 4c 24 70       	mov    0x70(%rsp),%rcx
    2f23:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
    2f2a:	00 00 
    2f2c:	75 1b                	jne    2f49 <dafs_rm_dir+0x89>
    2f2e:	48 83 c4 78          	add    $0x78,%rsp
    2f32:	5b                   	pop    %rbx
    2f33:	41 5c                	pop    %r12
    2f35:	41 5d                	pop    %r13
    2f37:	41 5e                	pop    %r14
    2f39:	41 5f                	pop    %r15
    2f3b:	5d                   	pop    %rbp
    2f3c:	c3                   	retq   
    2f3d:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
    2f42:	e8 00 00 00 00       	callq  2f47 <dafs_rm_dir+0x87>
    2f47:	eb c7                	jmp    2f10 <dafs_rm_dir+0x50>
    2f49:	e8 00 00 00 00       	callq  2f4e <dafs_rm_dir+0x8e>

	if (!dentry->d_name.len)
		return -EINVAL;


	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    2f4e:	e8 00 00 00 00       	callq  2f53 <dafs_rm_dir+0x93>
    2f53:	49 c7 85 80 00 00 00 	movq   $0x0,0x80(%r13)
    2f5a:	00 00 00 00 
    2f5e:	49 89 45 78          	mov    %rax,0x78(%r13)
 
    nova_dbg("%s start",__func__);
    2f62:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi

	if (!dentry->d_name.len)
		return -EINVAL;


	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    2f69:	49 8b 95 80 00 00 00 	mov    0x80(%r13),%rdx
    2f70:	49 8b 45 78          	mov    0x78(%r13),%rax
 
    nova_dbg("%s start",__func__);
    2f74:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi

	if (!dentry->d_name.len)
		return -EINVAL;


	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    2f7b:	49 89 55 70          	mov    %rdx,0x70(%r13)
    2f7f:	49 89 45 68          	mov    %rax,0x68(%r13)
 
    nova_dbg("%s start",__func__);
    2f83:	e8 00 00 00 00       	callq  2f88 <dafs_rm_dir+0xc8>
    ph = get_dentry_path(dentry,0);
    2f88:	4c 89 e7             	mov    %r12,%rdi
    2f8b:	e8 70 d1 ff ff       	callq  100 <get_dentry_path.isra.4>
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    2f90:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx


	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
 
    nova_dbg("%s start",__func__);
    ph = get_dentry_path(dentry,0);
    2f94:	48 89 c7             	mov    %rax,%rdi
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    2f97:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    2f9c:	31 c0                	xor    %eax,%eax
    2f9e:	f2 ae                	repnz scas %es:(%rdi),%al
    2fa0:	48 f7 d1             	not    %rcx
    2fa3:	48 8d 79 ff          	lea    -0x1(%rcx),%rdi
    2fa7:	e8 44 d1 ff ff       	callq  f0 <kzalloc.constprop.9>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    2fac:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi

	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
 
    nova_dbg("%s start",__func__);
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    2fb1:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    2fb6:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    2fba:	31 c0                	xor    %eax,%eax
    2fbc:	f2 ae                	repnz scas %es:(%rdi),%al
    2fbe:	48 f7 d1             	not    %rcx
    2fc1:	48 8d 79 ff          	lea    -0x1(%rcx),%rdi
    2fc5:	e8 26 d1 ff ff       	callq  f0 <kzalloc.constprop.9>
    //memcpy(phname, ph, strlen(ph));
    nova_dbg("%s start dentry %s",__func__,ph);
    2fca:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    2fcf:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    2fd6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
 
    nova_dbg("%s start",__func__);
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    2fdd:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    //memcpy(phname, ph, strlen(ph));
    nova_dbg("%s start dentry %s",__func__,ph);
    2fe2:	e8 00 00 00 00       	callq  2fe7 <dafs_rm_dir+0x127>
    ph = get_dentry_path(dentry,0);
    2fe7:	4c 89 e7             	mov    %r12,%rdi
    2fea:	e8 11 d1 ff ff       	callq  100 <get_dentry_path.isra.4>
    dzt_ei = find_dzt(sb, ph, phn);
    2fef:	4c 8b 64 24 10       	mov    0x10(%rsp),%r12
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph));
    nova_dbg("%s start dentry %s",__func__,ph);
    ph = get_dentry_path(dentry,0);
    2ff4:	48 89 c6             	mov    %rax,%rsi
    dzt_ei = find_dzt(sb, ph, phn);
    2ff7:	48 89 df             	mov    %rbx,%rdi
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph));
    nova_dbg("%s start dentry %s",__func__,ph);
    ph = get_dentry_path(dentry,0);
    2ffa:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    dzt_ei = find_dzt(sb, ph, phn);
    2fff:	4c 89 e2             	mov    %r12,%rdx
    3002:	e8 f9 cf ff ff       	callq  0 <find_dzt>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    3007:	48 8b 93 b0 03 00 00 	mov    0x3b0(%rbx),%rdx
    300e:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    3013:	4c 89 e7             	mov    %r12,%rdi
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph));
    nova_dbg("%s start dentry %s",__func__,ph);
    ph = get_dentry_path(dentry,0);
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    3016:	48 8b 40 10          	mov    0x10(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    301a:	48 89 c6             	mov    %rax,%rsi
    301d:	48 03 72 18          	add    0x18(%rdx),%rsi
    3021:	48 85 c0             	test   %rax,%rax
    3024:	b8 00 00 00 00       	mov    $0x0,%eax
    3029:	48 0f 45 c6          	cmovne %rsi,%rax
    phlen = strlen(phn);
    302d:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    3031:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    3036:	31 c0                	xor    %eax,%eax
    3038:	f2 ae                	repnz scas %es:(%rdi),%al
    303a:	48 89 ca             	mov    %rcx,%rdx
    303d:	48 f7 d2             	not    %rdx
    3040:	48 83 ea 01          	sub    $0x1,%rdx

    if(phlen==1){
    3044:	48 83 fa 01          	cmp    $0x1,%rdx
    3048:	0f 84 ed 03 00 00    	je     343b <dafs_rm_dir+0x57b>
        //flen = strlen(ph);
        //memcpy(phname, ph, flen);
        strcat(phname, ph);
    } else {
        flen = strlen(ph)-phlen;
    304e:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    3053:	31 c0                	xor    %eax,%eax
    3055:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    3059:	f2 ae                	repnz scas %es:(%rdi),%al
        memcpy(phname, ph+phlen, flen);
    305b:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    if(phlen==1){
        //flen = strlen(ph);
        //memcpy(phname, ph, flen);
        strcat(phname, ph);
    } else {
        flen = strlen(ph)-phlen;
    3060:	48 89 c8             	mov    %rcx,%rax
    3063:	48 f7 d0             	not    %rax
        memcpy(phname, ph+phlen, flen);
    3066:	48 8d 34 17          	lea    (%rdi,%rdx,1),%rsi
    if(phlen==1){
        //flen = strlen(ph);
        //memcpy(phname, ph, flen);
        strcat(phname, ph);
    } else {
        flen = strlen(ph)-phlen;
    306a:	48 83 e8 01          	sub    $0x1,%rax
        memcpy(phname, ph+phlen, flen);
    306e:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
    if(phlen==1){
        //flen = strlen(ph);
        //memcpy(phname, ph, flen);
        strcat(phname, ph);
    } else {
        flen = strlen(ph)-phlen;
    3073:	48 29 d0             	sub    %rdx,%rax
        memcpy(phname, ph+phlen, flen);
    3076:	48 89 c2             	mov    %rax,%rdx
    if(phlen==1){
        //flen = strlen(ph);
        //memcpy(phname, ph, flen);
        strcat(phname, ph);
    } else {
        flen = strlen(ph)-phlen;
    3079:	49 89 c4             	mov    %rax,%r12
    307c:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
        memcpy(phname, ph+phlen, flen);
    3081:	e8 00 00 00 00       	callq  3086 <dafs_rm_dir+0x1c6>
        phname[flen]='\0';
    3086:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
    308b:	42 c6 04 22 00       	movb   $0x0,(%rdx,%r12,1)
    }

    dzt_eno = dzt_ei->dzt_eno;
    nova_dbg("%s start hash name is %s ",__func__, phname);
    3090:	4c 8b 64 24 28       	mov    0x28(%rsp),%r12
    3095:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    309c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    30a3:	4c 89 e2             	mov    %r12,%rdx
    30a6:	e8 00 00 00 00       	callq  30ab <dafs_rm_dir+0x1eb>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    30ab:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    30b0:	85 c0                	test   %eax,%eax
    30b2:	0f 8e 97 03 00 00    	jle    344f <dafs_rm_dir+0x58f>
    30b8:	83 e8 01             	sub    $0x1,%eax
    30bb:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
    30c0:	4c 89 e0             	mov    %r12,%rax
    30c3:	45 31 e4             	xor    %r12d,%r12d
		hash = hash * seed + (*str++);
    30c6:	4c 89 e2             	mov    %r12,%rdx
    30c9:	48 83 c0 01          	add    $0x1,%rax
    30cd:	48 c1 e2 05          	shl    $0x5,%rdx
    30d1:	4c 29 e2             	sub    %r12,%rdx
    30d4:	49 89 d4             	mov    %rdx,%r12
    30d7:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    30dc:	49 01 d4             	add    %rdx,%r12
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    30df:	48 39 c1             	cmp    %rax,%rcx
    30e2:	75 e2                	jne    30c6 <dafs_rm_dir+0x206>
    ph_hash = BKDRHash(phname, flen);
    nova_dbg("%s end hash",__func__);
    30e4:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    30eb:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    30f2:	e8 00 00 00 00       	callq  30f7 <dafs_rm_dir+0x237>

    /*lookup in hash table*/
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    30f7:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    30fc:	4c 8d 44 24 44       	lea    0x44(%rsp),%r8
    3101:	b9 01 00 00 00       	mov    $0x1,%ecx
    3106:	4c 89 e2             	mov    %r12,%rdx
    3109:	48 89 df             	mov    %rbx,%rdi
    310c:	48 8b 70 18          	mov    0x18(%rax),%rsi
    3110:	e8 00 00 00 00       	callq  3115 <dafs_rm_dir+0x255>
    if(!ret)
    3115:	85 c0                	test   %eax,%eax
    3117:	0f 84 fc fd ff ff    	je     2f19 <dafs_rm_dir+0x59>
        return -EINVAL;

    dafs_de = &dafs_ze->dentry[de_pos];
    311d:	8b 44 24 44          	mov    0x44(%rsp),%eax
        ei_hash = le64_to_cpu(dafs_de->dzt_hn);
        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
        free_zone_area(sb, sub_ei);
    }*/

	links_count = cpu_to_le16(dir->i_nlink);
    3121:	41 8b 4d 48          	mov    0x48(%r13),%ecx
    /*lookup in hash table*/
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    if(!ret)
        return -EINVAL;

    dafs_de = &dafs_ze->dentry[de_pos];
    3125:	48 89 c2             	mov    %rax,%rdx
    3128:	48 89 04 24          	mov    %rax,(%rsp)
    312c:	48 05 81 00 00 00    	add    $0x81,%rax
    3132:	48 c1 e0 07          	shl    $0x7,%rax
    3136:	48 03 44 24 30       	add    0x30(%rsp),%rax
        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
        free_zone_area(sb, sub_ei);
    }*/

	links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
    313b:	66 85 c9             	test   %cx,%cx
    /*lookup in hash table*/
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    if(!ret)
        return -EINVAL;

    dafs_de = &dafs_ze->dentry[de_pos];
    313e:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
        free_zone_area(sb, sub_ei);
    }*/

	links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
    3143:	0f 85 af 02 00 00    	jne    33f8 <dafs_rm_dir+0x538>
		links_count = 0;
    3149:	31 c0                	xor    %eax,%eax
        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
        free_zone_area(sb, sub_ei);
    }*/

	links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
    314b:	41 83 ff ff          	cmp    $0xffffffff,%r15d
    314f:	0f 85 a3 02 00 00    	jne    33f8 <dafs_rm_dir+0x538>
    3155:	48 8b 0c 24          	mov    (%rsp),%rcx
    3159:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
    315e:	48 c1 e1 07          	shl    $0x7,%rcx
    3162:	4c 8d 3c 0e          	lea    (%rsi,%rcx,1),%r15
		links_count = 0;
	else
		links_count += link_change;
	dafs_de->links_count = cpu_to_le16(links_count);
    3166:	66 41 89 87 86 40 00 	mov    %ax,0x4086(%r15)
    316d:	00 

    bitpos = de_pos * 2;
   
    /*remove from par*/
    par_pos = le32_to_cpu(dafs_de->par_pos);
    if(dir->i_ino == NOVA_ROOT_INO || par_pos!=0){
    316e:	49 83 7d 40 01       	cmpq   $0x1,0x40(%r13)
		links_count = 0;
	else
		links_count += link_change;
	dafs_de->links_count = cpu_to_le16(links_count);

    bitpos = de_pos * 2;
    3173:	8d 04 12             	lea    (%rdx,%rdx,1),%eax
    3176:	89 44 24 0c          	mov    %eax,0xc(%rsp)
   
    /*remove from par*/
    par_pos = le32_to_cpu(dafs_de->par_pos);
    317a:	41 8b 87 8c 40 00 00 	mov    0x408c(%r15),%eax
    if(dir->i_ino == NOVA_ROOT_INO || par_pos!=0){
    3181:	0f 84 e0 01 00 00    	je     3367 <dafs_rm_dir+0x4a7>
    3187:	85 c0                	test   %eax,%eax
    3189:	0f 85 d8 01 00 00    	jne    3367 <dafs_rm_dir+0x4a7>
            }
        }
    } 

CONT:
    make_zone_ptr(&z_p, dafs_ze);
    318f:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
    3194:	48 8d 7c 24 48       	lea    0x48(%rsp),%rdi
    3199:	e8 00 00 00 00       	callq  319e <dafs_rm_dir+0x2de>
    test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    319e:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
}

static inline int test_and_clear_bit_le(int nr, void *addr)
{
	return test_and_clear_bit(nr ^ BITOP_LE_SWIZZLE, addr);
    31a3:	48 63 54 24 0c       	movslq 0xc(%rsp),%rdx
    31a8:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_clear_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "btr", *addr, "Ir", nr, "%0", "c");
    31ab:	f0 48 0f b3 10       	lock btr %rdx,(%rax)
    31b0:	72 00                	jb     31b2 <dafs_rm_dir+0x2f2>
	bitpos++;
    test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    31b2:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    31b7:	48 8b 10             	mov    (%rax),%rdx
    31ba:	8b 44 24 0c          	mov    0xc(%rsp),%eax
    31be:	83 c0 01             	add    $0x1,%eax
    31c1:	48 98                	cltq   
    31c3:	f0 48 0f b3 02       	lock btr %rax,(%rdx)
    31c8:	72 00                	jb     31ca <dafs_rm_dir+0x30a>
    make_invalid_htable(sb, dzt_ei->ht_head, ph_hash, 1);
    31ca:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    31cf:	b9 01 00 00 00       	mov    $0x1,%ecx
    31d4:	4c 89 e2             	mov    %r12,%rdx
    31d7:	48 89 df             	mov    %rbx,%rdi
    31da:	48 8b 70 18          	mov    0x18(%rax),%rsi
    31de:	e8 00 00 00 00       	callq  31e3 <dafs_rm_dir+0x323>
    delete_ext(z_p, dafs_de);
    31e3:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
    31e8:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    31ed:	e8 00 00 00 00       	callq  31f2 <dafs_rm_dir+0x332>

    if(dafs_de->file_type == ROOT_DIRECTORY) {
    31f2:	41 80 bf 82 40 00 00 	cmpb   $0x2,0x4082(%r15)
    31f9:	02 
    31fa:	0f 84 01 02 00 00    	je     3401 <dafs_rm_dir+0x541>
    }
    /*make invalid sub file only for empty dir
     * free dir_tree*/
    this = NULL;
    next = NULL;
    rm_dir = radix_tree_delete(&dzt_ei->dir_tree, ph_hash);
    3200:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    3205:	4c 89 e6             	mov    %r12,%rsi
    3208:	48 8d 78 38          	lea    0x38(%rax),%rdi
    320c:	e8 00 00 00 00       	callq  3211 <dafs_rm_dir+0x351>
    BUG_ON(rm_dir==NULL);
    3211:	48 85 c0             	test   %rax,%rax
    }
    /*make invalid sub file only for empty dir
     * free dir_tree*/
    this = NULL;
    next = NULL;
    rm_dir = radix_tree_delete(&dzt_ei->dir_tree, ph_hash);
    3214:	49 89 c4             	mov    %rax,%r12
    BUG_ON(rm_dir==NULL);
    3217:	0f 84 3c 02 00 00    	je     3459 <dafs_rm_dir+0x599>
    head = &rm_dir->sub_file;
    list_for_each_safe(this, next, head){
    321d:	4c 8b 68 18          	mov    0x18(%rax),%r13
     * free dir_tree*/
    this = NULL;
    next = NULL;
    rm_dir = radix_tree_delete(&dzt_ei->dir_tree, ph_hash);
    BUG_ON(rm_dir==NULL);
    head = &rm_dir->sub_file;
    3221:	4c 8d 78 18          	lea    0x18(%rax),%r15
    list_for_each_safe(this, next, head){
    3225:	4d 39 ef             	cmp    %r13,%r15
    3228:	4d 8b 75 00          	mov    0x0(%r13),%r14
    322c:	0f 84 b3 00 00 00    	je     32e5 <dafs_rm_dir+0x425>
    3232:	4c 89 f0             	mov    %r14,%rax
    3235:	4d 89 ee             	mov    %r13,%r14
    3238:	4d 89 e5             	mov    %r12,%r13
        rm_sf = list_entry(this, struct file_p, list);
        sub_pos = rm_sf->pos;
    323b:	41 8b 56 10          	mov    0x10(%r14),%edx
        bitpos = sub_pos*2;
        sub_de = &dafs_ze->dentry[sub_pos];
        sub_hash = le64_to_cpu(sub_de->hname);
    323f:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
    3244:	49 89 c4             	mov    %rax,%r12
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    3247:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
    BUG_ON(rm_dir==NULL);
    head = &rm_dir->sub_file;
    list_for_each_safe(this, next, head){
        rm_sf = list_entry(this, struct file_p, list);
        sub_pos = rm_sf->pos;
        bitpos = sub_pos*2;
    324c:	8d 04 12             	lea    (%rdx,%rdx,1),%eax
        sub_de = &dafs_ze->dentry[sub_pos];
        sub_hash = le64_to_cpu(sub_de->hname);
    324f:	48 c1 e2 07          	shl    $0x7,%rdx
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    3253:	48 8b 09             	mov    (%rcx),%rcx
    list_for_each_safe(this, next, head){
        rm_sf = list_entry(this, struct file_p, list);
        sub_pos = rm_sf->pos;
        bitpos = sub_pos*2;
        sub_de = &dafs_ze->dentry[sub_pos];
        sub_hash = le64_to_cpu(sub_de->hname);
    3256:	48 8b 94 16 a8 40 00 	mov    0x40a8(%rsi,%rdx,1),%rdx
    325d:	00 
    325e:	48 63 f0             	movslq %eax,%rsi
    3261:	f0 48 0f b3 31       	lock btr %rsi,(%rcx)
    3266:	72 00                	jb     3268 <dafs_rm_dir+0x3a8>
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    3268:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
    326d:	83 c0 01             	add    $0x1,%eax
    3270:	48 98                	cltq   
    3272:	48 8b 09             	mov    (%rcx),%rcx
    3275:	f0 48 0f b3 01       	lock btr %rax,(%rcx)
    327a:	72 00                	jb     327c <dafs_rm_dir+0x3bc>
        make_invalid_htable(sb, dzt_ei->ht_head, sub_hash, 1);
    327c:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    3281:	b9 01 00 00 00       	mov    $0x1,%ecx
    3286:	48 89 df             	mov    %rbx,%rdi
    3289:	48 8b 70 18          	mov    0x18(%rax),%rsi
    328d:	e8 00 00 00 00       	callq  3292 <dafs_rm_dir+0x3d2>
        delete_ext(z_p, dafs_de);
    3292:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
    3297:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    329c:	e8 00 00 00 00       	callq  32a1 <dafs_rm_dir+0x3e1>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    32a1:	49 8b 46 08          	mov    0x8(%r14),%rax
    32a5:	49 8b 16             	mov    (%r14),%rdx
        list_del(&rm_sf->list);
        kfree(rm_sf);
    32a8:	4c 89 f7             	mov    %r14,%rdi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    32ab:	48 89 42 08          	mov    %rax,0x8(%rdx)
	prev->next = next;
    32af:	48 89 10             	mov    %rdx,(%rax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    32b2:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
    32b9:	00 ad de 
    32bc:	49 89 06             	mov    %rax,(%r14)
	entry->prev = LIST_POISON2;
    32bf:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
    32c6:	00 ad de 
    32c9:	49 89 46 08          	mov    %rax,0x8(%r14)
    32cd:	4d 89 e6             	mov    %r12,%r14
    32d0:	e8 00 00 00 00       	callq  32d5 <dafs_rm_dir+0x415>
    this = NULL;
    next = NULL;
    rm_dir = radix_tree_delete(&dzt_ei->dir_tree, ph_hash);
    BUG_ON(rm_dir==NULL);
    head = &rm_dir->sub_file;
    list_for_each_safe(this, next, head){
    32d5:	4d 39 e7             	cmp    %r12,%r15
    32d8:	49 8b 04 24          	mov    (%r12),%rax
    32dc:	0f 85 59 ff ff ff    	jne    323b <dafs_rm_dir+0x37b>
    32e2:	4d 89 ec             	mov    %r13,%r12
        delete_ext(z_p, dafs_de);
        list_del(&rm_sf->list);
        kfree(rm_sf);
    }

    kfree(rm_dir);
    32e5:	4c 89 e7             	mov    %r12,%rdi
    32e8:	e8 00 00 00 00       	callq  32ed <dafs_rm_dir+0x42d>
    tes_empty_zone(sb, z_p);
    32ed:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
    32f2:	48 89 df             	mov    %rbx,%rdi
    32f5:	e8 00 00 00 00       	callq  32fa <dafs_rm_dir+0x43a>

END:
    kfree(phname);
    32fa:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
    32ff:	e8 00 00 00 00       	callq  3304 <dafs_rm_dir+0x444>
    kfree(ph);
    3304:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    3309:	e8 00 00 00 00       	callq  330e <dafs_rm_dir+0x44e>
    kfree(phn);
    330e:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
    3313:	e8 00 00 00 00       	callq  3318 <dafs_rm_dir+0x458>
    
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    3318:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 331f <dafs_rm_dir+0x45f>
    331f:	74 2d                	je     334e <dafs_rm_dir+0x48e>
    3321:	48 8d 7c 24 60       	lea    0x60(%rsp),%rdi
    3326:	e8 00 00 00 00       	callq  332b <dafs_rm_dir+0x46b>
    332b:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
    3330:	48 2b 44 24 50       	sub    0x50(%rsp),%rax
    3335:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    333c:	48 2b 44 24 58       	sub    0x58(%rsp),%rax
    3341:	48 03 44 24 68       	add    0x68(%rsp),%rax
    3346:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 334e <dafs_rm_dir+0x48e>
    334d:	00 
    kfree(z_p);
    334e:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    kfree(phname);
    kfree(ph);
    kfree(phn);
    
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    3353:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 335b <dafs_rm_dir+0x49b>
    335a:	00 
    kfree(z_p);
    335b:	e8 00 00 00 00       	callq  3360 <dafs_rm_dir+0x4a0>
    //nova_dbg("%s end",__func__);
	return 0;
    3360:	31 c0                	xor    %eax,%eax
    3362:	e9 b7 fb ff ff       	jmpq   2f1e <dafs_rm_dir+0x5e>
    /*remove from par*/
    par_pos = le32_to_cpu(dafs_de->par_pos);
    if(dir->i_ino == NOVA_ROOT_INO || par_pos!=0){
        par_de = &dafs_ze->dentry[par_pos];
        par_hash = le64_to_cpu(par_de->hname);
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    3367:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
   
    /*remove from par*/
    par_pos = le32_to_cpu(dafs_de->par_pos);
    if(dir->i_ino == NOVA_ROOT_INO || par_pos!=0){
        par_de = &dafs_ze->dentry[par_pos];
        par_hash = le64_to_cpu(par_de->hname);
    336c:	48 c1 e0 07          	shl    $0x7,%rax
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    3370:	48 8b b4 02 a8 40 00 	mov    0x40a8(%rdx,%rax,1),%rsi
    3377:	00 
    3378:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    337d:	48 8d 78 38          	lea    0x38(%rax),%rdi
    3381:	e8 00 00 00 00       	callq  3386 <dafs_rm_dir+0x4c6>
        BUG_ON(par_dir==NULL);
    3386:	48 85 c0             	test   %rax,%rax
    3389:	0f 84 c8 00 00 00    	je     3457 <dafs_rm_dir+0x597>
        head = &par_dir->sub_file;
        list_for_each_safe(this, next, head) {
    338f:	48 8b 78 18          	mov    0x18(%rax),%rdi
    if(dir->i_ino == NOVA_ROOT_INO || par_pos!=0){
        par_de = &dafs_ze->dentry[par_pos];
        par_hash = le64_to_cpu(par_de->hname);
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        BUG_ON(par_dir==NULL);
        head = &par_dir->sub_file;
    3393:	48 8d 50 18          	lea    0x18(%rax),%rdx
        list_for_each_safe(this, next, head) {
    3397:	48 39 fa             	cmp    %rdi,%rdx
    339a:	48 8b 37             	mov    (%rdi),%rsi
    339d:	0f 84 ec fd ff ff    	je     318f <dafs_rm_dir+0x2cf>
            rm_sf = list_entry(this, struct file_p, list);
            if(rm_sf->pos == de_pos){
    33a3:	8b 4c 24 44          	mov    0x44(%rsp),%ecx
    33a7:	3b 4f 10             	cmp    0x10(%rdi),%ecx
    33aa:	74 14                	je     33c0 <dafs_rm_dir+0x500>
        par_de = &dafs_ze->dentry[par_pos];
        par_hash = le64_to_cpu(par_de->hname);
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        BUG_ON(par_dir==NULL);
        head = &par_dir->sub_file;
        list_for_each_safe(this, next, head) {
    33ac:	48 89 f7             	mov    %rsi,%rdi
    33af:	48 8b 36             	mov    (%rsi),%rsi
    33b2:	48 39 fa             	cmp    %rdi,%rdx
    33b5:	0f 84 d4 fd ff ff    	je     318f <dafs_rm_dir+0x2cf>
            rm_sf = list_entry(this, struct file_p, list);
            if(rm_sf->pos == de_pos){
    33bb:	39 4f 10             	cmp    %ecx,0x10(%rdi)
    33be:	75 ec                	jne    33ac <dafs_rm_dir+0x4ec>
                par_dir->sub_num--;
    33c0:	48 83 68 08 01       	subq   $0x1,0x8(%rax)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    33c5:	48 8b 47 08          	mov    0x8(%rdi),%rax
    33c9:	48 8b 17             	mov    (%rdi),%rdx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    33cc:	48 89 42 08          	mov    %rax,0x8(%rdx)
	prev->next = next;
    33d0:	48 89 10             	mov    %rdx,(%rax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    33d3:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
    33da:	00 ad de 
    33dd:	48 89 07             	mov    %rax,(%rdi)
	entry->prev = LIST_POISON2;
    33e0:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
    33e7:	00 ad de 
    33ea:	48 89 47 08          	mov    %rax,0x8(%rdi)
                list_del(&rm_sf->list);
                kfree(rm_sf);
    33ee:	e8 00 00 00 00       	callq  33f3 <dafs_rm_dir+0x533>
                goto CONT;
    33f3:	e9 97 fd ff ff       	jmpq   318f <dafs_rm_dir+0x2cf>

	links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
		links_count = 0;
	else
		links_count += link_change;
    33f8:	42 8d 04 39          	lea    (%rcx,%r15,1),%eax
    33fc:	e9 54 fd ff ff       	jmpq   3155 <dafs_rm_dir+0x295>
    make_invalid_htable(sb, dzt_ei->ht_head, ph_hash, 1);
    delete_ext(z_p, dafs_de);

    if(dafs_de->file_type == ROOT_DIRECTORY) {
        //nova_dbg("%s dentry is root zone",__func__);
        delete_dir_info(dzt_ei, ph_hash);
    3401:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
    3406:	4c 89 e6             	mov    %r12,%rsi
    3409:	e8 00 00 00 00       	callq  340e <dafs_rm_dir+0x54e>
        ei_hash = le64_to_cpu(dafs_de->dzt_hn);
    340e:	48 8b 04 24          	mov    (%rsp),%rax
        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
    3412:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    3417:	4c 89 f7             	mov    %r14,%rdi
    delete_ext(z_p, dafs_de);

    if(dafs_de->file_type == ROOT_DIRECTORY) {
        //nova_dbg("%s dentry is root zone",__func__);
        delete_dir_info(dzt_ei, ph_hash);
        ei_hash = le64_to_cpu(dafs_de->dzt_hn);
    341a:	48 c1 e0 07          	shl    $0x7,%rax
        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
    341e:	48 8b b4 02 a8 40 00 	mov    0x40a8(%rdx,%rax,1),%rsi
    3425:	00 
    3426:	e8 00 00 00 00       	callq  342b <dafs_rm_dir+0x56b>
        free_zone_area(sb, sub_ei);
    342b:	48 89 df             	mov    %rbx,%rdi
    342e:	48 89 c6             	mov    %rax,%rsi
    3431:	e8 00 00 00 00       	callq  3436 <dafs_rm_dir+0x576>
        goto END;
    3436:	e9 bf fe ff ff       	jmpq   32fa <dafs_rm_dir+0x43a>
    phlen = strlen(phn);

    if(phlen==1){
        //flen = strlen(ph);
        //memcpy(phname, ph, flen);
        strcat(phname, ph);
    343b:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
    3440:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
    3445:	e8 00 00 00 00       	callq  344a <dafs_rm_dir+0x58a>
    344a:	e9 41 fc ff ff       	jmpq   3090 <dafs_rm_dir+0x1d0>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    344f:	45 31 e4             	xor    %r12d,%r12d
    3452:	e9 8d fc ff ff       	jmpq   30e4 <dafs_rm_dir+0x224>
    par_pos = le32_to_cpu(dafs_de->par_pos);
    if(dir->i_ino == NOVA_ROOT_INO || par_pos!=0){
        par_de = &dafs_ze->dentry[par_pos];
        par_hash = le64_to_cpu(par_de->hname);
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        BUG_ON(par_dir==NULL);
    3457:	0f 0b                	ud2    
    /*make invalid sub file only for empty dir
     * free dir_tree*/
    this = NULL;
    next = NULL;
    rm_dir = radix_tree_delete(&dzt_ei->dir_tree, ph_hash);
    BUG_ON(rm_dir==NULL);
    3459:	0f 0b                	ud2    
    345b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003460 <dafs_remove_dentry>:
	return 0;
}

/*remove dir when use rename*/
int dafs_remove_dentry(struct dentry *dentry)
{
    3460:	e8 00 00 00 00       	callq  3465 <dafs_remove_dentry+0x5>
    3465:	55                   	push   %rbp
    3466:	48 89 e5             	mov    %rsp,%rbp
    3469:	41 57                	push   %r15
    346b:	41 56                	push   %r14
    346d:	41 55                	push   %r13
    346f:	41 54                	push   %r12
    3471:	49 89 fc             	mov    %rdi,%r12
    3474:	53                   	push   %rbx
    3475:	48 83 ec 40          	sub    $0x40,%rsp
    char *phname, *ph, *phn;
    int ret;
	timing_t remove_dentry_time;

    //nova_dbg("dafs start removing dentry");
	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    3479:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 347f <dafs_remove_dentry+0x1f>
	return 0;
}

/*remove dir when use rename*/
int dafs_remove_dentry(struct dentry *dentry)
{
    347f:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    3486:	00 00 
    3488:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    348d:	31 c0                	xor    %eax,%eax
    struct inode *dir = dentry->d_parent->d_inode;
    348f:	48 8b 47 18          	mov    0x18(%rdi),%rax
    char *phname, *ph, *phn;
    int ret;
	timing_t remove_dentry_time;

    //nova_dbg("dafs start removing dentry");
	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    3493:	85 f6                	test   %esi,%esi
}

/*remove dir when use rename*/
int dafs_remove_dentry(struct dentry *dentry)
{
    struct inode *dir = dentry->d_parent->d_inode;
    3495:	48 8b 58 30          	mov    0x30(%rax),%rbx
    struct super_block *sb = dir->i_sb;
    3499:	4c 8b 7b 28          	mov    0x28(%rbx),%r15
    char *phname, *ph, *phn;
    int ret;
	timing_t remove_dentry_time;

    //nova_dbg("dafs start removing dentry");
	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    349d:	75 2f                	jne    34ce <dafs_remove_dentry+0x6e>

	if (!dentry->d_name.len)
    349f:	8b 47 24             	mov    0x24(%rdi),%eax
    34a2:	85 c0                	test   %eax,%eax
    34a4:	75 3b                	jne    34e1 <dafs_remove_dentry+0x81>
		return -EINVAL;
    34a6:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    //nova_dbg("%s end", __func__);
	return 0;
}
    34ab:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
    34b0:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    34b7:	00 00 
    34b9:	0f 85 d1 02 00 00    	jne    3790 <dafs_remove_dentry+0x330>
    34bf:	48 83 c4 40          	add    $0x40,%rsp
    34c3:	5b                   	pop    %rbx
    34c4:	41 5c                	pop    %r12
    34c6:	41 5d                	pop    %r13
    34c8:	41 5e                	pop    %r14
    34ca:	41 5f                	pop    %r15
    34cc:	5d                   	pop    %rbp
    34cd:	c3                   	retq   
    34ce:	48 8d 7c 24 18       	lea    0x18(%rsp),%rdi
    34d3:	e8 00 00 00 00       	callq  34d8 <dafs_remove_dentry+0x78>
	timing_t remove_dentry_time;

    //nova_dbg("dafs start removing dentry");
	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);

	if (!dentry->d_name.len)
    34d8:	41 8b 4c 24 24       	mov    0x24(%r12),%ecx
    34dd:	85 c9                	test   %ecx,%ecx
    34df:	74 c5                	je     34a6 <dafs_remove_dentry+0x46>
		return -EINVAL;


	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    34e1:	e8 00 00 00 00       	callq  34e6 <dafs_remove_dentry+0x86>
    34e6:	48 c7 83 80 00 00 00 	movq   $0x0,0x80(%rbx)
    34ed:	00 00 00 00 
    34f1:	48 89 43 78          	mov    %rax,0x78(%rbx)

    /*直接rm direntry就可以
    * 先找到相应的dir*/    
    ph = get_dentry_path(dentry,0);
    34f5:	4c 89 e7             	mov    %r12,%rdi

	if (!dentry->d_name.len)
		return -EINVAL;


	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    34f8:	48 8b 93 80 00 00 00 	mov    0x80(%rbx),%rdx
    34ff:	48 8b 43 78          	mov    0x78(%rbx),%rax
    3503:	48 89 53 70          	mov    %rdx,0x70(%rbx)
    3507:	48 89 43 68          	mov    %rax,0x68(%rbx)

    /*直接rm direntry就可以
    * 先找到相应的dir*/    
    ph = get_dentry_path(dentry,0);
    350b:	e8 f0 cb ff ff       	callq  100 <get_dentry_path.isra.4>
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    3510:	48 89 c7             	mov    %rax,%rdi

	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;

    /*直接rm direntry就可以
    * 先找到相应的dir*/    
    ph = get_dentry_path(dentry,0);
    3513:	49 89 c5             	mov    %rax,%r13
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    3516:	e8 00 00 00 00       	callq  351b <dafs_remove_dentry+0xbb>
    351b:	be d0 80 00 00       	mov    $0x80d0,%esi
    3520:	48 89 c7             	mov    %rax,%rdi
    3523:	e8 00 00 00 00       	callq  3528 <dafs_remove_dentry+0xc8>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    3528:	4c 89 ef             	mov    %r13,%rdi
    352b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    3530:	e8 00 00 00 00       	callq  3535 <dafs_remove_dentry+0xd5>
    3535:	be d0 80 00 00       	mov    $0x80d0,%esi
    353a:	48 89 c7             	mov    %rax,%rdi
    353d:	e8 00 00 00 00       	callq  3542 <dafs_remove_dentry+0xe2>
    3542:	49 89 c4             	mov    %rax,%r12
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    3545:	49 8b 87 b0 03 00 00 	mov    0x3b0(%r15),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    354c:	4c 89 ef             	mov    %r13,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    354f:	4c 8b b0 d8 01 00 00 	mov    0x1d8(%rax),%r14
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    3556:	e8 00 00 00 00       	callq  355b <dafs_remove_dentry+0xfb>
    355b:	4c 89 ee             	mov    %r13,%rsi
    355e:	48 89 c2             	mov    %rax,%rdx
    3561:	4c 89 e7             	mov    %r12,%rdi
    3564:	e8 00 00 00 00       	callq  3569 <dafs_remove_dentry+0x109>
    tlen = strlen(phstr);
    3569:	4c 89 ef             	mov    %r13,%rdi
    356c:	e8 00 00 00 00       	callq  3571 <dafs_remove_dentry+0x111>
    3571:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
    3574:	be 2f 00 00 00       	mov    $0x2f,%esi
    3579:	4c 89 e7             	mov    %r12,%rdi
    357c:	e8 00 00 00 00       	callq  3581 <dafs_remove_dentry+0x121>
        phlen = tlen -strlen(tem);
    3581:	48 89 c7             	mov    %rax,%rdi
    3584:	e8 00 00 00 00       	callq  3589 <dafs_remove_dentry+0x129>
        tlen = phlen;
        //bug
        if(phlen==0){
    3589:	48 29 c3             	sub    %rax,%rbx
    358c:	0f 84 88 01 00 00    	je     371a <dafs_remove_dentry+0x2ba>
            break;
        }
        memcpy(ph,phstr,tlen);
    3592:	48 89 da             	mov    %rbx,%rdx
    3595:	4c 89 ee             	mov    %r13,%rsi
    3598:	4c 89 e7             	mov    %r12,%rdi
    359b:	e8 00 00 00 00       	callq  35a0 <dafs_remove_dentry+0x140>
	int i;

	for (i = 0; i < length; i++) {
    35a0:	85 db                	test   %ebx,%ebx
        ph[tlen]='\0';
    35a2:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
    35a7:	0f 8e 55 01 00 00    	jle    3702 <dafs_remove_dentry+0x2a2>
    35ad:	8d 43 ff             	lea    -0x1(%rbx),%eax
    35b0:	4c 89 e2             	mov    %r12,%rdx
    35b3:	31 f6                	xor    %esi,%esi
    35b5:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
    35ba:	48 89 f0             	mov    %rsi,%rax
    35bd:	48 83 c2 01          	add    $0x1,%rdx
    35c1:	48 c1 e0 05          	shl    $0x5,%rax
    35c5:	48 29 f0             	sub    %rsi,%rax
    35c8:	48 89 c6             	mov    %rax,%rsi
    35cb:	48 0f be 42 ff       	movsbq -0x1(%rdx),%rax
    35d0:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    35d3:	48 39 d1             	cmp    %rdx,%rcx
    35d6:	75 e2                	jne    35ba <dafs_remove_dentry+0x15a>
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    35d8:	4c 89 f7             	mov    %r14,%rdi
    35db:	e8 00 00 00 00       	callq  35e0 <dafs_remove_dentry+0x180>
        if(dzt_ei){
    35e0:	48 85 c0             	test   %rax,%rax
    35e3:	74 8f                	je     3574 <dafs_remove_dentry+0x114>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    35e5:	49 8b 97 b0 03 00 00 	mov    0x3b0(%r15),%rdx
    memcpy(ph, "/", 1);
    ph[1]='\0';
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    if(!dzt_ei){
    35ec:	48 89 c3             	mov    %rax,%rbx
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph));
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    35ef:	48 8b 40 10          	mov    0x10(%rax),%rax
    phlen = strlen(phn);
    35f3:	4c 89 e7             	mov    %r12,%rdi
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    35f6:	49 89 c6             	mov    %rax,%r14
    35f9:	4c 03 72 18          	add    0x18(%rdx),%r14
    35fd:	48 85 c0             	test   %rax,%rax
    3600:	b8 00 00 00 00       	mov    $0x0,%eax
    3605:	4c 0f 44 f0          	cmove  %rax,%r14
    3609:	e8 00 00 00 00       	callq  360e <dafs_remove_dentry+0x1ae>
    if(phlen==1){
    360e:	48 83 f8 01          	cmp    $0x1,%rax
    3612:	0f 84 28 01 00 00    	je     3740 <dafs_remove_dentry+0x2e0>
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    3618:	4c 89 ef             	mov    %r13,%rdi
    361b:	48 89 04 24          	mov    %rax,(%rsp)
    361f:	e8 00 00 00 00       	callq  3624 <dafs_remove_dentry+0x1c4>
    3624:	48 8b 14 24          	mov    (%rsp),%rdx
    3628:	48 29 d0             	sub    %rdx,%rax
        memcpy(phname, ph+phlen, flen);
    362b:	49 8d 74 15 00       	lea    0x0(%r13,%rdx,1),%rsi
    3630:	48 89 04 24          	mov    %rax,(%rsp)
    3634:	48 89 c2             	mov    %rax,%rdx
    3637:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    363c:	e8 00 00 00 00       	callq  3641 <dafs_remove_dentry+0x1e1>
        phname[flen]='\0';
    3641:	48 8b 0c 24          	mov    (%rsp),%rcx
    3645:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    364a:	85 c9                	test   %ecx,%ecx
    364c:	c6 04 08 00          	movb   $0x0,(%rax,%rcx,1)
    3650:	0f 8e 33 01 00 00    	jle    3789 <dafs_remove_dentry+0x329>
    3656:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    365b:	8d 41 ff             	lea    -0x1(%rcx),%eax
    365e:	31 d2                	xor    %edx,%edx
    3660:	48 8d 74 07 01       	lea    0x1(%rdi,%rax,1),%rsi
    3665:	48 89 f9             	mov    %rdi,%rcx
		hash = hash * seed + (*str++);
    3668:	48 89 d0             	mov    %rdx,%rax
    366b:	48 83 c1 01          	add    $0x1,%rcx
    366f:	48 c1 e0 05          	shl    $0x5,%rax
    3673:	48 29 d0             	sub    %rdx,%rax
    3676:	48 89 c2             	mov    %rax,%rdx
    3679:	48 0f be 41 ff       	movsbq -0x1(%rcx),%rax
    367e:	48 01 c2             	add    %rax,%rdx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    3681:	48 39 f1             	cmp    %rsi,%rcx
    3684:	75 e2                	jne    3668 <dafs_remove_dentry+0x208>

    dzt_eno = dzt_ei->dzt_eno;
    ph_hash = BKDRHash(phname, flen);

    /*lookup in hash table*/
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    3686:	48 8b 73 18          	mov    0x18(%rbx),%rsi
    368a:	4c 8d 44 24 14       	lea    0x14(%rsp),%r8
    368f:	b9 01 00 00 00       	mov    $0x1,%ecx
    3694:	4c 89 ff             	mov    %r15,%rdi
    3697:	e8 00 00 00 00       	callq  369c <dafs_remove_dentry+0x23c>
    if(!ret){
    369c:	85 c0                	test   %eax,%eax
    369e:	0f 84 02 fe ff ff    	je     34a6 <dafs_remove_dentry+0x46>
        //nova_dbg("not find in hashtable");
        return -EINVAL;
    }

    dafs_de = &dafs_ze->dentry[de_pos];
    36a4:	8b 74 24 14          	mov    0x14(%rsp),%esi
    /*
    de_addr = le64_to_cpu(&dafs_de);
    record_dir_log(sb, de_addr, 0, DIR_RMDIR);*/

    
    ret = __remove_direntry(sb, dafs_de, dafs_ze, dzt_ei, de_pos);
    36a8:	48 89 d9             	mov    %rbx,%rcx
    36ab:	4c 89 f2             	mov    %r14,%rdx
    36ae:	4c 89 ff             	mov    %r15,%rdi
    if(!ret){
        //nova_dbg("not find in hashtable");
        return -EINVAL;
    }

    dafs_de = &dafs_ze->dentry[de_pos];
    36b1:	49 89 f0             	mov    %rsi,%r8
    36b4:	48 81 c6 81 00 00 00 	add    $0x81,%rsi
    36bb:	48 c1 e6 07          	shl    $0x7,%rsi
    36bf:	4c 01 f6             	add    %r14,%rsi
    /*
    de_addr = le64_to_cpu(&dafs_de);
    record_dir_log(sb, de_addr, 0, DIR_RMDIR);*/

    
    ret = __remove_direntry(sb, dafs_de, dafs_ze, dzt_ei, de_pos);
    36c2:	e8 f9 e5 ff ff       	callq  1cc0 <__remove_direntry>

    if(ret)
    36c7:	85 c0                	test   %eax,%eax
    36c9:	0f 85 dc fd ff ff    	jne    34ab <dafs_remove_dentry+0x4b>
        return ret;
    kfree(phname);
    36cf:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    36d4:	e8 00 00 00 00       	callq  36d9 <dafs_remove_dentry+0x279>
    kfree(phn);
    36d9:	4c 89 e7             	mov    %r12,%rdi
    36dc:	e8 00 00 00 00       	callq  36e1 <dafs_remove_dentry+0x281>
    kfree(ph);
    36e1:	4c 89 ef             	mov    %r13,%rdi
    36e4:	e8 00 00 00 00       	callq  36e9 <dafs_remove_dentry+0x289>
    
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    36e9:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 36ef <dafs_remove_dentry+0x28f>
    36ef:	85 d2                	test   %edx,%edx
    36f1:	75 64                	jne    3757 <dafs_remove_dentry+0x2f7>
    36f3:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 36fb <dafs_remove_dentry+0x29b>
    36fa:	00 
    //nova_dbg("%s end", __func__);
	return 0;
    36fb:	31 c0                	xor    %eax,%eax
    36fd:	e9 a9 fd ff ff       	jmpq   34ab <dafs_remove_dentry+0x4b>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    3702:	31 f6                	xor    %esi,%esi
        memcpy(ph,phstr,tlen);
        ph[tlen]='\0';
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    3704:	4c 89 f7             	mov    %r14,%rdi
    3707:	e8 00 00 00 00       	callq  370c <dafs_remove_dentry+0x2ac>
        if(dzt_ei){
    370c:	48 85 c0             	test   %rax,%rax
    370f:	0f 84 5f fe ff ff    	je     3574 <dafs_remove_dentry+0x114>
    3715:	e9 cb fe ff ff       	jmpq   35e5 <dafs_remove_dentry+0x185>
            return dzt_ei;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    371a:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    ph[1]='\0';
    371f:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    3725:	be 2f 00 00 00       	mov    $0x2f,%esi
    372a:	4c 89 f7             	mov    %r14,%rdi
    372d:	e8 00 00 00 00       	callq  3732 <dafs_remove_dentry+0x2d2>
    if(!dzt_ei){
    3732:	48 85 c0             	test   %rax,%rax
    3735:	0f 85 aa fe ff ff    	jne    35e5 <dafs_remove_dentry+0x185>
    373b:	e8 00 00 00 00       	callq  3740 <dafs_remove_dentry+0x2e0>
    //memcpy(phname, ph, strlen(ph));
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
    3740:	4c 89 ef             	mov    %r13,%rdi
    3743:	e8 00 00 00 00       	callq  3748 <dafs_remove_dentry+0x2e8>
        memcpy(phname, ph, flen);
    3748:	4c 89 ee             	mov    %r13,%rsi
    374b:	48 89 c2             	mov    %rax,%rdx
    374e:	48 89 04 24          	mov    %rax,(%rsp)
    3752:	e9 e0 fe ff ff       	jmpq   3637 <dafs_remove_dentry+0x1d7>
    3757:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
    375c:	e8 00 00 00 00       	callq  3761 <dafs_remove_dentry+0x301>
    kfree(phname);
    kfree(phn);
    kfree(ph);
    
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    3761:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    3766:	48 2b 44 24 18       	sub    0x18(%rsp),%rax
    376b:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    3772:	48 2b 44 24 20       	sub    0x20(%rsp),%rax
    3777:	48 03 44 24 30       	add    0x30(%rsp),%rax
    377c:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 3784 <dafs_remove_dentry+0x324>
    3783:	00 
    3784:	e9 6a ff ff ff       	jmpq   36f3 <dafs_remove_dentry+0x293>
    3789:	31 d2                	xor    %edx,%edx
    378b:	e9 f6 fe ff ff       	jmpq   3686 <dafs_remove_dentry+0x226>
    //nova_dbg("%s end", __func__);
	return 0;
}
    3790:	e8 00 00 00 00       	callq  3795 <dafs_remove_dentry+0x335>
    3795:	90                   	nop
    3796:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    379d:	00 00 00 

00000000000037a0 <dafs_append_dir_init_entries>:

/*append . and .. entries*/
int dafs_append_dir_init_entries(struct super_block *sb, u32 par_pos, struct dzt_entry_info *dzt_ei,
                                 u64 self_ino, u64 parent_ino, const char *ful_name)
{
    37a0:	e8 00 00 00 00       	callq  37a5 <dafs_append_dir_init_entries+0x5>
    37a5:	55                   	push   %rbp
    37a6:	48 89 e5             	mov    %rsp,%rbp
    37a9:	41 57                	push   %r15
    37ab:	41 56                	push   %r14
    37ad:	41 55                	push   %r13
    37af:	41 54                	push   %r12
    37b1:	4d 89 cf             	mov    %r9,%r15
    37b4:	53                   	push   %rbx
    37b5:	48 83 ec 60          	sub    $0x60,%rsp
    37b9:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
    u32 cur_pos = 0;
    //int ret;
	

    //nova_dbg("%s start ino is %llu, par_ino is %llu", __func__, self_ino, parent_ino);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    37bd:	48 8b 42 10          	mov    0x10(%rdx),%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    37c1:	48 8b 97 b0 03 00 00 	mov    0x3b0(%rdi),%rdx
}

/*append . and .. entries*/
int dafs_append_dir_init_entries(struct super_block *sb, u32 par_pos, struct dzt_entry_info *dzt_ei,
                                 u64 self_ino, u64 parent_ino, const char *ful_name)
{
    37c8:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)

    //nova_dbg("%s start ino is %llu, par_ino is %llu", __func__, self_ino, parent_ino);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    //nova_dbg("par ze addr is %llu", dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    37cc:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
}

/*append . and .. entries*/
int dafs_append_dir_init_entries(struct super_block *sb, u32 par_pos, struct dzt_entry_info *dzt_ei,
                                 u64 self_ino, u64 parent_ino, const char *ful_name)
{
    37d0:	65 48 8b 1c 25 28 00 	mov    %gs:0x28,%rbx
    37d7:	00 00 
    37d9:	48 89 5d d0          	mov    %rbx,-0x30(%rbp)
    37dd:	31 db                	xor    %ebx,%ebx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    37df:	49 89 c5             	mov    %rax,%r13
    37e2:	89 75 a8             	mov    %esi,-0x58(%rbp)
    37e5:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    37e9:	4c 03 6a 18          	add    0x18(%rdx),%r13
    37ed:	48 85 c0             	test   %rax,%rax
    37f0:	b8 00 00 00 00       	mov    $0x0,%eax
    37f5:	4c 89 45 98          	mov    %r8,-0x68(%rbp)
    37f9:	4c 0f 44 e8          	cmove  %rax,%r13
    //nova_dbg("%s start ino is %llu, par_ino is %llu", __func__, self_ino, parent_ino);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    //nova_dbg("par ze addr is %llu", dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    bitpos = 0;
    37fd:	45 31 e4             	xor    %r12d,%r12d

    //nova_dbg("%s start ino is %llu, par_ino is %llu", __func__, self_ino, parent_ino);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    //nova_dbg("par ze addr is %llu", dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    3800:	4c 89 ee             	mov    %r13,%rsi
    3803:	e8 00 00 00 00       	callq  3808 <dafs_append_dir_init_entries+0x68>
    3808:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    380c:	48 8b 30             	mov    (%rax),%rsi
    380f:	31 c0                	xor    %eax,%eax
    3811:	eb 18                	jmp    382b <dafs_append_dir_init_entries+0x8b>
    bitpos = 0;
    while(cur_pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
            bitpos+=2;
    3813:	41 83 c4 02          	add    $0x2,%r12d
            cur_pos++;
    3817:	83 c3 01             	add    $0x1,%ebx
    381a:	48 83 c0 02          	add    $0x2,%rax
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    //nova_dbg("par ze addr is %llu", dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    bitpos = 0;
    while(cur_pos<NR_DENTRY_IN_ZONE){
    381e:	41 81 fc fe ff 01 00 	cmp    $0x1fffe,%r12d
    3825:	0f 84 b0 04 00 00    	je     3cdb <dafs_append_dir_init_entries+0x53b>

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    382b:	48 0f a3 06          	bt     %rax,(%rsi)
    382f:	19 d2                	sbb    %edx,%edx
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
    3831:	85 d2                	test   %edx,%edx
    3833:	75 de                	jne    3813 <dafs_append_dir_init_entries+0x73>
    3835:	48 8d 48 01          	lea    0x1(%rax),%rcx
    3839:	48 0f a3 0e          	bt     %rcx,(%rsi)
    383d:	19 d2                	sbb    %edx,%edx
    383f:	85 d2                	test   %edx,%edx
    3841:	75 d0                	jne    3813 <dafs_append_dir_init_entries+0x73>
    /* if not enough entries, negtive split*/
    if(cur_pos == NR_DENTRY_IN_ZONE){
        dafs_split_zone(sb, dzt_ei, 0, NEGTIVE_SPLIT);
    }

    p_len = strlen(ful_name);
    3843:	4c 89 ff             	mov    %r15,%rdi
    3846:	48 89 8d 78 ff ff ff 	mov    %rcx,-0x88(%rbp)
    384d:	e8 00 00 00 00       	callq  3852 <dafs_append_dir_init_entries+0xb2>
    phn = kzalloc(sizeof(char)*(p_len+4), GFP_KERNEL);
    3852:	48 8d 78 04          	lea    0x4(%rax),%rdi
    3856:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    385a:	e8 91 c8 ff ff       	callq  f0 <kzalloc.constprop.9>
    memcpy(phn, ful_name, p_len);
    385f:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    3863:	4c 89 fe             	mov    %r15,%rsi
    3866:	48 89 c7             	mov    %rax,%rdi
    phn[p_len]='\0';

    dafs_de = &dafs_ze->dentry[cur_pos];
    3869:	41 89 df             	mov    %ebx,%r15d
    if(cur_pos == NR_DENTRY_IN_ZONE){
        dafs_split_zone(sb, dzt_ei, 0, NEGTIVE_SPLIT);
    }

    p_len = strlen(ful_name);
    phn = kzalloc(sizeof(char)*(p_len+4), GFP_KERNEL);
    386c:	49 89 c6             	mov    %rax,%r14
    memcpy(phn, ful_name, p_len);
    386f:	e8 00 00 00 00       	callq  3874 <dafs_append_dir_init_entries+0xd4>
    3874:	4c 89 fe             	mov    %r15,%rsi
    phn[p_len]='\0';
    3877:	48 8b 45 b8          	mov    -0x48(%rbp),%rax

    dafs_de = &dafs_ze->dentry[cur_pos];
    387b:	4d 8d 97 81 00 00 00 	lea    0x81(%r15),%r10
    3882:	48 c1 e6 07          	shl    $0x7,%rsi
    3886:	49 8d 54 35 00       	lea    0x0(%r13,%rsi,1),%rdx
    388b:	49 c1 e2 07          	shl    $0x7,%r10
    388f:	48 89 75 88          	mov    %rsi,-0x78(%rbp)
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 1;
    dafs_de->links_count = 1;
    3893:	be 01 00 00 00       	mov    $0x1,%esi
    }

    p_len = strlen(ful_name);
    phn = kzalloc(sizeof(char)*(p_len+4), GFP_KERNEL);
    memcpy(phn, ful_name, p_len);
    phn[p_len]='\0';
    3898:	41 c6 04 06 00       	movb   $0x0,(%r14,%rax,1)

    dafs_de = &dafs_ze->dentry[cur_pos];
    389d:	4d 01 ea             	add    %r13,%r10
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 1;
    dafs_de->links_count = 1;
    38a0:	66 89 b2 86 40 00 00 	mov    %si,0x4086(%rdx)
    phn = kzalloc(sizeof(char)*(p_len+4), GFP_KERNEL);
    memcpy(phn, ful_name, p_len);
    phn[p_len]='\0';

    dafs_de = &dafs_ze->dentry[cur_pos];
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    38a7:	c6 82 80 40 00 00 06 	movb   $0x6,0x4080(%rdx)
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    38ae:	c6 82 82 40 00 00 00 	movb   $0x0,0x4082(%rdx)
    dafs_de->name_len = 1;
    38b5:	c6 82 81 40 00 00 01 	movb   $0x1,0x4081(%rdx)
    p_len = strlen(ful_name);
    phn = kzalloc(sizeof(char)*(p_len+4), GFP_KERNEL);
    memcpy(phn, ful_name, p_len);
    phn[p_len]='\0';

    dafs_de = &dafs_ze->dentry[cur_pos];
    38bc:	4c 89 55 80          	mov    %r10,-0x80(%rbp)
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 1;
    dafs_de->links_count = 1;
    38c0:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    38c4:	e8 00 00 00 00       	callq  38c9 <dafs_append_dir_init_entries+0x129>
    38c9:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
    /*if not super root sub init file, then isr_sf = 0*/
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(self_ino);
    38cd:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    dafs_de->size = sb->s_blocksize;
    dafs_de->par_pos = cpu_to_le32(par_pos);
    
    memcpy(dafs_de->name, ".", 1);
    38d1:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    dafs_de->name[1]='\0';

    /*set ful_name*/
    p_len += 2;
    dafs_de->fname_len = cpu_to_le64(p_len);
    if(p_len == 3)
    38d5:	4c 8b 55 80          	mov    -0x80(%rbp),%r10
    38d9:	48 8b 8d 78 ff ff ff 	mov    -0x88(%rbp),%rcx
    dafs_de->name_len = 1;
    dafs_de->links_count = 1;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    /*if not super root sub init file, then isr_sf = 0*/
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(self_ino);
    38e0:	48 89 ba 98 40 00 00 	mov    %rdi,0x4098(%rdx)
    dafs_de->size = sb->s_blocksize;
    38e7:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 1;
    dafs_de->links_count = 1;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    38eb:	89 82 88 40 00 00    	mov    %eax,0x4088(%rdx)
    /*if not super root sub init file, then isr_sf = 0*/
    dafs_de->isr_sf = 0;
    38f1:	c6 82 83 40 00 00 00 	movb   $0x0,0x4083(%rdx)
    38f8:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
    38fc:	4c 89 55 90          	mov    %r10,-0x70(%rbp)
    dafs_de->ino = cpu_to_le64(self_ino);
    dafs_de->size = sb->s_blocksize;
    3900:	48 8b 47 18          	mov    0x18(%rdi),%rax
    dafs_de->par_pos = cpu_to_le32(par_pos);
    3904:	8b 7d a8             	mov    -0x58(%rbp),%edi
    3907:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
    dafs_de->links_count = 1;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    /*if not super root sub init file, then isr_sf = 0*/
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(self_ino);
    dafs_de->size = sb->s_blocksize;
    390b:	48 89 82 a0 40 00 00 	mov    %rax,0x40a0(%rdx)
    
    memcpy(dafs_de->name, ".", 1);
    dafs_de->name[1]='\0';

    /*set ful_name*/
    p_len += 2;
    3912:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    /*if not super root sub init file, then isr_sf = 0*/
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(self_ino);
    dafs_de->size = sb->s_blocksize;
    dafs_de->par_pos = cpu_to_le32(par_pos);
    3916:	89 ba 8c 40 00 00    	mov    %edi,0x408c(%rdx)
    
    memcpy(dafs_de->name, ".", 1);
    391c:	41 c6 84 35 b0 40 00 	movb   $0x2e,0x40b0(%r13,%rsi,1)
    3923:	00 2e 

    /*set ful_name*/
    p_len += 2;
    dafs_de->fname_len = cpu_to_le64(p_len);
    if(p_len == 3)
        strcat(phn, ".");
    3925:	4c 89 f7             	mov    %r14,%rdi
    dafs_de->ino = cpu_to_le64(self_ino);
    dafs_de->size = sb->s_blocksize;
    dafs_de->par_pos = cpu_to_le32(par_pos);
    
    memcpy(dafs_de->name, ".", 1);
    dafs_de->name[1]='\0';
    3928:	c6 82 b1 40 00 00 00 	movb   $0x0,0x40b1(%rdx)

    /*set ful_name*/
    p_len += 2;
    392f:	48 8d 70 02          	lea    0x2(%rax),%rsi
    dafs_de->fname_len = cpu_to_le64(p_len);
    if(p_len == 3)
    3933:	48 83 fe 03          	cmp    $0x3,%rsi
    memcpy(dafs_de->name, ".", 1);
    dafs_de->name[1]='\0';

    /*set ful_name*/
    p_len += 2;
    dafs_de->fname_len = cpu_to_le64(p_len);
    3937:	48 89 b2 90 40 00 00 	mov    %rsi,0x4090(%rdx)
    393e:	48 89 75 88          	mov    %rsi,-0x78(%rbp)
    if(p_len == 3)
    3942:	0f 84 b3 03 00 00    	je     3cfb <dafs_append_dir_init_entries+0x55b>
        strcat(phn, ".");
    else
        strcat(phn, "/.");
    3948:	e8 00 00 00 00       	callq  394d <dafs_append_dir_init_entries+0x1ad>
    394d:	ba 2f 2e 00 00       	mov    $0x2e2f,%edx
    3952:	4c 01 f0             	add    %r14,%rax
    3955:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
    3959:	66 89 10             	mov    %dx,(%rax)
    395c:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    3960:	4c 8b 55 90          	mov    -0x70(%rbp),%r10
    3964:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
    3968:	c6 40 02 00          	movb   $0x0,0x2(%rax)
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    396c:	4c 89 f8             	mov    %r15,%rax
    dafs_de->ext_flag=0;
    396f:	45 31 db             	xor    %r11d,%r11d
    if(p_len == 3)
        strcat(phn, ".");
    else
        strcat(phn, "/.");
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    3972:	48 c1 e0 07          	shl    $0x7,%rax
    3976:	41 c6 84 05 d8 40 00 	movb   $0x0,0x40d8(%r13,%rax,1)
    397d:	00 00 
    dafs_de->ext_flag=0;
     
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    397f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
        strcat(phn, ".");
    else
        strcat(phn, "/.");
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    dafs_de->ext_flag=0;
    3983:	66 44 89 9a 84 40 00 	mov    %r11w,0x4084(%rdx)
    398a:	00 
     
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    398b:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    398e:	f0 48 0f ab 08       	lock bts %rcx,(%rax)
    3993:	72 00                	jb     3995 <dafs_append_dir_init_entries+0x1f5>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    3995:	85 f6                	test   %esi,%esi
    bitpos++;
    3997:	45 8d 4c 24 02       	lea    0x2(%r12),%r9d
    399c:	0f 8e 7d 03 00 00    	jle    3d1f <dafs_append_dir_init_entries+0x57f>
    39a2:	8d 46 ff             	lea    -0x1(%rsi),%eax
    39a5:	31 d2                	xor    %edx,%edx
    39a7:	49 8d 74 06 01       	lea    0x1(%r14,%rax,1),%rsi
    39ac:	4c 89 f0             	mov    %r14,%rax
		hash = hash * seed + (*str++);
    39af:	48 89 d1             	mov    %rdx,%rcx
    39b2:	48 83 c0 01          	add    $0x1,%rax
    39b6:	48 c1 e1 05          	shl    $0x5,%rcx
    39ba:	48 29 d1             	sub    %rdx,%rcx
    39bd:	48 89 ca             	mov    %rcx,%rdx
    39c0:	48 0f be 48 ff       	movsbq -0x1(%rax),%rcx
    39c5:	48 01 ca             	add    %rcx,%rdx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    39c8:	48 39 f0             	cmp    %rsi,%rax
    39cb:	75 e2                	jne    39af <dafs_append_dir_init_entries+0x20f>
    //h_len = phlen + 2;
    hashname = BKDRHash(phn, p_len);
    //nova_dbg("%s init entry name %s",__func__,phn);
    dafs_de->hname = cpu_to_le64(hashname);
    39cd:	49 c1 e7 07          	shl    $0x7,%r15
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    39d1:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    39d5:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    bitpos++;
    //h_len = phlen + 2;
    hashname = BKDRHash(phn, p_len);
    //nova_dbg("%s init entry name %s",__func__,phn);
    dafs_de->hname = cpu_to_le64(hashname);
    39db:	4b 89 94 3d a8 40 00 	mov    %rdx,0x40a8(%r13,%r15,1)
    39e2:	00 
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    39e3:	4c 8b 7d b0          	mov    -0x50(%rbp),%r15
    39e7:	89 d9                	mov    %ebx,%ecx
    39e9:	4c 89 55 90          	mov    %r10,-0x70(%rbp)
    39ed:	44 89 4d a0          	mov    %r9d,-0x60(%rbp)
    39f1:	49 8b 77 18          	mov    0x18(%r15),%rsi
    39f5:	e8 00 00 00 00       	callq  39fa <dafs_append_dir_init_entries+0x25a>

    par_de = &dafs_ze->dentry[par_pos];
    //nova_dbg("par pos is %d, cur pos is %d", par_pos,cur_pos);
    par_hn = le64_to_cpu(par_de->hname);
    39fa:	8b 45 a8             	mov    -0x58(%rbp),%eax
    /*bugbugbugbugbug*/
    //nova_dbg("parent hashname is %llu", par_hn);
    /*update dir info entry */
    par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    39fd:	49 8d 7f 38          	lea    0x38(%r15),%rdi
    dafs_de->hname = cpu_to_le64(hashname);
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);

    par_de = &dafs_ze->dentry[par_pos];
    //nova_dbg("par pos is %d, cur pos is %d", par_pos,cur_pos);
    par_hn = le64_to_cpu(par_de->hname);
    3a01:	48 c1 e0 07          	shl    $0x7,%rax
    /*bugbugbugbugbug*/
    //nova_dbg("parent hashname is %llu", par_hn);
    /*update dir info entry */
    par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    3a05:	49 8b b4 05 a8 40 00 	mov    0x40a8(%r13,%rax,1),%rsi
    3a0c:	00 
    3a0d:	e8 00 00 00 00       	callq  3a12 <dafs_append_dir_init_entries+0x272>
    if(!par_dir){
    3a12:	48 85 c0             	test   %rax,%rax
    //nova_dbg("par pos is %d, cur pos is %d", par_pos,cur_pos);
    par_hn = le64_to_cpu(par_de->hname);
    /*bugbugbugbugbug*/
    //nova_dbg("parent hashname is %llu", par_hn);
    /*update dir info entry */
    par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    3a15:	49 89 c7             	mov    %rax,%r15
    if(!par_dir){
    3a18:	44 8b 4d a0          	mov    -0x60(%rbp),%r9d
    3a1c:	4c 8b 55 90          	mov    -0x70(%rbp),%r10
    3a20:	0f 84 16 03 00 00    	je     3d3c <dafs_append_dir_init_entries+0x59c>
        nova_dbg("dafs not find dir entry");
        return -EINVAL;
    }
    par_dir->sub_num++;
    3a26:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    3a2b:	ba 14 00 00 00       	mov    $0x14,%edx
    3a30:	be d0 80 00 00       	mov    $0x80d0,%esi
    3a35:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 3a3c <dafs_append_dir_init_entries+0x29c>
    3a3c:	4c 89 55 90          	mov    %r10,-0x70(%rbp)
    3a40:	44 89 4d a0          	mov    %r9d,-0x60(%rbp)
    3a44:	e8 00 00 00 00       	callq  3a49 <dafs_append_dir_init_entries+0x2a9>
    new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
    new_sf->pos = cur_pos;
    3a49:	89 58 10             	mov    %ebx,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    3a4c:	49 8b 57 20          	mov    0x20(%r15),%rdx
    list_add_tail(&new_sf->list, &par_dir->sub_file);
    3a50:	49 8d 7f 18          	lea    0x18(%r15),%rdi
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    3a54:	4c 8b 55 90          	mov    -0x70(%rbp),%r10
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    3a58:	49 89 47 20          	mov    %rax,0x20(%r15)
	new->next = next;
    3a5c:	48 89 38             	mov    %rdi,(%rax)
    3a5f:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
	new->prev = prev;
    3a63:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    3a67:	48 89 02             	mov    %rax,(%rdx)
	if (support_clwb) {
    3a6a:	31 d2                	xor    %edx,%edx
    3a6c:	44 8b 0d 00 00 00 00 	mov    0x0(%rip),%r9d        # 3a73 <dafs_append_dir_init_entries+0x2d3>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    3a73:	44 89 d1             	mov    %r10d,%ecx
    3a76:	83 e1 3f             	and    $0x3f,%ecx
    3a79:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    3a7c:	45 85 c9             	test   %r9d,%r9d
    3a7f:	44 8b 4d a0          	mov    -0x60(%rbp),%r9d
    3a83:	0f 84 2d 02 00 00    	je     3cb6 <dafs_append_dir_init_entries+0x516>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    3a89:	89 d0                	mov    %edx,%eax
    3a8b:	4c 01 d0             	add    %r10,%rax
    3a8e:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    3a92:	83 c2 40             	add    $0x40,%edx
    3a95:	39 d1                	cmp    %edx,%ecx
    3a97:	77 f0                	ja     3a89 <dafs_append_dir_init_entries+0x2e9>

    //nova_dbg("%s . pos is %d",__func__,cur_pos);
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    cur_pos++;
    3a99:	83 c3 01             	add    $0x1,%ebx

    while(cur_pos<NR_DENTRY_IN_ZONE){
    3a9c:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
    3aa2:	0f 87 85 02 00 00    	ja     3d2d <dafs_append_dir_init_entries+0x58d>
    3aa8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3aac:	48 8b 08             	mov    (%rax),%rcx
    3aaf:	eb 03                	jmp    3ab4 <dafs_append_dir_init_entries+0x314>
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
            bitpos+=2;
    3ab1:	41 89 c1             	mov    %eax,%r9d

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    3ab4:	49 63 c1             	movslq %r9d,%rax
    3ab7:	48 0f a3 01          	bt     %rax,(%rcx)
    3abb:	19 c0                	sbb    %eax,%eax
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    cur_pos++;

    while(cur_pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
    3abd:	85 c0                	test   %eax,%eax
    3abf:	75 11                	jne    3ad2 <dafs_append_dir_init_entries+0x332>
#error "Please fix <asm/byteorder.h>"
#endif

static inline int test_bit_le(int nr, const void *addr)
{
	return test_bit(nr ^ BITOP_LE_SWIZZLE, addr);
    3ac1:	41 8d 51 01          	lea    0x1(%r9),%edx
    3ac5:	48 63 d2             	movslq %edx,%rdx
    3ac8:	48 0f a3 11          	bt     %rdx,(%rcx)
    3acc:	19 c0                	sbb    %eax,%eax
    3ace:	85 c0                	test   %eax,%eax
    3ad0:	74 16                	je     3ae8 <dafs_append_dir_init_entries+0x348>
            bitpos+=2;
            cur_pos++;
    3ad2:	83 c3 01             	add    $0x1,%ebx
    
    cur_pos++;

    while(cur_pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
            bitpos+=2;
    3ad5:	41 8d 41 02          	lea    0x2(%r9),%eax
    //nova_dbg("%s . pos is %d",__func__,cur_pos);
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    cur_pos++;

    while(cur_pos<NR_DENTRY_IN_ZONE){
    3ad9:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
    3adf:	75 d0                	jne    3ab1 <dafs_append_dir_init_entries+0x311>
    3ae1:	41 83 c1 03          	add    $0x3,%r9d
    3ae5:	49 63 d1             	movslq %r9d,%rdx
            cur_pos++;
        }else{
            break;
        }
    }
    dafs_de = &dafs_ze->dentry[cur_pos];
    3ae8:	89 d9                	mov    %ebx,%ecx
    3aea:	48 89 55 80          	mov    %rdx,-0x80(%rbp)
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 2;
    dafs_de->links_count = 2;
    3aee:	ba 02 00 00 00       	mov    $0x2,%edx
    3af3:	48 89 cf             	mov    %rcx,%rdi
            cur_pos++;
        }else{
            break;
        }
    }
    dafs_de = &dafs_ze->dentry[cur_pos];
    3af6:	4c 8d a1 81 00 00 00 	lea    0x81(%rcx),%r12
    3afd:	48 89 4d 88          	mov    %rcx,-0x78(%rbp)
    3b01:	48 c1 e7 07          	shl    $0x7,%rdi
    3b05:	49 8d 74 3d 00       	lea    0x0(%r13,%rdi,1),%rsi
    3b0a:	48 89 7d 90          	mov    %rdi,-0x70(%rbp)
    3b0e:	49 c1 e4 07          	shl    $0x7,%r12
    3b12:	4d 01 ec             	add    %r13,%r12
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 2;
    dafs_de->links_count = 2;
    3b15:	66 89 96 86 40 00 00 	mov    %dx,0x4086(%rsi)
        }else{
            break;
        }
    }
    dafs_de = &dafs_ze->dentry[cur_pos];
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    3b1c:	c6 86 80 40 00 00 06 	movb   $0x6,0x4080(%rsi)
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    3b23:	c6 86 82 40 00 00 00 	movb   $0x0,0x4082(%rsi)
    dafs_de->name_len = 2;
    3b2a:	c6 86 81 40 00 00 02 	movb   $0x2,0x4081(%rsi)
    dafs_de->links_count = 2;
    3b31:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    3b35:	e8 00 00 00 00       	callq  3b3a <dafs_append_dir_init_entries+0x39a>
    3b3a:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(parent_ino);
    dafs_de->size = sb->s_blocksize;
    memcpy(dafs_de->name, "..", 2);
    3b3e:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
    3b42:	b9 2e 2e 00 00       	mov    $0x2e2e,%ecx
    dafs_de->name[2]='\0';
    p_len ++; 
    3b47:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 2;
    dafs_de->links_count = 2;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    3b4b:	89 86 88 40 00 00    	mov    %eax,0x4088(%rsi)
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(parent_ino);
    3b51:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 2;
    dafs_de->links_count = 2;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    dafs_de->isr_sf = 0;
    3b55:	c6 86 83 40 00 00 00 	movb   $0x0,0x4083(%rsi)
    dafs_de->ino = cpu_to_le64(parent_ino);
    dafs_de->size = sb->s_blocksize;
    memcpy(dafs_de->name, "..", 2);
    dafs_de->name[2]='\0';
    p_len ++; 
    3b5c:	49 83 c0 03          	add    $0x3,%r8
    dafs_de->fname_len = cpu_to_le64(p_len);
    3b60:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 2;
    dafs_de->links_count = 2;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(parent_ino);
    3b64:	48 89 86 98 40 00 00 	mov    %rax,0x4098(%rsi)
    dafs_de->size = sb->s_blocksize;
    3b6b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    3b6f:	48 8b 40 18          	mov    0x18(%rax),%rax
    3b73:	48 89 86 a0 40 00 00 	mov    %rax,0x40a0(%rsi)
    memcpy(dafs_de->name, "..", 2);
    3b7a:	66 41 89 8c 3d b0 40 	mov    %cx,0x40b0(%r13,%rdi,1)
    3b81:	00 00 
    dafs_de->name[2]='\0';
    p_len ++; 
    dafs_de->fname_len = cpu_to_le64(p_len);
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    dafs_de->ext_flag=0;
    3b83:	31 ff                	xor    %edi,%edi
    dafs_de->ino = cpu_to_le64(parent_ino);
    dafs_de->size = sb->s_blocksize;
    memcpy(dafs_de->name, "..", 2);
    dafs_de->name[2]='\0';
    p_len ++; 
    dafs_de->fname_len = cpu_to_le64(p_len);
    3b85:	4c 89 86 90 40 00 00 	mov    %r8,0x4090(%rsi)
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    dafs_de->ext_flag=0;
    3b8c:	66 89 be 84 40 00 00 	mov    %di,0x4084(%rsi)
    strcat(phn, ".");
    3b93:	4c 89 f7             	mov    %r14,%rdi
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(parent_ino);
    dafs_de->size = sb->s_blocksize;
    memcpy(dafs_de->name, "..", 2);
    dafs_de->name[2]='\0';
    3b96:	c6 86 b2 40 00 00 00 	movb   $0x0,0x40b2(%rsi)
    p_len ++; 
    dafs_de->fname_len = cpu_to_le64(p_len);
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    3b9d:	c6 86 d8 40 00 00 00 	movb   $0x0,0x40d8(%rsi)
    dafs_de->ext_flag=0;
    strcat(phn, ".");
    3ba4:	e8 00 00 00 00       	callq  3ba9 <dafs_append_dir_init_entries+0x409>
    3ba9:	41 b8 2e 00 00 00    	mov    $0x2e,%r8d
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    3baf:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
    3bb3:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
    3bb7:	66 45 89 04 06       	mov    %r8w,(%r14,%rax,1)
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    3bbc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3bc0:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
    3bc4:	48 8b 00             	mov    (%rax),%rax
    3bc7:	f0 48 0f ab 10       	lock bts %rdx,(%rax)
    3bcc:	72 00                	jb     3bce <dafs_append_dir_init_entries+0x42e>
    3bce:	45 85 c0             	test   %r8d,%r8d
    3bd1:	0f 8e 4f 01 00 00    	jle    3d26 <dafs_append_dir_init_entries+0x586>
    3bd7:	41 8d 40 ff          	lea    -0x1(%r8),%eax
    3bdb:	31 d2                	xor    %edx,%edx
    3bdd:	49 8d 7c 06 01       	lea    0x1(%r14,%rax,1),%rdi
    3be2:	4c 89 f0             	mov    %r14,%rax
		hash = hash * seed + (*str++);
    3be5:	48 89 d6             	mov    %rdx,%rsi
    3be8:	48 83 c0 01          	add    $0x1,%rax
    3bec:	48 c1 e6 05          	shl    $0x5,%rsi
    3bf0:	48 29 d6             	sub    %rdx,%rsi
    3bf3:	48 89 f2             	mov    %rsi,%rdx
    3bf6:	48 0f be 70 ff       	movsbq -0x1(%rax),%rsi
    3bfb:	48 01 f2             	add    %rsi,%rdx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    3bfe:	48 39 c7             	cmp    %rax,%rdi
    3c01:	75 e2                	jne    3be5 <dafs_append_dir_init_entries+0x445>
    hashname = BKDRHash(phn, p_len);
    dafs_de->hname = cpu_to_le64(hashname);
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    3c03:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    hashname = BKDRHash(phn, p_len);
    dafs_de->hname = cpu_to_le64(hashname);
    3c07:	48 c1 e1 07          	shl    $0x7,%rcx
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    3c0b:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    hashname = BKDRHash(phn, p_len);
    dafs_de->hname = cpu_to_le64(hashname);
    3c0f:	49 89 94 0d a8 40 00 	mov    %rdx,0x40a8(%r13,%rcx,1)
    3c16:	00 
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    3c17:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    3c1d:	89 d9                	mov    %ebx,%ecx
    3c1f:	48 8b 70 18          	mov    0x18(%rax),%rsi
    3c23:	e8 00 00 00 00       	callq  3c28 <dafs_append_dir_init_entries+0x488>
    
    /*update dir info entry */
    par_dir->sub_num++;
    3c28:	49 83 47 08 01       	addq   $0x1,0x8(%r15)
    3c2d:	ba 14 00 00 00       	mov    $0x14,%edx
    3c32:	be d0 80 00 00       	mov    $0x80d0,%esi
    3c37:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 3c3e <dafs_append_dir_init_entries+0x49e>
    3c3e:	e8 00 00 00 00       	callq  3c43 <dafs_append_dir_init_entries+0x4a3>
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
    3c43:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
    new_sf->pos = cur_pos;
    3c47:	89 58 10             	mov    %ebx,0x10(%rax)
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    3c4a:	44 89 e1             	mov    %r12d,%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    3c4d:	49 8b 57 20          	mov    0x20(%r15),%rdx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    3c51:	49 89 47 20          	mov    %rax,0x20(%r15)
    3c55:	83 e1 3f             	and    $0x3f,%ecx
    3c58:	83 e9 80             	sub    $0xffffff80,%ecx
	new->next = next;
    3c5b:	48 89 38             	mov    %rdi,(%rax)
	new->prev = prev;
    3c5e:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    3c62:	48 89 02             	mov    %rax,(%rdx)
	if (support_clwb) {
    3c65:	31 d2                	xor    %edx,%edx
    3c67:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 3c6d <dafs_append_dir_init_entries+0x4cd>
    3c6d:	85 c0                	test   %eax,%eax
    3c6f:	74 59                	je     3cca <dafs_append_dir_init_entries+0x52a>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    3c71:	89 d0                	mov    %edx,%eax
    3c73:	4c 01 e0             	add    %r12,%rax
    3c76:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    3c7a:	83 c2 40             	add    $0x40,%edx
    3c7d:	39 d1                	cmp    %edx,%ecx
    3c7f:	77 f0                	ja     3c71 <dafs_append_dir_init_entries+0x4d1>
    list_add_tail(&new_sf->list, &par_dir->sub_file);

    //nova_dbg("%s .. pos is %d",__func__,cur_pos);
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    //kfree(phname);
    kfree(phn);
    3c81:	4c 89 f7             	mov    %r14,%rdi
    3c84:	e8 00 00 00 00       	callq  3c89 <dafs_append_dir_init_entries+0x4e9>
    kfree(zone_p);
    3c89:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    3c8d:	e8 00 00 00 00       	callq  3c92 <dafs_append_dir_init_entries+0x4f2>
    //nova_dbg("dafs finish add initial part in dir");
    return 0;
    3c92:	31 c0                	xor    %eax,%eax
}
    3c94:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    3c98:	65 48 33 3c 25 28 00 	xor    %gs:0x28,%rdi
    3c9f:	00 00 
    3ca1:	0f 85 90 00 00 00    	jne    3d37 <dafs_append_dir_init_entries+0x597>
    3ca7:	48 83 c4 60          	add    $0x60,%rsp
    3cab:	5b                   	pop    %rbx
    3cac:	41 5c                	pop    %r12
    3cae:	41 5d                	pop    %r13
    3cb0:	41 5e                	pop    %r14
    3cb2:	41 5f                	pop    %r15
    3cb4:	5d                   	pop    %rbp
    3cb5:	c3                   	retq   
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    3cb6:	89 d0                	mov    %edx,%eax
    3cb8:	4c 01 d0             	add    %r10,%rax
    3cbb:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    3cbe:	83 c2 40             	add    $0x40,%edx
    3cc1:	39 d1                	cmp    %edx,%ecx
    3cc3:	77 f1                	ja     3cb6 <dafs_append_dir_init_entries+0x516>
    3cc5:	e9 cf fd ff ff       	jmpq   3a99 <dafs_append_dir_init_entries+0x2f9>
			_mm_clflush(buf + i);
    3cca:	89 d0                	mov    %edx,%eax
    3ccc:	4c 01 e0             	add    %r12,%rax
    3ccf:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    3cd2:	83 c2 40             	add    $0x40,%edx
    3cd5:	39 d1                	cmp    %edx,%ecx
    3cd7:	77 f1                	ja     3cca <dafs_append_dir_init_entries+0x52a>
    3cd9:	eb a6                	jmp    3c81 <dafs_append_dir_init_entries+0x4e1>
        }
    }

    /* if not enough entries, negtive split*/
    if(cur_pos == NR_DENTRY_IN_ZONE){
        dafs_split_zone(sb, dzt_ei, 0, NEGTIVE_SPLIT);
    3cdb:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    3cdf:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    3ce3:	31 c9                	xor    %ecx,%ecx
    3ce5:	31 d2                	xor    %edx,%edx
    3ce7:	bb ff ff 00 00       	mov    $0xffff,%ebx
    3cec:	e8 00 00 00 00       	callq  3cf1 <dafs_append_dir_init_entries+0x551>
    3cf1:	b9 ff ff 01 00       	mov    $0x1ffff,%ecx
    3cf6:	e9 48 fb ff ff       	jmpq   3843 <dafs_append_dir_init_entries+0xa3>

    /*set ful_name*/
    p_len += 2;
    dafs_de->fname_len = cpu_to_le64(p_len);
    if(p_len == 3)
        strcat(phn, ".");
    3cfb:	e8 00 00 00 00       	callq  3d00 <dafs_append_dir_init_entries+0x560>
    3d00:	b9 2e 00 00 00       	mov    $0x2e,%ecx
    3d05:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
    3d09:	4c 8b 55 90          	mov    -0x70(%rbp),%r10
    3d0d:	66 41 89 0c 06       	mov    %cx,(%r14,%rax,1)
    3d12:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    3d16:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
    3d1a:	e9 4d fc ff ff       	jmpq   396c <dafs_append_dir_init_entries+0x1cc>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    3d1f:	31 d2                	xor    %edx,%edx
    3d21:	e9 a7 fc ff ff       	jmpq   39cd <dafs_append_dir_init_entries+0x22d>
    3d26:	31 d2                	xor    %edx,%edx
    3d28:	e9 d6 fe ff ff       	jmpq   3c03 <dafs_append_dir_init_entries+0x463>
    3d2d:	41 8d 54 24 03       	lea    0x3(%r12),%edx
    3d32:	e9 b1 fd ff ff       	jmpq   3ae8 <dafs_append_dir_init_entries+0x348>
    //kfree(phname);
    kfree(phn);
    kfree(zone_p);
    //nova_dbg("dafs finish add initial part in dir");
    return 0;
}
    3d37:	e8 00 00 00 00       	callq  3d3c <dafs_append_dir_init_entries+0x59c>
    /*bugbugbugbugbug*/
    //nova_dbg("parent hashname is %llu", par_hn);
    /*update dir info entry */
    par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    if(!par_dir){
        nova_dbg("dafs not find dir entry");
    3d3c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    3d43:	e8 00 00 00 00       	callq  3d48 <dafs_append_dir_init_entries+0x5a8>
        return -EINVAL;
    3d48:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    3d4d:	e9 42 ff ff ff       	jmpq   3c94 <dafs_append_dir_init_entries+0x4f4>
    3d52:	0f 1f 40 00          	nopl   0x0(%rax)
    3d56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d5d:	00 00 00 

0000000000003d60 <dafs_empty_dir>:
    return 0;
}

/*bug 应该检验一下状态图是否有效*/
int dafs_empty_dir(struct inode *inode, struct dentry *dentry)
{
    3d60:	e8 00 00 00 00       	callq  3d65 <dafs_empty_dir+0x5>
    3d65:	55                   	push   %rbp
    3d66:	ba 00 04 00 00       	mov    $0x400,%edx
    3d6b:	48 89 e5             	mov    %rsp,%rbp
    3d6e:	41 57                	push   %r15
    3d70:	41 56                	push   %r14
    3d72:	41 55                	push   %r13
    3d74:	41 54                	push   %r12
    3d76:	49 89 f5             	mov    %rsi,%r13
    3d79:	53                   	push   %rbx
    3d7a:	be d0 80 00 00       	mov    $0x80d0,%esi
    3d7f:	48 83 ec 28          	sub    $0x28,%rsp
    3d83:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    3d8a:	00 00 
    3d8c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    3d90:	31 c0                	xor    %eax,%eax
    struct super_block *sb = inode->i_sb;
    3d92:	48 8b 47 28          	mov    0x28(%rdi),%rax
    3d96:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 3d9d <dafs_empty_dir+0x3d>
    3d9d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    3da1:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    3da8:	00 00 

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    char *ph=NULL, *buf=NULL, *tem=NULL, *mntchar= "/mnt/ramdisk", *end="", *ppath=NULL;
    struct fs_struct *fs = current->fs;
    3daa:	4c 8b b8 30 06 00 00 	mov    0x630(%rax),%r15
    3db1:	e8 00 00 00 00       	callq  3db6 <dafs_empty_dir+0x56>
    3db6:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 3dbd <dafs_empty_dir+0x5d>
    3dbd:	ba 00 04 00 00       	mov    $0x400,%edx
    3dc2:	be d0 80 00 00       	mov    $0x80d0,%esi
    3dc7:	49 89 c6             	mov    %rax,%r14
    3dca:	e8 00 00 00 00       	callq  3dcf <dafs_empty_dir+0x6f>
    3dcf:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 3dd6 <dafs_empty_dir+0x76>
    3dd6:	48 89 c3             	mov    %rax,%rbx
    3dd9:	ba 00 04 00 00       	mov    $0x400,%edx
    3dde:	be d0 80 00 00       	mov    $0x80d0,%esi
    3de3:	e8 00 00 00 00       	callq  3de8 <dafs_empty_dir+0x88>

    //nova_dbg("%s:dafs get dentry path",__func__);
    ph = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    buf = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    tem = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    if(!buf)
    3de8:	48 85 db             	test   %rbx,%rbx
    3deb:	0f 84 2f 01 00 00    	je     3f20 <dafs_empty_dir+0x1c0>
        goto ERR;

    read_lock(&fs->lock);
    3df1:	49 8d 7f 04          	lea    0x4(%r15),%rdi
    3df5:	49 89 c4             	mov    %rax,%r12
    3df8:	e8 00 00 00 00       	callq  3dfd <dafs_empty_dir+0x9d>
    vfsmnt = mntget(fs->pwd.mnt);
    3dfd:	49 8b 7f 28          	mov    0x28(%r15),%rdi
    3e01:	e8 00 00 00 00       	callq  3e06 <dafs_empty_dir+0xa6>
    if(!vfsmnt){
    3e06:	48 85 c0             	test   %rax,%rax
    tem = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    if(!buf)
        goto ERR;

    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    3e09:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    if(!vfsmnt){
    3e0d:	0f 84 0d 01 00 00    	je     3f20 <dafs_empty_dir+0x1c0>
    3e13:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
    3e18:	f0 41 0f c1 47 04    	lock xadd %eax,0x4(%r15)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
    3e1e:	49 8b 75 28          	mov    0x28(%r13),%rsi
    3e22:	49 c7 c7 00 00 00 00 	mov    $0x0,%r15
    3e29:	b9 02 00 00 00       	mov    $0x2,%ecx
    3e2e:	4c 89 ff             	mov    %r15,%rdi
    3e31:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    3e33:	0f 84 a8 03 00 00    	je     41e1 <dafs_empty_dir+0x481>
        strcat(buf,"/");
    3e39:	48 89 df             	mov    %rbx,%rdi
    3e3c:	e8 00 00 00 00       	callq  3e41 <dafs_empty_dir+0xe1>
    3e41:	b9 2f 00 00 00       	mov    $0x2f,%ecx
    3e46:	66 89 0c 03          	mov    %cx,(%rbx,%rax,1)
        ph[1]='\0';
        return ph;
    }

    do{
        strcat(buf, "/");
    3e4a:	48 89 df             	mov    %rbx,%rdi
    3e4d:	e8 00 00 00 00       	callq  3e52 <dafs_empty_dir+0xf2>
    3e52:	ba 2f 00 00 00       	mov    $0x2f,%edx
        strcat(buf, tem_dentry->d_name.name);
    3e57:	48 8d 7c 03 01       	lea    0x1(%rbx,%rax,1),%rdi
        ph[1]='\0';
        return ph;
    }

    do{
        strcat(buf, "/");
    3e5c:	66 89 14 03          	mov    %dx,(%rbx,%rax,1)
        strcat(buf, tem_dentry->d_name.name);
    3e60:	49 8b 75 28          	mov    0x28(%r13),%rsi
    3e64:	e8 00 00 00 00       	callq  3e69 <dafs_empty_dir+0x109>
        p_dentry = tem_dentry->d_parent;
    3e69:	4d 8b 6d 18          	mov    0x18(%r13),%r13
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
    3e6d:	b9 02 00 00 00       	mov    $0x2,%ecx
    3e72:	4c 89 ff             	mov    %r15,%rdi
    3e75:	49 8b 75 28          	mov    0x28(%r13),%rsi
    3e79:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    3e7b:	75 cd                	jne    3e4a <dafs_empty_dir+0xea>
    3e7d:	49 8b 45 30          	mov    0x30(%r13),%rax
    3e81:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
    3e86:	75 c2                	jne    3e4a <dafs_empty_dir+0xea>
            break;
    }while(1);

    BUG_ON(buf==NULL);
    //nova_dbg("%s buf is %s",__func__, buf);
    memcpy(tem, buf, strlen(buf));
    3e88:	48 89 df             	mov    %rbx,%rdi
    3e8b:	e8 00 00 00 00       	callq  3e90 <dafs_empty_dir+0x130>
    3e90:	48 89 de             	mov    %rbx,%rsi
    3e93:	48 89 c2             	mov    %rax,%rdx
    3e96:	4c 89 e7             	mov    %r12,%rdi
    3e99:	e8 00 00 00 00       	callq  3e9e <dafs_empty_dir+0x13e>
    tlen = strlen(buf);
    3e9e:	48 89 df             	mov    %rbx,%rdi
    3ea1:	e8 00 00 00 00       	callq  3ea6 <dafs_empty_dir+0x146>
    3ea6:	49 89 c5             	mov    %rax,%r13
    do{
        ppath = strrchr(tem, '/');
    3ea9:	be 2f 00 00 00       	mov    $0x2f,%esi
    3eae:	4c 89 e7             	mov    %r12,%rdi
    3eb1:	e8 00 00 00 00       	callq  3eb6 <dafs_empty_dir+0x156>
        phlen = tlen - strlen(ppath);
    3eb6:	48 89 c7             	mov    %rax,%rdi
    3eb9:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    3ebd:	e8 00 00 00 00       	callq  3ec2 <dafs_empty_dir+0x162>
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        strcat(ph, ppath);
    3ec2:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    //nova_dbg("%s buf is %s",__func__, buf);
    memcpy(tem, buf, strlen(buf));
    tlen = strlen(buf);
    do{
        ppath = strrchr(tem, '/');
        phlen = tlen - strlen(ppath);
    3ec6:	49 29 c5             	sub    %rax,%r13
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        strcat(ph, ppath);
    3ec9:	4c 89 f7             	mov    %r14,%rdi
    3ecc:	e8 00 00 00 00       	callq  3ed1 <dafs_empty_dir+0x171>
        memcpy(tem, buf, tlen);
    3ed1:	48 89 de             	mov    %rbx,%rsi
    3ed4:	4c 89 e7             	mov    %r12,%rdi
    3ed7:	4c 89 ea             	mov    %r13,%rdx
    3eda:	e8 00 00 00 00       	callq  3edf <dafs_empty_dir+0x17f>
        tem[tlen]='\0';
    3edf:	43 c6 04 2c 00       	movb   $0x0,(%r12,%r13,1)
        //memcpy(tem+tlen, end, 1);
        if(!strcmp(tem,"/"))
    3ee4:	b9 02 00 00 00       	mov    $0x2,%ecx
    3ee9:	4c 89 e6             	mov    %r12,%rsi
    3eec:	4c 89 ff             	mov    %r15,%rdi
    3eef:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    3ef1:	75 b6                	jne    3ea9 <dafs_empty_dir+0x149>
            break;
    }while(1);

    BUG_ON(strlen(ph)==1024);
    3ef3:	4c 89 f7             	mov    %r14,%rdi
    3ef6:	e8 00 00 00 00       	callq  3efb <dafs_empty_dir+0x19b>
    3efb:	48 3d 00 04 00 00    	cmp    $0x400,%rax
    3f01:	0f 84 d8 02 00 00    	je     41df <dafs_empty_dir+0x47f>
    //nova_dbg("%s ful ph is %s",__func__,ph);
    
    mntput(vfsmnt);
    3f07:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    3f0b:	e8 00 00 00 00       	callq  3f10 <dafs_empty_dir+0x1b0>
    
    kfree(buf);
    3f10:	48 89 df             	mov    %rbx,%rdi
    3f13:	e8 00 00 00 00       	callq  3f18 <dafs_empty_dir+0x1b8>
    kfree(tem);
    3f18:	4c 89 e7             	mov    %r12,%rdi
    3f1b:	e8 00 00 00 00       	callq  3f20 <dafs_empty_dir+0x1c0>
    unsigned long nr_de;
    int i, ret;

    //nova_dbg("%s dafs start test empty dir",__func__);
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    3f20:	4c 89 f7             	mov    %r14,%rdi
    3f23:	e8 00 00 00 00       	callq  3f28 <dafs_empty_dir+0x1c8>
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    3f28:	be d0 80 00 00       	mov    $0x80d0,%esi
    3f2d:	48 89 c7             	mov    %rax,%rdi
    3f30:	e8 00 00 00 00       	callq  3f35 <dafs_empty_dir+0x1d5>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    3f35:	4c 89 f7             	mov    %r14,%rdi
    3f38:	49 89 c7             	mov    %rax,%r15
    3f3b:	e8 00 00 00 00       	callq  3f40 <dafs_empty_dir+0x1e0>
    3f40:	be d0 80 00 00       	mov    $0x80d0,%esi
    3f45:	48 89 c7             	mov    %rax,%rdi
    3f48:	e8 00 00 00 00       	callq  3f4d <dafs_empty_dir+0x1ed>
    3f4d:	49 89 c4             	mov    %rax,%r12
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    3f50:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    3f54:	4c 89 f7             	mov    %r14,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    3f57:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
    3f5e:	4c 8b a8 d8 01 00 00 	mov    0x1d8(%rax),%r13
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    3f65:	e8 00 00 00 00       	callq  3f6a <dafs_empty_dir+0x20a>
    3f6a:	4c 89 f6             	mov    %r14,%rsi
    3f6d:	48 89 c2             	mov    %rax,%rdx
    3f70:	4c 89 e7             	mov    %r12,%rdi
    3f73:	e8 00 00 00 00       	callq  3f78 <dafs_empty_dir+0x218>
    tlen = strlen(phstr);
    3f78:	4c 89 f7             	mov    %r14,%rdi
    3f7b:	e8 00 00 00 00       	callq  3f80 <dafs_empty_dir+0x220>
    3f80:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
    3f83:	be 2f 00 00 00       	mov    $0x2f,%esi
    3f88:	4c 89 e7             	mov    %r12,%rdi
    3f8b:	e8 00 00 00 00       	callq  3f90 <dafs_empty_dir+0x230>
        phlen = tlen -strlen(tem);
    3f90:	48 89 c7             	mov    %rax,%rdi
    3f93:	e8 00 00 00 00       	callq  3f98 <dafs_empty_dir+0x238>
        tlen = phlen;
        //bug
        if(phlen==0){
    3f98:	48 29 c3             	sub    %rax,%rbx
    3f9b:	0f 84 ed 01 00 00    	je     418e <dafs_empty_dir+0x42e>
            break;
        }
        memcpy(ph,phstr,tlen);
    3fa1:	48 89 da             	mov    %rbx,%rdx
    3fa4:	4c 89 f6             	mov    %r14,%rsi
    3fa7:	4c 89 e7             	mov    %r12,%rdi
    3faa:	e8 00 00 00 00       	callq  3faf <dafs_empty_dir+0x24f>
	int i;

	for (i = 0; i < length; i++) {
    3faf:	85 db                	test   %ebx,%ebx
        ph[tlen]='\0';
    3fb1:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
    3fb6:	0f 8e ba 01 00 00    	jle    4176 <dafs_empty_dir+0x416>
    3fbc:	8d 43 ff             	lea    -0x1(%rbx),%eax
    3fbf:	4c 89 e2             	mov    %r12,%rdx
    3fc2:	31 f6                	xor    %esi,%esi
    3fc4:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
    3fc9:	48 89 f0             	mov    %rsi,%rax
    3fcc:	48 83 c2 01          	add    $0x1,%rdx
    3fd0:	48 c1 e0 05          	shl    $0x5,%rax
    3fd4:	48 29 f0             	sub    %rsi,%rax
    3fd7:	48 89 c6             	mov    %rax,%rsi
    3fda:	48 0f be 42 ff       	movsbq -0x1(%rdx),%rax
    3fdf:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    3fe2:	48 39 ca             	cmp    %rcx,%rdx
    3fe5:	75 e2                	jne    3fc9 <dafs_empty_dir+0x269>
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    3fe7:	4c 89 ef             	mov    %r13,%rdi
    3fea:	e8 00 00 00 00       	callq  3fef <dafs_empty_dir+0x28f>
        if(dzt_ei){
    3fef:	48 85 c0             	test   %rax,%rax
    3ff2:	74 8f                	je     3f83 <dafs_empty_dir+0x223>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    3ff4:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
    memcpy(ph, "/", 1);
    ph[1]='\0';
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    if(!dzt_ei){
    3ff8:	48 89 c3             	mov    %rax,%rbx
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph));
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    3ffb:	48 8b 40 10          	mov    0x10(%rax),%rax
    phlen = strlen(phn);
    3fff:	4c 89 e7             	mov    %r12,%rdi
    4002:	48 8b 91 b0 03 00 00 	mov    0x3b0(%rcx),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    4009:	49 89 c5             	mov    %rax,%r13
    400c:	4c 03 6a 18          	add    0x18(%rdx),%r13
    4010:	48 85 c0             	test   %rax,%rax
    4013:	b8 00 00 00 00       	mov    $0x0,%eax
    4018:	4c 0f 44 e8          	cmove  %rax,%r13
    401c:	e8 00 00 00 00       	callq  4021 <dafs_empty_dir+0x2c1>
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
    4021:	48 83 f8 01          	cmp    $0x1,%rax
    4025:	0f 84 89 01 00 00    	je     41b4 <dafs_empty_dir+0x454>
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    402b:	4c 89 f7             	mov    %r14,%rdi
    402e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    4032:	e8 00 00 00 00       	callq  4037 <dafs_empty_dir+0x2d7>
    4037:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
        memcpy(phname, ph+phlen, flen);
    403b:	4c 89 ff             	mov    %r15,%rdi
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    403e:	48 29 d0             	sub    %rdx,%rax
        memcpy(phname, ph+phlen, flen);
    4041:	49 8d 34 16          	lea    (%r14,%rdx,1),%rsi
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    4045:	49 89 c4             	mov    %rax,%r12
        memcpy(phname, ph+phlen, flen);
    4048:	48 89 c2             	mov    %rax,%rdx
    404b:	e8 00 00 00 00       	callq  4050 <dafs_empty_dir+0x2f0>
        phname[flen]='\0';
    4050:	43 c6 04 27 00       	movb   $0x0,(%r15,%r12,1)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    4055:	45 85 e4             	test   %r12d,%r12d
    4058:	0f 8e 79 01 00 00    	jle    41d7 <dafs_empty_dir+0x477>
    405e:	41 8d 44 24 ff       	lea    -0x1(%r12),%eax
    4063:	45 31 e4             	xor    %r12d,%r12d
    4066:	49 8d 4c 07 01       	lea    0x1(%r15,%rax,1),%rcx
    406b:	4c 89 f8             	mov    %r15,%rax
		hash = hash * seed + (*str++);
    406e:	4c 89 e2             	mov    %r12,%rdx
    4071:	48 83 c0 01          	add    $0x1,%rax
    4075:	48 c1 e2 05          	shl    $0x5,%rdx
    4079:	4c 29 e2             	sub    %r12,%rdx
    407c:	49 89 d4             	mov    %rdx,%r12
    407f:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    4084:	49 01 d4             	add    %rdx,%r12
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    4087:	48 39 c8             	cmp    %rcx,%rax
    408a:	75 e2                	jne    406e <dafs_empty_dir+0x30e>
    }

    ph_hash = BKDRHash(phname, flen);
    kfree(phname);
    408c:	4c 89 ff             	mov    %r15,%rdi
    408f:	e8 00 00 00 00       	callq  4094 <dafs_empty_dir+0x334>
    kfree(ph);
    4094:	4c 89 f7             	mov    %r14,%rdi
    4097:	e8 00 00 00 00       	callq  409c <dafs_empty_dir+0x33c>
    /*lookup in hash table, not decided*/
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    409c:	48 8b 73 18          	mov    0x18(%rbx),%rsi
    40a0:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    40a4:	4c 8d 45 cc          	lea    -0x34(%rbp),%r8
    40a8:	4c 89 e2             	mov    %r12,%rdx
    40ab:	b9 01 00 00 00       	mov    $0x1,%ecx
    40b0:	e8 00 00 00 00       	callq  40b5 <dafs_empty_dir+0x355>
    if(!ret)
    40b5:	85 c0                	test   %eax,%eax
        return -EINVAL;
    40b7:	ba ea ff ff ff       	mov    $0xffffffea,%edx
    ph_hash = BKDRHash(phname, flen);
    kfree(phname);
    kfree(ph);
    /*lookup in hash table, not decided*/
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    if(!ret)
    40bc:	0f 84 90 00 00 00    	je     4152 <dafs_empty_dir+0x3f2>
        return -EINVAL;

    //direntry = &dafs_ze->dentry[de_pos];
    
    par_dir = radix_tree_lookup(&dzt_ei->dir_tree, ph_hash);
    40c2:	48 8d 7b 38          	lea    0x38(%rbx),%rdi
    40c6:	4c 89 e6             	mov    %r12,%rsi
    40c9:	e8 00 00 00 00       	callq  40ce <dafs_empty_dir+0x36e>
   /* if(par_dir){
        nova_dbg("%s dafs find par dir, num is %d",__func__,par_dir->sub_num);
    }*/
    nr_de = par_dir->sub_num;
    40ce:	4c 8b 58 08          	mov    0x8(%rax),%r11
    if(nr_de > 2)
    40d2:	49 83 fb 02          	cmp    $0x2,%r11
    40d6:	77 78                	ja     4150 <dafs_empty_dir+0x3f0>
        return 0;

    head = &par_dir->sub_file;

    for(i = 0; i < nr_de; i++){
    40d8:	4d 85 db             	test   %r11,%r11
    }*/
    nr_de = par_dir->sub_num;
    if(nr_de > 2)
        return 0;

    head = &par_dir->sub_file;
    40db:	4c 8d 40 18          	lea    0x18(%rax),%r8

    for(i = 0; i < nr_de; i++){
    40df:	74 60                	je     4141 <dafs_empty_dir+0x3e1>
    40e1:	4c 8b 50 18          	mov    0x18(%rax),%r10
    40e5:	45 31 c9             	xor    %r9d,%r9d
        list_for_each(this, head) {
    40e8:	4d 39 d0             	cmp    %r10,%r8
    40eb:	4c 89 d0             	mov    %r10,%rax
    40ee:	8b 55 cc             	mov    -0x34(%rbp),%edx
    40f1:	74 0e                	je     4101 <dafs_empty_dir+0x3a1>
            tem_sf = list_entry(this, struct file_p, list);
            de_pos = tem_sf->pos;
    40f3:	8b 50 10             	mov    0x10(%rax),%edx
    40f6:	89 55 cc             	mov    %edx,-0x34(%rbp)
        return 0;

    head = &par_dir->sub_file;

    for(i = 0; i < nr_de; i++){
        list_for_each(this, head) {
    40f9:	48 8b 00             	mov    (%rax),%rax
    40fc:	49 39 c0             	cmp    %rax,%r8
    40ff:	75 f2                	jne    40f3 <dafs_empty_dir+0x393>
}*/
/*use dafs*/
static inline int is_dir_init_entry(struct super_block *sb,
	struct dafs_dentry *entry)
{
	if (entry->name_len == 1 && strncmp(entry->name, ".", 1) == 0)
    4101:	48 8d 82 81 00 00 00 	lea    0x81(%rdx),%rax
    4108:	48 c1 e0 07          	shl    $0x7,%rax
    410c:	41 0f b6 4c 05 01    	movzbl 0x1(%r13,%rax,1),%ecx
    4112:	80 f9 01             	cmp    $0x1,%cl
    4115:	74 31                	je     4148 <dafs_empty_dir+0x3e8>
		return 1;
	if (entry->name_len == 2 && strncmp(entry->name, "..", 2) == 0)
    4117:	80 f9 02             	cmp    $0x2,%cl
    411a:	75 34                	jne    4150 <dafs_empty_dir+0x3f0>
    411c:	48 c1 e2 07          	shl    $0x7,%rdx
    4120:	b9 02 00 00 00       	mov    $0x2,%ecx
    4125:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    412c:	49 8d b4 15 b0 40 00 	lea    0x40b0(%r13,%rdx,1),%rsi
    4133:	00 
    4134:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    4136:	75 18                	jne    4150 <dafs_empty_dir+0x3f0>
    if(nr_de > 2)
        return 0;

    head = &par_dir->sub_file;

    for(i = 0; i < nr_de; i++){
    4138:	41 83 c1 01          	add    $0x1,%r9d
    413c:	45 39 d9             	cmp    %r11d,%r9d
    413f:	75 a7                	jne    40e8 <dafs_empty_dir+0x388>
        if(!is_dir_init_entry(sb, denties[i]))
            return 0;
    }

    //nova_dbg("%s dir is empty",__func__);
    return 1;
    4141:	ba 01 00 00 00       	mov    $0x1,%edx
    4146:	eb 0a                	jmp    4152 <dafs_empty_dir+0x3f2>
}*/
/*use dafs*/
static inline int is_dir_init_entry(struct super_block *sb,
	struct dafs_dentry *entry)
{
	if (entry->name_len == 1 && strncmp(entry->name, ".", 1) == 0)
    4148:	41 80 7c 05 30 2e    	cmpb   $0x2e,0x30(%r13,%rax,1)
    414e:	74 e8                	je     4138 <dafs_empty_dir+0x3d8>
   /* if(par_dir){
        nova_dbg("%s dafs find par dir, num is %d",__func__,par_dir->sub_num);
    }*/
    nr_de = par_dir->sub_num;
    if(nr_de > 2)
        return 0;
    4150:	31 d2                	xor    %edx,%edx
    }

    //nova_dbg("%s dir is empty",__func__);
    return 1;

}
    4152:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    4156:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    415d:	00 00 
    415f:	89 d0                	mov    %edx,%eax
    4161:	0f 85 9b 00 00 00    	jne    4202 <dafs_empty_dir+0x4a2>
    4167:	48 83 c4 28          	add    $0x28,%rsp
    416b:	5b                   	pop    %rbx
    416c:	41 5c                	pop    %r12
    416e:	41 5d                	pop    %r13
    4170:	41 5e                	pop    %r14
    4172:	41 5f                	pop    %r15
    4174:	5d                   	pop    %rbp
    4175:	c3                   	retq   
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    4176:	31 f6                	xor    %esi,%esi
        memcpy(ph,phstr,tlen);
        ph[tlen]='\0';
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    4178:	4c 89 ef             	mov    %r13,%rdi
    417b:	e8 00 00 00 00       	callq  4180 <dafs_empty_dir+0x420>
        if(dzt_ei){
    4180:	48 85 c0             	test   %rax,%rax
    4183:	0f 84 fa fd ff ff    	je     3f83 <dafs_empty_dir+0x223>
    4189:	e9 66 fe ff ff       	jmpq   3ff4 <dafs_empty_dir+0x294>
            return dzt_ei;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    418e:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    ph[1]='\0';
    4193:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    4199:	be 2f 00 00 00       	mov    $0x2f,%esi
    419e:	4c 89 ef             	mov    %r13,%rdi
    41a1:	e8 00 00 00 00       	callq  41a6 <dafs_empty_dir+0x446>
    if(!dzt_ei){
    41a6:	48 85 c0             	test   %rax,%rax
    41a9:	0f 85 45 fe ff ff    	jne    3ff4 <dafs_empty_dir+0x294>
    41af:	e8 00 00 00 00       	callq  41b4 <dafs_empty_dir+0x454>
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
        flen = strlen(ph);
    41b4:	4c 89 f7             	mov    %r14,%rdi
    41b7:	e8 00 00 00 00       	callq  41bc <dafs_empty_dir+0x45c>
        memcpy(phname, ph, flen);
    41bc:	4c 89 f6             	mov    %r14,%rsi
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
        flen = strlen(ph);
    41bf:	49 89 c4             	mov    %rax,%r12
        memcpy(phname, ph, flen);
    41c2:	48 89 c2             	mov    %rax,%rdx
    41c5:	4c 89 ff             	mov    %r15,%rdi
    41c8:	e8 00 00 00 00       	callq  41cd <dafs_empty_dir+0x46d>
        phname[flen]='\0';
    41cd:	43 c6 04 27 00       	movb   $0x0,(%r15,%r12,1)
    41d2:	e9 7e fe ff ff       	jmpq   4055 <dafs_empty_dir+0x2f5>
    41d7:	45 31 e4             	xor    %r12d,%r12d
    41da:	e9 ad fe ff ff       	jmpq   408c <dafs_empty_dir+0x32c>
        //memcpy(tem+tlen, end, 1);
        if(!strcmp(tem,"/"))
            break;
    }while(1);

    BUG_ON(strlen(ph)==1024);
    41df:	0f 0b                	ud2    
    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
        strcat(buf,"/");
    else{
        nova_dbg("%s root dentry",__func__);
    41e1:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    41e8:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    41ef:	e8 00 00 00 00       	callq  41f4 <dafs_empty_dir+0x494>
        memcpy(ph, "/", 1);
    41f4:	41 c6 06 2f          	movb   $0x2f,(%r14)
        ph[1]='\0';
    41f8:	41 c6 46 01 00       	movb   $0x0,0x1(%r14)
    41fd:	e9 1e fd ff ff       	jmpq   3f20 <dafs_empty_dir+0x1c0>
    }

    //nova_dbg("%s dir is empty",__func__);
    return 1;

}
    4202:	e8 00 00 00 00       	callq  4207 <dafs_empty_dir+0x4a7>
    4207:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    420e:	00 00 

0000000000004210 <add_rename_zone_dir>:

/*add rename zone root dentry
 * dentry 是新的dentry*/
int add_rename_zone_dir(struct dentry *dentry, struct dafs_dentry *old_de, struct dzt_entry_info *old_ei,
        u64 *new_hn, u64 *root_len)
{
    4210:	e8 00 00 00 00       	callq  4215 <add_rename_zone_dir+0x5>
    4215:	55                   	push   %rbp
    4216:	48 89 e5             	mov    %rsp,%rbp
    4219:	41 57                	push   %r15
    421b:	41 56                	push   %r14
    421d:	41 55                	push   %r13
    421f:	41 54                	push   %r12
    4221:	49 89 ff             	mov    %rdi,%r15
    4224:	53                   	push   %rbx
    4225:	48 81 ec c0 00 00 00 	sub    $0xc0,%rsp
    
	/*nova_dbg_verbose("%s: dir %lu new inode %llu\n",
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
    422c:	44 8b 1d 00 00 00 00 	mov    0x0(%rip),%r11d        # 4233 <add_rename_zone_dir+0x23>
{
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
    struct nova_inode *pidir;
    //const char *name = dentry->d_name.name;
    unsigned short namelen = dentry->d_name.len;
    4233:	8b 5f 24             	mov    0x24(%rdi),%ebx

/*add rename zone root dentry
 * dentry 是新的dentry*/
int add_rename_zone_dir(struct dentry *dentry, struct dafs_dentry *old_de, struct dzt_entry_info *old_ei,
        u64 *new_hn, u64 *root_len)
{
    4236:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    423d:	00 00 
    423f:	48 89 84 24 b8 00 00 	mov    %rax,0xb8(%rsp)
    4246:	00 
    4247:	31 c0                	xor    %eax,%eax
    struct inode *dir = dentry->d_parent->d_inode;
    4249:	48 8b 47 18          	mov    0x18(%rdi),%rax

/*add rename zone root dentry
 * dentry 是新的dentry*/
int add_rename_zone_dir(struct dentry *dentry, struct dafs_dentry *old_de, struct dzt_entry_info *old_ei,
        u64 *new_hn, u64 *root_len)
{
    424d:	48 89 74 24 50       	mov    %rsi,0x50(%rsp)
    
	/*nova_dbg_verbose("%s: dir %lu new inode %llu\n",
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
    4252:	45 85 db             	test   %r11d,%r11d

/*add rename zone root dentry
 * dentry 是新的dentry*/
int add_rename_zone_dir(struct dentry *dentry, struct dafs_dentry *old_de, struct dzt_entry_info *old_ei,
        u64 *new_hn, u64 *root_len)
{
    4255:	48 89 54 24 48       	mov    %rdx,0x48(%rsp)
    425a:	48 89 4c 24 40       	mov    %rcx,0x40(%rsp)
    425f:	4c 89 44 24 30       	mov    %r8,0x30(%rsp)
    struct inode *dir = dentry->d_parent->d_inode;
    4264:	48 8b 40 30          	mov    0x30(%rax),%rax
    4268:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
    struct super_block *sb = dir->i_sb;
    426d:	48 8b 40 28          	mov    0x28(%rax),%rax
    4271:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
    
	/*nova_dbg_verbose("%s: dir %lu new inode %llu\n",
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
    4276:	0f 85 1d 08 00 00    	jne    4a99 <add_rename_zone_dir+0x889>
	if (namelen == 0)
    427c:	66 85 db             	test   %bx,%bx
    427f:	0f 84 f3 08 00 00    	je     4b78 <add_rename_zone_dir+0x968>
		return -EINVAL;
   
    ph = get_dentry_path(dentry,0);
    4285:	4c 89 ff             	mov    %r15,%rdi
    4288:	e8 73 be ff ff       	callq  100 <get_dentry_path.isra.4>
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    428d:	48 89 c7             	mov    %rax,%rdi

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
	if (namelen == 0)
		return -EINVAL;
   
    ph = get_dentry_path(dentry,0);
    4290:	49 89 c5             	mov    %rax,%r13
    4293:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    4298:	e8 00 00 00 00       	callq  429d <add_rename_zone_dir+0x8d>
    429d:	48 89 c7             	mov    %rax,%rdi
    42a0:	e8 4b be ff ff       	callq  f0 <kzalloc.constprop.9>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    42a5:	4c 89 ef             	mov    %r13,%rdi
	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
	if (namelen == 0)
		return -EINVAL;
   
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    42a8:	49 89 c6             	mov    %rax,%r14
    42ab:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    42b0:	e8 00 00 00 00       	callq  42b5 <add_rename_zone_dir+0xa5>
    42b5:	48 89 c7             	mov    %rax,%rdi
    42b8:	e8 33 be ff ff       	callq  f0 <kzalloc.constprop.9>
    slen = strlen(ph);
    42bd:	4c 89 ef             	mov    %r13,%rdi
	if (namelen == 0)
		return -EINVAL;
   
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    42c0:	49 89 c4             	mov    %rax,%r12
    slen = strlen(ph);
    42c3:	e8 00 00 00 00       	callq  42c8 <add_rename_zone_dir+0xb8>
    42c8:	89 c3                	mov    %eax,%ebx
    memcpy(phname, ph, slen);
    42ca:	4c 89 ee             	mov    %r13,%rsi
    42cd:	4c 89 f7             	mov    %r14,%rdi
    42d0:	48 89 da             	mov    %rbx,%rdx
    42d3:	e8 00 00 00 00       	callq  42d8 <add_rename_zone_dir+0xc8>
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    42d8:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    slen = strlen(ph);
    memcpy(phname, ph, slen);
    phname[slen]='\0';
    42dd:	41 c6 04 1e 00       	movb   $0x0,(%r14,%rbx,1)
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    42e2:	4c 89 f7             	mov    %r14,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    42e5:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
    42ec:	4c 8b a8 d8 01 00 00 	mov    0x1d8(%rax),%r13
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    42f3:	e8 00 00 00 00       	callq  42f8 <add_rename_zone_dir+0xe8>
    42f8:	4c 89 f6             	mov    %r14,%rsi
    42fb:	48 89 c2             	mov    %rax,%rdx
    42fe:	4c 89 e7             	mov    %r12,%rdi
    4301:	e8 00 00 00 00       	callq  4306 <add_rename_zone_dir+0xf6>
    tlen = strlen(phstr);
    4306:	4c 89 f7             	mov    %r14,%rdi
    4309:	e8 00 00 00 00       	callq  430e <add_rename_zone_dir+0xfe>
    430e:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
    4311:	be 2f 00 00 00       	mov    $0x2f,%esi
    4316:	4c 89 e7             	mov    %r12,%rdi
    4319:	e8 00 00 00 00       	callq  431e <add_rename_zone_dir+0x10e>
        phlen = tlen -strlen(tem);
    431e:	48 89 c7             	mov    %rax,%rdi
    4321:	e8 00 00 00 00       	callq  4326 <add_rename_zone_dir+0x116>
        tlen = phlen;
        //bug
        if(phlen==0){
    4326:	48 29 c3             	sub    %rax,%rbx
    4329:	0f 84 44 06 00 00    	je     4973 <add_rename_zone_dir+0x763>
            break;
        }
        memcpy(ph,phstr,tlen);
    432f:	48 89 da             	mov    %rbx,%rdx
    4332:	4c 89 f6             	mov    %r14,%rsi
    4335:	4c 89 e7             	mov    %r12,%rdi
    4338:	e8 00 00 00 00       	callq  433d <add_rename_zone_dir+0x12d>
	int i;

	for (i = 0; i < length; i++) {
    433d:	85 db                	test   %ebx,%ebx
        ph[tlen]='\0';
    433f:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
    4344:	0f 8e 7e 05 00 00    	jle    48c8 <add_rename_zone_dir+0x6b8>
    434a:	8d 43 ff             	lea    -0x1(%rbx),%eax
    434d:	4c 89 e2             	mov    %r12,%rdx
    4350:	31 f6                	xor    %esi,%esi
    4352:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
    4357:	48 89 f0             	mov    %rsi,%rax
    435a:	48 83 c2 01          	add    $0x1,%rdx
    435e:	48 c1 e0 05          	shl    $0x5,%rax
    4362:	48 29 f0             	sub    %rsi,%rax
    4365:	48 89 c6             	mov    %rax,%rsi
    4368:	48 0f be 42 ff       	movsbq -0x1(%rdx),%rax
    436d:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    4370:	48 39 ca             	cmp    %rcx,%rdx
    4373:	75 e2                	jne    4357 <add_rename_zone_dir+0x147>
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    4375:	4c 89 ef             	mov    %r13,%rdi
    4378:	e8 00 00 00 00       	callq  437d <add_rename_zone_dir+0x16d>
        if(dzt_ei){
    437d:	48 85 c0             	test   %rax,%rax
    4380:	74 8f                	je     4311 <add_rename_zone_dir+0x101>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    4382:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    memcpy(ph, "/", 1);
    ph[1]='\0';
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    if(!dzt_ei){
    4387:	48 89 84 24 80 00 00 	mov    %rax,0x80(%rsp)
    438e:	00 
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    slen = strlen(ph);
    memcpy(phname, ph, slen);
    phname[slen]='\0';
    dzt_ei = find_dzt(sb, phname, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    438f:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
    4396:	00 
    4397:	48 8b 97 b0 03 00 00 	mov    0x3b0(%rdi),%rdx
    439e:	48 8b 40 10          	mov    0x10(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    43a2:	48 89 c7             	mov    %rax,%rdi
    43a5:	48 03 7a 18          	add    0x18(%rdx),%rdi
    43a9:	48 85 c0             	test   %rax,%rax
    43ac:	b8 00 00 00 00       	mov    $0x0,%eax
    43b1:	48 0f 45 c7          	cmovne %rdi,%rax

    make_zone_ptr(&zone_p, dafs_ze);
    43b5:	48 8d bc 24 90 00 00 	lea    0x90(%rsp),%rdi
    43bc:	00 
    struct file_p *tem_sf, *new_sf;
    struct list_head *this, *head, *next;
    char *phname, *new_pn, *ph, *phn, *par_ph, *tname;
    unsigned long phlen;
    //unsigned short delen;
    u32 bitpos = 0, cur_pos = 0, par_pos, slen;
    43bd:	45 31 f6             	xor    %r14d,%r14d
    memcpy(phname, ph, slen);
    phname[slen]='\0';
    dzt_ei = find_dzt(sb, phname, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    43c0:	48 89 c6             	mov    %rax,%rsi
    43c3:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
    43c8:	e8 00 00 00 00       	callq  43cd <add_rename_zone_dir+0x1bd>
    43cd:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
    43d4:	00 
    struct file_p *tem_sf, *new_sf;
    struct list_head *this, *head, *next;
    char *phname, *new_pn, *ph, *phn, *par_ph, *tname;
    unsigned long phlen;
    //unsigned short delen;
    u32 bitpos = 0, cur_pos = 0, par_pos, slen;
    43d5:	31 d2                	xor    %edx,%edx
    43d7:	48 8b 30             	mov    (%rax),%rsi
    memcpy(phname, ph, slen);
    phname[slen]='\0';
    dzt_ei = find_dzt(sb, phname, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    43da:	31 c0                	xor    %eax,%eax
    43dc:	eb 17                	jmp    43f5 <add_rename_zone_dir+0x1e5>
    while(cur_pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
            bitpos+=2;
    43de:	83 c2 02             	add    $0x2,%edx
            cur_pos++;
    43e1:	41 83 c6 01          	add    $0x1,%r14d
    43e5:	48 83 c0 02          	add    $0x2,%rax
    phname[slen]='\0';
    dzt_ei = find_dzt(sb, phname, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    while(cur_pos<NR_DENTRY_IN_ZONE){
    43e9:	81 fa fe ff 01 00    	cmp    $0x1fffe,%edx
    43ef:	0f 84 b6 06 00 00    	je     4aab <add_rename_zone_dir+0x89b>

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    43f5:	48 0f a3 06          	bt     %rax,(%rsi)
    43f9:	19 c9                	sbb    %ecx,%ecx
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
    43fb:	85 c9                	test   %ecx,%ecx
    43fd:	75 df                	jne    43de <add_rename_zone_dir+0x1ce>
    43ff:	48 8d 58 01          	lea    0x1(%rax),%rbx
    4403:	48 0f a3 1e          	bt     %rbx,(%rsi)
    4407:	19 c9                	sbb    %ecx,%ecx
    4409:	85 c9                	test   %ecx,%ecx
    440b:	75 d1                	jne    43de <add_rename_zone_dir+0x1ce>
        }else{
            break;
        }
    }

    phlen = strlen(phn);
    440d:	4c 89 e7             	mov    %r12,%rdi
    4410:	e8 00 00 00 00       	callq  4415 <add_rename_zone_dir+0x205>
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
    4415:	4c 8b 6c 24 58       	mov    0x58(%rsp),%r13
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    441a:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    441f:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    4424:	48 8b 97 b0 03 00 00 	mov    0x3b0(%rdi),%rdx
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
    442b:	49 8b 45 c8          	mov    -0x38(%r13),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    442f:	48 89 c7             	mov    %rax,%rdi
    4432:	48 03 7a 18          	add    0x18(%rdx),%rdi
    4436:	48 85 c0             	test   %rax,%rax
    4439:	b8 00 00 00 00       	mov    $0x0,%eax
    443e:	48 0f 45 c7          	cmovne %rdi,%rax
    4442:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    pidir = nova_get_inode(sb, dir);
    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    4447:	e8 00 00 00 00       	callq  444c <add_rename_zone_dir+0x23c>
    444c:	49 89 45 78          	mov    %rax,0x78(%r13)
    4450:	49 8b 45 78          	mov    0x78(%r13),%rax
    4454:	4c 89 ef             	mov    %r13,%rdi
    //delen = DAFS_DIR_LEN(namelen + phlen);  

    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    4457:	48 8b 74 24 70       	mov    0x70(%rsp),%rsi
        }
    }

    phlen = strlen(phn);
    pidir = nova_get_inode(sb, dir);
    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    445c:	49 c7 85 80 00 00 00 	movq   $0x0,0x80(%r13)
    4463:	00 00 00 00 
    4467:	49 8b 95 80 00 00 00 	mov    0x80(%r13),%rdx
    446e:	49 89 45 68          	mov    %rax,0x68(%r13)
    //delen = DAFS_DIR_LEN(namelen + phlen);  

    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    4472:	44 89 f0             	mov    %r14d,%eax
    4475:	48 89 c1             	mov    %rax,%rcx
    4478:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
    447d:	48 05 81 00 00 00    	add    $0x81,%rax
    4483:	48 c1 e0 07          	shl    $0x7,%rax
        }
    }

    phlen = strlen(phn);
    pidir = nova_get_inode(sb, dir);
    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    4487:	49 89 55 70          	mov    %rdx,0x70(%r13)
    //delen = DAFS_DIR_LEN(namelen + phlen);  

    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    448b:	48 01 f0             	add    %rsi,%rax
    448e:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    4493:	48 89 c8             	mov    %rcx,%rax
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = dentry->d_name.len;
    dafs_de->file_type = ROOT_DIRECTORY;       //file_type是啥？ not decided

	dafs_de->links_count = old_de->links_count;
    4496:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
    449b:	48 c1 e0 07          	shl    $0x7,%rax
    449f:	4c 8d 2c 06          	lea    (%rsi,%rax,1),%r13

    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    //memset(dafs_de, 0, sizeof(dafs_de));
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    44a3:	41 c6 85 80 40 00 00 	movb   $0x6,0x4080(%r13)
    44aa:	06 
    dafs_de->name_len = dentry->d_name.len;
    44ab:	41 8b 57 24          	mov    0x24(%r15),%edx
    dafs_de->file_type = ROOT_DIRECTORY;       //file_type是啥？ not decided
    44af:	41 c6 85 82 40 00 00 	movb   $0x2,0x4082(%r13)
    44b6:	02 
    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    //memset(dafs_de, 0, sizeof(dafs_de));
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = dentry->d_name.len;
    44b7:	41 88 95 81 40 00 00 	mov    %dl,0x4081(%r13)
    dafs_de->file_type = ROOT_DIRECTORY;       //file_type是啥？ not decided

	dafs_de->links_count = old_de->links_count;
    44be:	0f b7 51 06          	movzwl 0x6(%rcx),%edx
    44c2:	66 41 89 95 86 40 00 	mov    %dx,0x4086(%r13)
    44c9:	00 

    dafs_de->mtime = cpu_to_le32(dir->i_mtime.tv_sec);
    44ca:	48 8b 57 68          	mov    0x68(%rdi),%rdx
    44ce:	41 89 95 88 40 00 00 	mov    %edx,0x4088(%r13)
    /*not root at first*/
    //dafs_de->isr_sf = old_de->isr_sf;
    dafs_de->ino = old_de->ino;
    44d5:	48 8b 51 18          	mov    0x18(%rcx),%rdx
    44d9:	49 89 95 98 40 00 00 	mov    %rdx,0x4098(%r13)
    dafs_de->size = cpu_to_le64(dir->i_size);
    44e0:	48 8b 57 50          	mov    0x50(%rdi),%rdx
    44e4:	49 89 95 a0 40 00 00 	mov    %rdx,0x40a0(%r13)
    /*add dentry name*/
    if(dentry->d_name.len <= SMALL_NAME_LEN){
    44eb:	41 83 7f 24 27       	cmpl   $0x27,0x24(%r15)
    44f0:	0f 86 ff 03 00 00    	jbe    48f5 <add_rename_zone_dir+0x6e5>
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
        dafs_de->name[dentry->d_name.len] = '\0'; 

    } else {
        dafs_de->ext_flag = 1;
    44f6:	41 b9 01 00 00 00    	mov    $0x1,%r9d
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, cur_pos, dentry->d_name.len, dentry->d_name.name, 0);
    44fc:	48 8b 8c 24 90 00 00 	mov    0x90(%rsp),%rcx
    4503:	00 
    4504:	48 8b 54 24 70       	mov    0x70(%rsp),%rdx
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
        dafs_de->name[dentry->d_name.len] = '\0'; 

    } else {
        dafs_de->ext_flag = 1;
    4509:	66 45 89 8d 84 40 00 	mov    %r9w,0x4084(%r13)
    4510:	00 
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, cur_pos, dentry->d_name.len, dentry->d_name.name, 0);
    4511:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
    4518:	00 
    4519:	45 89 f0             	mov    %r14d,%r8d
    451c:	49 8b 47 28          	mov    0x28(%r15),%rax
    4520:	48 8b b4 24 80 00 00 	mov    0x80(%rsp),%rsi
    4527:	00 
    4528:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    452d:	48 89 04 24          	mov    %rax,(%rsp)
    4531:	45 8b 4f 24          	mov    0x24(%r15),%r9d
    4535:	e8 00 00 00 00       	callq  453a <add_rename_zone_dir+0x32a>
    }

    dafs_de->fname_len = cpu_to_le64(phlen);
    453a:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
    453f:	48 8b 7c 24 68       	mov    0x68(%rsp),%rdi
    4544:	48 8b 4c 24 70       	mov    0x70(%rsp),%rcx
    4549:	48 c1 e0 07          	shl    $0x7,%rax
    454d:	48 89 bc 01 90 40 00 	mov    %rdi,0x4090(%rcx,%rax,1)
    4554:	00 

    /*set isr_sf, fulname*/
    temlen = phlen - dentry->d_name.len;
    4555:	41 8b 47 24          	mov    0x24(%r15),%eax
    4559:	49 89 ff             	mov    %rdi,%r15
    455c:	49 29 c7             	sub    %rax,%r15
    if(temlen == 1){
    455f:	49 83 ff 01          	cmp    $0x1,%r15
    4563:	0f 85 30 04 00 00    	jne    4999 <add_rename_zone_dir+0x789>
        dafs_de->isr_sf = 1;
    4569:	41 c6 85 83 40 00 00 	movb   $0x1,0x4083(%r13)
    4570:	01 
        dafs_de->par_pos = 0;
    4571:	41 c7 85 8c 40 00 00 	movl   $0x0,0x408c(%r13)
    4578:	00 00 00 00 
        kfree(par_ph);
        
    }

    /*set root dir fulname*/
    if(dafs_de->ext_flag==0){
    457c:	66 41 83 bd 84 40 00 	cmpw   $0x0,0x4084(%r13)
    4583:	00 00 
    4585:	0f 85 aa 03 00 00    	jne    4935 <add_rename_zone_dir+0x725>
        //re_len = SMALL_NAME_LEN - dentry->d_name.len;
        if(phlen<SMALL_NAME_LEN){
    458b:	4c 8b 7c 24 68       	mov    0x68(%rsp),%r15
    4590:	49 83 ff 26          	cmp    $0x26,%r15
    4594:	0f 87 8d 03 00 00    	ja     4927 <add_rename_zone_dir+0x717>
            memcpy(dafs_de->ful_name.f_name, phn, phlen);
    459a:	4c 8b 6c 24 60       	mov    0x60(%rsp),%r13
    459f:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    45a4:	4c 89 fa             	mov    %r15,%rdx
    45a7:	4c 89 e6             	mov    %r12,%rsi
    45aa:	49 c1 e5 07          	shl    $0x7,%r13
    45ae:	4a 8d bc 2f d8 40 00 	lea    0x40d8(%rdi,%r13,1),%rdi
    45b5:	00 
    45b6:	e8 00 00 00 00       	callq  45bb <add_rename_zone_dir+0x3ab>
            dafs_de->ful_name.f_name[phlen]='\0';
    45bb:	4c 03 6c 24 70       	add    0x70(%rsp),%r13
    45c0:	43 c6 84 2f d8 40 00 	movb   $0x0,0x40d8(%r15,%r13,1)
    45c7:	00 00 
    45c9:	45 89 fd             	mov    %r15d,%r13d
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    45cc:	45 85 ed             	test   %r13d,%r13d
    45cf:	0f 8e ad 05 00 00    	jle    4b82 <add_rename_zone_dir+0x972>
    45d5:	41 8d 45 ff          	lea    -0x1(%r13),%eax
    45d9:	45 31 ff             	xor    %r15d,%r15d
    45dc:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
    45e1:	4c 89 e0             	mov    %r12,%rax
		hash = hash * seed + (*str++);
    45e4:	4c 89 fa             	mov    %r15,%rdx
    45e7:	48 83 c0 01          	add    $0x1,%rax
    45eb:	48 c1 e2 05          	shl    $0x5,%rdx
    45ef:	4c 29 fa             	sub    %r15,%rdx
    45f2:	49 89 d7             	mov    %rdx,%r15
    45f5:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    45fa:	49 01 d7             	add    %rdx,%r15
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    45fd:	48 39 c8             	cmp    %rcx,%rax
    4600:	75 e2                	jne    45e4 <add_rename_zone_dir+0x3d4>
    /*get hash value*/
    hashname = BKDRHash(phn, phlen);


    /*get new ei path hashname*/
    if(dzt_ei->dzt_eno!=1){
    4602:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
    4609:	00 
    460a:	83 78 08 01          	cmpl   $0x1,0x8(%rax)
    460e:	0f 84 e8 04 00 00    	je     4afc <add_rename_zone_dir+0x8ec>
        newp_len =(u64)dzt_ei->root_len + phlen;
    4614:	4c 8b 6c 24 68       	mov    0x68(%rsp),%r13
    4619:	4c 03 68 28          	add    0x28(%rax),%r13
        new_pn = kzalloc(sizeof(char)*newp_len, GFP_KERNEL);
    461d:	4c 89 ef             	mov    %r13,%rdi
    4620:	e8 cb ba ff ff       	callq  f0 <kzalloc.constprop.9>
        get_zone_path(sb,dzt_ei, new_pn, phn);
    4625:	48 8b b4 24 80 00 00 	mov    0x80(%rsp),%rsi
    462c:	00 
    462d:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    4632:	4c 89 e1             	mov    %r12,%rcx
    4635:	48 89 c2             	mov    %rax,%rdx
    4638:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    463d:	e8 00 00 00 00       	callq  4642 <add_rename_zone_dir+0x432>
        *root_len = newp_len;
    4642:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    4647:	45 85 ed             	test   %r13d,%r13d
    464a:	4c 8b 44 24 68       	mov    0x68(%rsp),%r8
    464f:	4c 89 28             	mov    %r13,(%rax)
    4652:	0f 8e 32 05 00 00    	jle    4b8a <add_rename_zone_dir+0x97a>
    4658:	41 8d 45 ff          	lea    -0x1(%r13),%eax
    465c:	4c 89 c1             	mov    %r8,%rcx
    465f:	49 8d 74 00 01       	lea    0x1(%r8,%rax,1),%rsi
    4664:	31 c0                	xor    %eax,%eax
		hash = hash * seed + (*str++);
    4666:	48 89 c2             	mov    %rax,%rdx
    4669:	48 83 c1 01          	add    $0x1,%rcx
    466d:	48 c1 e2 05          	shl    $0x5,%rdx
    4671:	48 29 c2             	sub    %rax,%rdx
    4674:	48 89 d0             	mov    %rdx,%rax
    4677:	48 0f be 51 ff       	movsbq -0x1(%rcx),%rdx
    467c:	48 01 d0             	add    %rdx,%rax
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    467f:	48 39 ce             	cmp    %rcx,%rsi
    4682:	75 e2                	jne    4666 <add_rename_zone_dir+0x456>
        *new_hn = BKDRHash(new_pn, newp_len);
    4684:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
    4689:	48 89 07             	mov    %rax,(%rdi)
        kfree(new_pn);
    468c:	4c 89 c7             	mov    %r8,%rdi
    468f:	e8 00 00 00 00       	callq  4694 <add_rename_zone_dir+0x484>
        *root_len = newp_len;
        *new_hn = BKDRHash(new_pn, newp_len);
        kfree(new_pn);
    }

    dafs_de->dzt_hn = cpu_to_le64(*new_hn);
    4694:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
    4699:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    469e:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
    46a3:	48 8b 10             	mov    (%rax),%rdx
    46a6:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
    46ab:	89 f1                	mov    %esi,%ecx
    46ad:	83 e1 3f             	and    $0x3f,%ecx
    46b0:	48 c1 e0 07          	shl    $0x7,%rax
    46b4:	83 e9 80             	sub    $0xffffff80,%ecx
    46b7:	48 89 94 07 a8 40 00 	mov    %rdx,0x40a8(%rdi,%rax,1)
    46be:	00 
	if (support_clwb) {
    46bf:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # 46c5 <add_rename_zone_dir+0x4b5>
    46c5:	31 d2                	xor    %edx,%edx
    46c7:	85 ff                	test   %edi,%edi
    46c9:	0f 85 11 02 00 00    	jne    48e0 <add_rename_zone_dir+0x6d0>
    46cf:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    46d4:	89 d0                	mov    %edx,%eax
    46d6:	48 01 f0             	add    %rsi,%rax
    46d9:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    46dc:	83 c2 40             	add    $0x40,%edx
    46df:	39 d1                	cmp    %edx,%ecx
    46e1:	77 f1                	ja     46d4 <add_rename_zone_dir+0x4c4>
    /*not decided是不是每次写到nvm都需要这个接口*/ 
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    46e3:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
    46ea:	00 
    46eb:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    46ee:	f0 48 0f ab 18       	lock bts %rbx,(%rax)
    46f3:	72 00                	jb     46f5 <add_rename_zone_dir+0x4e5>
    
    dir->i_blocks = pidir->i_blocks;
    46f5:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    46fa:	48 8b 7c 24 58       	mov    0x58(%rsp),%rdi

    /*cpy dir_info*/
    new_dir = add_dir_info(dzt_ei, hashname, cur_pos);
    46ff:	44 89 f2             	mov    %r14d,%edx
    4702:	4c 89 fe             	mov    %r15,%rsi
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    
    dir->i_blocks = pidir->i_blocks;
    4705:	48 8b 40 20          	mov    0x20(%rax),%rax
    4709:	48 89 87 98 00 00 00 	mov    %rax,0x98(%rdi)

    /*cpy dir_info*/
    new_dir = add_dir_info(dzt_ei, hashname, cur_pos);
    4710:	48 8b bc 24 80 00 00 	mov    0x80(%rsp),%rdi
    4717:	00 
    4718:	e8 00 00 00 00       	callq  471d <add_rename_zone_dir+0x50d>
    phlen = le64_to_cpu(old_de->fname_len);
    471d:	4c 8b 6c 24 50       	mov    0x50(%rsp),%r13
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    
    dir->i_blocks = pidir->i_blocks;

    /*cpy dir_info*/
    new_dir = add_dir_info(dzt_ei, hashname, cur_pos);
    4722:	48 89 c3             	mov    %rax,%rbx
    phlen = le64_to_cpu(old_de->fname_len);
    4725:	4d 8b 65 10          	mov    0x10(%r13),%r12
    tname = kzalloc(sizeof(char)*phlen,GFP_KERNEL);
    4729:	4c 89 e7             	mov    %r12,%rdi
    472c:	e8 bf b9 ff ff       	callq  f0 <kzalloc.constprop.9>
    old_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    4731:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    dir->i_blocks = pidir->i_blocks;

    /*cpy dir_info*/
    new_dir = add_dir_info(dzt_ei, hashname, cur_pos);
    phlen = le64_to_cpu(old_de->fname_len);
    tname = kzalloc(sizeof(char)*phlen,GFP_KERNEL);
    4736:	49 89 c2             	mov    %rax,%r10
    4739:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    473e:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    4743:	be 00 00 00 00       	mov    $0x0,%esi
    old_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    4748:	48 8b 57 10          	mov    0x10(%rdi),%rdx
    get_de_name(old_de, old_ze, tname, 1);
    474c:	4c 89 ef             	mov    %r13,%rdi
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    474f:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    4756:	48 89 d1             	mov    %rdx,%rcx
    4759:	48 03 48 18          	add    0x18(%rax),%rcx
    475d:	48 85 d2             	test   %rdx,%rdx
    4760:	4c 89 d2             	mov    %r10,%rdx
    4763:	48 0f 45 f1          	cmovne %rcx,%rsi
    4767:	b9 01 00 00 00       	mov    $0x1,%ecx
    476c:	e8 00 00 00 00       	callq  4771 <add_rename_zone_dir+0x561>
    old_hn = BKDRHash(tname, phlen); 
    old_dir = radix_tree_delete(&old_ei->dir_tree, phlen);
    4771:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    4776:	4c 89 e6             	mov    %r12,%rsi
    4779:	48 83 c7 38          	add    $0x38,%rdi
    477d:	e8 00 00 00 00       	callq  4782 <add_rename_zone_dir+0x572>
    head = &old_dir->sub_file;
    list_for_each_safe(this, next, head){
    4782:	4c 8b 60 18          	mov    0x18(%rax),%r12
    tname = kzalloc(sizeof(char)*phlen,GFP_KERNEL);
    old_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    get_de_name(old_de, old_ze, tname, 1);
    old_hn = BKDRHash(tname, phlen); 
    old_dir = radix_tree_delete(&old_ei->dir_tree, phlen);
    head = &old_dir->sub_file;
    4786:	48 8d 78 18          	lea    0x18(%rax),%rdi
    phlen = le64_to_cpu(old_de->fname_len);
    tname = kzalloc(sizeof(char)*phlen,GFP_KERNEL);
    old_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    get_de_name(old_de, old_ze, tname, 1);
    old_hn = BKDRHash(tname, phlen); 
    old_dir = radix_tree_delete(&old_ei->dir_tree, phlen);
    478a:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    478f:	48 8d 43 18          	lea    0x18(%rbx),%rax
    head = &old_dir->sub_file;
    list_for_each_safe(this, next, head){
    4793:	4c 39 e7             	cmp    %r12,%rdi
    4796:	4d 8b 2c 24          	mov    (%r12),%r13
    479a:	0f 84 90 00 00 00    	je     4830 <add_rename_zone_dir+0x620>
    47a0:	44 89 74 24 60       	mov    %r14d,0x60(%rsp)
    47a5:	4c 89 7c 24 58       	mov    %r15,0x58(%rsp)
    47aa:	4d 89 e6             	mov    %r12,%r14
    47ad:	4d 89 ef             	mov    %r13,%r15
    47b0:	49 89 fc             	mov    %rdi,%r12
    47b3:	49 89 c5             	mov    %rax,%r13
    47b6:	eb 03                	jmp    47bb <add_rename_zone_dir+0x5ab>
    47b8:	49 89 c7             	mov    %rax,%r15
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    47bb:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 47c2 <add_rename_zone_dir+0x5b2>
    47c2:	ba 14 00 00 00       	mov    $0x14,%edx
    47c7:	be d0 80 00 00       	mov    $0x80d0,%esi
    47cc:	e8 00 00 00 00       	callq  47d1 <add_rename_zone_dir+0x5c1>
        tem_sf = list_entry(this, struct file_p, list);
        new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        new_sf->pos = tem_sf->pos;
    47d1:	41 8b 56 10          	mov    0x10(%r14),%edx
        list_add_tail(&new_sf->list, &new_dir->sub_file);
        list_del(&tem_sf->list);
        kfree(tem_sf);
    47d5:	4c 89 f7             	mov    %r14,%rdi
    old_dir = radix_tree_delete(&old_ei->dir_tree, phlen);
    head = &old_dir->sub_file;
    list_for_each_safe(this, next, head){
        tem_sf = list_entry(this, struct file_p, list);
        new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        new_sf->pos = tem_sf->pos;
    47d8:	89 50 10             	mov    %edx,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    47db:	48 8b 53 20          	mov    0x20(%rbx),%rdx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    47df:	48 89 43 20          	mov    %rax,0x20(%rbx)
	new->next = next;
    47e3:	4c 89 28             	mov    %r13,(%rax)
	new->prev = prev;
    47e6:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    47ea:	48 89 02             	mov    %rax,(%rdx)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    47ed:	49 8b 46 08          	mov    0x8(%r14),%rax
    47f1:	49 8b 16             	mov    (%r14),%rdx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    47f4:	48 89 42 08          	mov    %rax,0x8(%rdx)
	prev->next = next;
    47f8:	48 89 10             	mov    %rdx,(%rax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    47fb:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
    4802:	00 ad de 
    4805:	49 89 06             	mov    %rax,(%r14)
	entry->prev = LIST_POISON2;
    4808:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
    480f:	00 ad de 
    4812:	49 89 46 08          	mov    %rax,0x8(%r14)
    4816:	4d 89 fe             	mov    %r15,%r14
        list_add_tail(&new_sf->list, &new_dir->sub_file);
        list_del(&tem_sf->list);
        kfree(tem_sf);
    4819:	e8 00 00 00 00       	callq  481e <add_rename_zone_dir+0x60e>
    old_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    get_de_name(old_de, old_ze, tname, 1);
    old_hn = BKDRHash(tname, phlen); 
    old_dir = radix_tree_delete(&old_ei->dir_tree, phlen);
    head = &old_dir->sub_file;
    list_for_each_safe(this, next, head){
    481e:	4d 39 fc             	cmp    %r15,%r12
    4821:	49 8b 07             	mov    (%r15),%rax
    4824:	75 92                	jne    47b8 <add_rename_zone_dir+0x5a8>
    4826:	44 8b 74 24 60       	mov    0x60(%rsp),%r14d
    482b:	4c 8b 7c 24 58       	mov    0x58(%rsp),%r15
        new_sf->pos = tem_sf->pos;
        list_add_tail(&new_sf->list, &new_dir->sub_file);
        list_del(&tem_sf->list);
        kfree(tem_sf);
    }
    kfree(old_dir);
    4830:	48 8b 7c 24 68       	mov    0x68(%rsp),%rdi
    4835:	e8 00 00 00 00       	callq  483a <add_rename_zone_dir+0x62a>

    /*set pos in hash table for each zone*/
    //hashname = BKDRHash(phn, phlen);
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    483a:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
    4841:	00 
    4842:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    4847:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    484d:	44 89 f1             	mov    %r14d,%ecx
    4850:	4c 89 fa             	mov    %r15,%rdx
    4853:	48 8b 70 18          	mov    0x18(%rax),%rsi
    4857:	e8 00 00 00 00       	callq  485c <add_rename_zone_dir+0x64c>

    kfree(tname);
    485c:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    4861:	e8 00 00 00 00       	callq  4866 <add_rename_zone_dir+0x656>
    kfree(phname);
    4866:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    486b:	e8 00 00 00 00       	callq  4870 <add_rename_zone_dir+0x660>
    kfree(ph);
    4870:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
    4875:	e8 00 00 00 00       	callq  487a <add_rename_zone_dir+0x66a>
    kfree(zone_p);
    487a:	48 8b bc 24 90 00 00 	mov    0x90(%rsp),%rdi
    4881:	00 
    4882:	e8 00 00 00 00       	callq  4887 <add_rename_zone_dir+0x677>
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    4887:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 488d <add_rename_zone_dir+0x67d>
    488d:	85 c0                	test   %eax,%eax
    488f:	0f 85 26 02 00 00    	jne    4abb <add_rename_zone_dir+0x8ab>
    return ret;
    4895:	31 c0                	xor    %eax,%eax

    kfree(tname);
    kfree(phname);
    kfree(ph);
    kfree(zone_p);
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    4897:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 489f <add_rename_zone_dir+0x68f>
    489e:	00 
    return ret;
}
    489f:	48 8b bc 24 b8 00 00 	mov    0xb8(%rsp),%rdi
    48a6:	00 
    48a7:	65 48 33 3c 25 28 00 	xor    %gs:0x28,%rdi
    48ae:	00 00 
    48b0:	0f 85 e7 02 00 00    	jne    4b9d <add_rename_zone_dir+0x98d>
    48b6:	48 81 c4 c0 00 00 00 	add    $0xc0,%rsp
    48bd:	5b                   	pop    %rbx
    48be:	41 5c                	pop    %r12
    48c0:	41 5d                	pop    %r13
    48c2:	41 5e                	pop    %r14
    48c4:	41 5f                	pop    %r15
    48c6:	5d                   	pop    %rbp
    48c7:	c3                   	retq   
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    48c8:	31 f6                	xor    %esi,%esi
        memcpy(ph,phstr,tlen);
        ph[tlen]='\0';
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    48ca:	4c 89 ef             	mov    %r13,%rdi
    48cd:	e8 00 00 00 00       	callq  48d2 <add_rename_zone_dir+0x6c2>
        if(dzt_ei){
    48d2:	48 85 c0             	test   %rax,%rax
    48d5:	0f 84 36 fa ff ff    	je     4311 <add_rename_zone_dir+0x101>
    48db:	e9 a2 fa ff ff       	jmpq   4382 <add_rename_zone_dir+0x172>
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    48e0:	89 d0                	mov    %edx,%eax
    48e2:	48 01 f0             	add    %rsi,%rax
    48e5:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    48e9:	83 c2 40             	add    $0x40,%edx
    48ec:	39 d1                	cmp    %edx,%ecx
    48ee:	77 f0                	ja     48e0 <add_rename_zone_dir+0x6d0>
    48f0:	e9 ee fd ff ff       	jmpq   46e3 <add_rename_zone_dir+0x4d3>
    //dafs_de->isr_sf = old_de->isr_sf;
    dafs_de->ino = old_de->ino;
    dafs_de->size = cpu_to_le64(dir->i_size);
    /*add dentry name*/
    if(dentry->d_name.len <= SMALL_NAME_LEN){
        dafs_de->ext_flag = 0;
    48f5:	45 31 d2             	xor    %r10d,%r10d
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
    48f8:	48 8d bc 06 b0 40 00 	lea    0x40b0(%rsi,%rax,1),%rdi
    48ff:	00 
    //dafs_de->isr_sf = old_de->isr_sf;
    dafs_de->ino = old_de->ino;
    dafs_de->size = cpu_to_le64(dir->i_size);
    /*add dentry name*/
    if(dentry->d_name.len <= SMALL_NAME_LEN){
        dafs_de->ext_flag = 0;
    4900:	66 45 89 95 84 40 00 	mov    %r10w,0x4084(%r13)
    4907:	00 
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
    4908:	41 8b 57 24          	mov    0x24(%r15),%edx
    490c:	49 8b 77 28          	mov    0x28(%r15),%rsi
    4910:	e8 00 00 00 00       	callq  4915 <add_rename_zone_dir+0x705>
        dafs_de->name[dentry->d_name.len] = '\0'; 
    4915:	41 8b 47 24          	mov    0x24(%r15),%eax
    4919:	41 c6 84 05 b0 40 00 	movb   $0x0,0x40b0(%r13,%rax,1)
    4920:	00 00 
    4922:	e9 13 fc ff ff       	jmpq   453a <add_rename_zone_dir+0x32a>
        //re_len = SMALL_NAME_LEN - dentry->d_name.len;
        if(phlen<SMALL_NAME_LEN){
            memcpy(dafs_de->ful_name.f_name, phn, phlen);
            dafs_de->ful_name.f_name[phlen]='\0';
        } else {
            dafs_de->ext_flag = 2;
    4927:	41 b8 02 00 00 00    	mov    $0x2,%r8d
    492d:	66 45 89 85 84 40 00 	mov    %r8w,0x4084(%r13)
    4934:	00 
            ext_de_name(sb, dzt_ei, dafs_ze, zone_p, cur_pos, phlen, phn, 1);
        }
    } else
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, cur_pos, phlen, phn, 1);
    4935:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
    493a:	48 8b 8c 24 90 00 00 	mov    0x90(%rsp),%rcx
    4941:	00 
    4942:	45 89 f0             	mov    %r14d,%r8d
    4945:	48 8b 54 24 70       	mov    0x70(%rsp),%rdx
    494a:	48 8b b4 24 80 00 00 	mov    0x80(%rsp),%rsi
    4951:	00 
    4952:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    4957:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    495e:	00 
    495f:	4c 89 24 24          	mov    %r12,(%rsp)
    4963:	41 89 c1             	mov    %eax,%r9d
    4966:	41 89 c5             	mov    %eax,%r13d
    4969:	e8 00 00 00 00       	callq  496e <add_rename_zone_dir+0x75e>
    496e:	e9 59 fc ff ff       	jmpq   45cc <add_rename_zone_dir+0x3bc>
            return dzt_ei;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    4973:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    ph[1]='\0';
    4978:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    497e:	be 2f 00 00 00       	mov    $0x2f,%esi
    4983:	4c 89 ef             	mov    %r13,%rdi
    4986:	e8 00 00 00 00       	callq  498b <add_rename_zone_dir+0x77b>
    if(!dzt_ei){
    498b:	48 85 c0             	test   %rax,%rax
    498e:	0f 85 ee f9 ff ff    	jne    4382 <add_rename_zone_dir+0x172>
    4994:	e8 00 00 00 00       	callq  4999 <add_rename_zone_dir+0x789>
        dafs_de->isr_sf = 1;
        dafs_de->par_pos = 0;
    }else{
        dafs_de->isr_sf = 0;
        /*set par_pos*/
        par_ph = kzalloc(temlen*sizeof(char), GFP_KERNEL);
    4999:	4c 89 ff             	mov    %r15,%rdi
    temlen = phlen - dentry->d_name.len;
    if(temlen == 1){
        dafs_de->isr_sf = 1;
        dafs_de->par_pos = 0;
    }else{
        dafs_de->isr_sf = 0;
    499c:	41 c6 85 83 40 00 00 	movb   $0x0,0x4083(%r13)
    49a3:	00 
        /*set par_pos*/
        par_ph = kzalloc(temlen*sizeof(char), GFP_KERNEL);
    49a4:	e8 47 b7 ff ff       	callq  f0 <kzalloc.constprop.9>
        temlen--;
    49a9:	49 8d 4f ff          	lea    -0x1(%r15),%rcx
        memcpy(par_ph, phn, temlen);
    49ad:	4c 89 e6             	mov    %r12,%rsi
    49b0:	48 89 c7             	mov    %rax,%rdi
    49b3:	48 89 ca             	mov    %rcx,%rdx
    49b6:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
    49bb:	e8 00 00 00 00       	callq  49c0 <add_rename_zone_dir+0x7b0>
	int i;

	for (i = 0; i < length; i++) {
    49c0:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
    49c5:	49 89 c1             	mov    %rax,%r9
        par_ph[temlen] = '\0';
    49c8:	42 c6 44 38 ff 00    	movb   $0x0,-0x1(%rax,%r15,1)
    49ce:	85 c9                	test   %ecx,%ecx
    49d0:	0f 8e bb 01 00 00    	jle    4b91 <add_rename_zone_dir+0x981>
    49d6:	8d 41 ff             	lea    -0x1(%rcx),%eax
    49d9:	45 31 ff             	xor    %r15d,%r15d
    49dc:	49 8d 4c 01 01       	lea    0x1(%r9,%rax,1),%rcx
    49e1:	4c 89 c8             	mov    %r9,%rax
		hash = hash * seed + (*str++);
    49e4:	4c 89 fa             	mov    %r15,%rdx
    49e7:	48 83 c0 01          	add    $0x1,%rax
    49eb:	48 c1 e2 05          	shl    $0x5,%rdx
    49ef:	4c 29 fa             	sub    %r15,%rdx
    49f2:	49 89 d7             	mov    %rdx,%r15
    49f5:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    49fa:	49 01 d7             	add    %rdx,%r15
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    49fd:	48 39 c8             	cmp    %rcx,%rax
    4a00:	75 e2                	jne    49e4 <add_rename_zone_dir+0x7d4>
        //memcpy(par_ph+temlen, end, 1);
        par_hash = BKDRHash(par_ph, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
    4a02:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
    4a09:	00 
    4a0a:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    4a0f:	4c 8d 84 24 8c 00 00 	lea    0x8c(%rsp),%r8
    4a16:	00 
    4a17:	b9 01 00 00 00       	mov    $0x1,%ecx
    4a1c:	4c 89 fa             	mov    %r15,%rdx
    4a1f:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
    4a24:	48 8b 70 18          	mov    0x18(%rax),%rsi
    4a28:	e8 00 00 00 00       	callq  4a2d <add_rename_zone_dir+0x81d>
        dafs_de->par_pos = cpu_to_le32(par_pos);
    4a2d:	8b 84 24 8c 00 00 00 	mov    0x8c(%rsp),%eax

        /*set sub file pos*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    4a34:	4c 89 fe             	mov    %r15,%rsi
        memcpy(par_ph, phn, temlen);
        par_ph[temlen] = '\0';
        //memcpy(par_ph+temlen, end, 1);
        par_hash = BKDRHash(par_ph, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
        dafs_de->par_pos = cpu_to_le32(par_pos);
    4a37:	41 89 85 8c 40 00 00 	mov    %eax,0x408c(%r13)

        /*set sub file pos*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    4a3e:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
    4a45:	00 
    4a46:	48 8d 78 38          	lea    0x38(%rax),%rdi
    4a4a:	e8 00 00 00 00       	callq  4a4f <add_rename_zone_dir+0x83f>
        pdir->sub_num++;
    4a4f:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
        par_hash = BKDRHash(par_ph, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
        dafs_de->par_pos = cpu_to_le32(par_pos);

        /*set sub file pos*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    4a54:	49 89 c7             	mov    %rax,%r15
    4a57:	ba 14 00 00 00       	mov    $0x14,%edx
    4a5c:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 4a63 <add_rename_zone_dir+0x853>
    4a63:	be d0 80 00 00       	mov    $0x80d0,%esi
        pdir->sub_num++;
        tem_sf = (struct file_p *)kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = cur_pos;
        list_add_tail(&tem_sf->list, &pdir->sub_file);
    4a68:	49 83 c7 18          	add    $0x18,%r15
    4a6c:	e8 00 00 00 00       	callq  4a71 <add_rename_zone_dir+0x861>
        kfree(par_ph);
    4a71:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9

        /*set sub file pos*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        pdir->sub_num++;
        tem_sf = (struct file_p *)kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = cur_pos;
    4a76:	44 89 70 10          	mov    %r14d,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    4a7a:	49 8b 57 08          	mov    0x8(%r15),%rdx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    4a7e:	49 89 47 08          	mov    %rax,0x8(%r15)
        list_add_tail(&tem_sf->list, &pdir->sub_file);
    4a82:	4c 89 38             	mov    %r15,(%rax)
        kfree(par_ph);
    4a85:	4c 89 cf             	mov    %r9,%rdi
	new->next = next;
	new->prev = prev;
    4a88:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    4a8c:	48 89 02             	mov    %rax,(%rdx)
    4a8f:	e8 00 00 00 00       	callq  4a94 <add_rename_zone_dir+0x884>
    4a94:	e9 e3 fa ff ff       	jmpq   457c <add_rename_zone_dir+0x36c>
    4a99:	48 8d bc 24 98 00 00 	lea    0x98(%rsp),%rdi
    4aa0:	00 
    4aa1:	e8 00 00 00 00       	callq  4aa6 <add_rename_zone_dir+0x896>
    4aa6:	e9 d1 f7 ff ff       	jmpq   427c <add_rename_zone_dir+0x6c>
    4aab:	bb ff ff 01 00       	mov    $0x1ffff,%ebx
    4ab0:	41 be ff ff 00 00    	mov    $0xffff,%r14d
    4ab6:	e9 52 f9 ff ff       	jmpq   440d <add_rename_zone_dir+0x1fd>
    4abb:	48 8d bc 24 a8 00 00 	lea    0xa8(%rsp),%rdi
    4ac2:	00 
    4ac3:	e8 00 00 00 00       	callq  4ac8 <add_rename_zone_dir+0x8b8>

    kfree(tname);
    kfree(phname);
    kfree(ph);
    kfree(zone_p);
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    4ac8:	48 8b 84 24 a8 00 00 	mov    0xa8(%rsp),%rax
    4acf:	00 
    4ad0:	48 2b 84 24 98 00 00 	sub    0x98(%rsp),%rax
    4ad7:	00 
    4ad8:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    4adf:	48 2b 84 24 a0 00 00 	sub    0xa0(%rsp),%rax
    4ae6:	00 
    4ae7:	48 03 84 24 b0 00 00 	add    0xb0(%rsp),%rax
    4aee:	00 
    4aef:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 4af7 <add_rename_zone_dir+0x8e7>
    4af6:	00 
    4af7:	e9 99 fd ff ff       	jmpq   4895 <add_rename_zone_dir+0x685>
        *root_len = newp_len;
        *new_hn = BKDRHash(new_pn, newp_len);
        kfree(new_pn);
    } else {
        newp_len = phlen;
        new_pn = kzalloc(sizeof(char *)*newp_len, GFP_KERNEL);
    4afc:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
    4b01:	48 8d 3c c5 00 00 00 	lea    0x0(,%rax,8),%rdi
    4b08:	00 
    4b09:	e8 e2 b5 ff ff       	callq  f0 <kzalloc.constprop.9>
        memcpy(new_pn, phn, newp_len);
    4b0e:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
    4b13:	48 89 c7             	mov    %rax,%rdi
    4b16:	4c 89 e6             	mov    %r12,%rsi
    4b19:	e8 00 00 00 00       	callq  4b1e <add_rename_zone_dir+0x90e>
        new_pn[newp_len]='\0';
        *root_len = newp_len;
    4b1e:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
        *new_hn = BKDRHash(new_pn, newp_len);
        kfree(new_pn);
    } else {
        newp_len = phlen;
        new_pn = kzalloc(sizeof(char *)*newp_len, GFP_KERNEL);
        memcpy(new_pn, phn, newp_len);
    4b23:	48 89 c1             	mov    %rax,%rcx
        new_pn[newp_len]='\0';
    4b26:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
    4b2b:	45 85 ed             	test   %r13d,%r13d
    4b2e:	c6 04 01 00          	movb   $0x0,(%rcx,%rax,1)
        *root_len = newp_len;
    4b32:	48 89 07             	mov    %rax,(%rdi)
    4b35:	7e 62                	jle    4b99 <add_rename_zone_dir+0x989>
    4b37:	41 8d 45 ff          	lea    -0x1(%r13),%eax
    4b3b:	48 89 ce             	mov    %rcx,%rsi
    4b3e:	48 8d 7c 01 01       	lea    0x1(%rcx,%rax,1),%rdi
    4b43:	31 c0                	xor    %eax,%eax
		hash = hash * seed + (*str++);
    4b45:	48 89 c2             	mov    %rax,%rdx
    4b48:	48 83 c6 01          	add    $0x1,%rsi
    4b4c:	48 c1 e2 05          	shl    $0x5,%rdx
    4b50:	48 29 c2             	sub    %rax,%rdx
    4b53:	48 89 d0             	mov    %rdx,%rax
    4b56:	48 0f be 56 ff       	movsbq -0x1(%rsi),%rdx
    4b5b:	48 01 d0             	add    %rdx,%rax
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    4b5e:	48 39 f7             	cmp    %rsi,%rdi
    4b61:	75 e2                	jne    4b45 <add_rename_zone_dir+0x935>
        *new_hn = BKDRHash(new_pn, newp_len);
    4b63:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
    4b68:	48 89 07             	mov    %rax,(%rdi)
        kfree(new_pn);
    4b6b:	48 89 cf             	mov    %rcx,%rdi
    4b6e:	e8 00 00 00 00       	callq  4b73 <add_rename_zone_dir+0x963>
    4b73:	e9 1c fb ff ff       	jmpq   4694 <add_rename_zone_dir+0x484>
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
	if (namelen == 0)
		return -EINVAL;
    4b78:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    4b7d:	e9 1d fd ff ff       	jmpq   489f <add_rename_zone_dir+0x68f>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    4b82:	45 31 ff             	xor    %r15d,%r15d
    4b85:	e9 78 fa ff ff       	jmpq   4602 <add_rename_zone_dir+0x3f2>
    4b8a:	31 c0                	xor    %eax,%eax
    4b8c:	e9 f3 fa ff ff       	jmpq   4684 <add_rename_zone_dir+0x474>
    4b91:	45 31 ff             	xor    %r15d,%r15d
    4b94:	e9 69 fe ff ff       	jmpq   4a02 <add_rename_zone_dir+0x7f2>
    4b99:	31 c0                	xor    %eax,%eax
    4b9b:	eb c6                	jmp    4b63 <add_rename_zone_dir+0x953>
    kfree(phname);
    kfree(ph);
    kfree(zone_p);
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    return ret;
}
    4b9d:	e8 00 00 00 00       	callq  4ba2 <add_rename_zone_dir+0x992>
    4ba2:	0f 1f 40 00          	nopl   0x0(%rax)
    4ba6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    4bad:	00 00 00 

0000000000004bb0 <__rename_dir>:
 * n_ze是new_dentry所在的zone
 * path是新的目录的字符串
 * name纯的文件名*/
int __rename_dir(struct super_block *sb, struct dafs_dentry *src_de, \
        struct dzt_entry_info *dzt_ei, struct dzt_entry_info *old_ei, const char *path, char *name)
{
    4bb0:	e8 00 00 00 00       	callq  4bb5 <__rename_dir+0x5>
    4bb5:	55                   	push   %rbp
    4bb6:	48 89 f8             	mov    %rdi,%rax
    4bb9:	48 89 e5             	mov    %rsp,%rbp
    4bbc:	41 57                	push   %r15
    4bbe:	41 56                	push   %r14
    4bc0:	41 55                	push   %r13
    4bc2:	41 54                	push   %r12
    4bc4:	4d 89 ce             	mov    %r9,%r14
    4bc7:	53                   	push   %rbx
    4bc8:	48 89 d3             	mov    %rdx,%rbx
    4bcb:	4d 89 c4             	mov    %r8,%r12
    4bce:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    4bd5:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
    4bd9:	48 8b 90 b0 03 00 00 	mov    0x3b0(%rax),%rdx
    4be0:	48 89 bd 70 ff ff ff 	mov    %rdi,-0x90(%rbp)
    4be7:	48 89 b5 30 ff ff ff 	mov    %rsi,-0xd0(%rbp)
    4bee:	65 48 8b 3c 25 28 00 	mov    %gs:0x28,%rdi
    4bf5:	00 00 
    4bf7:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
    4bfb:	31 ff                	xor    %edi,%edi
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct zone_ptr *z_p;
    struct dafs_dentry *new_de, *sub_de, *par_de;
    struct dafs_zone_entry *ze, *o_ze;
    struct dzt_entry_info *ch_ei;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    4bfd:	48 8b 82 d8 01 00 00 	mov    0x1d8(%rdx),%rax
    u64 hashname, dzt_hn, ch_len, sub_len, old_hn, par_hash, rn_len;
    char *end="";

    //nova_dbg("%s start",__func__);
    ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    make_zone_ptr(&z_p, ze);
    4c04:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
 * n_ze是new_dentry所在的zone
 * path是新的目录的字符串
 * name纯的文件名*/
int __rename_dir(struct super_block *sb, struct dafs_dentry *src_de, \
        struct dzt_entry_info *dzt_ei, struct dzt_entry_info *old_ei, const char *path, char *name)
{
    4c08:	48 89 8d 20 ff ff ff 	mov    %rcx,-0xe0(%rbp)
    4c0f:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct zone_ptr *z_p;
    struct dafs_dentry *new_de, *sub_de, *par_de;
    struct dafs_zone_entry *ze, *o_ze;
    struct dzt_entry_info *ch_ei;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    4c13:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
    char *new_ph, *s_name, *sub_ph, *ch_ph, *tem, *r_name;
    u64 hashname, dzt_hn, ch_len, sub_len, old_hn, par_hash, rn_len;
    char *end="";

    //nova_dbg("%s start",__func__);
    ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    4c1a:	48 8b 43 10          	mov    0x10(%rbx),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    4c1e:	48 89 c3             	mov    %rax,%rbx
    4c21:	48 03 5a 18          	add    0x18(%rdx),%rbx
    4c25:	48 85 c0             	test   %rax,%rax
    4c28:	b8 00 00 00 00       	mov    $0x0,%eax
    4c2d:	48 0f 45 c3          	cmovne %rbx,%rax
    make_zone_ptr(&z_p, ze);
    4c31:	48 89 c6             	mov    %rax,%rsi
    4c34:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    4c38:	e8 00 00 00 00       	callq  4c3d <__rename_dir+0x8d>

    nlen = strlen(name);
    4c3d:	4c 89 f7             	mov    %r14,%rdi
    4c40:	e8 00 00 00 00       	callq  4c45 <__rename_dir+0x95>
    flen = strlen(path);
    4c45:	4c 89 e7             	mov    %r12,%rdi

    //nova_dbg("%s start",__func__);
    ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    make_zone_ptr(&z_p, ze);

    nlen = strlen(name);
    4c48:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    flen = strlen(path);
    4c4c:	e8 00 00 00 00       	callq  4c51 <__rename_dir+0xa1>
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    4c51:	48 8d 78 01          	lea    0x1(%rax),%rdi
    //nova_dbg("%s start",__func__);
    ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    make_zone_ptr(&z_p, ze);

    nlen = strlen(name);
    flen = strlen(path);
    4c55:	48 89 c3             	mov    %rax,%rbx
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    4c58:	e8 93 b4 ff ff       	callq  f0 <kzalloc.constprop.9>
    memcpy(new_ph, path, flen);
    4c5d:	48 89 da             	mov    %rbx,%rdx
    ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    make_zone_ptr(&z_p, ze);

    nlen = strlen(name);
    flen = strlen(path);
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    4c60:	49 89 c6             	mov    %rax,%r14
    memcpy(new_ph, path, flen);
    4c63:	4c 89 e6             	mov    %r12,%rsi
    4c66:	48 89 c7             	mov    %rax,%rdi
    ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    make_zone_ptr(&z_p, ze);

    nlen = strlen(name);
    flen = strlen(path);
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    4c69:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
    memcpy(new_ph, path, flen);
    4c70:	e8 00 00 00 00       	callq  4c75 <__rename_dir+0xc5>
    new_ph[flen]='\0';
    4c75:	41 c6 04 1e 00       	movb   $0x0,(%r14,%rbx,1)
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
    4c7a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    4c7e:	4c 8b 40 08          	mov    0x8(%rax),%r8
    4c82:	4d 85 c0             	test   %r8,%r8
    4c85:	0f 84 e1 0e 00 00    	je     5b6c <__rename_dir+0xfbc>
    4c8b:	48 8b 38             	mov    (%rax),%rdi
    4c8e:	31 c9                	xor    %ecx,%ecx
    4c90:	31 d2                	xor    %edx,%edx
    4c92:	eb 05                	jmp    4c99 <__rename_dir+0xe9>
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
            bitpos+=2;
            dir_pos++;
    4c94:	44 89 c9             	mov    %r9d,%ecx
    memcpy(new_ph, path, flen);
    new_ph[flen]='\0';
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
            bitpos+=2;
    4c97:	89 c2                	mov    %eax,%edx

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    4c99:	48 63 c2             	movslq %edx,%rax
    4c9c:	48 0f a3 07          	bt     %rax,(%rdi)
    4ca0:	19 c0                	sbb    %eax,%eax
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    memcpy(new_ph, path, flen);
    new_ph[flen]='\0';
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
    4ca2:	85 c0                	test   %eax,%eax
    4ca4:	75 15                	jne    4cbb <__rename_dir+0x10b>
    4ca6:	44 8d 62 01          	lea    0x1(%rdx),%r12d
    4caa:	4d 63 e4             	movslq %r12d,%r12
    4cad:	4c 0f a3 27          	bt     %r12,(%rdi)
    4cb1:	19 c0                	sbb    %eax,%eax
    4cb3:	85 c0                	test   %eax,%eax
    4cb5:	0f 84 b7 0d 00 00    	je     5a72 <__rename_dir+0xec2>
            bitpos+=2;
    4cbb:	8d 72 02             	lea    0x2(%rdx),%esi
            dir_pos++;
    4cbe:	44 8d 49 01          	lea    0x1(%rcx),%r9d
    flen = strlen(path);
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    memcpy(new_ph, path, flen);
    new_ph[flen]='\0';
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
    4cc2:	4c 39 c6             	cmp    %r8,%rsi
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
            bitpos+=2;
    4cc5:	48 89 f0             	mov    %rsi,%rax
    flen = strlen(path);
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    memcpy(new_ph, path, flen);
    new_ph[flen]='\0';
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
    4cc8:	72 ca                	jb     4c94 <__rename_dir+0xe4>
    4cca:	44 8d 62 03          	lea    0x3(%rdx),%r12d
    4cce:	44 8d 69 02          	lea    0x2(%rcx),%r13d
    4cd2:	44 8d 7a 04          	lea    0x4(%rdx),%r15d
    4cd6:	44 89 8d 54 ff ff ff 	mov    %r9d,-0xac(%rbp)
    4cdd:	4d 63 e4             	movslq %r12d,%r12
            dir_pos++;
        }else{
            break;
        }
    }
    new_de = &ze->dentry[dir_pos];
    4ce0:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
    par_id = dir_pos;
    //memset(new_de, 0, sizeof(new_de));    
    new_de->entry_type = src_de->entry_type;
    4ce6:	48 8b b5 30 ff ff ff 	mov    -0xd0(%rbp),%rsi
            dir_pos++;
        }else{
            break;
        }
    }
    new_de = &ze->dentry[dir_pos];
    4ced:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    par_id = dir_pos;
    //memset(new_de, 0, sizeof(new_de));    
    new_de->entry_type = src_de->entry_type;
    new_de->name_len = nlen;
    4cf1:	0f b6 4d b0          	movzbl -0x50(%rbp),%ecx
            dir_pos++;
        }else{
            break;
        }
    }
    new_de = &ze->dentry[dir_pos];
    4cf5:	48 89 c2             	mov    %rax,%rdx
    4cf8:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    4cfc:	4c 8d b0 81 00 00 00 	lea    0x81(%rax),%r14
    par_id = dir_pos;
    //memset(new_de, 0, sizeof(new_de));    
    new_de->entry_type = src_de->entry_type;
    4d03:	0f b6 06             	movzbl (%rsi),%eax
    4d06:	48 c1 e2 07          	shl    $0x7,%rdx
    4d0a:	4c 8d 14 17          	lea    (%rdi,%rdx,1),%r10
            dir_pos++;
        }else{
            break;
        }
    }
    new_de = &ze->dentry[dir_pos];
    4d0e:	49 c1 e6 07          	shl    $0x7,%r14
    4d12:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
    4d16:	49 01 fe             	add    %rdi,%r14
    par_id = dir_pos;
    //memset(new_de, 0, sizeof(new_de));    
    new_de->entry_type = src_de->entry_type;
    new_de->name_len = nlen;
    4d19:	41 88 8a 81 40 00 00 	mov    %cl,0x4081(%r10)
    new_de->file_type = src_de->file_type;       //file_type是啥？ not decided
	new_de->links_count = src_de->links_count;
    4d20:	4c 89 55 a0          	mov    %r10,-0x60(%rbp)
        }
    }
    new_de = &ze->dentry[dir_pos];
    par_id = dir_pos;
    //memset(new_de, 0, sizeof(new_de));    
    new_de->entry_type = src_de->entry_type;
    4d24:	41 88 82 80 40 00 00 	mov    %al,0x4080(%r10)
    new_de->name_len = nlen;
    new_de->file_type = src_de->file_type;       //file_type是啥？ not decided
    4d2b:	0f b6 46 02          	movzbl 0x2(%rsi),%eax
    4d2f:	41 88 82 82 40 00 00 	mov    %al,0x4082(%r10)
	new_de->links_count = src_de->links_count;
    4d36:	0f b7 46 06          	movzwl 0x6(%rsi),%eax
    4d3a:	66 41 89 82 86 40 00 	mov    %ax,0x4086(%r10)
    4d41:	00 
    //new_de->de_len = cpu_to_le16(delen);  
    new_de->mtime = cpu_to_le32(CURRENT_TIME_SEC.tv_sec);
    4d42:	e8 00 00 00 00       	callq  4d47 <__rename_dir+0x197>
    4d47:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
    //new_de->isr_sf = src_de->isr_sf;
    new_de->ino = src_de->ino;
    4d4b:	48 8b b5 30 ff ff ff 	mov    -0xd0(%rbp),%rsi
    new_de->entry_type = src_de->entry_type;
    new_de->name_len = nlen;
    new_de->file_type = src_de->file_type;       //file_type是啥？ not decided
	new_de->links_count = src_de->links_count;
    //new_de->de_len = cpu_to_le16(delen);  
    new_de->mtime = cpu_to_le32(CURRENT_TIME_SEC.tv_sec);
    4d52:	41 89 82 88 40 00 00 	mov    %eax,0x4088(%r10)
    //new_de->isr_sf = src_de->isr_sf;
    new_de->ino = src_de->ino;
    4d59:	48 8b 46 18          	mov    0x18(%rsi),%rax
    4d5d:	49 89 82 98 40 00 00 	mov    %rax,0x4098(%r10)
    
    new_de->size = src_de->size;
    4d64:	48 8b 46 20          	mov    0x20(%rsi),%rax
    4d68:	49 89 82 a0 40 00 00 	mov    %rax,0x40a0(%r10)
    /*set name*/
    if(nlen<=SMALL_NAME_LEN){
    4d6f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    4d73:	48 83 f8 27          	cmp    $0x27,%rax
    4d77:	0f 87 a4 07 00 00    	ja     5521 <__rename_dir+0x971>
        new_de->ext_flag = 0;
        memcpy(new_de->name, name, nlen);
    4d7d:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
    4d81:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    new_de->ino = src_de->ino;
    
    new_de->size = src_de->size;
    /*set name*/
    if(nlen<=SMALL_NAME_LEN){
        new_de->ext_flag = 0;
    4d85:	45 31 c9             	xor    %r9d,%r9d
        memcpy(new_de->name, name, nlen);
    4d88:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
    new_de->ino = src_de->ino;
    
    new_de->size = src_de->size;
    /*set name*/
    if(nlen<=SMALL_NAME_LEN){
        new_de->ext_flag = 0;
    4d8c:	66 45 89 8a 84 40 00 	mov    %r9w,0x4084(%r10)
    4d93:	00 
        memcpy(new_de->name, name, nlen);
    4d94:	48 8d bc 17 b0 40 00 	lea    0x40b0(%rdi,%rdx,1),%rdi
    4d9b:	00 
    4d9c:	48 89 c2             	mov    %rax,%rdx
    4d9f:	e8 00 00 00 00       	callq  4da4 <__rename_dir+0x1f4>
        new_de->name[nlen] = '\0';
    4da4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    4da8:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
    4dac:	41 c6 84 02 b0 40 00 	movb   $0x0,0x40b0(%r10,%rax,1)
    4db3:	00 00 
    } else {
        new_de->ext_flag = 1;
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, nlen, name, 0);
    }
    new_de->fname_len = cpu_to_le64(flen);
    4db5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    4db9:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
    4dbd:	48 c1 e0 07          	shl    $0x7,%rax
    4dc1:	48 8d 0c 06          	lea    (%rsi,%rax,1),%rcx
    4dc5:	48 89 99 90 40 00 00 	mov    %rbx,0x4090(%rcx)
    
    /*set dir fulname*/
    if(new_de->ext_flag==0){
    4dcc:	66 41 83 ba 84 40 00 	cmpw   $0x0,0x4084(%r10)
    4dd3:	00 00 
        new_de->name[nlen] = '\0';
    } else {
        new_de->ext_flag = 1;
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, nlen, name, 0);
    }
    new_de->fname_len = cpu_to_le64(flen);
    4dd5:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    
    /*set dir fulname*/
    if(new_de->ext_flag==0){
    4dd9:	0f 85 82 00 00 00    	jne    4e61 <__rename_dir+0x2b1>
        if(flen<SMALL_NAME_LEN){
    4ddf:	48 83 fb 26          	cmp    $0x26,%rbx
    4de3:	77 6f                	ja     4e54 <__rename_dir+0x2a4>
            memcpy(new_de->ful_name.f_name, new_ph, flen);
    4de5:	48 8d bc 06 d8 40 00 	lea    0x40d8(%rsi,%rax,1),%rdi
    4dec:	00 
    4ded:	48 8b b5 58 ff ff ff 	mov    -0xa8(%rbp),%rsi
    4df4:	48 89 da             	mov    %rbx,%rdx
    4df7:	4c 89 55 98          	mov    %r10,-0x68(%rbp)
    4dfb:	e8 00 00 00 00       	callq  4e00 <__rename_dir+0x250>
            new_de->ful_name.f_name[flen]='\0';
    4e00:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
    4e04:	4c 8b 55 98          	mov    -0x68(%rbp),%r10
    4e08:	c6 84 0b d8 40 00 00 	movb   $0x0,0x40d8(%rbx,%rcx,1)
    4e0f:	00 
    } else
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, flen, new_ph, 1);

    /*set par_pos and subpos in par
     * set isr_sf*/
    temlen = flen - nlen;
    4e10:	48 2b 5d b0          	sub    -0x50(%rbp),%rbx
    if(temlen == 1){
    4e14:	48 83 fb 01          	cmp    $0x1,%rbx
    4e18:	0f 85 8e 00 00 00    	jne    4eac <__rename_dir+0x2fc>
        new_de->isr_sf = 1;
        new_de->par_pos = 0;
        par_de = &ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
    4e1e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax

    /*set par_pos and subpos in par
     * set isr_sf*/
    temlen = flen - nlen;
    if(temlen == 1){
        new_de->isr_sf = 1;
    4e22:	41 c6 82 83 40 00 00 	movb   $0x1,0x4083(%r10)
    4e29:	01 
        new_de->par_pos = 0;
    4e2a:	41 c7 82 8c 40 00 00 	movl   $0x0,0x408c(%r10)
    4e31:	00 00 00 00 
        par_de = &ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
    4e35:	48 83 b8 98 40 00 00 	cmpq   $0x1,0x4098(%rax)
    4e3c:	01 
    4e3d:	0f 84 a5 0c 00 00    	je     5ae8 <__rename_dir+0xf38>
    4e43:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    4e47:	48 83 c0 38          	add    $0x38,%rax
    4e4b:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    4e4f:	e9 5f 01 00 00       	jmpq   4fb3 <__rename_dir+0x403>
    if(new_de->ext_flag==0){
        if(flen<SMALL_NAME_LEN){
            memcpy(new_de->ful_name.f_name, new_ph, flen);
            new_de->ful_name.f_name[flen]='\0';
        } else {
            new_de->ext_flag = 2;
    4e54:	bf 02 00 00 00       	mov    $0x2,%edi
    4e59:	66 41 89 ba 84 40 00 	mov    %di,0x4084(%r10)
    4e60:	00 
            ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, flen, new_ph, 1);
        }
    } else
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, flen, new_ph, 1);
    4e61:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
    4e68:	44 8b 85 54 ff ff ff 	mov    -0xac(%rbp),%r8d
    4e6f:	41 89 d9             	mov    %ebx,%r9d
    4e72:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    4e76:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    4e7a:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    4e7e:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
    4e85:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    4e8c:	00 
    4e8d:	48 89 04 24          	mov    %rax,(%rsp)
    4e91:	4c 89 55 a0          	mov    %r10,-0x60(%rbp)
    4e95:	e8 00 00 00 00       	callq  4e9a <__rename_dir+0x2ea>

    /*set par_pos and subpos in par
     * set isr_sf*/
    temlen = flen - nlen;
    4e9a:	48 2b 5d b0          	sub    -0x50(%rbp),%rbx
        } else {
            new_de->ext_flag = 2;
            ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, flen, new_ph, 1);
        }
    } else
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, flen, new_ph, 1);
    4e9e:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10

    /*set par_pos and subpos in par
     * set isr_sf*/
    temlen = flen - nlen;
    if(temlen == 1){
    4ea2:	48 83 fb 01          	cmp    $0x1,%rbx
    4ea6:	0f 84 72 ff ff ff    	je     4e1e <__rename_dir+0x26e>
            tem_sf->pos = cpu_to_le32(dir_pos);
            list_add_tail(&tem_sf->list, &pdir->sub_file);
            pdir->sub_num++;
        }
    } else {
        new_de->isr_sf = 0;
    4eac:	41 c6 82 83 40 00 00 	movb   $0x0,0x4083(%r10)
    4eb3:	00 
        tem = kzalloc(sizeof(char)*temlen, GFP_KERNEL);
    4eb4:	48 89 df             	mov    %rbx,%rdi
            tem_sf->pos = cpu_to_le32(dir_pos);
            list_add_tail(&tem_sf->list, &pdir->sub_file);
            pdir->sub_num++;
        }
    } else {
        new_de->isr_sf = 0;
    4eb7:	4c 89 55 a0          	mov    %r10,-0x60(%rbp)
        tem = kzalloc(sizeof(char)*temlen, GFP_KERNEL);
    4ebb:	e8 30 b2 ff ff       	callq  f0 <kzalloc.constprop.9>
        temlen--;
    4ec0:	48 8d 4b ff          	lea    -0x1(%rbx),%rcx
        memcpy(tem, new_ph, temlen);
    4ec4:	48 8b b5 58 ff ff ff 	mov    -0xa8(%rbp),%rsi
    4ecb:	48 89 c7             	mov    %rax,%rdi
    4ece:	48 89 ca             	mov    %rcx,%rdx
    4ed1:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    4ed5:	e8 00 00 00 00       	callq  4eda <__rename_dir+0x32a>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    4eda:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
    4ede:	49 89 c1             	mov    %rax,%r9
        tem[temlen]='\0';
    4ee1:	c6 44 18 ff 00       	movb   $0x0,-0x1(%rax,%rbx,1)
    4ee6:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
    4eea:	85 c9                	test   %ecx,%ecx
    4eec:	0f 8e ab 0b 00 00    	jle    5a9d <__rename_dir+0xeed>
    4ef2:	8d 41 ff             	lea    -0x1(%rcx),%eax
    4ef5:	31 db                	xor    %ebx,%ebx
    4ef7:	49 8d 4c 01 01       	lea    0x1(%r9,%rax,1),%rcx
    4efc:	4c 89 c8             	mov    %r9,%rax
		hash = hash * seed + (*str++);
    4eff:	48 89 da             	mov    %rbx,%rdx
    4f02:	48 83 c0 01          	add    $0x1,%rax
    4f06:	48 c1 e2 05          	shl    $0x5,%rdx
    4f0a:	48 29 da             	sub    %rbx,%rdx
    4f0d:	48 89 d3             	mov    %rdx,%rbx
    4f10:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    4f15:	48 01 d3             	add    %rdx,%rbx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    4f18:	48 39 c8             	cmp    %rcx,%rax
    4f1b:	75 e2                	jne    4eff <__rename_dir+0x34f>
        //memcpy(tem+temlen,end,1);
        par_hash = BKDRHash(tem, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
    4f1d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    4f21:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
    4f28:	4c 8d 45 c4          	lea    -0x3c(%rbp),%r8
    4f2c:	48 89 da             	mov    %rbx,%rdx
    4f2f:	b9 01 00 00 00       	mov    $0x1,%ecx
    4f34:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
    4f38:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
    4f3c:	48 8b 70 18          	mov    0x18(%rax),%rsi
    4f40:	e8 00 00 00 00       	callq  4f45 <__rename_dir+0x395>
        new_de->par_pos = cpu_to_le64(par_pos);
    4f45:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    4f49:	8b 45 c4             	mov    -0x3c(%rbp),%eax

        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    4f4c:	48 89 de             	mov    %rbx,%rsi
        memcpy(tem, new_ph, temlen);
        tem[temlen]='\0';
        //memcpy(tem+temlen,end,1);
        par_hash = BKDRHash(tem, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
        new_de->par_pos = cpu_to_le64(par_pos);
    4f4f:	41 89 82 8c 40 00 00 	mov    %eax,0x408c(%r10)

        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    4f56:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    4f5a:	48 83 c0 38          	add    $0x38,%rax
    4f5e:	48 89 c7             	mov    %rax,%rdi
    4f61:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    4f65:	e8 00 00 00 00       	callq  4f6a <__rename_dir+0x3ba>
        pdir->sub_num++;
    4f6a:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
    4f6f:	ba 14 00 00 00       	mov    $0x14,%edx
    4f74:	be d0 80 00 00       	mov    $0x80d0,%esi
    4f79:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 4f80 <__rename_dir+0x3d0>
        par_hash = BKDRHash(tem, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
        new_de->par_pos = cpu_to_le64(par_pos);

        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    4f80:	48 89 c3             	mov    %rax,%rbx
        pdir->sub_num++;
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = dir_pos;
        list_add_tail(&tem_sf->list, &pdir->sub_file);
    4f83:	48 83 c3 18          	add    $0x18,%rbx
    4f87:	e8 00 00 00 00       	callq  4f8c <__rename_dir+0x3dc>

        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        pdir->sub_num++;
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = dir_pos;
    4f8c:	8b b5 54 ff ff ff    	mov    -0xac(%rbp),%esi
        list_add_tail(&tem_sf->list, &pdir->sub_file);
        kfree(tem);
    4f92:	4c 8b 4d a0          	mov    -0x60(%rbp),%r9

        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        pdir->sub_num++;
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = dir_pos;
    4f96:	89 70 10             	mov    %esi,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    4f99:	48 8b 53 08          	mov    0x8(%rbx),%rdx
        list_add_tail(&tem_sf->list, &pdir->sub_file);
        kfree(tem);
    4f9d:	4c 89 cf             	mov    %r9,%rdi
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    4fa0:	48 89 43 08          	mov    %rax,0x8(%rbx)
        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        pdir->sub_num++;
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = dir_pos;
        list_add_tail(&tem_sf->list, &pdir->sub_file);
    4fa4:	48 89 18             	mov    %rbx,(%rax)
	new->next = next;
	new->prev = prev;
    4fa7:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    4fab:	48 89 02             	mov    %rax,(%rdx)
        kfree(tem);
    4fae:	e8 00 00 00 00       	callq  4fb3 <__rename_dir+0x403>
    }

    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)z_p->statemap);
    4fb3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    4fb7:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    4fba:	f0 4c 0f ab 20       	lock bts %r12,(%rax)
    4fbf:	72 00                	jb     4fc1 <__rename_dir+0x411>
    bitpos++;
    hashname = BKDRHash(new_ph, strlen(new_ph));
    4fc1:	48 8b 9d 58 ff ff ff 	mov    -0xa8(%rbp),%rbx
    4fc8:	48 89 df             	mov    %rbx,%rdi
    4fcb:	e8 00 00 00 00       	callq  4fd0 <__rename_dir+0x420>
    4fd0:	85 c0                	test   %eax,%eax
    4fd2:	0f 8e 08 0b 00 00    	jle    5ae0 <__rename_dir+0xf30>
    4fd8:	83 e8 01             	sub    $0x1,%eax
    4fdb:	45 31 e4             	xor    %r12d,%r12d
    4fde:	48 8d 74 03 01       	lea    0x1(%rbx,%rax,1),%rsi
    4fe3:	48 89 d8             	mov    %rbx,%rax
		hash = hash * seed + (*str++);
    4fe6:	4c 89 e2             	mov    %r12,%rdx
    4fe9:	48 83 c0 01          	add    $0x1,%rax
    4fed:	48 c1 e2 05          	shl    $0x5,%rdx
    4ff1:	4c 29 e2             	sub    %r12,%rdx
    4ff4:	49 89 d4             	mov    %rdx,%r12
    4ff7:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    4ffc:	49 01 d4             	add    %rdx,%r12
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    4fff:	48 39 f0             	cmp    %rsi,%rax
    5002:	75 e2                	jne    4fe6 <__rename_dir+0x436>
    record_pos_htable(sb, dzt_ei->ht_head, hashname, dir_pos, 1);
    5004:	48 8b 5d 88          	mov    -0x78(%rbp),%rbx
    5008:	8b 8d 54 ff ff ff    	mov    -0xac(%rbp),%ecx
    500e:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    5014:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
    501b:	4c 89 e2             	mov    %r12,%rdx
    501e:	48 8b 73 18          	mov    0x18(%rbx),%rsi
    5022:	e8 00 00 00 00       	callq  5027 <__rename_dir+0x477>
    new_de->hname = cpu_to_le64(hashname);
    5027:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    502b:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi

    dir_pos++;

    /*new dir_info_entry*/
    new_dir = add_dir_info(dzt_ei, hashname, dir_pos);
    502f:	44 89 ea             	mov    %r13d,%edx
    5032:	4c 89 e6             	mov    %r12,%rsi
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)z_p->statemap);
    bitpos++;
    hashname = BKDRHash(new_ph, strlen(new_ph));
    record_pos_htable(sb, dzt_ei->ht_head, hashname, dir_pos, 1);
    new_de->hname = cpu_to_le64(hashname);
    5035:	48 c1 e0 07          	shl    $0x7,%rax
    5039:	4c 89 a4 07 a8 40 00 	mov    %r12,0x40a8(%rdi,%rax,1)
    5040:	00 

    dir_pos++;

    /*new dir_info_entry*/
    new_dir = add_dir_info(dzt_ei, hashname, dir_pos);
    5041:	48 89 df             	mov    %rbx,%rdi
    5044:	e8 00 00 00 00       	callq  5049 <__rename_dir+0x499>
    new_dir->f_s = DENTRY_FREQUENCY_WRITE;
    5049:	c6 40 02 02          	movb   $0x2,0x2(%rax)

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
    504d:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 5053 <__rename_dir+0x4a3>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    5053:	44 89 f1             	mov    %r14d,%ecx
    5056:	83 e1 3f             	and    $0x3f,%ecx
	if (support_clwb) {
    5059:	31 d2                	xor    %edx,%edx
    new_de->hname = cpu_to_le64(hashname);

    dir_pos++;

    /*new dir_info_entry*/
    new_dir = add_dir_info(dzt_ei, hashname, dir_pos);
    505b:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    5062:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    5065:	85 f6                	test   %esi,%esi
    5067:	0f 84 02 05 00 00    	je     556f <__rename_dir+0x9bf>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    506d:	89 d0                	mov    %edx,%eax
    506f:	4c 01 f0             	add    %r14,%rax
    5072:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    5076:	83 c2 40             	add    $0x40,%edx
    5079:	39 d1                	cmp    %edx,%ecx
    507b:	77 f0                	ja     506d <__rename_dir+0x4bd>
        return -EINVAL;
    
    nova_flush_buffer(new_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    old_hn = le64_to_cpu(src_de->hname);
    old_dir = radix_tree_lookup(&dzt_ei->dir_tree, old_hn);
    507d:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
    5084:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    5088:	48 8b 70 28          	mov    0x28(%rax),%rsi
    508c:	e8 00 00 00 00       	callq  5091 <__rename_dir+0x4e1>
    head = &old_dir->sub_file;
    5091:	48 8d 58 18          	lea    0x18(%rax),%rbx
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
    5095:	c7 85 1c ff ff ff 00 	movl   $0x0,-0xe4(%rbp)
    509c:	00 00 00 
    
    nova_flush_buffer(new_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    old_hn = le64_to_cpu(src_de->hname);
    old_dir = radix_tree_lookup(&dzt_ei->dir_tree, old_hn);
    head = &old_dir->sub_file;
    509f:	48 89 de             	mov    %rbx,%rsi
    50a2:	48 89 9d 48 ff ff ff 	mov    %rbx,-0xb8(%rbp)
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
    50a9:	48 8b 58 18          	mov    0x18(%rax),%rbx
    50ad:	48 8b 03             	mov    (%rbx),%rax
    50b0:	48 89 45 98          	mov    %rax,-0x68(%rbp)
            
            /*add in dir subpos*/
            new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            new_sf->pos = dir_pos;
            new_dir->sub_num++;
            list_add_tail(&new_sf->list, &new_dir->sub_file);
    50b4:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
    50bb:	48 83 c0 18          	add    $0x18,%rax
    50bf:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
                o_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
                rn_len = le64_to_cpu(src_de->fname_len); 
                r_name = kzalloc(sizeof(char)*(rn_len+1),GFP_KERNEL);
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
    50c6:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
    50cd:	48 83 c0 38          	add    $0x38,%rax
    old_hn = le64_to_cpu(src_de->hname);
    old_dir = radix_tree_lookup(&dzt_ei->dir_tree, old_hn);
    head = &old_dir->sub_file;
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
    50d1:	48 39 de             	cmp    %rbx,%rsi
                o_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
                rn_len = le64_to_cpu(src_de->fname_len); 
                r_name = kzalloc(sizeof(char)*(rn_len+1),GFP_KERNEL);
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
    50d4:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
    old_hn = le64_to_cpu(src_de->hname);
    old_dir = radix_tree_lookup(&dzt_ei->dir_tree, old_hn);
    head = &old_dir->sub_file;
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
    50db:	0f 84 00 04 00 00    	je     54e1 <__rename_dir+0x931>
        tem_sf = list_entry(this, struct file_p, list);
        s_pos = tem_sf->pos;
    50e1:	8b 5b 10             	mov    0x10(%rbx),%ebx
    50e4:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 50eb <__rename_dir+0x53b>
    50eb:	ba 70 00 00 00       	mov    $0x70,%edx
    50f0:	be d0 80 00 00       	mov    $0x80d0,%esi
    50f5:	e8 00 00 00 00       	callq  50fa <__rename_dir+0x54a>
    50fa:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    50fe:	89 d8                	mov    %ebx,%eax
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    5100:	be d0 80 00 00       	mov    $0x80d0,%esi
    5105:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    5109:	48 89 c3             	mov    %rax,%rbx
    510c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    5110:	48 c1 e3 07          	shl    $0x7,%rbx
    5114:	4c 8d 34 18          	lea    (%rax,%rbx,1),%r14
        sub_de = &ze->dentry[s_pos];
        sub_ph = kzalloc(sizeof(char )*LARGE_NAME_LEN, GFP_KERNEL);
        sub_len = le64_to_cpu(sub_de->name_len);
    5118:	41 0f b6 86 81 40 00 	movzbl 0x4081(%r14),%eax
    511f:	00 
    5120:	48 8d 78 01          	lea    0x1(%rax),%rdi
    5124:	88 85 53 ff ff ff    	mov    %al,-0xad(%rbp)
    512a:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    512e:	e8 00 00 00 00       	callq  5133 <__rename_dir+0x583>
        s_name = kzalloc(sizeof(char )*(sub_len+1), GFP_KERNEL);
        if(sub_de->ext_flag==1)
    5133:	66 41 83 be 84 40 00 	cmpw   $0x1,0x4084(%r14)
    513a:	00 01 
    513c:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    5140:	0f 84 c8 04 00 00    	je     560e <__rename_dir+0xa5e>
            get_ext_name(sub_de->next, s_name);
        else{
            memcpy(s_name, sub_de->name, sub_len);
    5146:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    514a:	48 8d b4 18 b0 40 00 	lea    0x40b0(%rax,%rbx,1),%rsi
    5151:	00 
    5152:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
    5156:	83 f8 08             	cmp    $0x8,%eax
    5159:	0f 83 39 04 00 00    	jae    5598 <__rename_dir+0x9e8>
    515f:	a8 04                	test   $0x4,%al
    5161:	0f 85 f3 08 00 00    	jne    5a5a <__rename_dir+0xeaa>
    5167:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    516b:	85 ff                	test   %edi,%edi
    516d:	74 14                	je     5183 <__rename_dir+0x5d3>
    516f:	0f b6 06             	movzbl (%rsi),%eax
    5172:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
    5176:	88 03                	mov    %al,(%rbx)
    5178:	48 89 f8             	mov    %rdi,%rax
    517b:	a8 02                	test   $0x2,%al
    517d:	0f 85 21 09 00 00    	jne    5aa4 <__rename_dir+0xef4>
            s_name[sub_len] = '\0';
    5183:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    5187:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
    518b:	c6 04 18 00          	movb   $0x0,(%rax,%rbx,1)
        }
        memcpy(sub_ph, new_ph, strlen(new_ph));
    518f:	48 8b 9d 58 ff ff ff 	mov    -0xa8(%rbp),%rbx
    5196:	48 89 df             	mov    %rbx,%rdi
    5199:	e8 00 00 00 00       	callq  519e <__rename_dir+0x5ee>
    519e:	48 89 de             	mov    %rbx,%rsi
    51a1:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
    51a5:	48 89 c2             	mov    %rax,%rdx
    51a8:	48 89 df             	mov    %rbx,%rdi
    51ab:	e8 00 00 00 00       	callq  51b0 <__rename_dir+0x600>
        strcat(sub_ph, "/");
    51b0:	48 89 df             	mov    %rbx,%rdi
    51b3:	e8 00 00 00 00       	callq  51b8 <__rename_dir+0x608>
        strcat(sub_ph, s_name);
    51b8:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    51bc:	48 8d 7c 03 01       	lea    0x1(%rbx,%rax,1),%rdi
        else{
            memcpy(s_name, sub_de->name, sub_len);
            s_name[sub_len] = '\0';
        }
        memcpy(sub_ph, new_ph, strlen(new_ph));
        strcat(sub_ph, "/");
    51c1:	c6 04 03 2f          	movb   $0x2f,(%rbx,%rax,1)
        strcat(sub_ph, s_name);
    51c5:	e8 00 00 00 00       	callq  51ca <__rename_dir+0x61a>

        if(sub_de->file_type == NORMAL_DIRECTORY){
    51ca:	41 80 be 82 40 00 00 	cmpb   $0x1,0x4082(%r14)
    51d1:	01 
    51d2:	0f 84 0d 06 00 00    	je     57e5 <__rename_dir+0xc35>
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);

        } else {
            //delen = DAFS_DIR_LEN(str(s_name)+str(sub_ph));
            /*set dir entry*/
            while(bitpos<z_p->zone_max){
    51d8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    51dc:	44 89 fa             	mov    %r15d,%edx
    51df:	41 8d 5f 01          	lea    0x1(%r15),%ebx
    51e3:	48 63 db             	movslq %ebx,%rbx
    51e6:	48 8b 70 08          	mov    0x8(%rax),%rsi
    51ea:	48 39 f2             	cmp    %rsi,%rdx
    51ed:	73 40                	jae    522f <__rename_dir+0x67f>
    51ef:	48 8b 08             	mov    (%rax),%rcx
    51f2:	eb 03                	jmp    51f7 <__rename_dir+0x647>
                if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
                    bitpos+=2;
    51f4:	41 89 c7             	mov    %eax,%r15d

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    51f7:	49 63 c7             	movslq %r15d,%rax
    51fa:	48 0f a3 01          	bt     %rax,(%rcx)
    51fe:	19 c0                	sbb    %eax,%eax

        } else {
            //delen = DAFS_DIR_LEN(str(s_name)+str(sub_ph));
            /*set dir entry*/
            while(bitpos<z_p->zone_max){
                if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
    5200:	85 c0                	test   %eax,%eax
    5202:	75 11                	jne    5215 <__rename_dir+0x665>
    5204:	41 8d 5f 01          	lea    0x1(%r15),%ebx
    5208:	48 63 db             	movslq %ebx,%rbx
    520b:	48 0f a3 19          	bt     %rbx,(%rcx)
    520f:	19 c0                	sbb    %eax,%eax
    5211:	85 c0                	test   %eax,%eax
    5213:	74 1a                	je     522f <__rename_dir+0x67f>
                    bitpos+=2;
    5215:	41 8d 57 02          	lea    0x2(%r15),%edx
                    dir_pos++;
    5219:	41 83 c5 01          	add    $0x1,%r13d
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);

        } else {
            //delen = DAFS_DIR_LEN(str(s_name)+str(sub_ph));
            /*set dir entry*/
            while(bitpos<z_p->zone_max){
    521d:	48 39 f2             	cmp    %rsi,%rdx
                if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
                    bitpos+=2;
    5220:	48 89 d0             	mov    %rdx,%rax
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);

        } else {
            //delen = DAFS_DIR_LEN(str(s_name)+str(sub_ph));
            /*set dir entry*/
            while(bitpos<z_p->zone_max){
    5223:	72 cf                	jb     51f4 <__rename_dir+0x644>
    5225:	41 83 c7 03          	add    $0x3,%r15d
    5229:	49 63 df             	movslq %r15d,%rbx
                if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
                    bitpos+=2;
    522c:	41 89 d7             	mov    %edx,%r15d
                    dir_pos++;
                }else{
                    break;
                }
            }
            new_de = &ze->dentry[dir_pos]; 
    522f:	44 89 e8             	mov    %r13d,%eax
    5232:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    5236:	48 89 c2             	mov    %rax,%rdx
    5239:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    523d:	48 05 81 00 00 00    	add    $0x81,%rax
    5243:	48 c1 e0 07          	shl    $0x7,%rax
    5247:	48 c1 e2 07          	shl    $0x7,%rdx
    524b:	48 01 f8             	add    %rdi,%rax
    524e:	4c 8d 14 17          	lea    (%rdi,%rdx,1),%r10
    5252:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
    5259:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
            //memset(new_de, 0, sizeof(new_de));    
            new_de->entry_type = sub_de->entry_type;
    5260:	41 0f b6 86 80 40 00 	movzbl 0x4080(%r14),%eax
    5267:	00 
            new_de->name_len = sub_de->name_len;
            new_de->file_type = sub_de->file_type;       //file_type是啥？ not decided
	        new_de->links_count = sub_de->links_count;
    5268:	4c 89 95 68 ff ff ff 	mov    %r10,-0x98(%rbp)
                    break;
                }
            }
            new_de = &ze->dentry[dir_pos]; 
            //memset(new_de, 0, sizeof(new_de));    
            new_de->entry_type = sub_de->entry_type;
    526f:	41 88 82 80 40 00 00 	mov    %al,0x4080(%r10)
            new_de->name_len = sub_de->name_len;
    5276:	41 0f b6 86 81 40 00 	movzbl 0x4081(%r14),%eax
    527d:	00 
    527e:	41 88 82 81 40 00 00 	mov    %al,0x4081(%r10)
            new_de->file_type = sub_de->file_type;       //file_type是啥？ not decided
    5285:	41 0f b6 86 82 40 00 	movzbl 0x4082(%r14),%eax
    528c:	00 
    528d:	41 88 82 82 40 00 00 	mov    %al,0x4082(%r10)
	        new_de->links_count = sub_de->links_count;
    5294:	41 0f b7 86 86 40 00 	movzwl 0x4086(%r14),%eax
    529b:	00 
    529c:	66 41 89 82 86 40 00 	mov    %ax,0x4086(%r10)
    52a3:	00 
            //new_de->de_len = cpu_to_le16(delen);  
            new_de->mtime = cpu_to_le32(CURRENT_TIME_SEC.tv_sec);
    52a4:	e8 00 00 00 00       	callq  52a9 <__rename_dir+0x6f9>
    52a9:	4c 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%r10
            //new_de->isr_sf = sub_de->isr_sf;
            new_de->ino = sub_de->ino;
              
            new_de->size = sub_de->size;
            if(sub_de->ext_flag==1){
    52b0:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
            new_de->entry_type = sub_de->entry_type;
            new_de->name_len = sub_de->name_len;
            new_de->file_type = sub_de->file_type;       //file_type是啥？ not decided
	        new_de->links_count = sub_de->links_count;
            //new_de->de_len = cpu_to_le16(delen);  
            new_de->mtime = cpu_to_le32(CURRENT_TIME_SEC.tv_sec);
    52b7:	41 89 82 88 40 00 00 	mov    %eax,0x4088(%r10)
            //new_de->isr_sf = sub_de->isr_sf;
            new_de->ino = sub_de->ino;
    52be:	48 8b 45 80          	mov    -0x80(%rbp),%rax
    52c2:	48 c1 e0 07          	shl    $0x7,%rax
    52c6:	48 03 45 b8          	add    -0x48(%rbp),%rax
    52ca:	48 8b 88 98 40 00 00 	mov    0x4098(%rax),%rcx
    52d1:	49 89 8a 98 40 00 00 	mov    %rcx,0x4098(%r10)
              
            new_de->size = sub_de->size;
    52d8:	48 8b 80 a0 40 00 00 	mov    0x40a0(%rax),%rax
    52df:	49 89 82 a0 40 00 00 	mov    %rax,0x40a0(%r10)
            if(sub_de->ext_flag==1){
    52e6:	41 0f b7 86 84 40 00 	movzwl 0x4084(%r14),%eax
    52ed:	00 
    52ee:	66 83 f8 01          	cmp    $0x1,%ax
    52f2:	0f 84 a1 04 00 00    	je     5799 <__rename_dir+0xbe9>
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);

            }else{

                new_de->ext_flag = sub_de->ext_flag;
                memcpy(new_de->name, s_name, sub_len);
    52f8:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
                new_de->ext_flag=1;
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);

            }else{

                new_de->ext_flag = sub_de->ext_flag;
    52fc:	66 41 89 82 84 40 00 	mov    %ax,0x4084(%r10)
    5303:	00 
                memcpy(new_de->name, s_name, sub_len);
    5304:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    5308:	83 ff 08             	cmp    $0x8,%edi
    530b:	48 8d 84 10 b0 40 00 	lea    0x40b0(%rax,%rdx,1),%rax
    5312:	00 
    5313:	0f 83 bc 02 00 00    	jae    55d5 <__rename_dir+0xa25>
    5319:	83 e7 04             	and    $0x4,%edi
    531c:	0f 85 63 07 00 00    	jne    5a85 <__rename_dir+0xed5>
    5322:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    5326:	85 ff                	test   %edi,%edi
    5328:	74 12                	je     533c <__rename_dir+0x78c>
    532a:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    532e:	83 e7 02             	and    $0x2,%edi
    5331:	0f b6 16             	movzbl (%rsi),%edx
    5334:	88 10                	mov    %dl,(%rax)
    5336:	0f 85 7e 07 00 00    	jne    5aba <__rename_dir+0xf0a>
                new_de->name[sub_len] = '\0';
    533c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    5340:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
    5344:	48 c1 e0 07          	shl    $0x7,%rax
    5348:	48 03 45 b8          	add    -0x48(%rbp),%rax
    534c:	c6 84 06 b0 40 00 00 	movb   $0x0,0x40b0(%rsi,%rax,1)
    5353:	00 
            }

            sub_plen = strlen(sub_ph);
    5354:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    5358:	4c 89 95 68 ff ff ff 	mov    %r10,-0x98(%rbp)
    535f:	e8 00 00 00 00       	callq  5364 <__rename_dir+0x7b4>
            new_de->fname_len = cpu_to_le64(sub_plen);
    5364:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
    5368:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
            //new_de->par_pos = sub_de->par_pos;
            /*set isr_sf, new_de is not root*/
            new_de->isr_sf = 0;
    536c:	4c 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%r10
            new_de->par_pos = cpu_to_le32(par_id);
    5373:	8b b5 54 ff ff ff    	mov    -0xac(%rbp),%esi
                memcpy(new_de->name, s_name, sub_len);
                new_de->name[sub_len] = '\0';
            }

            sub_plen = strlen(sub_ph);
            new_de->fname_len = cpu_to_le64(sub_plen);
    5379:	48 c1 e2 07          	shl    $0x7,%rdx
    537d:	48 8d 0c 17          	lea    (%rdi,%rdx,1),%rcx
    5381:	48 89 81 90 40 00 00 	mov    %rax,0x4090(%rcx)
            new_de->isr_sf = 0;
            new_de->par_pos = cpu_to_le32(par_id);

            /*set fulname*/
            /*ROOT_DIRECTORY set fulname and update ei*/
            if(new_de->file_type==ROOT_DIRECTORY) {
    5388:	41 80 ba 82 40 00 00 	cmpb   $0x2,0x4082(%r10)
    538f:	02 

            sub_plen = strlen(sub_ph);
            new_de->fname_len = cpu_to_le64(sub_plen);
            //new_de->par_pos = sub_de->par_pos;
            /*set isr_sf, new_de is not root*/
            new_de->isr_sf = 0;
    5390:	41 c6 82 83 40 00 00 	movb   $0x0,0x4083(%r10)
    5397:	00 
            new_de->par_pos = cpu_to_le32(par_id);
    5398:	41 89 b2 8c 40 00 00 	mov    %esi,0x408c(%r10)

            /*set fulname*/
            /*ROOT_DIRECTORY set fulname and update ei*/
            if(new_de->file_type==ROOT_DIRECTORY) {
    539f:	0f 84 7d 02 00 00    	je     5622 <__rename_dir+0xa72>
                radix_tree_insert(&dzt_m->dzt_root, dzt_hn, ch_ei);
                radix_tree_tag_set(&dzt_m->dzt_root, dzt_hn, 1);
                kfree(ch_ph);
                new_de->dzt_hn = cpu_to_le64(dzt_hn);
            } else {
                new_de->ful_name.f_name[0]='\0';
    53a5:	c6 81 d8 40 00 00 00 	movb   $0x0,0x40d8(%rcx)
                new_de->hname = cpu_to_le64(hashname);
    53ac:	4c 89 a1 a8 40 00 00 	mov    %r12,0x40a8(%rcx)
                //new_de->dzt_hn = sub_de->dzt_hn;
            }

            /*make valid*/
            bitpos++;
            test_and_set_bit_le(bitpos, (void *)z_p->statemap);
    53b3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    53b7:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    53ba:	f0 48 0f ab 18       	lock bts %rbx,(%rax)
    53bf:	72 00                	jb     53c1 <__rename_dir+0x811>
            hashname = BKDRHash(sub_ph, strlen(sub_ph));
    53c1:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
    53c5:	4c 89 55 a0          	mov    %r10,-0x60(%rbp)
    53c9:	48 89 df             	mov    %rbx,%rdi
    53cc:	e8 00 00 00 00       	callq  53d1 <__rename_dir+0x821>
    53d1:	85 c0                	test   %eax,%eax
    53d3:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
    53d7:	0f 8e 1b 06 00 00    	jle    59f8 <__rename_dir+0xe48>
    53dd:	83 e8 01             	sub    $0x1,%eax
    53e0:	45 31 e4             	xor    %r12d,%r12d
    53e3:	48 8d 4c 03 01       	lea    0x1(%rbx,%rax,1),%rcx
    53e8:	48 89 d8             	mov    %rbx,%rax
		hash = hash * seed + (*str++);
    53eb:	4c 89 e2             	mov    %r12,%rdx
    53ee:	48 83 c0 01          	add    $0x1,%rax
    53f2:	48 c1 e2 05          	shl    $0x5,%rdx
    53f6:	4c 29 e2             	sub    %r12,%rdx
    53f9:	49 89 d4             	mov    %rdx,%r12
    53fc:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    5401:	49 01 d4             	add    %rdx,%r12
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    5404:	48 39 c8             	cmp    %rcx,%rax
    5407:	75 e2                	jne    53eb <__rename_dir+0x83b>
           
            /*rename dir_info*/
            if(new_de->file_type==ROOT_DIRECTORY){
    5409:	41 80 ba 82 40 00 00 	cmpb   $0x2,0x4082(%r10)
    5410:	02 
    5411:	0f 84 16 04 00 00    	je     582d <__rename_dir+0xc7d>
            if(new_de->file_type==NORMAL_DIRECTORY){
                new_de->ful_name->f_name[0]="/0";
                new_de->hname = cpu_to_le64(hashname);
            } */

            record_pos_htable(sb, dzt_ei->ht_head, hashname,  dir_pos, 1);
    5417:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    541b:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
    5422:	44 89 e9             	mov    %r13d,%ecx
    5425:	4c 89 e2             	mov    %r12,%rdx
    5428:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    542e:	48 8b 70 18          	mov    0x18(%rax),%rsi
    5432:	e8 00 00 00 00       	callq  5437 <__rename_dir+0x887>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    5437:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
	if (support_clwb) {
    543e:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 5444 <__rename_dir+0x894>
    5444:	31 d2                	xor    %edx,%edx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    5446:	89 f1                	mov    %esi,%ecx
    5448:	83 e1 3f             	and    $0x3f,%ecx
    544b:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    544e:	85 c0                	test   %eax,%eax
    5450:	0f 85 2d 01 00 00    	jne    5583 <__rename_dir+0x9d3>
    5456:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    545d:	89 d0                	mov    %edx,%eax
    545f:	48 01 f0             	add    %rsi,%rax
    5462:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    5465:	83 c2 40             	add    $0x40,%edx
    5468:	39 d1                	cmp    %edx,%ecx
    546a:	77 f1                	ja     545d <__rename_dir+0x8ad>
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    546c:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 5473 <__rename_dir+0x8c3>
    5473:	ba 14 00 00 00       	mov    $0x14,%edx
    5478:	be d0 80 00 00       	mov    $0x80d0,%esi
            new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            new_sf->pos = dir_pos;
            new_dir->sub_num++;
            list_add_tail(&new_sf->list, &new_dir->sub_file);

            bitpos++;
    547d:	41 83 c7 02          	add    $0x2,%r15d
    5481:	e8 00 00 00 00       	callq  5486 <__rename_dir+0x8d6>
            nova_flush_buffer(new_de, DAFS_DEF_DENTRY_SIZE, 0);
            
            /*add in dir subpos*/
            new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            new_sf->pos = dir_pos;
            new_dir->sub_num++;
    5486:	48 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%rdi
            record_pos_htable(sb, dzt_ei->ht_head, hashname,  dir_pos, 1);
            nova_flush_buffer(new_de, DAFS_DEF_DENTRY_SIZE, 0);
            
            /*add in dir subpos*/
            new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            new_sf->pos = dir_pos;
    548d:	44 89 68 10          	mov    %r13d,0x10(%rax)
            new_dir->sub_num++;
            list_add_tail(&new_sf->list, &new_dir->sub_file);

            bitpos++;
            dir_pos++;
    5491:	41 83 c5 01          	add    $0x1,%r13d
    5495:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    5499:	48 8b 57 20          	mov    0x20(%rdi),%rdx
            nova_flush_buffer(new_de, DAFS_DEF_DENTRY_SIZE, 0);
            
            /*add in dir subpos*/
            new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            new_sf->pos = dir_pos;
            new_dir->sub_num++;
    549d:	48 83 47 08 01       	addq   $0x1,0x8(%rdi)
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    54a2:	48 89 47 20          	mov    %rax,0x20(%rdi)
            list_add_tail(&new_sf->list, &new_dir->sub_file);
    54a6:	48 8b bd 38 ff ff ff 	mov    -0xc8(%rbp),%rdi
	new->next = next;
	new->prev = prev;
    54ad:	48 89 50 08          	mov    %rdx,0x8(%rax)
    54b1:	48 89 38             	mov    %rdi,(%rax)
	prev->next = new;
    54b4:	48 89 02             	mov    %rax,(%rdx)
            
        }
        //list_del(&tem_sf->list);
        //old_dir->sub_num--;
        //kfree(tem_sf);
        kfree(s_name);
    54b7:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    54bb:	e8 00 00 00 00       	callq  54c0 <__rename_dir+0x910>
        kfree(sub_ph);
    54c0:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    54c4:	e8 00 00 00 00       	callq  54c9 <__rename_dir+0x919>
    old_hn = le64_to_cpu(src_de->hname);
    old_dir = radix_tree_lookup(&dzt_ei->dir_tree, old_hn);
    head = &old_dir->sub_file;
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
    54c9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    54cd:	48 39 9d 48 ff ff ff 	cmp    %rbx,-0xb8(%rbp)
    54d4:	48 8b 00             	mov    (%rax),%rax
    54d7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    54db:	0f 85 00 fc ff ff    	jne    50e1 <__rename_dir+0x531>
        //old_dir->sub_num--;
        //kfree(tem_sf);
        kfree(s_name);
        kfree(sub_ph);
    }
    kfree(z_p);
    54e1:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    54e5:	e8 00 00 00 00       	callq  54ea <__rename_dir+0x93a>
    kfree(new_ph);
    54ea:	48 8b bd 58 ff ff ff 	mov    -0xa8(%rbp),%rdi
    54f1:	e8 00 00 00 00       	callq  54f6 <__rename_dir+0x946>
    //nova_dbg("%s end",__func__);
    return ret;

}
    54f6:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    54fa:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    5501:	00 00 
    5503:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
    5509:	0f 85 7e 06 00 00    	jne    5b8d <__rename_dir+0xfdd>
    550f:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    5516:	5b                   	pop    %rbx
    5517:	41 5c                	pop    %r12
    5519:	41 5d                	pop    %r13
    551b:	41 5e                	pop    %r14
    551d:	41 5f                	pop    %r15
    551f:	5d                   	pop    %rbp
    5520:	c3                   	retq   
    if(nlen<=SMALL_NAME_LEN){
        new_de->ext_flag = 0;
        memcpy(new_de->name, name, nlen);
        new_de->name[nlen] = '\0';
    } else {
        new_de->ext_flag = 1;
    5521:	41 b8 01 00 00 00    	mov    $0x1,%r8d
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, nlen, name, 0);
    5527:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    552b:	44 8b 4d b0          	mov    -0x50(%rbp),%r9d
    if(nlen<=SMALL_NAME_LEN){
        new_de->ext_flag = 0;
        memcpy(new_de->name, name, nlen);
        new_de->name[nlen] = '\0';
    } else {
        new_de->ext_flag = 1;
    552f:	66 45 89 82 84 40 00 	mov    %r8w,0x4084(%r10)
    5536:	00 
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, nlen, name, 0);
    5537:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    553b:	44 8b 85 54 ff ff ff 	mov    -0xac(%rbp),%r8d
    5542:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    5546:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    554a:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
    5551:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
    5558:	00 
    5559:	48 89 04 24          	mov    %rax,(%rsp)
    if(nlen<=SMALL_NAME_LEN){
        new_de->ext_flag = 0;
        memcpy(new_de->name, name, nlen);
        new_de->name[nlen] = '\0';
    } else {
        new_de->ext_flag = 1;
    555d:	4c 89 55 a0          	mov    %r10,-0x60(%rbp)
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, nlen, name, 0);
    5561:	e8 00 00 00 00       	callq  5566 <__rename_dir+0x9b6>
    5566:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
    556a:	e9 46 f8 ff ff       	jmpq   4db5 <__rename_dir+0x205>
			_mm_clflush(buf + i);
    556f:	89 d0                	mov    %edx,%eax
    5571:	4c 01 f0             	add    %r14,%rax
    5574:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    5577:	83 c2 40             	add    $0x40,%edx
    557a:	39 d1                	cmp    %edx,%ecx
    557c:	77 f1                	ja     556f <__rename_dir+0x9bf>
    557e:	e9 fa fa ff ff       	jmpq   507d <__rename_dir+0x4cd>
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    5583:	89 d0                	mov    %edx,%eax
    5585:	48 01 f0             	add    %rsi,%rax
    5588:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    558c:	83 c2 40             	add    $0x40,%edx
    558f:	39 d1                	cmp    %edx,%ecx
    5591:	77 f0                	ja     5583 <__rename_dir+0x9d3>
    5593:	e9 d4 fe ff ff       	jmpq   546c <__rename_dir+0x8bc>
        sub_len = le64_to_cpu(sub_de->name_len);
        s_name = kzalloc(sizeof(char )*(sub_len+1), GFP_KERNEL);
        if(sub_de->ext_flag==1)
            get_ext_name(sub_de->next, s_name);
        else{
            memcpy(s_name, sub_de->name, sub_len);
    5598:	48 8b 06             	mov    (%rsi),%rax
    559b:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    559f:	48 89 07             	mov    %rax,(%rdi)
    55a2:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
    55a6:	89 d8                	mov    %ebx,%eax
    55a8:	48 8b 54 06 f8       	mov    -0x8(%rsi,%rax,1),%rdx
    55ad:	48 89 54 07 f8       	mov    %rdx,-0x8(%rdi,%rax,1)
    55b2:	48 89 f8             	mov    %rdi,%rax
    55b5:	48 83 c7 08          	add    $0x8,%rdi
    55b9:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    55bd:	48 29 f8             	sub    %rdi,%rax
    55c0:	8d 0c 03             	lea    (%rbx,%rax,1),%ecx
    55c3:	48 29 c6             	sub    %rax,%rsi
    55c6:	89 c8                	mov    %ecx,%eax
    55c8:	c1 e8 03             	shr    $0x3,%eax
    55cb:	89 c1                	mov    %eax,%ecx
    55cd:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    55d0:	e9 ae fb ff ff       	jmpq   5183 <__rename_dir+0x5d3>
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);

            }else{

                new_de->ext_flag = sub_de->ext_flag;
                memcpy(new_de->name, s_name, sub_len);
    55d5:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    55d9:	48 8d 78 08          	lea    0x8(%rax),%rdi
    55dd:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    55e1:	48 8b 16             	mov    (%rsi),%rdx
    55e4:	48 89 10             	mov    %rdx,(%rax)
    55e7:	4c 8b 5d a0          	mov    -0x60(%rbp),%r11
    55eb:	44 89 da             	mov    %r11d,%edx
    55ee:	48 8b 4c 16 f8       	mov    -0x8(%rsi,%rdx,1),%rcx
    55f3:	48 89 4c 10 f8       	mov    %rcx,-0x8(%rax,%rdx,1)
    55f8:	48 29 f8             	sub    %rdi,%rax
    55fb:	48 29 c6             	sub    %rax,%rsi
    55fe:	44 01 d8             	add    %r11d,%eax
    5601:	c1 e8 03             	shr    $0x3,%eax
    5604:	89 c1                	mov    %eax,%ecx
    5606:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    5609:	e9 2e fd ff ff       	jmpq   533c <__rename_dir+0x78c>
        sub_de = &ze->dentry[s_pos];
        sub_ph = kzalloc(sizeof(char )*LARGE_NAME_LEN, GFP_KERNEL);
        sub_len = le64_to_cpu(sub_de->name_len);
        s_name = kzalloc(sizeof(char )*(sub_len+1), GFP_KERNEL);
        if(sub_de->ext_flag==1)
            get_ext_name(sub_de->next, s_name);
    560e:	49 8b be b0 40 00 00 	mov    0x40b0(%r14),%rdi
    5615:	48 89 c6             	mov    %rax,%rsi
    5618:	e8 00 00 00 00       	callq  561d <__rename_dir+0xa6d>
    561d:	e9 6d fb ff ff       	jmpq   518f <__rename_dir+0x5df>

            /*set fulname*/
            /*ROOT_DIRECTORY set fulname and update ei*/
            if(new_de->file_type==ROOT_DIRECTORY) {
                /*set_ful name*/
                if(sub_de->ext_flag==0){
    5622:	66 41 83 be 84 40 00 	cmpw   $0x0,0x4084(%r14)
    5629:	00 00 
    562b:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
    5632:	0f 85 c8 03 00 00    	jne    5a00 <__rename_dir+0xe50>
                    if(sub_plen<SMALL_NAME_LEN){
    5638:	48 83 f8 26          	cmp    $0x26,%rax
    563c:	0f 87 6e 03 00 00    	ja     59b0 <__rename_dir+0xe00>
                        memcpy(new_de->ful_name.f_name, sub_ph, sub_plen);
    5642:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    5646:	48 8d bc 17 d8 40 00 	lea    0x40d8(%rdi,%rdx,1),%rdi
    564d:	00 
    564e:	48 89 c2             	mov    %rax,%rdx
    5651:	4c 89 95 60 ff ff ff 	mov    %r10,-0xa0(%rbp)
    5658:	e8 00 00 00 00       	callq  565d <__rename_dir+0xaad>
                        new_de->ful_name.f_name[sub_len]='\0';
    565d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
    5661:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
    5668:	4c 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%r10
    566f:	c6 84 08 d8 40 00 00 	movb   $0x0,0x40d8(%rax,%rcx,1)
    5676:	00 
                        ext_de_name(sb ,dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);
                    }
                } else
                    ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);

                dzt_hn = le64_to_cpu(sub_de->dzt_hn);
    5677:	48 8b 45 80          	mov    -0x80(%rbp),%rax
                ch_ei = radix_tree_delete(&dzt_m->dzt_root, dzt_hn);
    567b:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    567f:	4c 89 55 a0          	mov    %r10,-0x60(%rbp)
                        ext_de_name(sb ,dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);
                    }
                } else
                    ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);

                dzt_hn = le64_to_cpu(sub_de->dzt_hn);
    5683:	48 c1 e0 07          	shl    $0x7,%rax
                ch_ei = radix_tree_delete(&dzt_m->dzt_root, dzt_hn);
    5687:	48 8b b4 07 a8 40 00 	mov    0x40a8(%rdi,%rax,1),%rsi
    568e:	00 
    568f:	48 8b bd 28 ff ff ff 	mov    -0xd8(%rbp),%rdi
    5696:	e8 00 00 00 00       	callq  569b <__rename_dir+0xaeb>
                if(dzt_ei->dzt_eno!=1) {
    569b:	4c 8b 75 88          	mov    -0x78(%rbp),%r14
    569f:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
                    }
                } else
                    ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);

                dzt_hn = le64_to_cpu(sub_de->dzt_hn);
                ch_ei = radix_tree_delete(&dzt_m->dzt_root, dzt_hn);
    56a3:	49 89 c0             	mov    %rax,%r8
    56a6:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
                if(dzt_ei->dzt_eno!=1) {
                    ch_len =(u64)dzt_ei->root_len + strlen(sub_ph);
    56aa:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
                } else
                    ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);

                dzt_hn = le64_to_cpu(sub_de->dzt_hn);
                ch_ei = radix_tree_delete(&dzt_m->dzt_root, dzt_hn);
                if(dzt_ei->dzt_eno!=1) {
    56ae:	41 83 7e 08 01       	cmpl   $0x1,0x8(%r14)
    56b3:	4c 89 55 80          	mov    %r10,-0x80(%rbp)
    56b7:	0f 84 59 03 00 00    	je     5a16 <__rename_dir+0xe66>
                    ch_len =(u64)dzt_ei->root_len + strlen(sub_ph);
    56bd:	e8 00 00 00 00       	callq  56c2 <__rename_dir+0xb12>
    56c2:	49 03 46 28          	add    0x28(%r14),%rax
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    56c6:	be d0 80 00 00       	mov    $0x80d0,%esi
    56cb:	48 8d 3c c5 00 00 00 	lea    0x0(,%rax,8),%rdi
    56d2:	00 
    56d3:	49 89 c4             	mov    %rax,%r12
    56d6:	e8 00 00 00 00       	callq  56db <__rename_dir+0xb2b>
                    ch_ph = kzalloc(sizeof(char *)*ch_len, GFP_KERNEL);
                    get_zone_path(sb, dzt_ei, ch_ph, sub_ph);
    56db:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
    56df:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    56e3:	48 89 c2             	mov    %rax,%rdx
    56e6:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
    56ed:	49 89 c6             	mov    %rax,%r14
    56f0:	e8 00 00 00 00       	callq  56f5 <__rename_dir+0xb45>
    56f5:	45 85 e4             	test   %r12d,%r12d
    56f8:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
    56fc:	4c 8b 55 80          	mov    -0x80(%rbp),%r10
    5700:	0f 8e 4d 03 00 00    	jle    5a53 <__rename_dir+0xea3>
    5706:	41 8d 44 24 ff       	lea    -0x1(%r12),%eax
    570b:	31 c9                	xor    %ecx,%ecx
    570d:	49 8d 74 06 01       	lea    0x1(%r14,%rax,1),%rsi
    5712:	4c 89 f0             	mov    %r14,%rax
		hash = hash * seed + (*str++);
    5715:	48 89 ca             	mov    %rcx,%rdx
    5718:	48 83 c0 01          	add    $0x1,%rax
    571c:	48 c1 e2 05          	shl    $0x5,%rdx
    5720:	48 29 ca             	sub    %rcx,%rdx
    5723:	48 89 d1             	mov    %rdx,%rcx
    5726:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    572b:	48 01 d1             	add    %rdx,%rcx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    572e:	48 39 f0             	cmp    %rsi,%rax
    5731:	75 e2                	jne    5715 <__rename_dir+0xb65>
                    memcpy(ch_ph, sub_ph, ch_len);
                    ch_ph[ch_len]='\0';
                    //memcpy(ch_ph+ch_len,end,1);
                }
                dzt_hn = BKDRHash(ch_ph, ch_len);
                ch_ei->root_len = (u32)ch_len;
    5733:	41 83 e4 ff          	and    $0xffffffff,%r12d
                ch_ei->hash_name = dzt_hn;
    5737:	49 89 48 30          	mov    %rcx,0x30(%r8)
                radix_tree_insert(&dzt_m->dzt_root, dzt_hn, ch_ei);
    573b:	4c 89 c2             	mov    %r8,%rdx
                    memcpy(ch_ph, sub_ph, ch_len);
                    ch_ph[ch_len]='\0';
                    //memcpy(ch_ph+ch_len,end,1);
                }
                dzt_hn = BKDRHash(ch_ph, ch_len);
                ch_ei->root_len = (u32)ch_len;
    573e:	4d 89 60 28          	mov    %r12,0x28(%r8)
                ch_ei->hash_name = dzt_hn;
                radix_tree_insert(&dzt_m->dzt_root, dzt_hn, ch_ei);
    5742:	4c 8b a5 28 ff ff ff 	mov    -0xd8(%rbp),%r12
    5749:	48 89 ce             	mov    %rcx,%rsi
    574c:	4c 89 55 80          	mov    %r10,-0x80(%rbp)
    5750:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    5754:	4c 89 e7             	mov    %r12,%rdi
    5757:	e8 00 00 00 00       	callq  575c <__rename_dir+0xbac>
                radix_tree_tag_set(&dzt_m->dzt_root, dzt_hn, 1);
    575c:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
    5760:	ba 01 00 00 00       	mov    $0x1,%edx
    5765:	4c 89 e7             	mov    %r12,%rdi
    5768:	48 89 ce             	mov    %rcx,%rsi
    576b:	e8 00 00 00 00       	callq  5770 <__rename_dir+0xbc0>
                kfree(ch_ph);
    5770:	4c 89 f7             	mov    %r14,%rdi
    5773:	e8 00 00 00 00       	callq  5778 <__rename_dir+0xbc8>
                new_de->dzt_hn = cpu_to_le64(dzt_hn);
    5778:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    577c:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
    5780:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
    5784:	4c 8b 55 80          	mov    -0x80(%rbp),%r10
    5788:	48 c1 e0 07          	shl    $0x7,%rax
    578c:	48 89 8c 06 a8 40 00 	mov    %rcx,0x40a8(%rsi,%rax,1)
    5793:	00 
    5794:	e9 1a fc ff ff       	jmpq   53b3 <__rename_dir+0x803>
            //new_de->isr_sf = sub_de->isr_sf;
            new_de->ino = sub_de->ino;
              
            new_de->size = sub_de->size;
            if(sub_de->ext_flag==1){
                new_de->ext_flag=1;
    5799:	b9 01 00 00 00       	mov    $0x1,%ecx
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);
    579e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    57a2:	44 0f b6 8d 53 ff ff 	movzbl -0xad(%rbp),%r9d
    57a9:	ff 
            //new_de->isr_sf = sub_de->isr_sf;
            new_de->ino = sub_de->ino;
              
            new_de->size = sub_de->size;
            if(sub_de->ext_flag==1){
                new_de->ext_flag=1;
    57aa:	66 41 89 8a 84 40 00 	mov    %cx,0x4084(%r10)
    57b1:	00 
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);
    57b2:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    57b6:	45 89 e8             	mov    %r13d,%r8d
    57b9:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    57bd:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    57c1:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
    57c8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
    57cf:	00 
    57d0:	48 89 04 24          	mov    %rax,(%rsp)
    57d4:	e8 00 00 00 00       	callq  57d9 <__rename_dir+0xc29>
    57d9:	4c 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%r10
    57e0:	e9 6f fb ff ff       	jmpq   5354 <__rename_dir+0x7a4>
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
        tem_sf = list_entry(this, struct file_p, list);
        s_pos = tem_sf->pos;
        sub_de = &ze->dentry[s_pos];
    57e5:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
    57e9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
        memcpy(sub_ph, new_ph, strlen(new_ph));
        strcat(sub_ph, "/");
        strcat(sub_ph, s_name);

        if(sub_de->file_type == NORMAL_DIRECTORY){
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);
    57ed:	4c 8b 4d a8          	mov    -0x58(%rbp),%r9
    57f1:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
    57f5:	48 8b 8d 20 ff ff ff 	mov    -0xe0(%rbp),%rcx
    57fc:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
        tem_sf = list_entry(this, struct file_p, list);
        s_pos = tem_sf->pos;
        sub_de = &ze->dentry[s_pos];
    5800:	48 81 c6 81 00 00 00 	add    $0x81,%rsi
        memcpy(sub_ph, new_ph, strlen(new_ph));
        strcat(sub_ph, "/");
        strcat(sub_ph, s_name);

        if(sub_de->file_type == NORMAL_DIRECTORY){
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);
    5807:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
        tem_sf = list_entry(this, struct file_p, list);
        s_pos = tem_sf->pos;
        sub_de = &ze->dentry[s_pos];
    580e:	48 89 f3             	mov    %rsi,%rbx
    5811:	48 c1 e3 07          	shl    $0x7,%rbx
    5815:	48 8d 34 18          	lea    (%rax,%rbx,1),%rsi
        memcpy(sub_ph, new_ph, strlen(new_ph));
        strcat(sub_ph, "/");
        strcat(sub_ph, s_name);

        if(sub_de->file_type == NORMAL_DIRECTORY){
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);
    5819:	e8 00 00 00 00       	callq  581e <__rename_dir+0xc6e>
    581e:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
    5822:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
    5828:	e9 8a fc ff ff       	jmpq   54b7 <__rename_dir+0x907>
            test_and_set_bit_le(bitpos, (void *)z_p->statemap);
            hashname = BKDRHash(sub_ph, strlen(sub_ph));
           
            /*rename dir_info*/
            if(new_de->file_type==ROOT_DIRECTORY){
                nr_dir = add_dir_info(dzt_ei, hashname, dir_pos);
    582d:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
    5831:	44 89 ea             	mov    %r13d,%edx
    5834:	4c 89 e6             	mov    %r12,%rsi
    5837:	e8 00 00 00 00       	callq  583c <__rename_dir+0xc8c>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    583c:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
    5843:	48 89 c3             	mov    %rax,%rbx
                o_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    5846:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
    584d:	48 8b 96 b0 03 00 00 	mov    0x3b0(%rsi),%rdx
    5854:	48 8b 40 10          	mov    0x10(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    5858:	48 89 c6             	mov    %rax,%rsi
    585b:	48 03 72 18          	add    0x18(%rdx),%rsi
    585f:	48 85 c0             	test   %rax,%rax
    5862:	b8 00 00 00 00       	mov    $0x0,%eax
    5867:	48 0f 44 f0          	cmove  %rax,%rsi
                rn_len = le64_to_cpu(src_de->fname_len); 
    586b:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
    5872:	48 89 75 98          	mov    %rsi,-0x68(%rbp)
    5876:	4c 8b 40 10          	mov    0x10(%rax),%r8
                r_name = kzalloc(sizeof(char)*(rn_len+1),GFP_KERNEL);
    587a:	49 8d 78 01          	lea    0x1(%r8),%rdi
    587e:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
    5882:	e8 69 a8 ff ff       	callq  f0 <kzalloc.constprop.9>
                get_de_name(src_de, o_ze, r_name, 1);
    5887:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
    588b:	48 8b bd 30 ff ff ff 	mov    -0xd0(%rbp),%rdi
    5892:	b9 01 00 00 00       	mov    $0x1,%ecx
    5897:	48 89 c2             	mov    %rax,%rdx
            /*rename dir_info*/
            if(new_de->file_type==ROOT_DIRECTORY){
                nr_dir = add_dir_info(dzt_ei, hashname, dir_pos);
                o_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
                rn_len = le64_to_cpu(src_de->fname_len); 
                r_name = kzalloc(sizeof(char)*(rn_len+1),GFP_KERNEL);
    589a:	49 89 c6             	mov    %rax,%r14
                get_de_name(src_de, o_ze, r_name, 1);
    589d:	e8 00 00 00 00       	callq  58a2 <__rename_dir+0xcf2>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    58a2:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
    58a6:	45 85 c0             	test   %r8d,%r8d
    58a9:	0f 8e 2a 02 00 00    	jle    5ad9 <__rename_dir+0xf29>
    58af:	41 8d 40 ff          	lea    -0x1(%r8),%eax
    58b3:	31 f6                	xor    %esi,%esi
    58b5:	49 8d 54 06 01       	lea    0x1(%r14,%rax,1),%rdx
		hash = hash * seed + (*str++);
    58ba:	48 89 f0             	mov    %rsi,%rax
    58bd:	49 83 c6 01          	add    $0x1,%r14
    58c1:	48 c1 e0 05          	shl    $0x5,%rax
    58c5:	48 29 f0             	sub    %rsi,%rax
    58c8:	48 89 c6             	mov    %rax,%rsi
    58cb:	49 0f be 46 ff       	movsbq -0x1(%r14),%rax
    58d0:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    58d3:	49 39 d6             	cmp    %rdx,%r14
    58d6:	75 e2                	jne    58ba <__rename_dir+0xd0a>
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
    58d8:	48 8b bd 10 ff ff ff 	mov    -0xf0(%rbp),%rdi
    58df:	e8 00 00 00 00       	callq  58e4 <__rename_dir+0xd34>
                this = head = next =NULL;
                head = &old_dir->sub_file;
                list_for_each_safe(this, next, head){
    58e4:	48 8b 48 18          	mov    0x18(%rax),%rcx
                r_name = kzalloc(sizeof(char)*(rn_len+1),GFP_KERNEL);
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
                this = head = next =NULL;
                head = &old_dir->sub_file;
    58e8:	48 8d 78 18          	lea    0x18(%rax),%rdi
                o_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
                rn_len = le64_to_cpu(src_de->fname_len); 
                r_name = kzalloc(sizeof(char)*(rn_len+1),GFP_KERNEL);
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
    58ec:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                this = head = next =NULL;
                head = &old_dir->sub_file;
    58f0:	48 89 bd 48 ff ff ff 	mov    %rdi,-0xb8(%rbp)
                list_for_each_safe(this, next, head){
    58f7:	48 39 cf             	cmp    %rcx,%rdi
    58fa:	4c 8b 31             	mov    (%rcx),%r14
    58fd:	0f 84 cd 01 00 00    	je     5ad0 <__rename_dir+0xf20>
    5903:	48 8d 43 18          	lea    0x18(%rbx),%rax
    5907:	44 89 7d 98          	mov    %r15d,-0x68(%rbp)
    590b:	44 89 6d 90          	mov    %r13d,-0x70(%rbp)
    590f:	4c 89 65 80          	mov    %r12,-0x80(%rbp)
    5913:	49 89 ff             	mov    %rdi,%r15
    5916:	4d 89 f4             	mov    %r14,%r12
    5919:	49 89 cd             	mov    %rcx,%r13
    591c:	49 89 c6             	mov    %rax,%r14
    591f:	eb 03                	jmp    5924 <__rename_dir+0xd74>
    5921:	49 89 c4             	mov    %rax,%r12
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    5924:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 592b <__rename_dir+0xd7b>
    592b:	ba 14 00 00 00       	mov    $0x14,%edx
    5930:	be d0 80 00 00       	mov    $0x80d0,%esi
    5935:	e8 00 00 00 00       	callq  593a <__rename_dir+0xd8a>
                    tem_sf = list_entry(this, struct file_p, list);
                    new_sf = kzalloc(sizeof(struct file_p),GFP_KERNEL);
                    new_sf->pos = tem_sf->pos;
    593a:	41 8b 55 10          	mov    0x10(%r13),%edx
                    list_add_tail(&new_sf->list, &nr_dir->sub_file);
                    list_del(&tem_sf->list);
                    kfree(tem_sf);
    593e:	4c 89 ef             	mov    %r13,%rdi
                this = head = next =NULL;
                head = &old_dir->sub_file;
                list_for_each_safe(this, next, head){
                    tem_sf = list_entry(this, struct file_p, list);
                    new_sf = kzalloc(sizeof(struct file_p),GFP_KERNEL);
                    new_sf->pos = tem_sf->pos;
    5941:	89 50 10             	mov    %edx,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    5944:	48 8b 53 20          	mov    0x20(%rbx),%rdx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    5948:	48 89 43 20          	mov    %rax,0x20(%rbx)
	new->next = next;
    594c:	4c 89 30             	mov    %r14,(%rax)
	new->prev = prev;
    594f:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    5953:	48 89 02             	mov    %rax,(%rdx)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    5956:	49 8b 45 08          	mov    0x8(%r13),%rax
    595a:	49 8b 55 00          	mov    0x0(%r13),%rdx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    595e:	48 89 42 08          	mov    %rax,0x8(%rdx)
	prev->next = next;
    5962:	48 89 10             	mov    %rdx,(%rax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    5965:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
    596c:	00 ad de 
    596f:	49 89 45 00          	mov    %rax,0x0(%r13)
	entry->prev = LIST_POISON2;
    5973:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
    597a:	00 ad de 
    597d:	49 89 45 08          	mov    %rax,0x8(%r13)
    5981:	4d 89 e5             	mov    %r12,%r13
                    list_add_tail(&new_sf->list, &nr_dir->sub_file);
                    list_del(&tem_sf->list);
                    kfree(tem_sf);
    5984:	e8 00 00 00 00       	callq  5989 <__rename_dir+0xdd9>
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
                this = head = next =NULL;
                head = &old_dir->sub_file;
                list_for_each_safe(this, next, head){
    5989:	4d 39 e7             	cmp    %r12,%r15
    598c:	49 8b 04 24          	mov    (%r12),%rax
    5990:	75 8f                	jne    5921 <__rename_dir+0xd71>
    5992:	44 8b 6d 90          	mov    -0x70(%rbp),%r13d
    5996:	4c 8b 65 80          	mov    -0x80(%rbp),%r12
    599a:	44 8b 7d 98          	mov    -0x68(%rbp),%r15d
    599e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
                    new_sf->pos = tem_sf->pos;
                    list_add_tail(&new_sf->list, &nr_dir->sub_file);
                    list_del(&tem_sf->list);
                    kfree(tem_sf);
                }
                kfree(old_dir);
    59a2:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    59a6:	e8 00 00 00 00       	callq  59ab <__rename_dir+0xdfb>
    59ab:	e9 67 fa ff ff       	jmpq   5417 <__rename_dir+0x867>
                    if(sub_plen<SMALL_NAME_LEN){
                        memcpy(new_de->ful_name.f_name, sub_ph, sub_plen);
                        new_de->ful_name.f_name[sub_len]='\0';
                    } else {
                        new_de->ext_flag = 2;
                        ext_de_name(sb ,dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);
    59b0:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
                if(sub_de->ext_flag==0){
                    if(sub_plen<SMALL_NAME_LEN){
                        memcpy(new_de->ful_name.f_name, sub_ph, sub_plen);
                        new_de->ful_name.f_name[sub_len]='\0';
                    } else {
                        new_de->ext_flag = 2;
    59b4:	ba 02 00 00 00       	mov    $0x2,%edx
    59b9:	4c 89 55 a0          	mov    %r10,-0x60(%rbp)
    59bd:	66 41 89 92 84 40 00 	mov    %dx,0x4084(%r10)
    59c4:	00 
                        ext_de_name(sb ,dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);
    59c5:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    59cc:	00 
    59cd:	48 89 3c 24          	mov    %rdi,(%rsp)
                    }
                } else
                    ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);
    59d1:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    59d5:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    59d9:	41 89 c1             	mov    %eax,%r9d
    59dc:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    59e0:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
    59e7:	45 89 e8             	mov    %r13d,%r8d
    59ea:	e8 00 00 00 00       	callq  59ef <__rename_dir+0xe3f>
    59ef:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
    59f3:	e9 7f fc ff ff       	jmpq   5677 <__rename_dir+0xac7>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    59f8:	45 31 e4             	xor    %r12d,%r12d
    59fb:	e9 09 fa ff ff       	jmpq   5409 <__rename_dir+0x859>
    5a00:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    5a04:	4c 89 55 a0          	mov    %r10,-0x60(%rbp)
    5a08:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    5a0f:	00 
    5a10:	48 89 34 24          	mov    %rsi,(%rsp)
    5a14:	eb bb                	jmp    59d1 <__rename_dir+0xe21>
                if(dzt_ei->dzt_eno!=1) {
                    ch_len =(u64)dzt_ei->root_len + strlen(sub_ph);
                    ch_ph = kzalloc(sizeof(char *)*ch_len, GFP_KERNEL);
                    get_zone_path(sb, dzt_ei, ch_ph, sub_ph);
                } else {
                    ch_len = strlen(sub_ph);
    5a16:	e8 00 00 00 00       	callq  5a1b <__rename_dir+0xe6b>
                    ch_ph = kzalloc(sizeof(char *)*ch_len, GFP_KERNEL);
    5a1b:	48 8d 3c c5 00 00 00 	lea    0x0(,%rax,8),%rdi
    5a22:	00 
                if(dzt_ei->dzt_eno!=1) {
                    ch_len =(u64)dzt_ei->root_len + strlen(sub_ph);
                    ch_ph = kzalloc(sizeof(char *)*ch_len, GFP_KERNEL);
                    get_zone_path(sb, dzt_ei, ch_ph, sub_ph);
                } else {
                    ch_len = strlen(sub_ph);
    5a23:	49 89 c4             	mov    %rax,%r12
                    ch_ph = kzalloc(sizeof(char *)*ch_len, GFP_KERNEL);
    5a26:	e8 c5 a6 ff ff       	callq  f0 <kzalloc.constprop.9>
                    memcpy(ch_ph, sub_ph, ch_len);
    5a2b:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    5a2f:	4c 89 e2             	mov    %r12,%rdx
    5a32:	48 89 c7             	mov    %rax,%rdi
                    ch_len =(u64)dzt_ei->root_len + strlen(sub_ph);
                    ch_ph = kzalloc(sizeof(char *)*ch_len, GFP_KERNEL);
                    get_zone_path(sb, dzt_ei, ch_ph, sub_ph);
                } else {
                    ch_len = strlen(sub_ph);
                    ch_ph = kzalloc(sizeof(char *)*ch_len, GFP_KERNEL);
    5a35:	49 89 c6             	mov    %rax,%r14
                    memcpy(ch_ph, sub_ph, ch_len);
    5a38:	e8 00 00 00 00       	callq  5a3d <__rename_dir+0xe8d>
	int i;

	for (i = 0; i < length; i++) {
    5a3d:	45 85 e4             	test   %r12d,%r12d
                    ch_ph[ch_len]='\0';
    5a40:	43 c6 04 26 00       	movb   $0x0,(%r14,%r12,1)
    5a45:	4c 8b 55 80          	mov    -0x80(%rbp),%r10
    5a49:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
    5a4d:	0f 8f b3 fc ff ff    	jg     5706 <__rename_dir+0xb56>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    5a53:	31 c9                	xor    %ecx,%ecx
    5a55:	e9 d9 fc ff ff       	jmpq   5733 <__rename_dir+0xb83>
        sub_len = le64_to_cpu(sub_de->name_len);
        s_name = kzalloc(sizeof(char )*(sub_len+1), GFP_KERNEL);
        if(sub_de->ext_flag==1)
            get_ext_name(sub_de->next, s_name);
        else{
            memcpy(s_name, sub_de->name, sub_len);
    5a5a:	8b 06                	mov    (%rsi),%eax
    5a5c:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
    5a60:	89 03                	mov    %eax,(%rbx)
    5a62:	8b 45 a0             	mov    -0x60(%rbp),%eax
    5a65:	8b 54 06 fc          	mov    -0x4(%rsi,%rax,1),%edx
    5a69:	89 54 03 fc          	mov    %edx,-0x4(%rbx,%rax,1)
    5a6d:	e9 11 f7 ff ff       	jmpq   5183 <__rename_dir+0x5d3>
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    memcpy(new_ph, path, flen);
    new_ph[flen]='\0';
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
    5a72:	44 8d 69 01          	lea    0x1(%rcx),%r13d
    5a76:	44 8d 7a 02          	lea    0x2(%rdx),%r15d
    5a7a:	89 8d 54 ff ff ff    	mov    %ecx,-0xac(%rbp)
    5a80:	e9 5b f2 ff ff       	jmpq   4ce0 <__rename_dir+0x130>
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);

            }else{

                new_de->ext_flag = sub_de->ext_flag;
                memcpy(new_de->name, s_name, sub_len);
    5a85:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    5a89:	8b 17                	mov    (%rdi),%edx
    5a8b:	89 10                	mov    %edx,(%rax)
    5a8d:	8b 55 a0             	mov    -0x60(%rbp),%edx
    5a90:	8b 4c 17 fc          	mov    -0x4(%rdi,%rdx,1),%ecx
    5a94:	89 4c 10 fc          	mov    %ecx,-0x4(%rax,%rdx,1)
    5a98:	e9 9f f8 ff ff       	jmpq   533c <__rename_dir+0x78c>
    5a9d:	31 db                	xor    %ebx,%ebx
    5a9f:	e9 79 f4 ff ff       	jmpq   4f1d <__rename_dir+0x36d>
        sub_len = le64_to_cpu(sub_de->name_len);
        s_name = kzalloc(sizeof(char )*(sub_len+1), GFP_KERNEL);
        if(sub_de->ext_flag==1)
            get_ext_name(sub_de->next, s_name);
        else{
            memcpy(s_name, sub_de->name, sub_len);
    5aa4:	8b 45 a0             	mov    -0x60(%rbp),%eax
    5aa7:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
    5aab:	0f b7 54 06 fe       	movzwl -0x2(%rsi,%rax,1),%edx
    5ab0:	66 89 54 03 fe       	mov    %dx,-0x2(%rbx,%rax,1)
    5ab5:	e9 c9 f6 ff ff       	jmpq   5183 <__rename_dir+0x5d3>
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);

            }else{

                new_de->ext_flag = sub_de->ext_flag;
                memcpy(new_de->name, s_name, sub_len);
    5aba:	8b 55 a0             	mov    -0x60(%rbp),%edx
    5abd:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    5ac1:	0f b7 4c 16 fe       	movzwl -0x2(%rsi,%rdx,1),%ecx
    5ac6:	66 89 4c 10 fe       	mov    %cx,-0x2(%rax,%rdx,1)
    5acb:	e9 6c f8 ff ff       	jmpq   533c <__rename_dir+0x78c>
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
                this = head = next =NULL;
                head = &old_dir->sub_file;
                list_for_each_safe(this, next, head){
    5ad0:	4c 89 75 98          	mov    %r14,-0x68(%rbp)
    5ad4:	e9 c9 fe ff ff       	jmpq   59a2 <__rename_dir+0xdf2>
    5ad9:	31 f6                	xor    %esi,%esi
    5adb:	e9 f8 fd ff ff       	jmpq   58d8 <__rename_dir+0xd28>
    5ae0:	45 31 e4             	xor    %r12d,%r12d
    5ae3:	e9 1c f5 ff ff       	jmpq   5004 <__rename_dir+0x454>
        new_de->par_pos = 0;
        par_de = &ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
            //nova_dbg("new par is root");
            par_hash = le64_to_cpu(par_de->hname);
    5ae8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
            lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
    5aec:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
    5af3:	4c 8d 45 c4          	lea    -0x3c(%rbp),%r8
    5af7:	b9 01 00 00 00       	mov    $0x1,%ecx
        new_de->par_pos = 0;
        par_de = &ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
            //nova_dbg("new par is root");
            par_hash = le64_to_cpu(par_de->hname);
    5afc:	48 8b 98 a8 40 00 00 	mov    0x40a8(%rax),%rbx
            lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
    5b03:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    5b07:	48 8b 70 18          	mov    0x18(%rax),%rsi
    5b0b:	48 89 da             	mov    %rbx,%rdx
    5b0e:	e8 00 00 00 00       	callq  5b13 <__rename_dir+0xf63>
            pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    5b13:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    5b17:	48 89 de             	mov    %rbx,%rsi
    5b1a:	48 83 c0 38          	add    $0x38,%rax
    5b1e:	48 89 c7             	mov    %rax,%rdi
    5b21:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    5b25:	e8 00 00 00 00       	callq  5b2a <__rename_dir+0xf7a>
    5b2a:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 5b31 <__rename_dir+0xf81>
    5b31:	ba 14 00 00 00       	mov    $0x14,%edx
    5b36:	be d0 80 00 00       	mov    $0x80d0,%esi
    5b3b:	48 89 c3             	mov    %rax,%rbx
    5b3e:	e8 00 00 00 00       	callq  5b43 <__rename_dir+0xf93>
            tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            tem_sf->pos = cpu_to_le32(dir_pos);
    5b43:	8b b5 54 ff ff ff    	mov    -0xac(%rbp),%esi
            list_add_tail(&tem_sf->list, &pdir->sub_file);
    5b49:	48 8d 4b 18          	lea    0x18(%rbx),%rcx
            //nova_dbg("new par is root");
            par_hash = le64_to_cpu(par_de->hname);
            lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
            pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
            tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            tem_sf->pos = cpu_to_le32(dir_pos);
    5b4d:	89 70 10             	mov    %esi,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    5b50:	48 8b 53 20          	mov    0x20(%rbx),%rdx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    5b54:	48 89 43 20          	mov    %rax,0x20(%rbx)
            list_add_tail(&tem_sf->list, &pdir->sub_file);
    5b58:	48 89 08             	mov    %rcx,(%rax)
	new->next = next;
	new->prev = prev;
    5b5b:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    5b5f:	48 89 02             	mov    %rax,(%rdx)
            pdir->sub_num++;
    5b62:	48 83 43 08 01       	addq   $0x1,0x8(%rbx)
    5b67:	e9 47 f4 ff ff       	jmpq   4fb3 <__rename_dir+0x403>
    flen = strlen(path);
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    memcpy(new_ph, path, flen);
    new_ph[flen]='\0';
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
    5b6c:	41 bc 01 00 00 00    	mov    $0x1,%r12d
    5b72:	41 bd 01 00 00 00    	mov    $0x1,%r13d
    5b78:	41 bf 02 00 00 00    	mov    $0x2,%r15d
    struct dzt_entry_info *ch_ei;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    struct dir_info *new_dir, *old_dir, *pdir, *nr_dir;
    struct list_head *this, *head, *next;
    struct file_p *tem_sf, *new_sf;
    u32 bitpos = 0, dir_pos = 0, s_pos, par_pos, par_id;
    5b7e:	c7 85 54 ff ff ff 00 	movl   $0x0,-0xac(%rbp)
    5b85:	00 00 00 
    5b88:	e9 53 f1 ff ff       	jmpq   4ce0 <__rename_dir+0x130>
    kfree(z_p);
    kfree(new_ph);
    //nova_dbg("%s end",__func__);
    return ret;

}
    5b8d:	e8 00 00 00 00       	callq  5b92 <__rename_dir+0xfe2>
    5b92:	0f 1f 40 00          	nopl   0x0(%rax)
    5b96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    5b9d:	00 00 00 

0000000000005ba0 <add_rename_dir>:

/*rename directories*/
int add_rename_dir(struct dentry *o_dentry, struct dentry *n_dentry, struct dafs_dentry *old_de,
                   struct dzt_entry_info *old_ei)
{
    5ba0:	e8 00 00 00 00       	callq  5ba5 <add_rename_dir+0x5>
    5ba5:	55                   	push   %rbp
    5ba6:	48 89 e5             	mov    %rsp,%rbp
    5ba9:	41 57                	push   %r15
    5bab:	41 56                	push   %r14
    5bad:	41 55                	push   %r13
    5baf:	41 54                	push   %r12
    5bb1:	49 89 f7             	mov    %rsi,%r15
    5bb4:	53                   	push   %rbx
    5bb5:	48 83 ec 38          	sub    $0x38,%rsp
    struct super_block *sb = o_dentry->d_sb;
    5bb9:	48 8b 47 68          	mov    0x68(%rdi),%rax
    5bbd:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 5bc4 <add_rename_dir+0x24>
}

/*rename directories*/
int add_rename_dir(struct dentry *o_dentry, struct dentry *n_dentry, struct dafs_dentry *old_de,
                   struct dzt_entry_info *old_ei)
{
    5bc4:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
    5bc8:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
    5bcc:	ba 00 04 00 00       	mov    $0x400,%edx
    5bd1:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
    struct super_block *sb = o_dentry->d_sb;
    5bd5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    //struct dafs_dentry *new_de;
    struct dzt_entry_info *n_ei;
    struct dafs_zone_entry *n_ze;
    char *n_phname, *ph, *phn, *n_name;
    u32 namelen = n_dentry->d_name.len;
    5bd9:	8b 46 24             	mov    0x24(%rsi),%eax
    5bdc:	be d0 80 00 00       	mov    $0x80d0,%esi
    5be1:	89 45 c4             	mov    %eax,-0x3c(%rbp)
    5be4:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    5beb:	00 00 

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    char *ph=NULL, *buf=NULL, *tem=NULL, *mntchar= "/mnt/ramdisk", *end="", *ppath=NULL;
    struct fs_struct *fs = current->fs;
    5bed:	4c 8b a8 30 06 00 00 	mov    0x630(%rax),%r13
    5bf4:	e8 00 00 00 00       	callq  5bf9 <add_rename_dir+0x59>
    5bf9:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 5c00 <add_rename_dir+0x60>
    5c00:	ba 00 04 00 00       	mov    $0x400,%edx
    5c05:	be d0 80 00 00       	mov    $0x80d0,%esi
    5c0a:	49 89 c6             	mov    %rax,%r14
    5c0d:	e8 00 00 00 00       	callq  5c12 <add_rename_dir+0x72>
    5c12:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 5c19 <add_rename_dir+0x79>
    5c19:	48 89 c3             	mov    %rax,%rbx
    5c1c:	ba 00 04 00 00       	mov    $0x400,%edx
    5c21:	be d0 80 00 00       	mov    $0x80d0,%esi
    5c26:	e8 00 00 00 00       	callq  5c2b <add_rename_dir+0x8b>

    //nova_dbg("%s:dafs get dentry path",__func__);
    ph = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    buf = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    tem = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    if(!buf)
    5c2b:	48 85 db             	test   %rbx,%rbx
    5c2e:	0f 84 32 01 00 00    	je     5d66 <add_rename_dir+0x1c6>
        goto ERR;

    read_lock(&fs->lock);
    5c34:	49 8d 7d 04          	lea    0x4(%r13),%rdi
    5c38:	49 89 c4             	mov    %rax,%r12
    5c3b:	e8 00 00 00 00       	callq  5c40 <add_rename_dir+0xa0>
    vfsmnt = mntget(fs->pwd.mnt);
    5c40:	49 8b 7d 28          	mov    0x28(%r13),%rdi
    5c44:	e8 00 00 00 00       	callq  5c49 <add_rename_dir+0xa9>
    if(!vfsmnt){
    5c49:	48 85 c0             	test   %rax,%rax
    tem = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    if(!buf)
        goto ERR;

    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    5c4c:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    if(!vfsmnt){
    5c50:	0f 84 10 01 00 00    	je     5d66 <add_rename_dir+0x1c6>
    5c56:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
    5c5b:	f0 41 0f c1 45 04    	lock xadd %eax,0x4(%r13)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
    5c61:	49 8b 77 28          	mov    0x28(%r15),%rsi
    5c65:	4d 89 fd             	mov    %r15,%r13
    5c68:	49 c7 c7 00 00 00 00 	mov    $0x0,%r15
    5c6f:	b9 02 00 00 00       	mov    $0x2,%ecx
    5c74:	4c 89 ff             	mov    %r15,%rdi
    5c77:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    5c79:	0f 84 d0 02 00 00    	je     5f4f <add_rename_dir+0x3af>
        strcat(buf,"/");
    5c7f:	48 89 df             	mov    %rbx,%rdi
    5c82:	e8 00 00 00 00       	callq  5c87 <add_rename_dir+0xe7>
    5c87:	b9 2f 00 00 00       	mov    $0x2f,%ecx
    5c8c:	66 89 0c 03          	mov    %cx,(%rbx,%rax,1)
        ph[1]='\0';
        return ph;
    }

    do{
        strcat(buf, "/");
    5c90:	48 89 df             	mov    %rbx,%rdi
    5c93:	e8 00 00 00 00       	callq  5c98 <add_rename_dir+0xf8>
    5c98:	ba 2f 00 00 00       	mov    $0x2f,%edx
        strcat(buf, tem_dentry->d_name.name);
    5c9d:	48 8d 7c 03 01       	lea    0x1(%rbx,%rax,1),%rdi
        ph[1]='\0';
        return ph;
    }

    do{
        strcat(buf, "/");
    5ca2:	66 89 14 03          	mov    %dx,(%rbx,%rax,1)
        strcat(buf, tem_dentry->d_name.name);
    5ca6:	49 8b 75 28          	mov    0x28(%r13),%rsi
    5caa:	e8 00 00 00 00       	callq  5caf <add_rename_dir+0x10f>
        p_dentry = tem_dentry->d_parent;
    5caf:	4d 8b 6d 18          	mov    0x18(%r13),%r13
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
    5cb3:	b9 02 00 00 00       	mov    $0x2,%ecx
    5cb8:	4c 89 ff             	mov    %r15,%rdi
    5cbb:	49 8b 75 28          	mov    0x28(%r13),%rsi
    5cbf:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    5cc1:	75 cd                	jne    5c90 <add_rename_dir+0xf0>
    5cc3:	49 8b 45 30          	mov    0x30(%r13),%rax
    5cc7:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
    5ccc:	75 c2                	jne    5c90 <add_rename_dir+0xf0>
            break;
    }while(1);

    BUG_ON(buf==NULL);
    //nova_dbg("%s buf is %s",__func__, buf);
    memcpy(tem, buf, strlen(buf));
    5cce:	48 89 df             	mov    %rbx,%rdi
    5cd1:	e8 00 00 00 00       	callq  5cd6 <add_rename_dir+0x136>
    5cd6:	48 89 de             	mov    %rbx,%rsi
    5cd9:	48 89 c2             	mov    %rax,%rdx
    5cdc:	4c 89 e7             	mov    %r12,%rdi
    5cdf:	e8 00 00 00 00       	callq  5ce4 <add_rename_dir+0x144>
    tlen = strlen(buf);
    5ce4:	48 89 df             	mov    %rbx,%rdi
    5ce7:	e8 00 00 00 00       	callq  5cec <add_rename_dir+0x14c>
    5cec:	49 89 c5             	mov    %rax,%r13
    do{
        ppath = strrchr(tem, '/');
    5cef:	be 2f 00 00 00       	mov    $0x2f,%esi
    5cf4:	4c 89 e7             	mov    %r12,%rdi
    5cf7:	e8 00 00 00 00       	callq  5cfc <add_rename_dir+0x15c>
        phlen = tlen - strlen(ppath);
    5cfc:	48 89 c7             	mov    %rax,%rdi
    5cff:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    5d03:	e8 00 00 00 00       	callq  5d08 <add_rename_dir+0x168>
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        strcat(ph, ppath);
    5d08:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    //nova_dbg("%s buf is %s",__func__, buf);
    memcpy(tem, buf, strlen(buf));
    tlen = strlen(buf);
    do{
        ppath = strrchr(tem, '/');
        phlen = tlen - strlen(ppath);
    5d0c:	49 29 c5             	sub    %rax,%r13
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        strcat(ph, ppath);
    5d0f:	4c 89 f7             	mov    %r14,%rdi
    5d12:	e8 00 00 00 00       	callq  5d17 <add_rename_dir+0x177>
        memcpy(tem, buf, tlen);
    5d17:	48 89 de             	mov    %rbx,%rsi
    5d1a:	4c 89 e7             	mov    %r12,%rdi
    5d1d:	4c 89 ea             	mov    %r13,%rdx
    5d20:	e8 00 00 00 00       	callq  5d25 <add_rename_dir+0x185>
        tem[tlen]='\0';
    5d25:	43 c6 04 2c 00       	movb   $0x0,(%r12,%r13,1)
        //memcpy(tem+tlen, end, 1);
        if(!strcmp(tem,"/"))
    5d2a:	b9 02 00 00 00       	mov    $0x2,%ecx
    5d2f:	4c 89 e6             	mov    %r12,%rsi
    5d32:	4c 89 ff             	mov    %r15,%rdi
    5d35:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    5d37:	75 b6                	jne    5cef <add_rename_dir+0x14f>
            break;
    }while(1);

    BUG_ON(strlen(ph)==1024);
    5d39:	4c 89 f7             	mov    %r14,%rdi
    5d3c:	e8 00 00 00 00       	callq  5d41 <add_rename_dir+0x1a1>
    5d41:	48 3d 00 04 00 00    	cmp    $0x400,%rax
    5d47:	0f 84 00 02 00 00    	je     5f4d <add_rename_dir+0x3ad>
    //nova_dbg("%s ful ph is %s",__func__,ph);
    
    mntput(vfsmnt);
    5d4d:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    5d51:	e8 00 00 00 00       	callq  5d56 <add_rename_dir+0x1b6>
    
    kfree(buf);
    5d56:	48 89 df             	mov    %rbx,%rdi
    5d59:	e8 00 00 00 00       	callq  5d5e <add_rename_dir+0x1be>
    kfree(tem);
    5d5e:	4c 89 e7             	mov    %r12,%rdi
    5d61:	e8 00 00 00 00       	callq  5d66 <add_rename_dir+0x1c6>
    //int i;
    int ret= 0;

    //nova_dbg("%s start",__func__); 
    ph = get_dentry_path(n_dentry,0);
    n_phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    5d66:	4c 89 f7             	mov    %r14,%rdi
    5d69:	e8 00 00 00 00       	callq  5d6e <add_rename_dir+0x1ce>
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    5d6e:	be d0 80 00 00       	mov    $0x80d0,%esi
    5d73:	48 89 c7             	mov    %rax,%rdi
    5d76:	e8 00 00 00 00       	callq  5d7b <add_rename_dir+0x1db>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    5d7b:	4c 89 f7             	mov    %r14,%rdi
    5d7e:	49 89 c7             	mov    %rax,%r15
    5d81:	e8 00 00 00 00       	callq  5d86 <add_rename_dir+0x1e6>
    5d86:	be d0 80 00 00       	mov    $0x80d0,%esi
    5d8b:	48 89 c7             	mov    %rax,%rdi
    5d8e:	e8 00 00 00 00       	callq  5d93 <add_rename_dir+0x1f3>
    5d93:	49 89 c4             	mov    %rax,%r12
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    5d96:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    5d9a:	4c 89 f7             	mov    %r14,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    5d9d:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
    5da4:	4c 8b a8 d8 01 00 00 	mov    0x1d8(%rax),%r13
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    5dab:	e8 00 00 00 00       	callq  5db0 <add_rename_dir+0x210>
    5db0:	4c 89 f6             	mov    %r14,%rsi
    5db3:	48 89 c2             	mov    %rax,%rdx
    5db6:	4c 89 e7             	mov    %r12,%rdi
    5db9:	e8 00 00 00 00       	callq  5dbe <add_rename_dir+0x21e>
    tlen = strlen(phstr);
    5dbe:	4c 89 f7             	mov    %r14,%rdi
    5dc1:	e8 00 00 00 00       	callq  5dc6 <add_rename_dir+0x226>
    5dc6:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
    5dc9:	be 2f 00 00 00       	mov    $0x2f,%esi
    5dce:	4c 89 e7             	mov    %r12,%rdi
    5dd1:	e8 00 00 00 00       	callq  5dd6 <add_rename_dir+0x236>
        phlen = tlen -strlen(tem);
    5dd6:	48 89 c7             	mov    %rax,%rdi
    5dd9:	e8 00 00 00 00       	callq  5dde <add_rename_dir+0x23e>
        tlen = phlen;
        //bug
        if(phlen==0){
    5dde:	48 29 c3             	sub    %rax,%rbx
    5de1:	0f 84 20 01 00 00    	je     5f07 <add_rename_dir+0x367>
            break;
        }
        memcpy(ph,phstr,tlen);
    5de7:	48 89 da             	mov    %rbx,%rdx
    5dea:	4c 89 f6             	mov    %r14,%rsi
    5ded:	4c 89 e7             	mov    %r12,%rdi
    5df0:	e8 00 00 00 00       	callq  5df5 <add_rename_dir+0x255>
	int i;

	for (i = 0; i < length; i++) {
    5df5:	85 db                	test   %ebx,%ebx
        ph[tlen]='\0';
    5df7:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
    5dfc:	0f 8e ed 00 00 00    	jle    5eef <add_rename_dir+0x34f>
    5e02:	8d 43 ff             	lea    -0x1(%rbx),%eax
    5e05:	4c 89 e2             	mov    %r12,%rdx
    5e08:	31 f6                	xor    %esi,%esi
    5e0a:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
    5e0f:	48 89 f0             	mov    %rsi,%rax
    5e12:	48 83 c2 01          	add    $0x1,%rdx
    5e16:	48 c1 e0 05          	shl    $0x5,%rax
    5e1a:	48 29 f0             	sub    %rsi,%rax
    5e1d:	48 89 c6             	mov    %rax,%rsi
    5e20:	48 0f be 42 ff       	movsbq -0x1(%rdx),%rax
    5e25:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    5e28:	48 39 ca             	cmp    %rcx,%rdx
    5e2b:	75 e2                	jne    5e0f <add_rename_dir+0x26f>
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    5e2d:	4c 89 ef             	mov    %r13,%rdi
    5e30:	e8 00 00 00 00       	callq  5e35 <add_rename_dir+0x295>
        if(dzt_ei){
    5e35:	48 85 c0             	test   %rax,%rax
    5e38:	74 8f                	je     5dc9 <add_rename_dir+0x229>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(n_phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    
    phlen = strlen(phn);
    5e3a:	4c 89 e7             	mov    %r12,%rdi
    memcpy(ph, "/", 1);
    ph[1]='\0';
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    if(!dzt_ei){
    5e3d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(n_phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    
    phlen = strlen(phn);
    5e41:	e8 00 00 00 00       	callq  5e46 <add_rename_dir+0x2a6>
    if(phlen==1){
    5e46:	48 83 f8 01          	cmp    $0x1,%rax
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(n_phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    
    phlen = strlen(phn);
    5e4a:	48 89 c3             	mov    %rax,%rbx
    if(phlen==1){
        flen = strlen(ph);
    5e4d:	4c 89 f7             	mov    %r14,%rdi
    //memcpy(n_phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    
    phlen = strlen(phn);
    if(phlen==1){
    5e50:	0f 84 d7 00 00 00    	je     5f2d <add_rename_dir+0x38d>
        flen = strlen(ph);
        memcpy(n_phname, ph, flen);
        n_phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    5e56:	e8 00 00 00 00       	callq  5e5b <add_rename_dir+0x2bb>
        memcpy(n_phname, ph+phlen, flen);
    5e5b:	49 8d 34 1e          	lea    (%r14,%rbx,1),%rsi
    if(phlen==1){
        flen = strlen(ph);
        memcpy(n_phname, ph, flen);
        n_phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    5e5f:	48 29 d8             	sub    %rbx,%rax
        memcpy(n_phname, ph+phlen, flen);
    5e62:	4c 89 ff             	mov    %r15,%rdi
    if(phlen==1){
        flen = strlen(ph);
        memcpy(n_phname, ph, flen);
        n_phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    5e65:	49 89 c5             	mov    %rax,%r13
        memcpy(n_phname, ph+phlen, flen);
    5e68:	48 89 c2             	mov    %rax,%rdx
    5e6b:	e8 00 00 00 00       	callq  5e70 <add_rename_dir+0x2d0>
        n_phname[flen]='\0';
    5e70:	43 c6 04 2f 00       	movb   $0x0,(%r15,%r13,1)
    }

    n_name = kzalloc(sizeof(char)*namelen, GFP_KERNEL);
    5e75:	8b 5d c4             	mov    -0x3c(%rbp),%ebx
    5e78:	be d0 80 00 00       	mov    $0x80d0,%esi
    5e7d:	48 89 df             	mov    %rbx,%rdi
    5e80:	e8 00 00 00 00       	callq  5e85 <add_rename_dir+0x2e5>
    5e85:	49 89 c5             	mov    %rax,%r13
    memcpy(n_name, n_dentry->d_name.name, namelen);
    5e88:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    5e8c:	48 89 da             	mov    %rbx,%rdx
    5e8f:	4c 89 ef             	mov    %r13,%rdi
    5e92:	48 8b 70 28          	mov    0x28(%rax),%rsi
    5e96:	e8 00 00 00 00       	callq  5e9b <add_rename_dir+0x2fb>
    n_name[namelen] = '\0';

    ret = __rename_dir(sb, old_de, n_ei, old_ei,n_phname, n_name);
    5e9b:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
    5e9f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    5ea3:	4d 89 e9             	mov    %r13,%r9
    5ea6:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    5eaa:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    5eae:	4d 89 f8             	mov    %r15,%r8
        n_phname[flen]='\0';
    }

    n_name = kzalloc(sizeof(char)*namelen, GFP_KERNEL);
    memcpy(n_name, n_dentry->d_name.name, namelen);
    n_name[namelen] = '\0';
    5eb1:	41 c6 44 1d 00 00    	movb   $0x0,0x0(%r13,%rbx,1)

    ret = __rename_dir(sb, old_de, n_ei, old_ei,n_phname, n_name);
    5eb7:	e8 00 00 00 00       	callq  5ebc <add_rename_dir+0x31c>
    
    kfree(n_phname);
    5ebc:	4c 89 ff             	mov    %r15,%rdi

    n_name = kzalloc(sizeof(char)*namelen, GFP_KERNEL);
    memcpy(n_name, n_dentry->d_name.name, namelen);
    n_name[namelen] = '\0';

    ret = __rename_dir(sb, old_de, n_ei, old_ei,n_phname, n_name);
    5ebf:	89 c3                	mov    %eax,%ebx
    
    kfree(n_phname);
    5ec1:	e8 00 00 00 00       	callq  5ec6 <add_rename_dir+0x326>
    kfree(phn);
    5ec6:	4c 89 e7             	mov    %r12,%rdi
    5ec9:	e8 00 00 00 00       	callq  5ece <add_rename_dir+0x32e>
    kfree(ph);
    5ece:	4c 89 f7             	mov    %r14,%rdi
    5ed1:	e8 00 00 00 00       	callq  5ed6 <add_rename_dir+0x336>
    kfree(n_name);
    5ed6:	4c 89 ef             	mov    %r13,%rdi
    5ed9:	e8 00 00 00 00       	callq  5ede <add_rename_dir+0x33e>
    //nova_dbg("%s end",__func__);
    return ret;
}
    5ede:	48 83 c4 38          	add    $0x38,%rsp
    5ee2:	89 d8                	mov    %ebx,%eax
    5ee4:	5b                   	pop    %rbx
    5ee5:	41 5c                	pop    %r12
    5ee7:	41 5d                	pop    %r13
    5ee9:	41 5e                	pop    %r14
    5eeb:	41 5f                	pop    %r15
    5eed:	5d                   	pop    %rbp
    5eee:	c3                   	retq   
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    5eef:	31 f6                	xor    %esi,%esi
        memcpy(ph,phstr,tlen);
        ph[tlen]='\0';
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    5ef1:	4c 89 ef             	mov    %r13,%rdi
    5ef4:	e8 00 00 00 00       	callq  5ef9 <add_rename_dir+0x359>
        if(dzt_ei){
    5ef9:	48 85 c0             	test   %rax,%rax
    5efc:	0f 84 c7 fe ff ff    	je     5dc9 <add_rename_dir+0x229>
    5f02:	e9 33 ff ff ff       	jmpq   5e3a <add_rename_dir+0x29a>
            return dzt_ei;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    5f07:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    ph[1]='\0';
    5f0c:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    5f12:	be 2f 00 00 00       	mov    $0x2f,%esi
    5f17:	4c 89 ef             	mov    %r13,%rdi
    5f1a:	e8 00 00 00 00       	callq  5f1f <add_rename_dir+0x37f>
    if(!dzt_ei){
    5f1f:	48 85 c0             	test   %rax,%rax
    5f22:	0f 85 12 ff ff ff    	jne    5e3a <add_rename_dir+0x29a>
    5f28:	e8 00 00 00 00       	callq  5f2d <add_rename_dir+0x38d>
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
    5f2d:	e8 00 00 00 00       	callq  5f32 <add_rename_dir+0x392>
        memcpy(n_phname, ph, flen);
    5f32:	4c 89 f6             	mov    %r14,%rsi
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
    5f35:	48 89 c3             	mov    %rax,%rbx
        memcpy(n_phname, ph, flen);
    5f38:	48 89 c2             	mov    %rax,%rdx
    5f3b:	4c 89 ff             	mov    %r15,%rdi
    5f3e:	e8 00 00 00 00       	callq  5f43 <add_rename_dir+0x3a3>
        n_phname[flen]='\0';
    5f43:	41 c6 04 1f 00       	movb   $0x0,(%r15,%rbx,1)
    5f48:	e9 28 ff ff ff       	jmpq   5e75 <add_rename_dir+0x2d5>
        //memcpy(tem+tlen, end, 1);
        if(!strcmp(tem,"/"))
            break;
    }while(1);

    BUG_ON(strlen(ph)==1024);
    5f4d:	0f 0b                	ud2    
    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
        strcat(buf,"/");
    else{
        nova_dbg("%s root dentry",__func__);
    5f4f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    5f56:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    5f5d:	e8 00 00 00 00       	callq  5f62 <add_rename_dir+0x3c2>
        memcpy(ph, "/", 1);
    5f62:	41 c6 06 2f          	movb   $0x2f,(%r14)
        ph[1]='\0';
    5f66:	41 c6 46 01 00       	movb   $0x0,0x1(%r14)
    5f6b:	e9 f6 fd ff ff       	jmpq   5d66 <add_rename_dir+0x1c6>

0000000000005f70 <__rename_dir_direntry>:
/*rename_s 是父文件夹是否变化的标志
 * 0不变化父文件夹
 * ch_link inc or dec links
 * not decided 标记log*/
int __rename_dir_direntry(struct dentry *old_dentry, struct dentry *new_dentry)
{ 
    5f70:	e8 00 00 00 00       	callq  5f75 <__rename_dir_direntry+0x5>
    5f75:	55                   	push   %rbp
    5f76:	48 89 e5             	mov    %rsp,%rbp
    5f79:	41 57                	push   %r15
    5f7b:	41 56                	push   %r14
    5f7d:	41 55                	push   %r13
    5f7f:	41 54                	push   %r12
    5f81:	53                   	push   %rbx
    5f82:	48 83 ec 48          	sub    $0x48,%rsp
    struct super_block *sb = old_dentry->d_sb;
    5f86:	4c 8b 7f 68          	mov    0x68(%rdi),%r15
/*rename_s 是父文件夹是否变化的标志
 * 0不变化父文件夹
 * ch_link inc or dec links
 * not decided 标记log*/
int __rename_dir_direntry(struct dentry *old_dentry, struct dentry *new_dentry)
{ 
    5f8a:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
    5f8e:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    5f95:	00 00 
    5f97:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    5f9b:	31 c0                	xor    %eax,%eax
    5f9d:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
    struct super_block *sb = old_dentry->d_sb;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dafs_dentry *old_de;
    struct dzt_entry_info *ch_ei, *old_ei;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    5fa1:	49 8b 87 b0 03 00 00 	mov    0x3b0(%r15),%rax
    5fa8:	48 8b 80 d8 01 00 00 	mov    0x1d8(%rax),%rax
    5faf:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    u64 ph_hash, ht_addr, flen, phlen;
    int err = -ENOENT;
    int ret;

    //nova_dbg("%s start",__func__);
    ph = get_dentry_path(old_dentry, 0);
    5fb3:	e8 48 a1 ff ff       	callq  100 <get_dentry_path.isra.4>
    //nova_dbg("strictly full name is %s", ph);
    //nova_dbg("strictly full name length is %llu", strlen(ph));
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    5fb8:	48 89 c7             	mov    %rax,%rdi
    u64 ph_hash, ht_addr, flen, phlen;
    int err = -ENOENT;
    int ret;

    //nova_dbg("%s start",__func__);
    ph = get_dentry_path(old_dentry, 0);
    5fbb:	49 89 c5             	mov    %rax,%r13
    //nova_dbg("strictly full name is %s", ph);
    //nova_dbg("strictly full name length is %llu", strlen(ph));
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    5fbe:	e8 00 00 00 00       	callq  5fc3 <__rename_dir_direntry+0x53>
    5fc3:	be d0 80 00 00       	mov    $0x80d0,%esi
    5fc8:	48 89 c7             	mov    %rax,%rdi
    5fcb:	e8 00 00 00 00       	callq  5fd0 <__rename_dir_direntry+0x60>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    5fd0:	4c 89 ef             	mov    %r13,%rdi
    5fd3:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    5fd7:	e8 00 00 00 00       	callq  5fdc <__rename_dir_direntry+0x6c>
    5fdc:	be d0 80 00 00       	mov    $0x80d0,%esi
    5fe1:	48 89 c7             	mov    %rax,%rdi
    5fe4:	e8 00 00 00 00       	callq  5fe9 <__rename_dir_direntry+0x79>
    5fe9:	49 89 c4             	mov    %rax,%r12
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    5fec:	49 8b 87 b0 03 00 00 	mov    0x3b0(%r15),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    5ff3:	4c 89 ef             	mov    %r13,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    5ff6:	4c 8b b0 d8 01 00 00 	mov    0x1d8(%rax),%r14
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    5ffd:	e8 00 00 00 00       	callq  6002 <__rename_dir_direntry+0x92>
    6002:	4c 89 ee             	mov    %r13,%rsi
    6005:	48 89 c2             	mov    %rax,%rdx
    6008:	4c 89 e7             	mov    %r12,%rdi
    600b:	e8 00 00 00 00       	callq  6010 <__rename_dir_direntry+0xa0>
    tlen = strlen(phstr);
    6010:	4c 89 ef             	mov    %r13,%rdi
    6013:	e8 00 00 00 00       	callq  6018 <__rename_dir_direntry+0xa8>
    6018:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
    601b:	be 2f 00 00 00       	mov    $0x2f,%esi
    6020:	4c 89 e7             	mov    %r12,%rdi
    6023:	e8 00 00 00 00       	callq  6028 <__rename_dir_direntry+0xb8>
        phlen = tlen -strlen(tem);
    6028:	48 89 c7             	mov    %rax,%rdi
    602b:	e8 00 00 00 00       	callq  6030 <__rename_dir_direntry+0xc0>
        tlen = phlen;
        //bug
        if(phlen==0){
    6030:	48 29 c3             	sub    %rax,%rbx
    6033:	0f 84 b3 01 00 00    	je     61ec <__rename_dir_direntry+0x27c>
            break;
        }
        memcpy(ph,phstr,tlen);
    6039:	48 89 da             	mov    %rbx,%rdx
    603c:	4c 89 ee             	mov    %r13,%rsi
    603f:	4c 89 e7             	mov    %r12,%rdi
    6042:	e8 00 00 00 00       	callq  6047 <__rename_dir_direntry+0xd7>
	int i;

	for (i = 0; i < length; i++) {
    6047:	85 db                	test   %ebx,%ebx
        ph[tlen]='\0';
    6049:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
    604e:	0f 8e 80 01 00 00    	jle    61d4 <__rename_dir_direntry+0x264>
    6054:	8d 43 ff             	lea    -0x1(%rbx),%eax
    6057:	4c 89 e2             	mov    %r12,%rdx
    605a:	31 f6                	xor    %esi,%esi
    605c:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
    6061:	48 89 f0             	mov    %rsi,%rax
    6064:	48 83 c2 01          	add    $0x1,%rdx
    6068:	48 c1 e0 05          	shl    $0x5,%rax
    606c:	48 29 f0             	sub    %rsi,%rax
    606f:	48 89 c6             	mov    %rax,%rsi
    6072:	48 0f be 42 ff       	movsbq -0x1(%rdx),%rax
    6077:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    607a:	48 39 ca             	cmp    %rcx,%rdx
    607d:	75 e2                	jne    6061 <__rename_dir_direntry+0xf1>
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    607f:	4c 89 f7             	mov    %r14,%rdi
    6082:	e8 00 00 00 00       	callq  6087 <__rename_dir_direntry+0x117>
        if(dzt_ei){
    6087:	48 85 c0             	test   %rax,%rax
    608a:	74 8f                	je     601b <__rename_dir_direntry+0xab>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    608c:	49 8b 97 b0 03 00 00 	mov    0x3b0(%r15),%rdx
    memcpy(ph, "/", 1);
    ph[1]='\0';
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    if(!dzt_ei){
    6093:	48 89 c3             	mov    %rax,%rbx
    //nova_dbg("strictly full name is %s", ph);
    //nova_dbg("strictly full name length is %llu", strlen(ph));
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    old_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    6096:	48 8b 40 10          	mov    0x10(%rax),%rax
    phlen = strlen(phn);
    609a:	4c 89 e7             	mov    %r12,%rdi
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    609d:	49 89 c6             	mov    %rax,%r14
    60a0:	4c 03 72 18          	add    0x18(%rdx),%r14
    60a4:	48 85 c0             	test   %rax,%rax
    60a7:	b8 00 00 00 00       	mov    $0x0,%eax
    60ac:	4c 0f 44 f0          	cmove  %rax,%r14
    60b0:	e8 00 00 00 00       	callq  60b5 <__rename_dir_direntry+0x145>
    dzt_eno = old_ei->dzt_eno;
    if(phlen==1){
    60b5:	48 83 f8 01          	cmp    $0x1,%rax
    60b9:	0f 84 5e 01 00 00    	je     621d <__rename_dir_direntry+0x2ad>
        slen = strlen(ph);
        memcpy(phname, ph, slen);
        phname[slen] = '\0';
    } else {
        flen = strlen(ph)-phlen;
    60bf:	4c 89 ef             	mov    %r13,%rdi
    60c2:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    60c6:	e8 00 00 00 00       	callq  60cb <__rename_dir_direntry+0x15b>
    60cb:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
        memcpy(phname, ph+phlen, flen);
    60cf:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    if(phlen==1){
        slen = strlen(ph);
        memcpy(phname, ph, slen);
        phname[slen] = '\0';
    } else {
        flen = strlen(ph)-phlen;
    60d3:	48 29 c8             	sub    %rcx,%rax
        memcpy(phname, ph+phlen, flen);
    60d6:	49 8d 74 0d 00       	lea    0x0(%r13,%rcx,1),%rsi
    60db:	48 89 c2             	mov    %rax,%rdx
    60de:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    60e2:	e8 00 00 00 00       	callq  60e7 <__rename_dir_direntry+0x177>
        phname[flen] = '\0';
    60e7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    60eb:	4c 8b 45 98          	mov    -0x68(%rbp),%r8
    60ef:	42 c6 04 00 00       	movb   $0x0,(%rax,%r8,1)
    }
    ph_hash = BKDRHash(phname, strlen(phname));
    60f4:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    60f8:	e8 00 00 00 00       	callq  60fd <__rename_dir_direntry+0x18d>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    60fd:	85 c0                	test   %eax,%eax
    60ff:	0f 8e c0 01 00 00    	jle    62c5 <__rename_dir_direntry+0x355>
    6105:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    6109:	83 e8 01             	sub    $0x1,%eax
    610c:	31 d2                	xor    %edx,%edx
    610e:	48 8d 74 07 01       	lea    0x1(%rdi,%rax,1),%rsi
    6113:	48 89 f9             	mov    %rdi,%rcx
		hash = hash * seed + (*str++);
    6116:	48 89 d0             	mov    %rdx,%rax
    6119:	48 83 c1 01          	add    $0x1,%rcx
    611d:	48 c1 e0 05          	shl    $0x5,%rax
    6121:	48 29 d0             	sub    %rdx,%rax
    6124:	48 89 c2             	mov    %rax,%rdx
    6127:	48 0f be 41 ff       	movsbq -0x1(%rcx),%rax
    612c:	48 01 c2             	add    %rax,%rdx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    612f:	48 39 f1             	cmp    %rsi,%rcx
    6132:	75 e2                	jne    6116 <__rename_dir_direntry+0x1a6>
    ht_addr = old_ei->ht_head;
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    6134:	48 8b 73 18          	mov    0x18(%rbx),%rsi
    6138:	4c 8d 45 bc          	lea    -0x44(%rbp),%r8
    613c:	b9 01 00 00 00       	mov    $0x1,%ecx
    6141:	4c 89 ff             	mov    %r15,%rdi
    6144:	e8 00 00 00 00       	callq  6149 <__rename_dir_direntry+0x1d9>
    6149:	89 c2                	mov    %eax,%edx
    struct dafs_zone_entry *dafs_ze;
    char *phname, *ph, *phn;
    u32 dzt_eno, de_pos,slen;
    u64 old_hn, new_hn, root_len;
    u64 ph_hash, ht_addr, flen, phlen;
    int err = -ENOENT;
    614b:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        phname[flen] = '\0';
    }
    ph_hash = BKDRHash(phname, strlen(phname));
    ht_addr = old_ei->ht_head;
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    if(!ret){
    6150:	85 d2                	test   %edx,%edx
    6152:	74 5e                	je     61b2 <__rename_dir_direntry+0x242>
        //nova_dbg("not found dentry in nvm");
        goto OUT;
    }
    old_de = &dafs_ze->dentry[de_pos];
    6154:	8b 45 bc             	mov    -0x44(%rbp),%eax
    kfree(phname);
    6157:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    if(!ret){
        //nova_dbg("not found dentry in nvm");
        goto OUT;
    }
    old_de = &dafs_ze->dentry[de_pos];
    615b:	4c 8d b8 81 00 00 00 	lea    0x81(%rax),%r15
    6162:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    kfree(phname);
    6166:	e8 00 00 00 00       	callq  616b <__rename_dir_direntry+0x1fb>
    kfree(ph);
    616b:	4c 89 ef             	mov    %r13,%rdi
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    if(!ret){
        //nova_dbg("not found dentry in nvm");
        goto OUT;
    }
    old_de = &dafs_ze->dentry[de_pos];
    616e:	49 c1 e7 07          	shl    $0x7,%r15
    kfree(phname);
    kfree(ph);
    6172:	e8 00 00 00 00       	callq  6177 <__rename_dir_direntry+0x207>
    kfree(phn);
    6177:	4c 89 e7             	mov    %r12,%rdi
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    if(!ret){
        //nova_dbg("not found dentry in nvm");
        goto OUT;
    }
    old_de = &dafs_ze->dentry[de_pos];
    617a:	4d 01 f7             	add    %r14,%r15
    kfree(phname);
    kfree(ph);
    kfree(phn);
    617d:	e8 00 00 00 00       	callq  6182 <__rename_dir_direntry+0x212>
    6182:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    6186:	48 c1 e0 07          	shl    $0x7,%rax
    618a:	49 01 c6             	add    %rax,%r14
    //old_de = dafs_find_direntry(sb, old_dentry,0,0);
    //dz_no = le64_to_cpu(old_de->zone_no);
    
    if(old_de->file_type == ROOT_DIRECTORY){
    618d:	41 80 be 82 40 00 00 	cmpb   $0x2,0x4082(%r14)
    6194:	02 
    6195:	0f 84 b0 00 00 00    	je     624b <__rename_dir_direntry+0x2db>
        old_de->file_type = NORMAL_FILE;
        err = dafs_remove_dentry(old_dentry);

    } else {
        
        err = add_rename_dir(old_dentry, new_dentry, old_de, old_ei); 
    619b:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
    619f:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    61a3:	48 89 d9             	mov    %rbx,%rcx
    61a6:	4c 89 fa             	mov    %r15,%rdx
    61a9:	e8 00 00 00 00       	callq  61ae <__rename_dir_direntry+0x23e>
        if(err)
    61ae:	85 c0                	test   %eax,%eax
    61b0:	74 60                	je     6212 <__rename_dir_direntry+0x2a2>
            return err;
        err = dafs_remove_dentry(old_dentry);
    }
OUT:
   return err;
}
    61b2:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    61b6:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    61bd:	00 00 
    61bf:	0f 85 07 01 00 00    	jne    62cc <__rename_dir_direntry+0x35c>
    61c5:	48 83 c4 48          	add    $0x48,%rsp
    61c9:	5b                   	pop    %rbx
    61ca:	41 5c                	pop    %r12
    61cc:	41 5d                	pop    %r13
    61ce:	41 5e                	pop    %r14
    61d0:	41 5f                	pop    %r15
    61d2:	5d                   	pop    %rbp
    61d3:	c3                   	retq   
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    61d4:	31 f6                	xor    %esi,%esi
        memcpy(ph,phstr,tlen);
        ph[tlen]='\0';
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    61d6:	4c 89 f7             	mov    %r14,%rdi
    61d9:	e8 00 00 00 00       	callq  61de <__rename_dir_direntry+0x26e>
        if(dzt_ei){
    61de:	48 85 c0             	test   %rax,%rax
    61e1:	0f 84 34 fe ff ff    	je     601b <__rename_dir_direntry+0xab>
    61e7:	e9 a0 fe ff ff       	jmpq   608c <__rename_dir_direntry+0x11c>
            return dzt_ei;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    61ec:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    ph[1]='\0';
    61f1:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    61f7:	be 2f 00 00 00       	mov    $0x2f,%esi
    61fc:	4c 89 f7             	mov    %r14,%rdi
    61ff:	e8 00 00 00 00       	callq  6204 <__rename_dir_direntry+0x294>
    if(!dzt_ei){
    6204:	48 85 c0             	test   %rax,%rax
    6207:	0f 85 7f fe ff ff    	jne    608c <__rename_dir_direntry+0x11c>
    620d:	e8 00 00 00 00       	callq  6212 <__rename_dir_direntry+0x2a2>
    } else {
        
        err = add_rename_dir(old_dentry, new_dentry, old_de, old_ei); 
        if(err)
            return err;
        err = dafs_remove_dentry(old_dentry);
    6212:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    6216:	e8 00 00 00 00       	callq  621b <__rename_dir_direntry+0x2ab>
    621b:	eb 95                	jmp    61b2 <__rename_dir_direntry+0x242>
    old_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    phlen = strlen(phn);
    dzt_eno = old_ei->dzt_eno;
    if(phlen==1){
        slen = strlen(ph);
    621d:	4c 89 ef             	mov    %r13,%rdi
    6220:	e8 00 00 00 00       	callq  6225 <__rename_dir_direntry+0x2b5>
        memcpy(phname, ph, slen);
    6225:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    6229:	89 c1                	mov    %eax,%ecx
    622b:	4c 89 ee             	mov    %r13,%rsi
    622e:	48 89 ca             	mov    %rcx,%rdx
    6231:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
    6235:	e8 00 00 00 00       	callq  623a <__rename_dir_direntry+0x2ca>
        phname[slen] = '\0';
    623a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    623e:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
    6242:	c6 04 08 00          	movb   $0x0,(%rax,%rcx,1)
    6246:	e9 a9 fe ff ff       	jmpq   60f4 <__rename_dir_direntry+0x184>
    //old_de = dafs_find_direntry(sb, old_dentry,0,0);
    //dz_no = le64_to_cpu(old_de->zone_no);
    
    if(old_de->file_type == ROOT_DIRECTORY){
        old_hn = le64_to_cpu(old_de->hname);
        ch_ei = radix_tree_delete(&dzt_m->dzt_root, old_hn);
    624b:	49 8b b6 a8 40 00 00 	mov    0x40a8(%r14),%rsi
    6252:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
    6256:	e8 00 00 00 00       	callq  625b <__rename_dir_direntry+0x2eb>
        err = add_rename_zone_dir(new_dentry, old_de, old_ei, &new_hn, &root_len);
    625b:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    625f:	4c 8d 45 c8          	lea    -0x38(%rbp),%r8
    6263:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
    6267:	48 89 da             	mov    %rbx,%rdx
    626a:	4c 89 fe             	mov    %r15,%rsi
    //old_de = dafs_find_direntry(sb, old_dentry,0,0);
    //dz_no = le64_to_cpu(old_de->zone_no);
    
    if(old_de->file_type == ROOT_DIRECTORY){
        old_hn = le64_to_cpu(old_de->hname);
        ch_ei = radix_tree_delete(&dzt_m->dzt_root, old_hn);
    626d:	49 89 c4             	mov    %rax,%r12
        err = add_rename_zone_dir(new_dentry, old_de, old_ei, &new_hn, &root_len);
    6270:	e8 00 00 00 00       	callq  6275 <__rename_dir_direntry+0x305>
        /*防止zone被删除*/
        if(err)
    6275:	85 c0                	test   %eax,%eax
    6277:	0f 85 35 ff ff ff    	jne    61b2 <__rename_dir_direntry+0x242>
            return err;
        ch_ei->root_len = root_len;
        ch_ei->hash_name = new_hn;
    627d:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
        /*update ei hashname, root len and set dirty bit*/
        radix_tree_insert(&dzt_m->dzt_root, new_hn, ch_ei);
    6281:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
    6285:	4c 89 e2             	mov    %r12,%rdx
        ch_ei = radix_tree_delete(&dzt_m->dzt_root, old_hn);
        err = add_rename_zone_dir(new_dentry, old_de, old_ei, &new_hn, &root_len);
        /*防止zone被删除*/
        if(err)
            return err;
        ch_ei->root_len = root_len;
    6288:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
        ch_ei->hash_name = new_hn;
    628c:	49 89 74 24 30       	mov    %rsi,0x30(%r12)
        /*update ei hashname, root len and set dirty bit*/
        radix_tree_insert(&dzt_m->dzt_root, new_hn, ch_ei);
    6291:	48 89 df             	mov    %rbx,%rdi
        ch_ei = radix_tree_delete(&dzt_m->dzt_root, old_hn);
        err = add_rename_zone_dir(new_dentry, old_de, old_ei, &new_hn, &root_len);
        /*防止zone被删除*/
        if(err)
            return err;
        ch_ei->root_len = root_len;
    6294:	49 89 44 24 28       	mov    %rax,0x28(%r12)
        ch_ei->hash_name = new_hn;
        /*update ei hashname, root len and set dirty bit*/
        radix_tree_insert(&dzt_m->dzt_root, new_hn, ch_ei);
    6299:	e8 00 00 00 00       	callq  629e <__rename_dir_direntry+0x32e>
        radix_tree_tag_set(&dzt_m->dzt_root, new_hn, 1);
    629e:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    62a2:	48 89 df             	mov    %rbx,%rdi
    62a5:	ba 01 00 00 00       	mov    $0x1,%edx
    62aa:	e8 00 00 00 00       	callq  62af <__rename_dir_direntry+0x33f>

        old_de->file_type = NORMAL_FILE;
        err = dafs_remove_dentry(old_dentry);
    62af:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
        ch_ei->hash_name = new_hn;
        /*update ei hashname, root len and set dirty bit*/
        radix_tree_insert(&dzt_m->dzt_root, new_hn, ch_ei);
        radix_tree_tag_set(&dzt_m->dzt_root, new_hn, 1);

        old_de->file_type = NORMAL_FILE;
    62b3:	41 c6 86 82 40 00 00 	movb   $0x0,0x4082(%r14)
    62ba:	00 
        err = dafs_remove_dentry(old_dentry);
    62bb:	e8 00 00 00 00       	callq  62c0 <__rename_dir_direntry+0x350>
    62c0:	e9 ed fe ff ff       	jmpq   61b2 <__rename_dir_direntry+0x242>
    62c5:	31 d2                	xor    %edx,%edx
    62c7:	e9 68 fe ff ff       	jmpq   6134 <__rename_dir_direntry+0x1c4>
            return err;
        err = dafs_remove_dentry(old_dentry);
    }
OUT:
   return err;
}
    62cc:	e8 00 00 00 00       	callq  62d1 <__rename_dir_direntry+0x361>
    62d1:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    62d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    62dd:	00 00 00 

00000000000062e0 <__rename_file_dentry>:

int __rename_file_dentry(struct dentry *old_dentry, struct dentry *new_dentry)
{
    62e0:	e8 00 00 00 00       	callq  62e5 <__rename_file_dentry+0x5>
    62e5:	55                   	push   %rbp
    u64 temlen, phlen, flen;
    u64 hashname, par_hn, ino;
    int ret = 0;
    char *end ="";

    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);
    62e6:	31 c9                	xor    %ecx,%ecx
    62e8:	31 d2                	xor    %edx,%edx
OUT:
   return err;
}

int __rename_file_dentry(struct dentry *old_dentry, struct dentry *new_dentry)
{
    62ea:	48 89 e5             	mov    %rsp,%rbp
    62ed:	41 57                	push   %r15
    62ef:	41 56                	push   %r14
    62f1:	41 55                	push   %r13
    62f3:	41 54                	push   %r12
    62f5:	49 89 f7             	mov    %rsi,%r15
    62f8:	53                   	push   %rbx
    u64 temlen, phlen, flen;
    u64 hashname, par_hn, ino;
    int ret = 0;
    char *end ="";

    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);
    62f9:	48 89 fe             	mov    %rdi,%rsi
OUT:
   return err;
}

int __rename_file_dentry(struct dentry *old_dentry, struct dentry *new_dentry)
{
    62fc:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
    6300:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    6307:	00 00 
    6309:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    630d:	31 c0                	xor    %eax,%eax
    struct super_block *sb = old_dentry->d_sb;
    630f:	48 8b 47 68          	mov    0x68(%rdi),%rax
    u64 temlen, phlen, flen;
    u64 hashname, par_hn, ino;
    int ret = 0;
    char *end ="";

    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);
    6313:	48 89 c7             	mov    %rax,%rdi
   return err;
}

int __rename_file_dentry(struct dentry *old_dentry, struct dentry *new_dentry)
{
    struct super_block *sb = old_dentry->d_sb;
    6316:	48 89 c3             	mov    %rax,%rbx
    6319:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    u64 temlen, phlen, flen;
    u64 hashname, par_hn, ino;
    int ret = 0;
    char *end ="";

    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);
    631d:	e8 00 00 00 00       	callq  6322 <__rename_file_dentry+0x42>

    //nova_dbg("dafs start rename file dentry");

    ph = get_dentry_path(new_dentry,0);
    6322:	4c 89 ff             	mov    %r15,%rdi
    u64 temlen, phlen, flen;
    u64 hashname, par_hn, ino;
    int ret = 0;
    char *end ="";

    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);
    6325:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

    //nova_dbg("dafs start rename file dentry");

    ph = get_dentry_path(new_dentry,0);
    6329:	e8 d2 9d ff ff       	callq  100 <get_dentry_path.isra.4>
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    632e:	48 89 c7             	mov    %rax,%rdi

    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);

    //nova_dbg("dafs start rename file dentry");

    ph = get_dentry_path(new_dentry,0);
    6331:	49 89 c5             	mov    %rax,%r13
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    6334:	e8 00 00 00 00       	callq  6339 <__rename_file_dentry+0x59>
    6339:	be d0 80 00 00       	mov    $0x80d0,%esi
    633e:	48 89 c7             	mov    %rax,%rdi
    6341:	e8 00 00 00 00       	callq  6346 <__rename_file_dentry+0x66>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    6346:	4c 89 ef             	mov    %r13,%rdi
    6349:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    634d:	e8 00 00 00 00       	callq  6352 <__rename_file_dentry+0x72>
    6352:	be d0 80 00 00       	mov    $0x80d0,%esi
    6357:	48 89 c7             	mov    %rax,%rdi
    635a:	e8 00 00 00 00       	callq  635f <__rename_file_dentry+0x7f>
    635f:	49 89 c4             	mov    %rax,%r12
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    6362:	48 8b 83 b0 03 00 00 	mov    0x3b0(%rbx),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    6369:	4c 89 ef             	mov    %r13,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    636c:	4c 8b b0 d8 01 00 00 	mov    0x1d8(%rax),%r14
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    6373:	e8 00 00 00 00       	callq  6378 <__rename_file_dentry+0x98>
    6378:	4c 89 ee             	mov    %r13,%rsi
    637b:	48 89 c2             	mov    %rax,%rdx
    637e:	4c 89 e7             	mov    %r12,%rdi
    6381:	e8 00 00 00 00       	callq  6386 <__rename_file_dentry+0xa6>
    tlen = strlen(phstr);
    6386:	4c 89 ef             	mov    %r13,%rdi
    6389:	e8 00 00 00 00       	callq  638e <__rename_file_dentry+0xae>
    638e:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
    6391:	be 2f 00 00 00       	mov    $0x2f,%esi
    6396:	4c 89 e7             	mov    %r12,%rdi
    6399:	e8 00 00 00 00       	callq  639e <__rename_file_dentry+0xbe>
        phlen = tlen -strlen(tem);
    639e:	48 89 c7             	mov    %rax,%rdi
    63a1:	e8 00 00 00 00       	callq  63a6 <__rename_file_dentry+0xc6>
        tlen = phlen;
        //bug
        if(phlen==0){
    63a6:	48 29 c3             	sub    %rax,%rbx
    63a9:	0f 84 48 04 00 00    	je     67f7 <__rename_file_dentry+0x517>
            break;
        }
        memcpy(ph,phstr,tlen);
    63af:	48 89 da             	mov    %rbx,%rdx
    63b2:	4c 89 ee             	mov    %r13,%rsi
    63b5:	4c 89 e7             	mov    %r12,%rdi
    63b8:	e8 00 00 00 00       	callq  63bd <__rename_file_dentry+0xdd>
	int i;

	for (i = 0; i < length; i++) {
    63bd:	85 db                	test   %ebx,%ebx
        ph[tlen]='\0';
    63bf:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
    63c4:	0f 8e 15 04 00 00    	jle    67df <__rename_file_dentry+0x4ff>
    63ca:	8d 43 ff             	lea    -0x1(%rbx),%eax
    63cd:	4c 89 e2             	mov    %r12,%rdx
    63d0:	31 f6                	xor    %esi,%esi
    63d2:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
    63d7:	48 89 f0             	mov    %rsi,%rax
    63da:	48 83 c2 01          	add    $0x1,%rdx
    63de:	48 c1 e0 05          	shl    $0x5,%rax
    63e2:	48 29 f0             	sub    %rsi,%rax
    63e5:	48 89 c6             	mov    %rax,%rsi
    63e8:	48 0f be 42 ff       	movsbq -0x1(%rdx),%rax
    63ed:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    63f0:	48 39 ca             	cmp    %rcx,%rdx
    63f3:	75 e2                	jne    63d7 <__rename_file_dentry+0xf7>
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    63f5:	4c 89 f7             	mov    %r14,%rdi
    63f8:	e8 00 00 00 00       	callq  63fd <__rename_file_dentry+0x11d>
        if(dzt_ei){
    63fd:	48 85 c0             	test   %rax,%rax
    6400:	74 8f                	je     6391 <__rename_file_dentry+0xb1>
    memcpy(ph, "/", 1);
    ph[1]='\0';
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    if(!dzt_ei){
    6402:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    6406:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    phlen = strlen(phn);
    640a:	4c 89 e7             	mov    %r12,%rdi
    ph = get_dentry_path(new_dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    640d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    6411:	48 8b 93 b0 03 00 00 	mov    0x3b0(%rbx),%rdx
    6418:	48 8b 40 10          	mov    0x10(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    641c:	48 89 c3             	mov    %rax,%rbx
    641f:	48 03 5a 18          	add    0x18(%rdx),%rbx
    6423:	48 85 c0             	test   %rax,%rax
    6426:	b8 00 00 00 00       	mov    $0x0,%eax
    642b:	48 0f 45 c3          	cmovne %rbx,%rax
    642f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    phlen = strlen(phn);
    6433:	e8 00 00 00 00       	callq  6438 <__rename_file_dentry+0x158>
    if(phlen==1){
    6438:	48 83 f8 01          	cmp    $0x1,%rax
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    phlen = strlen(phn);
    643c:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    if(phlen==1){
        flen = strlen(ph);
    6440:	4c 89 ef             	mov    %r13,%rdi
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
    6443:	0f 84 83 04 00 00    	je     68cc <__rename_file_dentry+0x5ec>
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    6449:	e8 00 00 00 00       	callq  644e <__rename_file_dentry+0x16e>
    644e:	48 8b 5d 88          	mov    -0x78(%rbp),%rbx
    6452:	48 29 d8             	sub    %rbx,%rax
        memcpy(phname, ph+phlen, flen);
    6455:	49 8d 74 1d 00       	lea    0x0(%r13,%rbx,1),%rsi
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    645a:	48 89 45 80          	mov    %rax,-0x80(%rbp)
        memcpy(phname, ph+phlen, flen);
    645e:	48 89 c3             	mov    %rax,%rbx
    6461:	48 89 c2             	mov    %rax,%rdx
    6464:	4c 8b 75 98          	mov    -0x68(%rbp),%r14
    6468:	4c 89 f7             	mov    %r14,%rdi
    646b:	e8 00 00 00 00       	callq  6470 <__rename_file_dentry+0x190>
        phname[flen]='\0';
    6470:	41 c6 04 1e 00       	movb   $0x0,(%r14,%rbx,1)
    }
    make_zone_ptr(&z_p, n_ze);
    6475:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
    6479:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
    647d:	e8 00 00 00 00       	callq  6482 <__rename_file_dentry+0x1a2>
    while(bitpos<z_p->zone_max){
    6482:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6486:	48 8b 78 08          	mov    0x8(%rax),%rdi
    648a:	48 85 ff             	test   %rdi,%rdi
    648d:	0f 84 5f 04 00 00    	je     68f2 <__rename_file_dentry+0x612>
    6493:	48 8b 30             	mov    (%rax),%rsi
    6496:	45 31 f6             	xor    %r14d,%r14d
    6499:	31 c9                	xor    %ecx,%ecx
    649b:	eb 02                	jmp    649f <__rename_file_dentry+0x1bf>
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
            bitpos+=2;
    649d:	89 c1                	mov    %eax,%ecx

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    649f:	48 63 c1             	movslq %ecx,%rax
    64a2:	48 0f a3 06          	bt     %rax,(%rsi)
    64a6:	19 c0                	sbb    %eax,%eax
        memcpy(phname, ph+phlen, flen);
        phname[flen]='\0';
    }
    make_zone_ptr(&z_p, n_ze);
    while(bitpos<z_p->zone_max){
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
    64a8:	85 c0                	test   %eax,%eax
    64aa:	75 10                	jne    64bc <__rename_file_dentry+0x1dc>
    64ac:	8d 59 01             	lea    0x1(%rcx),%ebx
    64af:	48 63 db             	movslq %ebx,%rbx
    64b2:	48 0f a3 1e          	bt     %rbx,(%rsi)
    64b6:	19 c0                	sbb    %eax,%eax
    64b8:	85 c0                	test   %eax,%eax
    64ba:	74 15                	je     64d1 <__rename_file_dentry+0x1f1>
            bitpos+=2;
    64bc:	8d 51 02             	lea    0x2(%rcx),%edx
            cur_pos++;
    64bf:	41 83 c6 01          	add    $0x1,%r14d
        flen = strlen(ph)-phlen;
        memcpy(phname, ph+phlen, flen);
        phname[flen]='\0';
    }
    make_zone_ptr(&z_p, n_ze);
    while(bitpos<z_p->zone_max){
    64c3:	48 39 d7             	cmp    %rdx,%rdi
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
            bitpos+=2;
    64c6:	48 89 d0             	mov    %rdx,%rax
        flen = strlen(ph)-phlen;
        memcpy(phname, ph+phlen, flen);
        phname[flen]='\0';
    }
    make_zone_ptr(&z_p, n_ze);
    while(bitpos<z_p->zone_max){
    64c9:	77 d2                	ja     649d <__rename_file_dentry+0x1bd>
    64cb:	8d 59 03             	lea    0x3(%rcx),%ebx
    64ce:	48 63 db             	movslq %ebx,%rbx
    //pidir = nova_get_inode(sb, dir);
    //dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    //de_len = DAFS_DIR_LEN(namelen + phlen); 

    /*get dentry on nvm*/
    dafs_de = &n_ze->dentry[cur_pos];
    64d1:	44 89 f0             	mov    %r14d,%eax
    64d4:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    64d8:	48 89 c2             	mov    %rax,%rdx
    64db:	4c 8d 98 81 00 00 00 	lea    0x81(%rax),%r11
    64e2:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    64e6:	48 c1 e2 07          	shl    $0x7,%rdx
    64ea:	4c 8d 14 17          	lea    (%rdi,%rdx,1),%r10
    64ee:	49 c1 e3 07          	shl    $0x7,%r11
    64f2:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
    64f9:	49 01 fb             	add    %rdi,%r11
    //memset(dafs_de, 0, sizeof(dafs_de));
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = new_dentry->d_name.len;
    dafs_de->file_type = o_de->file_type;       //file_type是啥？ not decided
    64fc:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi

    /*get dentry on nvm*/
    dafs_de = &n_ze->dentry[cur_pos];
    //memset(dafs_de, 0, sizeof(dafs_de));
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    6500:	41 c6 82 80 40 00 00 	movb   $0x6,0x4080(%r10)
    6507:	06 
    dafs_de->name_len = new_dentry->d_name.len;
    6508:	41 8b 47 24          	mov    0x24(%r15),%eax
    //pidir = nova_get_inode(sb, dir);
    //dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    //de_len = DAFS_DIR_LEN(namelen + phlen); 

    /*get dentry on nvm*/
    dafs_de = &n_ze->dentry[cur_pos];
    650c:	4c 89 9d 70 ff ff ff 	mov    %r11,-0x90(%rbp)
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = new_dentry->d_name.len;
    dafs_de->file_type = o_de->file_type;       //file_type是啥？ not decided

	dafs_de->links_count = o_de->links_count;
    6513:	4c 89 95 78 ff ff ff 	mov    %r10,-0x88(%rbp)
    /*get dentry on nvm*/
    dafs_de = &n_ze->dentry[cur_pos];
    //memset(dafs_de, 0, sizeof(dafs_de));
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = new_dentry->d_name.len;
    651a:	41 88 82 81 40 00 00 	mov    %al,0x4081(%r10)
    dafs_de->file_type = o_de->file_type;       //file_type是啥？ not decided
    6521:	0f b6 47 02          	movzbl 0x2(%rdi),%eax
    6525:	41 88 82 82 40 00 00 	mov    %al,0x4082(%r10)

	dafs_de->links_count = o_de->links_count;
    652c:	0f b7 47 06          	movzwl 0x6(%rdi),%eax
    6530:	66 41 89 82 86 40 00 	mov    %ax,0x4086(%r10)
    6537:	00 

    //dafs_de->de_len = cpu_to_le16(de_len);  
    dafs_de->mtime = cpu_to_le32(CURRENT_TIME_SEC.tv_sec);
    6538:	e8 00 00 00 00       	callq  653d <__rename_file_dentry+0x25d>
    653d:	4c 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10
    /*not root at first*/
    //dafs_de->isr_sf = o_de->isr_sf;
    dafs_de->ino = o_de->ino;
    6544:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    
    dafs_de->size = o_de->size;
     
    /*judge name len && set dentry name*/
    if(new_dentry->d_name.len <= SMALL_NAME_LEN){
    6548:	4c 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%r11
    dafs_de->file_type = o_de->file_type;       //file_type是啥？ not decided

	dafs_de->links_count = o_de->links_count;

    //dafs_de->de_len = cpu_to_le16(de_len);  
    dafs_de->mtime = cpu_to_le32(CURRENT_TIME_SEC.tv_sec);
    654f:	41 89 82 88 40 00 00 	mov    %eax,0x4088(%r10)
    /*not root at first*/
    //dafs_de->isr_sf = o_de->isr_sf;
    dafs_de->ino = o_de->ino;
    6556:	48 8b 47 18          	mov    0x18(%rdi),%rax
    655a:	4c 89 9d 78 ff ff ff 	mov    %r11,-0x88(%rbp)
    6561:	49 89 82 98 40 00 00 	mov    %rax,0x4098(%r10)
    
    dafs_de->size = o_de->size;
    6568:	48 8b 47 20          	mov    0x20(%rdi),%rax
    656c:	49 89 82 a0 40 00 00 	mov    %rax,0x40a0(%r10)
     
    /*judge name len && set dentry name*/
    if(new_dentry->d_name.len <= SMALL_NAME_LEN){
    6573:	41 83 7f 24 27       	cmpl   $0x27,0x24(%r15)
    6578:	0f 87 9f 02 00 00    	ja     681d <__rename_file_dentry+0x53d>
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,new_dentry->d_name.name,new_dentry->d_name.len);
    657e:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
    6585:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    
    dafs_de->size = o_de->size;
     
    /*judge name len && set dentry name*/
    if(new_dentry->d_name.len <= SMALL_NAME_LEN){
        dafs_de->ext_flag = 0;
    6589:	31 c9                	xor    %ecx,%ecx
    658b:	66 41 89 8a 84 40 00 	mov    %cx,0x4084(%r10)
    6592:	00 
        memcpy(dafs_de->name,new_dentry->d_name.name,new_dentry->d_name.len);
    6593:	49 8b 77 28          	mov    0x28(%r15),%rsi
    
    dafs_de->size = o_de->size;
     
    /*judge name len && set dentry name*/
    if(new_dentry->d_name.len <= SMALL_NAME_LEN){
        dafs_de->ext_flag = 0;
    6597:	4c 89 55 a0          	mov    %r10,-0x60(%rbp)
        memcpy(dafs_de->name,new_dentry->d_name.name,new_dentry->d_name.len);
    659b:	48 8d bc 17 b0 40 00 	lea    0x40b0(%rdi,%rdx,1),%rdi
    65a2:	00 
    65a3:	41 8b 57 24          	mov    0x24(%r15),%edx
    65a7:	e8 00 00 00 00       	callq  65ac <__rename_file_dentry+0x2cc>
        dafs_de->name[new_dentry->d_name.len] = '\0'; 
    65ac:	41 8b 47 24          	mov    0x24(%r15),%eax
    65b0:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
    65b4:	4c 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11
    65bb:	41 c6 84 02 b0 40 00 	movb   $0x0,0x40b0(%r10,%rax,1)
    65c2:	00 00 

    } else {
        dafs_de->ext_flag = 1;
        ext_de_name(sb, n_ei, n_ze, z_p, cur_pos, new_dentry->d_name.len, new_dentry->d_name.name, 0);
    }
    dafs_de->fname_len = cpu_to_le64(flen);
    65c4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    65c8:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
    65cc:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
    65d0:	48 c1 e0 07          	shl    $0x7,%rax
    65d4:	48 01 c8             	add    %rcx,%rax
    65d7:	48 89 b8 90 40 00 00 	mov    %rdi,0x4090(%rax)
    /*fulname is null for NORMAL_FILE*/
    dafs_de->ful_name.f_name[0]= '\0';
    65de:	c6 80 d8 40 00 00 00 	movb   $0x0,0x40d8(%rax)

    /*set isr_sf and par_pos*/
    temlen = flen-new_dentry->d_name.len;
    65e5:	41 8b 47 24          	mov    0x24(%r15),%eax
    65e9:	49 89 ff             	mov    %rdi,%r15
    65ec:	49 29 c7             	sub    %rax,%r15
    if(temlen == 1){
    65ef:	49 83 ff 01          	cmp    $0x1,%r15
    65f3:	0f 84 85 02 00 00    	je     687e <__rename_file_dentry+0x59e>
            new_sf->pos = cpu_to_le32(cur_pos);
            list_add_tail(&new_sf->list, &par_dir->sub_file);
            par_dir->sub_num++;
        }
    } else {
        dafs_de->isr_sf = 0;
    65f9:	41 c6 82 83 40 00 00 	movb   $0x0,0x4083(%r10)
    6600:	00 
        tem = kzalloc(sizeof(char)*temlen, GFP_KERNEL);
    6601:	4c 89 ff             	mov    %r15,%rdi
    6604:	4c 89 9d 78 ff ff ff 	mov    %r11,-0x88(%rbp)
            new_sf->pos = cpu_to_le32(cur_pos);
            list_add_tail(&new_sf->list, &par_dir->sub_file);
            par_dir->sub_num++;
        }
    } else {
        dafs_de->isr_sf = 0;
    660b:	4c 89 55 80          	mov    %r10,-0x80(%rbp)
        tem = kzalloc(sizeof(char)*temlen, GFP_KERNEL);
    660f:	e8 dc 9a ff ff       	callq  f0 <kzalloc.constprop.9>
        temlen--;
    6614:	4d 8d 47 ff          	lea    -0x1(%r15),%r8
        memcpy(tem, phname, temlen);
    6618:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
    661c:	48 89 c7             	mov    %rax,%rdi
    661f:	4c 89 c2             	mov    %r8,%rdx
    6622:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
    6626:	e8 00 00 00 00       	callq  662b <__rename_file_dentry+0x34b>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    662b:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
    662f:	48 89 c1             	mov    %rax,%rcx
        tem[temlen]='\0';
    6632:	42 c6 44 38 ff 00    	movb   $0x0,-0x1(%rax,%r15,1)
    6638:	4c 8b 55 80          	mov    -0x80(%rbp),%r10
    663c:	4c 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11
    6643:	45 85 c0             	test   %r8d,%r8d
    6646:	0f 8e 97 02 00 00    	jle    68e3 <__rename_file_dentry+0x603>
    664c:	41 8d 40 ff          	lea    -0x1(%r8),%eax
    6650:	45 31 ff             	xor    %r15d,%r15d
    6653:	48 8d 54 01 01       	lea    0x1(%rcx,%rax,1),%rdx
		hash = hash * seed + (*str++);
    6658:	4c 89 f8             	mov    %r15,%rax
    665b:	48 83 c1 01          	add    $0x1,%rcx
    665f:	48 c1 e0 05          	shl    $0x5,%rax
    6663:	4c 29 f8             	sub    %r15,%rax
    6666:	49 89 c7             	mov    %rax,%r15
    6669:	48 0f be 41 ff       	movsbq -0x1(%rcx),%rax
    666e:	49 01 c7             	add    %rax,%r15
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    6671:	48 39 d1             	cmp    %rdx,%rcx
    6674:	75 e2                	jne    6658 <__rename_file_dentry+0x378>
        //memcpy(tem+temlen, end, 1);
        par_hn = BKDRHash(tem, temlen);
        lookup_in_hashtable(sb, n_ei->ht_head, par_hn, 1, &par_pos);
    6676:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    667a:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    667e:	4c 8d 45 c4          	lea    -0x3c(%rbp),%r8
    6682:	b9 01 00 00 00       	mov    $0x1,%ecx
    6687:	4c 89 fa             	mov    %r15,%rdx
    668a:	4c 89 55 80          	mov    %r10,-0x80(%rbp)
    668e:	4c 89 5d a0          	mov    %r11,-0x60(%rbp)
    6692:	48 8b 70 18          	mov    0x18(%rax),%rsi
    6696:	e8 00 00 00 00       	callq  669b <__rename_file_dentry+0x3bb>
        dafs_de->par_pos = cpu_to_le32(par_pos);
    669b:	8b 45 c4             	mov    -0x3c(%rbp),%eax
    669e:	4c 8b 55 80          	mov    -0x80(%rbp),%r10
    66a2:	41 89 82 8c 40 00 00 	mov    %eax,0x408c(%r10)
        //nova_dbg("%s new dentry par name %s, pos%d",__func__, tem, par_pos);
        /*set subpos*/
        par_dir = radix_tree_lookup(&n_ei->dir_tree, par_hn);
    66a9:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    66ad:	4c 89 fe             	mov    %r15,%rsi
    66b0:	48 8d 78 38          	lea    0x38(%rax),%rdi
    66b4:	e8 00 00 00 00       	callq  66b9 <__rename_file_dentry+0x3d9>
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    66b9:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 66c0 <__rename_file_dentry+0x3e0>
    66c0:	49 89 c7             	mov    %rax,%r15
    66c3:	ba 14 00 00 00       	mov    $0x14,%edx
    66c8:	be d0 80 00 00       	mov    $0x80d0,%esi
    66cd:	e8 00 00 00 00       	callq  66d2 <__rename_file_dentry+0x3f2>
        new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        new_sf->pos = cpu_to_le32(cur_pos);
    66d2:	44 89 70 10          	mov    %r14d,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    66d6:	49 8b 57 20          	mov    0x20(%r15),%rdx
        list_add_tail(&new_sf->list, &par_dir->sub_file);
    66da:	49 8d 4f 18          	lea    0x18(%r15),%rcx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    66de:	49 89 47 20          	mov    %rax,0x20(%r15)
    66e2:	48 89 08             	mov    %rcx,(%rax)
	new->next = next;
	new->prev = prev;
    66e5:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    66e9:	48 89 02             	mov    %rax,(%rdx)
        par_dir->sub_num++;
    66ec:	49 83 47 08 01       	addq   $0x1,0x8(%r15)
    66f1:	4c 8b 5d a0          	mov    -0x60(%rbp),%r11
    }
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)z_p->statemap);
    66f5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    66f9:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    66fc:	f0 48 0f ab 18       	lock bts %rbx,(%rax)
    6701:	72 00                	jb     6703 <__rename_file_dentry+0x423>
    6703:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    6707:	85 c0                	test   %eax,%eax
    6709:	0f 8e dc 01 00 00    	jle    68eb <__rename_file_dentry+0x60b>
    670f:	83 e8 01             	sub    $0x1,%eax
    6712:	31 d2                	xor    %edx,%edx
    6714:	49 8d 74 04 01       	lea    0x1(%r12,%rax,1),%rsi
    6719:	4c 89 e0             	mov    %r12,%rax
		hash = hash * seed + (*str++);
    671c:	48 89 d1             	mov    %rdx,%rcx
    671f:	48 83 c0 01          	add    $0x1,%rax
    6723:	48 c1 e1 05          	shl    $0x5,%rcx
    6727:	48 29 d1             	sub    %rdx,%rcx
    672a:	48 89 ca             	mov    %rcx,%rdx
    672d:	48 0f be 48 ff       	movsbq -0x1(%rax),%rcx
    6732:	48 01 ca             	add    %rcx,%rdx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    6735:	48 39 f0             	cmp    %rsi,%rax
    6738:	75 e2                	jne    671c <__rename_file_dentry+0x43c>
   
    /*set pos in hash table for each zone*/
    hashname = BKDRHash(phn, phlen);
    dafs_de->hname = cpu_to_le64(hashname);
    673a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    673e:	48 8b 5d b8          	mov    -0x48(%rbp),%rbx
    record_pos_htable(sb, n_ei->ht_head, hashname, cur_pos, 1);
    6742:	44 89 f1             	mov    %r14d,%ecx
    6745:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    6749:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    674f:	4c 89 5d a0          	mov    %r11,-0x60(%rbp)
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)z_p->statemap);
   
    /*set pos in hash table for each zone*/
    hashname = BKDRHash(phn, phlen);
    dafs_de->hname = cpu_to_le64(hashname);
    6753:	48 c1 e0 07          	shl    $0x7,%rax
    6757:	48 89 94 03 a8 40 00 	mov    %rdx,0x40a8(%rbx,%rax,1)
    675e:	00 
    record_pos_htable(sb, n_ei->ht_head, hashname, cur_pos, 1);
    675f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    6763:	48 8b 70 18          	mov    0x18(%rax),%rsi
    6767:	e8 00 00 00 00       	callq  676c <__rename_file_dentry+0x48c>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    676c:	4c 8b 5d a0          	mov    -0x60(%rbp),%r11
	if (support_clwb) {
    6770:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 6776 <__rename_file_dentry+0x496>
    6776:	31 d2                	xor    %edx,%edx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    6778:	44 89 d9             	mov    %r11d,%ecx
    677b:	83 e1 3f             	and    $0x3f,%ecx
    677e:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    6781:	85 c0                	test   %eax,%eax
    6783:	0f 84 e1 00 00 00    	je     686a <__rename_file_dentry+0x58a>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    6789:	89 d0                	mov    %edx,%eax
    678b:	4c 01 d8             	add    %r11,%rax
    678e:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    6792:	83 c2 40             	add    $0x40,%edx
    6795:	39 d1                	cmp    %edx,%ecx
    6797:	77 f0                	ja     6789 <__rename_file_dentry+0x4a9>

    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    //dafs_remove_dentry(old_dentry);
    
    kfree(phname);
    6799:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
    679d:	e8 00 00 00 00       	callq  67a2 <__rename_file_dentry+0x4c2>
    kfree(ph);
    67a2:	4c 89 ef             	mov    %r13,%rdi
    67a5:	e8 00 00 00 00       	callq  67aa <__rename_file_dentry+0x4ca>
    kfree(phn);
    67aa:	4c 89 e7             	mov    %r12,%rdi
    67ad:	e8 00 00 00 00       	callq  67b2 <__rename_file_dentry+0x4d2>
    kfree(z_p);
    67b2:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    67b6:	e8 00 00 00 00       	callq  67bb <__rename_file_dentry+0x4db>
    //NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    //nova_dbg("%s end",__func__);

    return ret;
    
}
    67bb:	31 c0                	xor    %eax,%eax
    67bd:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    67c1:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    67c8:	00 00 
    67ca:	0f 85 2f 01 00 00    	jne    68ff <__rename_file_dentry+0x61f>
    67d0:	48 83 ec 80          	sub    $0xffffffffffffff80,%rsp
    67d4:	5b                   	pop    %rbx
    67d5:	41 5c                	pop    %r12
    67d7:	41 5d                	pop    %r13
    67d9:	41 5e                	pop    %r14
    67db:	41 5f                	pop    %r15
    67dd:	5d                   	pop    %rbp
    67de:	c3                   	retq   
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    67df:	31 f6                	xor    %esi,%esi
        memcpy(ph,phstr,tlen);
        ph[tlen]='\0';
        //memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    67e1:	4c 89 f7             	mov    %r14,%rdi
    67e4:	e8 00 00 00 00       	callq  67e9 <__rename_file_dentry+0x509>
        if(dzt_ei){
    67e9:	48 85 c0             	test   %rax,%rax
    67ec:	0f 84 9f fb ff ff    	je     6391 <__rename_file_dentry+0xb1>
    67f2:	e9 0b fc ff ff       	jmpq   6402 <__rename_file_dentry+0x122>
            return dzt_ei;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    67f7:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    ph[1]='\0';
    67fc:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    //memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    6802:	be 2f 00 00 00       	mov    $0x2f,%esi
    6807:	4c 89 f7             	mov    %r14,%rdi
    680a:	e8 00 00 00 00       	callq  680f <__rename_file_dentry+0x52f>
    if(!dzt_ei){
    680f:	48 85 c0             	test   %rax,%rax
    6812:	0f 85 ea fb ff ff    	jne    6402 <__rename_file_dentry+0x122>
    6818:	e8 00 00 00 00       	callq  681d <__rename_file_dentry+0x53d>
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,new_dentry->d_name.name,new_dentry->d_name.len);
        dafs_de->name[new_dentry->d_name.len] = '\0'; 

    } else {
        dafs_de->ext_flag = 1;
    681d:	ba 01 00 00 00       	mov    $0x1,%edx
        ext_de_name(sb, n_ei, n_ze, z_p, cur_pos, new_dentry->d_name.len, new_dentry->d_name.name, 0);
    6822:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    6826:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,new_dentry->d_name.name,new_dentry->d_name.len);
        dafs_de->name[new_dentry->d_name.len] = '\0'; 

    } else {
        dafs_de->ext_flag = 1;
    682a:	66 41 89 92 84 40 00 	mov    %dx,0x4084(%r10)
    6831:	00 
        ext_de_name(sb, n_ei, n_ze, z_p, cur_pos, new_dentry->d_name.len, new_dentry->d_name.name, 0);
    6832:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
    6839:	00 
    683a:	45 89 f0             	mov    %r14d,%r8d
    683d:	49 8b 47 28          	mov    0x28(%r15),%rax
    6841:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    6845:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,new_dentry->d_name.name,new_dentry->d_name.len);
        dafs_de->name[new_dentry->d_name.len] = '\0'; 

    } else {
        dafs_de->ext_flag = 1;
    6849:	4c 89 55 a0          	mov    %r10,-0x60(%rbp)
        ext_de_name(sb, n_ei, n_ze, z_p, cur_pos, new_dentry->d_name.len, new_dentry->d_name.name, 0);
    684d:	48 89 04 24          	mov    %rax,(%rsp)
    6851:	45 8b 4f 24          	mov    0x24(%r15),%r9d
    6855:	e8 00 00 00 00       	callq  685a <__rename_file_dentry+0x57a>
    685a:	4c 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11
    6861:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
    6865:	e9 5a fd ff ff       	jmpq   65c4 <__rename_file_dentry+0x2e4>
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    686a:	89 d0                	mov    %edx,%eax
    686c:	4c 01 d8             	add    %r11,%rax
    686f:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    6872:	83 c2 40             	add    $0x40,%edx
    6875:	39 d1                	cmp    %edx,%ecx
    6877:	77 f1                	ja     686a <__rename_file_dentry+0x58a>
    6879:	e9 1b ff ff ff       	jmpq   6799 <__rename_file_dentry+0x4b9>
    dafs_de->ful_name.f_name[0]= '\0';

    /*set isr_sf and par_pos*/
    temlen = flen-new_dentry->d_name.len;
    if(temlen == 1){
        dafs_de->isr_sf = 1;
    687e:	41 c6 82 83 40 00 00 	movb   $0x1,0x4083(%r10)
    6885:	01 
        dafs_de->par_pos = 0;
    6886:	41 c7 82 8c 40 00 00 	movl   $0x0,0x408c(%r10)
    688d:	00 00 00 00 
        par_de = &n_ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
    6891:	48 83 b9 98 40 00 00 	cmpq   $0x1,0x4098(%rcx)
    6898:	01 
    6899:	0f 85 56 fe ff ff    	jne    66f5 <__rename_file_dentry+0x415>
            //nova_dbg("new par is root");
            par_hn = le64_to_cpu(par_de->hname);
            lookup_in_hashtable(sb, n_ei->ht_head, par_hn, 1, &par_pos);
    689f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
        dafs_de->par_pos = 0;
        par_de = &n_ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
            //nova_dbg("new par is root");
            par_hn = le64_to_cpu(par_de->hname);
    68a3:	4c 8b b9 a8 40 00 00 	mov    0x40a8(%rcx),%r15
            lookup_in_hashtable(sb, n_ei->ht_head, par_hn, 1, &par_pos);
    68aa:	4c 8d 45 c4          	lea    -0x3c(%rbp),%r8
    68ae:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    68b2:	b9 01 00 00 00       	mov    $0x1,%ecx
    68b7:	4c 89 5d a0          	mov    %r11,-0x60(%rbp)
    68bb:	48 8b 70 18          	mov    0x18(%rax),%rsi
    68bf:	4c 89 fa             	mov    %r15,%rdx
    68c2:	e8 00 00 00 00       	callq  68c7 <__rename_file_dentry+0x5e7>
    68c7:	e9 dd fd ff ff       	jmpq   66a9 <__rename_file_dentry+0x3c9>
    //memcpy(phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
    68cc:	e8 00 00 00 00       	callq  68d1 <__rename_file_dentry+0x5f1>
        memcpy(phname, ph, flen);
    68d1:	4c 89 ee             	mov    %r13,%rsi
    //memcpy(phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
    68d4:	48 89 c3             	mov    %rax,%rbx
    68d7:	48 89 45 80          	mov    %rax,-0x80(%rbp)
        memcpy(phname, ph, flen);
    68db:	48 89 c2             	mov    %rax,%rdx
    68de:	e9 81 fb ff ff       	jmpq   6464 <__rename_file_dentry+0x184>
    68e3:	45 31 ff             	xor    %r15d,%r15d
    68e6:	e9 8b fd ff ff       	jmpq   6676 <__rename_file_dentry+0x396>
    68eb:	31 d2                	xor    %edx,%edx
    68ed:	e9 48 fe ff ff       	jmpq   673a <__rename_file_dentry+0x45a>
        flen = strlen(ph)-phlen;
        memcpy(phname, ph+phlen, flen);
        phname[flen]='\0';
    }
    make_zone_ptr(&z_p, n_ze);
    while(bitpos<z_p->zone_max){
    68f2:	bb 01 00 00 00       	mov    $0x1,%ebx
    struct dzt_entry_info *n_ei;
    struct zone_ptr *z_p;
    struct dir_info *par_dir;
    struct file_p *new_sf;
    char *phname, *ph, *phn, *tem;
    u32 bitpos=0, cur_pos=0, par_pos;
    68f7:	45 31 f6             	xor    %r14d,%r14d
    68fa:	e9 d2 fb ff ff       	jmpq   64d1 <__rename_file_dentry+0x1f1>
    //NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    //nova_dbg("%s end",__func__);

    return ret;
    
}
    68ff:	e8 00 00 00 00       	callq  6904 <__rename_file_dentry+0x624>

Disassembly of section .text.unlikely:

0000000000000000 <find_dzt.part.3>:
/* find currect zone
 * ph record file ful name
 * 反向查找
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	0f 0b                	ud2    
