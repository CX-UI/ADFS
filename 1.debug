
dafs_dir.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <find_dzt>:
/* find currect zone
 * ph record file ful name
 * 反向查找
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
       0:	55                   	push   %rbp
       1:	48 89 e5             	mov    %rsp,%rbp
       4:	41 56                	push   %r14
       6:	41 55                	push   %r13
       8:	41 54                	push   %r12
       a:	53                   	push   %rbx
       b:	49 89 f5             	mov    %rsi,%r13
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
       e:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
/* find currect zone
 * ph record file ful name
 * 反向查找
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
      15:	49 89 d4             	mov    %rdx,%r12
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
      18:	48 89 f7             	mov    %rsi,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
      1b:	4c 8b b0 d8 01 00 00 	mov    0x1d8(%rax),%r14
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
      22:	e8 00 00 00 00       	callq  27 <find_dzt+0x27>
      27:	4c 89 ee             	mov    %r13,%rsi
      2a:	48 89 c2             	mov    %rax,%rdx
      2d:	4c 89 e7             	mov    %r12,%rdi
      30:	e8 00 00 00 00       	callq  35 <find_dzt+0x35>
    tlen = strlen(phstr);
      35:	4c 89 ef             	mov    %r13,%rdi
      38:	e8 00 00 00 00       	callq  3d <find_dzt+0x3d>
      3d:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
      40:	be 2f 00 00 00       	mov    $0x2f,%esi
      45:	4c 89 e7             	mov    %r12,%rdi
      48:	e8 00 00 00 00       	callq  4d <find_dzt+0x4d>
        phlen = tlen -strlen(tem);
      4d:	48 89 c7             	mov    %rax,%rdi
      50:	e8 00 00 00 00       	callq  55 <find_dzt+0x55>
        tlen = phlen;
        //bug
        if(phlen==0){
      55:	48 29 c3             	sub    %rax,%rbx
      58:	74 6e                	je     c8 <find_dzt+0xc8>
            break;
        }
        memcpy(ph,phstr,tlen);
      5a:	48 89 da             	mov    %rbx,%rdx
      5d:	4c 89 ee             	mov    %r13,%rsi
      60:	4c 89 e7             	mov    %r12,%rdi
      63:	e8 00 00 00 00       	callq  68 <find_dzt+0x68>
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
      68:	85 db                	test   %ebx,%ebx
        memcpy(ph+tlen, end, 1);
      6a:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
      6f:	7e 42                	jle    b3 <find_dzt+0xb3>
      71:	8d 43 ff             	lea    -0x1(%rbx),%eax
      74:	4c 89 e2             	mov    %r12,%rdx
      77:	31 f6                	xor    %esi,%esi
      79:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
      7e:	48 89 f0             	mov    %rsi,%rax
      81:	48 83 c2 01          	add    $0x1,%rdx
      85:	48 c1 e0 06          	shl    $0x6,%rax
      89:	48 01 f0             	add    %rsi,%rax
      8c:	48 8d 04 46          	lea    (%rsi,%rax,2),%rax
      90:	48 0f be 72 ff       	movsbq -0x1(%rdx),%rsi
      95:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
      98:	48 39 ca             	cmp    %rcx,%rdx
      9b:	75 e1                	jne    7e <find_dzt+0x7e>
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
      9d:	4c 89 f7             	mov    %r14,%rdi
      a0:	e8 00 00 00 00       	callq  a5 <find_dzt+0xa5>
        if(dzt_ei){
      a5:	48 85 c0             	test   %rax,%rax
      a8:	74 96                	je     40 <find_dzt+0x40>
    }

END:
    //nova_dbg("dafs finish finding dzt:%d, zone addr 0x%llu",dzt_ei->dzt_eno, dzt_ei->dz_addr);
    return dzt_ei;
}
      aa:	5b                   	pop    %rbx
      ab:	41 5c                	pop    %r12
      ad:	41 5d                	pop    %r13
      af:	41 5e                	pop    %r14
      b1:	5d                   	pop    %rbp
      b2:	c3                   	retq   

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
      b3:	31 f6                	xor    %esi,%esi
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
      b5:	4c 89 f7             	mov    %r14,%rdi
      b8:	e8 00 00 00 00       	callq  bd <find_dzt+0xbd>
        if(dzt_ei){
      bd:	48 85 c0             	test   %rax,%rax
      c0:	0f 84 7a ff ff ff    	je     40 <find_dzt+0x40>
      c6:	eb e2                	jmp    aa <find_dzt+0xaa>
            goto END;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
      c8:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    memcpy(ph+1,end,1);
      cd:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
      d3:	be 2f 00 00 00       	mov    $0x2f,%esi
      d8:	4c 89 f7             	mov    %r14,%rdi
      db:	e8 00 00 00 00       	callq  e0 <find_dzt+0xe0>
    if(!dzt_ei){
      e0:	48 85 c0             	test   %rax,%rax
      e3:	75 c5                	jne    aa <find_dzt+0xaa>
      e5:	e8 00 00 00 00       	callq  ea <find_dzt+0xea>
      ea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000000000f0 <kzalloc.constprop.9>:
/**
 * kzalloc - allocate memory. The memory is set to zero.
 * @size: how many bytes of memory are required.
 * @flags: the type of memory to allocate (see kmalloc).
 */
static inline void *kzalloc(size_t size, gfp_t flags)
      f0:	55                   	push   %rbp
			return kmem_cache_alloc_trace(kmalloc_caches[index],
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
      f1:	be d0 80 00 00       	mov    $0x80d0,%esi
/**
 * kzalloc - allocate memory. The memory is set to zero.
 * @size: how many bytes of memory are required.
 * @flags: the type of memory to allocate (see kmalloc).
 */
static inline void *kzalloc(size_t size, gfp_t flags)
      f6:	48 89 e5             	mov    %rsp,%rbp
			return kmem_cache_alloc_trace(kmalloc_caches[index],
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
      f9:	e8 00 00 00 00       	callq  fe <kzalloc.constprop.9+0xe>
 * @flags: the type of memory to allocate (see kmalloc).
 */
static inline void *kzalloc(size_t size, gfp_t flags)
{
	return kmalloc(size, flags | __GFP_ZERO);
}
      fe:	5d                   	pop    %rbp
      ff:	c3                   	retq   

0000000000000100 <get_dentry_path.isra.4>:
    return 0;

}

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
     100:	55                   	push   %rbp
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
     101:	ba 00 04 00 00       	mov    $0x400,%edx
     106:	be d0 80 00 00       	mov    $0x80d0,%esi

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
     10b:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
     112:	00 00 
     114:	48 89 e5             	mov    %rsp,%rbp
     117:	41 57                	push   %r15
     119:	41 56                	push   %r14
     11b:	41 55                	push   %r13
     11d:	41 54                	push   %r12
     11f:	49 89 fd             	mov    %rdi,%r13
     122:	53                   	push   %rbx
     123:	48 83 ec 10          	sub    $0x10,%rsp
     127:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 12e <get_dentry_path.isra.4+0x2e>
{
    char *ph=NULL, *buf=NULL, *tem=NULL, *mntchar= "/mnt/ramdisk", *end="", *ppath=NULL;
    struct fs_struct *fs = current->fs;
     12e:	4c 8b b0 30 06 00 00 	mov    0x630(%rax),%r14
     135:	e8 00 00 00 00       	callq  13a <get_dentry_path.isra.4+0x3a>
     13a:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 141 <get_dentry_path.isra.4+0x41>
     141:	ba 00 04 00 00       	mov    $0x400,%edx
     146:	be d0 80 00 00       	mov    $0x80d0,%esi
     14b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     14f:	e8 00 00 00 00       	callq  154 <get_dentry_path.isra.4+0x54>
     154:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 15b <get_dentry_path.isra.4+0x5b>
     15b:	48 89 c3             	mov    %rax,%rbx
     15e:	ba 00 04 00 00       	mov    $0x400,%edx
     163:	be d0 80 00 00       	mov    $0x80d0,%esi
     168:	e8 00 00 00 00       	callq  16d <get_dentry_path.isra.4+0x6d>

    //nova_dbg("%s:dafs get dentry path",__func__);
    ph = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    buf = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    tem = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    if(!buf)
     16d:	48 85 db             	test   %rbx,%rbx
     170:	0f 84 1a 01 00 00    	je     290 <get_dentry_path.isra.4+0x190>
        goto ERR;

    read_lock(&fs->lock);
     176:	49 8d 7e 04          	lea    0x4(%r14),%rdi
     17a:	49 89 c4             	mov    %rax,%r12
     17d:	e8 00 00 00 00       	callq  182 <get_dentry_path.isra.4+0x82>
    vfsmnt = mntget(fs->pwd.mnt);
     182:	49 8b 7e 28          	mov    0x28(%r14),%rdi
     186:	e8 00 00 00 00       	callq  18b <get_dentry_path.isra.4+0x8b>
    if(!vfsmnt){
     18b:	48 85 c0             	test   %rax,%rax
    tem = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    if(!buf)
        goto ERR;

    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
     18e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    if(!vfsmnt){
     192:	0f 84 f8 00 00 00    	je     290 <get_dentry_path.isra.4+0x190>
 *
 * Atomically adds @i to @v and returns @i + @v
 */
static __always_inline int atomic_add_return(int i, atomic_t *v)
{
	return i + xadd(&v->counter, i);
     198:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
     19d:	f0 41 0f c1 46 04    	lock xadd %eax,0x4(%r14)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
     1a3:	49 8b 75 28          	mov    0x28(%r13),%rsi
     1a7:	49 c7 c6 00 00 00 00 	mov    $0x0,%r14
     1ae:	b9 02 00 00 00       	mov    $0x2,%ecx
     1b3:	4c 89 f7             	mov    %r14,%rdi
     1b6:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
     1b8:	0f 85 e5 00 00 00    	jne    2a3 <get_dentry_path.isra.4+0x1a3>
        strcat(buf,"/");

    do{
        strcat(buf, "/");
     1be:	48 89 df             	mov    %rbx,%rdi
     1c1:	e8 00 00 00 00       	callq  1c6 <get_dentry_path.isra.4+0xc6>
     1c6:	ba 2f 00 00 00       	mov    $0x2f,%edx
        strcat(buf, tem_dentry->d_name.name);
     1cb:	48 8d 7c 03 01       	lea    0x1(%rbx,%rax,1),%rdi
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
        strcat(buf,"/");

    do{
        strcat(buf, "/");
     1d0:	66 89 14 03          	mov    %dx,(%rbx,%rax,1)
        strcat(buf, tem_dentry->d_name.name);
     1d4:	49 8b 75 28          	mov    0x28(%r13),%rsi
     1d8:	e8 00 00 00 00       	callq  1dd <get_dentry_path.isra.4+0xdd>
        p_dentry = tem_dentry->d_parent;
     1dd:	4d 8b 6d 18          	mov    0x18(%r13),%r13
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
     1e1:	b9 02 00 00 00       	mov    $0x2,%ecx
     1e6:	4c 89 f7             	mov    %r14,%rdi
     1e9:	49 8b 75 28          	mov    0x28(%r13),%rsi
     1ed:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
     1ef:	75 cd                	jne    1be <get_dentry_path.isra.4+0xbe>
     1f1:	49 8b 45 30          	mov    0x30(%r13),%rax
     1f5:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
     1fa:	75 c2                	jne    1be <get_dentry_path.isra.4+0xbe>
            break;
    }while(1);

    memcpy(tem, buf, strlen(buf));
     1fc:	48 89 df             	mov    %rbx,%rdi
     1ff:	e8 00 00 00 00       	callq  204 <get_dentry_path.isra.4+0x104>
     204:	48 89 de             	mov    %rbx,%rsi
     207:	48 89 c2             	mov    %rax,%rdx
     20a:	4c 89 e7             	mov    %r12,%rdi
     20d:	e8 00 00 00 00       	callq  212 <get_dentry_path.isra.4+0x112>
    tlen = strlen(buf);
     212:	48 89 df             	mov    %rbx,%rdi
     215:	e8 00 00 00 00       	callq  21a <get_dentry_path.isra.4+0x11a>
     21a:	49 89 c5             	mov    %rax,%r13
    do{
        ppath = strrchr(tem, '/');
     21d:	be 2f 00 00 00       	mov    $0x2f,%esi
     222:	4c 89 e7             	mov    %r12,%rdi
     225:	e8 00 00 00 00       	callq  22a <get_dentry_path.isra.4+0x12a>
        phlen = tlen - strlen(ppath);
     22a:	48 89 c7             	mov    %rax,%rdi
    }while(1);

    memcpy(tem, buf, strlen(buf));
    tlen = strlen(buf);
    do{
        ppath = strrchr(tem, '/');
     22d:	49 89 c7             	mov    %rax,%r15
        phlen = tlen - strlen(ppath);
     230:	e8 00 00 00 00       	callq  235 <get_dentry_path.isra.4+0x135>
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        strcat(ph, ppath);
     235:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi

    memcpy(tem, buf, strlen(buf));
    tlen = strlen(buf);
    do{
        ppath = strrchr(tem, '/');
        phlen = tlen - strlen(ppath);
     239:	49 29 c5             	sub    %rax,%r13
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        strcat(ph, ppath);
     23c:	4c 89 fe             	mov    %r15,%rsi
     23f:	e8 00 00 00 00       	callq  244 <get_dentry_path.isra.4+0x144>
        memcpy(tem, buf, tlen);
     244:	48 89 de             	mov    %rbx,%rsi
     247:	4c 89 e7             	mov    %r12,%rdi
     24a:	4c 89 ea             	mov    %r13,%rdx
     24d:	e8 00 00 00 00       	callq  252 <get_dentry_path.isra.4+0x152>
        memcpy(tem+tlen, end, 1);
     252:	43 c6 04 2c 00       	movb   $0x0,(%r12,%r13,1)
        if(!strcmp(tem,"/"))
     257:	b9 02 00 00 00       	mov    $0x2,%ecx
     25c:	4c 89 e6             	mov    %r12,%rsi
     25f:	4c 89 f7             	mov    %r14,%rdi
     262:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
     264:	75 b7                	jne    21d <get_dentry_path.isra.4+0x11d>
            break;
    }while(1);

    BUG_ON(strlen(ph)==1024);
     266:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
     26a:	e8 00 00 00 00       	callq  26f <get_dentry_path.isra.4+0x16f>
     26f:	48 3d 00 04 00 00    	cmp    $0x400,%rax
     275:	74 42                	je     2b9 <get_dentry_path.isra.4+0x1b9>
    //nova_dbg("%s ful ph is %s",__func__,ph);
    
    mntput(vfsmnt);
     277:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
     27b:	e8 00 00 00 00       	callq  280 <get_dentry_path.isra.4+0x180>
    
    kfree(buf);
     280:	48 89 df             	mov    %rbx,%rdi
     283:	e8 00 00 00 00       	callq  288 <get_dentry_path.isra.4+0x188>
    kfree(tem);
     288:	4c 89 e7             	mov    %r12,%rdi
     28b:	e8 00 00 00 00       	callq  290 <get_dentry_path.isra.4+0x190>
    //nova_dbg("dafs finish get dentry path");
ERR:
    return ph;
}
     290:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
     294:	48 83 c4 10          	add    $0x10,%rsp
     298:	5b                   	pop    %rbx
     299:	41 5c                	pop    %r12
     29b:	41 5d                	pop    %r13
     29d:	41 5e                	pop    %r14
     29f:	41 5f                	pop    %r15
     2a1:	5d                   	pop    %rbp
     2a2:	c3                   	retq   
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
        strcat(buf,"/");
     2a3:	48 89 df             	mov    %rbx,%rdi
     2a6:	e8 00 00 00 00       	callq  2ab <get_dentry_path.isra.4+0x1ab>
     2ab:	b9 2f 00 00 00       	mov    $0x2f,%ecx
     2b0:	66 89 0c 03          	mov    %cx,(%rbx,%rax,1)
     2b4:	e9 05 ff ff ff       	jmpq   1be <get_dentry_path.isra.4+0xbe>
        memcpy(tem+tlen, end, 1);
        if(!strcmp(tem,"/"))
            break;
    }while(1);

    BUG_ON(strlen(ph)==1024);
     2b9:	0f 0b                	ud2    
     2bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000002c0 <tes_empty_zone>:

#define DT2IF(dt) (((dt) << 12) & S_IFMT)
#define IF2DT(sif) (((sif) & S_IFMT) >> 12)

void tes_empty_zone(struct super_block *sb, struct zone_ptr *z_p)
{
     2c0:	e8 00 00 00 00       	callq  2c5 <tes_empty_zone+0x5>
     2c5:	55                   	push   %rbp
     2c6:	48 89 e5             	mov    %rsp,%rbp
     2c9:	41 56                	push   %r14
     2cb:	49 89 f6             	mov    %rsi,%r14
     2ce:	41 55                	push   %r13
     2d0:	41 bd 01 00 00 00    	mov    $0x1,%r13d
     2d6:	41 54                	push   %r12
    u32 pos = 0, epos = 0;
     2d8:	45 31 e4             	xor    %r12d,%r12d

#define DT2IF(dt) (((dt) << 12) & S_IFMT)
#define IF2DT(sif) (((sif) & S_IFMT) >> 12)

void tes_empty_zone(struct super_block *sb, struct zone_ptr *z_p)
{
     2db:	53                   	push   %rbx
     2dc:	31 db                	xor    %ebx,%ebx
    u32 pos = 0, epos = 0;
    u32 bitpos = 0;

    while(pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
     2de:	49 8b 16             	mov    (%r14),%rdx

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
     2e1:	48 0f a3 1a          	bt     %rbx,(%rdx)
     2e5:	19 c0                	sbb    %eax,%eax
     2e7:	85 c0                	test   %eax,%eax
     2e9:	75 42                	jne    32d <tes_empty_zone+0x6d>
     2eb:	48 8d 43 01          	lea    0x1(%rbx),%rax
     2ef:	48 0f a3 02          	bt     %rax,(%rdx)
     2f3:	19 c0                	sbb    %eax,%eax
     2f5:	85 c0                	test   %eax,%eax
     2f7:	75 34                	jne    32d <tes_empty_zone+0x6d>
            pos++;
            nova_dbg("%s: valid pos %d", __func__, pos);
        } else {
            bitpos+=2;
            pos++;
            epos++;
     2f9:	41 83 c4 01          	add    $0x1,%r12d
     2fd:	48 83 c3 02          	add    $0x2,%rbx
     301:	41 83 c5 01          	add    $0x1,%r13d
void tes_empty_zone(struct super_block *sb, struct zone_ptr *z_p)
{
    u32 pos = 0, epos = 0;
    u32 bitpos = 0;

    while(pos<NR_DENTRY_IN_ZONE){
     305:	48 81 fb fe ff 01 00 	cmp    $0x1fffe,%rbx
     30c:	75 d0                	jne    2de <tes_empty_zone+0x1e>
            bitpos+=2;
            pos++;
            epos++;
        }
    }
    nova_dbg("%s: empty pos num %d",__func__, epos);
     30e:	44 89 e2             	mov    %r12d,%edx
     311:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     318:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     31f:	e8 00 00 00 00       	callq  324 <tes_empty_zone+0x64>
}
     324:	5b                   	pop    %rbx
     325:	41 5c                	pop    %r12
     327:	41 5d                	pop    %r13
     329:	41 5e                	pop    %r14
     32b:	5d                   	pop    %rbp
     32c:	c3                   	retq   

    while(pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
            bitpos+=2;
            pos++;
            nova_dbg("%s: valid pos %d", __func__, pos);
     32d:	44 89 ea             	mov    %r13d,%edx
     330:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     337:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     33e:	e8 00 00 00 00       	callq  343 <tes_empty_zone+0x83>
     343:	eb b8                	jmp    2fd <tes_empty_zone+0x3d>
     345:	90                   	nop
     346:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     34d:	00 00 00 

0000000000000350 <delete_dir_info>:
    nova_dbg("%s: empty pos num %d",__func__, epos);
}

/*delete dir_info entry*/
int delete_dir_info(struct dzt_entry_info *ei, u64 hashname)
{
     350:	e8 00 00 00 00       	callq  355 <delete_dir_info+0x5>
     355:	55                   	push   %rbp
    struct dir_info *dir_i;
    struct file_p *o_sf;
    struct list_head *this=NULL, *head=NULL, *next=NULL;

    //nova_dbg("%s start",__func__);
    dir_i = radix_tree_delete(&ei->dir_tree, hashname);
     356:	48 83 c7 38          	add    $0x38,%rdi
    nova_dbg("%s: empty pos num %d",__func__, epos);
}

/*delete dir_info entry*/
int delete_dir_info(struct dzt_entry_info *ei, u64 hashname)
{
     35a:	48 89 e5             	mov    %rsp,%rbp
     35d:	41 55                	push   %r13
     35f:	41 54                	push   %r12
     361:	53                   	push   %rbx
    struct dir_info *dir_i;
    struct file_p *o_sf;
    struct list_head *this=NULL, *head=NULL, *next=NULL;

    //nova_dbg("%s start",__func__);
    dir_i = radix_tree_delete(&ei->dir_tree, hashname);
     362:	e8 00 00 00 00       	callq  367 <delete_dir_info+0x17>
    if(!dir_i){
     367:	48 85 c0             	test   %rax,%rax
     36a:	74 59                	je     3c5 <delete_dir_info+0x75>
        //nova_dbg("dir info not found");
        goto OUT;
    }
    //nova_dbg("dir sub num is %llu",dir_i->sub_num);
    head = &dir_i->sub_file;
    list_for_each_safe(this, next, head) {
     36c:	48 8b 78 18          	mov    0x18(%rax),%rdi
    if(!dir_i){
        //nova_dbg("dir info not found");
        goto OUT;
    }
    //nova_dbg("dir sub num is %llu",dir_i->sub_num);
    head = &dir_i->sub_file;
     370:	4c 8d 60 18          	lea    0x18(%rax),%r12
     374:	49 89 c5             	mov    %rax,%r13
    list_for_each_safe(this, next, head) {
     377:	48 8b 1f             	mov    (%rdi),%rbx
     37a:	49 39 fc             	cmp    %rdi,%r12
     37d:	48 89 d8             	mov    %rbx,%rax
     380:	75 05                	jne    387 <delete_dir_info+0x37>
     382:	eb 39                	jmp    3bd <delete_dir_info+0x6d>
     384:	48 89 c3             	mov    %rax,%rbx
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
     387:	48 8b 57 08          	mov    0x8(%rdi),%rdx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
     38b:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = next;
     38f:	48 89 02             	mov    %rax,(%rdx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
     392:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
     399:	00 ad de 
     39c:	48 89 07             	mov    %rax,(%rdi)
	entry->prev = LIST_POISON2;
     39f:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
     3a6:	00 ad de 
     3a9:	48 89 47 08          	mov    %rax,0x8(%rdi)
        o_sf = list_entry(this, struct file_p, list);
        //nova_dbg("list pos %d",o_sf->pos);
        //find bug
        list_del(&o_sf->list);
        kfree(o_sf);
     3ad:	e8 00 00 00 00       	callq  3b2 <delete_dir_info+0x62>
        //nova_dbg("dir info not found");
        goto OUT;
    }
    //nova_dbg("dir sub num is %llu",dir_i->sub_num);
    head = &dir_i->sub_file;
    list_for_each_safe(this, next, head) {
     3b2:	49 39 dc             	cmp    %rbx,%r12
     3b5:	48 8b 03             	mov    (%rbx),%rax
     3b8:	48 89 df             	mov    %rbx,%rdi
     3bb:	75 c7                	jne    384 <delete_dir_info+0x34>
        //find bug
        list_del(&o_sf->list);
        kfree(o_sf);
    }

    kfree(dir_i);
     3bd:	4c 89 ef             	mov    %r13,%rdi
     3c0:	e8 00 00 00 00       	callq  3c5 <delete_dir_info+0x75>
OUT:
    //nova_dbg("%s end",__func__);
    return 0;
}
     3c5:	5b                   	pop    %rbx
     3c6:	31 c0                	xor    %eax,%eax
     3c8:	41 5c                	pop    %r12
     3ca:	41 5d                	pop    %r13
     3cc:	5d                   	pop    %rbp
     3cd:	c3                   	retq   
     3ce:	66 90                	xchg   %ax,%ax

00000000000003d0 <delete_dir_tree>:

/*delete dir_info tree*/
int delete_dir_tree(struct dzt_entry_info *ei)
{
     3d0:	e8 00 00 00 00       	callq  3d5 <delete_dir_tree+0x5>
     3d5:	55                   	push   %rbp
    struct dir_info *dir_i;
    struct dir_info *entries[FREE_BATCH];
    struct file_p *o_sf;
    struct list_head *head, *this, *next;
    u64 key, dir_index=0;
     3d6:	31 d2                	xor    %edx,%edx
    return 0;
}

/*delete dir_info tree*/
int delete_dir_tree(struct dzt_entry_info *ei)
{
     3d8:	48 89 e5             	mov    %rsp,%rbp
     3db:	41 57                	push   %r15
     3dd:	41 56                	push   %r14
     3df:	41 55                	push   %r13
     3e1:	41 54                	push   %r12
     3e3:	53                   	push   %rbx
     3e4:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
     3eb:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     3f2:	00 00 
     3f4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     3f8:	31 c0                	xor    %eax,%eax
     3fa:	48 8d 47 38          	lea    0x38(%rdi),%rax
     3fe:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    u64 key, dir_index=0;
    int nr, i;
    void *ret;

    do {
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
     405:	48 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%rdi
     40c:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
     413:	b9 10 00 00 00       	mov    $0x10,%ecx
     418:	e8 00 00 00 00       	callq  41d <delete_dir_tree+0x4d>
        for(i=0; i<nr; i++) {
     41d:	85 c0                	test   %eax,%eax
    u64 key, dir_index=0;
    int nr, i;
    void *ret;

    do {
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
     41f:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
        for(i=0; i<nr; i++) {
     425:	0f 8e c6 00 00 00    	jle    4f1 <delete_dir_tree+0x121>
     42b:	83 e8 01             	sub    $0x1,%eax
     42e:	4c 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%r14
     435:	48 8d 84 c5 58 ff ff 	lea    -0xa8(%rbp,%rax,8),%rax
     43c:	ff 
     43d:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
            dir_i = entries[i];
     444:	4d 8b 2e             	mov    (%r14),%r13
            key = dir_i->dir_hash;
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
     447:	48 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%rdi

    do {
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
        for(i=0; i<nr; i++) {
            dir_i = entries[i];
            key = dir_i->dir_hash;
     44e:	49 8b 45 10          	mov    0x10(%r13),%rax
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
            head = &dir_i->sub_file;
     452:	4d 8d 65 18          	lea    0x18(%r13),%r12
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
        for(i=0; i<nr; i++) {
            dir_i = entries[i];
            key = dir_i->dir_hash;
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
     456:	48 89 c6             	mov    %rax,%rsi

    do {
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
        for(i=0; i<nr; i++) {
            dir_i = entries[i];
            key = dir_i->dir_hash;
     459:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
     460:	e8 00 00 00 00       	callq  465 <delete_dir_tree+0x95>
            head = &dir_i->sub_file;
            list_for_each_safe(this, next, head) {
     465:	49 8b 7d 18          	mov    0x18(%r13),%rdi
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
        for(i=0; i<nr; i++) {
            dir_i = entries[i];
            key = dir_i->dir_hash;
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
     469:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
            head = &dir_i->sub_file;
            list_for_each_safe(this, next, head) {
     470:	4c 8b 3f             	mov    (%rdi),%r15
     473:	49 39 fc             	cmp    %rdi,%r12
     476:	4c 89 fb             	mov    %r15,%rbx
     479:	75 05                	jne    480 <delete_dir_tree+0xb0>
     47b:	eb 39                	jmp    4b6 <delete_dir_tree+0xe6>
     47d:	4c 89 fb             	mov    %r15,%rbx
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
     480:	48 8b 57 08          	mov    0x8(%rdi),%rdx
	entry->next = LIST_POISON1;
     484:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
     48b:	00 ad de 
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
     48e:	49 89 57 08          	mov    %rdx,0x8(%r15)
	prev->next = next;
     492:	4c 89 3a             	mov    %r15,(%rdx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
     495:	48 89 07             	mov    %rax,(%rdi)
	entry->prev = LIST_POISON2;
     498:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
     49f:	00 ad de 
     4a2:	48 89 47 08          	mov    %rax,0x8(%rdi)
                o_sf = list_entry(this, struct file_p, list);
                list_del(&o_sf->list);
                kfree(o_sf);
     4a6:	e8 00 00 00 00       	callq  4ab <delete_dir_tree+0xdb>
            dir_i = entries[i];
            key = dir_i->dir_hash;
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
            head = &dir_i->sub_file;
            list_for_each_safe(this, next, head) {
     4ab:	49 39 dc             	cmp    %rbx,%r12
     4ae:	4d 8b 3f             	mov    (%r15),%r15
     4b1:	48 89 df             	mov    %rbx,%rdi
     4b4:	75 c7                	jne    47d <delete_dir_tree+0xad>
                o_sf = list_entry(this, struct file_p, list);
                list_del(&o_sf->list);
                kfree(o_sf);
            }
            if(!ret)
     4b6:	48 83 bd 48 ff ff ff 	cmpq   $0x0,-0xb8(%rbp)
     4bd:	00 
     4be:	74 35                	je     4f5 <delete_dir_tree+0x125>
                return -EINVAL;
                //nova_dbg("ret is NULL\n");
            kfree(dir_i);
     4c0:	4c 89 ef             	mov    %r13,%rdi
     4c3:	49 83 c6 08          	add    $0x8,%r14
     4c7:	e8 00 00 00 00       	callq  4cc <delete_dir_tree+0xfc>
    int nr, i;
    void *ret;

    do {
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
        for(i=0; i<nr; i++) {
     4cc:	4c 3b b5 30 ff ff ff 	cmp    -0xd0(%rbp),%r14
     4d3:	0f 85 6b ff ff ff    	jne    444 <delete_dir_tree+0x74>
            if(!ret)
                return -EINVAL;
                //nova_dbg("ret is NULL\n");
            kfree(dir_i);
        }
        dir_index ++;
     4d9:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
     4e0:	48 83 c2 01          	add    $0x1,%rdx
    } while (nr==FREE_BATCH);
     4e4:	83 bd 2c ff ff ff 10 	cmpl   $0x10,-0xd4(%rbp)
     4eb:	0f 84 14 ff ff ff    	je     405 <delete_dir_tree+0x35>

    return 0;
     4f1:	31 c0                	xor    %eax,%eax
     4f3:	eb 05                	jmp    4fa <delete_dir_tree+0x12a>
                o_sf = list_entry(this, struct file_p, list);
                list_del(&o_sf->list);
                kfree(o_sf);
            }
            if(!ret)
                return -EINVAL;
     4f5:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
        }
        dir_index ++;
    } while (nr==FREE_BATCH);

    return 0;
}
     4fa:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
     4fe:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
     505:	00 00 
     507:	75 12                	jne    51b <delete_dir_tree+0x14b>
     509:	48 81 c4 b0 00 00 00 	add    $0xb0,%rsp
     510:	5b                   	pop    %rbx
     511:	41 5c                	pop    %r12
     513:	41 5d                	pop    %r13
     515:	41 5e                	pop    %r14
     517:	41 5f                	pop    %r15
     519:	5d                   	pop    %rbp
     51a:	c3                   	retq   
     51b:	e8 00 00 00 00       	callq  520 <add_dir_info>

0000000000000520 <add_dir_info>:

}*/

/*add dir_info_entry in dir_info_tree*/
struct dir_info *add_dir_info(struct dzt_entry_info *ei, u64 hash_name, u32 pos)
{
     520:	e8 00 00 00 00       	callq  525 <add_dir_info+0x5>
     525:	55                   	push   %rbp
     526:	48 89 e5             	mov    %rsp,%rbp
     529:	41 56                	push   %r14
     52b:	41 55                	push   %r13
     52d:	41 54                	push   %r12
     52f:	49 89 fc             	mov    %rdi,%r12
     532:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 539 <add_dir_info+0x19>
     539:	53                   	push   %rbx
     53a:	49 89 f5             	mov    %rsi,%r13
     53d:	41 89 d6             	mov    %edx,%r14d
     540:	be d0 80 00 00       	mov    $0x80d0,%esi
     545:	ba 28 00 00 00       	mov    $0x28,%edx
     54a:	e8 00 00 00 00       	callq  54f <add_dir_info+0x2f>
     54f:	48 89 c3             	mov    %rax,%rbx
    new_dir->r_f = 0;
    new_dir->sub_s = 0;
    new_dir->f_s = 0;
    new_dir->prio = LEVEL_0;
    new_dir->sub_num = 0;
    new_dir->dir_hash = hash_name;
     552:	4c 89 68 10          	mov    %r13,0x10(%rax)
    new_dir->dir_pos = pos;
     556:	44 89 70 04          	mov    %r14d,0x4(%rax)
{
    struct dir_info *new_dir;

    //nova_dbg("dafs add dir info in radix tree");
    new_dir = kzalloc(sizeof(struct dir_info), GFP_KERNEL);
    new_dir->r_f = 0;
     55a:	c6 00 00             	movb   $0x0,(%rax)
    new_dir->sub_s = 0;
     55d:	c6 40 01 00          	movb   $0x0,0x1(%rax)
    new_dir->prio = LEVEL_0;
    new_dir->sub_num = 0;
    new_dir->dir_hash = hash_name;
    new_dir->dir_pos = pos;
    //nova_dbg("dir hash name is %llu", hash_name);
    INIT_LIST_HEAD(&new_dir->sub_file);
     561:	48 8d 40 18          	lea    0x18(%rax),%rax

    //nova_dbg("dafs add dir info in radix tree");
    new_dir = kzalloc(sizeof(struct dir_info), GFP_KERNEL);
    new_dir->r_f = 0;
    new_dir->sub_s = 0;
    new_dir->f_s = 0;
     565:	c6 40 ea 00          	movb   $0x0,-0x16(%rax)
    new_dir->prio = LEVEL_0;
     569:	c6 40 eb 00          	movb   $0x0,-0x15(%rax)
    new_dir->sub_num = 0;
    new_dir->dir_hash = hash_name;
    new_dir->dir_pos = pos;
    //nova_dbg("dir hash name is %llu", hash_name);
    INIT_LIST_HEAD(&new_dir->sub_file);
    radix_tree_insert(&ei->dir_tree, hash_name, new_dir);
     56d:	49 8d 7c 24 38       	lea    0x38(%r12),%rdi
    new_dir = kzalloc(sizeof(struct dir_info), GFP_KERNEL);
    new_dir->r_f = 0;
    new_dir->sub_s = 0;
    new_dir->f_s = 0;
    new_dir->prio = LEVEL_0;
    new_dir->sub_num = 0;
     572:	48 c7 40 f0 00 00 00 	movq   $0x0,-0x10(%rax)
     579:	00 
    new_dir->dir_hash = hash_name;
    new_dir->dir_pos = pos;
    //nova_dbg("dir hash name is %llu", hash_name);
    INIT_LIST_HEAD(&new_dir->sub_file);
    radix_tree_insert(&ei->dir_tree, hash_name, new_dir);
     57a:	48 89 da             	mov    %rbx,%rdx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
     57d:	48 89 43 18          	mov    %rax,0x18(%rbx)
	list->prev = list;
     581:	48 89 43 20          	mov    %rax,0x20(%rbx)
     585:	4c 89 ee             	mov    %r13,%rsi
     588:	e8 00 00 00 00       	callq  58d <add_dir_info+0x6d>
    return new_dir;
}
     58d:	48 89 d8             	mov    %rbx,%rax
     590:	5b                   	pop    %rbx
     591:	41 5c                	pop    %r12
     593:	41 5d                	pop    %r13
     595:	41 5e                	pop    %r14
     597:	5d                   	pop    %rbp
     598:	c3                   	retq   
     599:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000005a0 <update_read_hot>:

/*update read frequency when read happens*/
int update_read_hot(struct dzt_entry_info *dzt_ei, u64 hn)
{
     5a0:	e8 00 00 00 00       	callq  5a5 <update_read_hot+0x5>
     5a5:	55                   	push   %rbp
    struct dir_info *dir_info;
    dir_info = radix_tree_lookup(&dzt_ei->dir_tree, hn);
     5a6:	48 83 c7 38          	add    $0x38,%rdi
    return new_dir;
}

/*update read frequency when read happens*/
int update_read_hot(struct dzt_entry_info *dzt_ei, u64 hn)
{
     5aa:	48 89 e5             	mov    %rsp,%rbp
    struct dir_info *dir_info;
    dir_info = radix_tree_lookup(&dzt_ei->dir_tree, hn);
     5ad:	e8 00 00 00 00       	callq  5b2 <update_read_hot+0x12>
    if(!dir_info)
     5b2:	48 85 c0             	test   %rax,%rax
     5b5:	74 07                	je     5be <update_read_hot+0x1e>
        BUG();
    dir_info->r_f++;
     5b7:	80 00 01             	addb   $0x1,(%rax)

    return 0;
}
     5ba:	31 c0                	xor    %eax,%eax
     5bc:	5d                   	pop    %rbp
     5bd:	c3                   	retq   
int update_read_hot(struct dzt_entry_info *dzt_ei, u64 hn)
{
    struct dir_info *dir_info;
    dir_info = radix_tree_lookup(&dzt_ei->dir_tree, hn);
    if(!dir_info)
        BUG();
     5be:	0f 0b                	ud2    

00000000000005c0 <dafs_readdir>:
    
}

/*遍历文件夹，dir_emit填充到用户空间*/
static int dafs_readdir(struct file *file, struct dir_context *ctx)
{
     5c0:	e8 00 00 00 00       	callq  5c5 <dafs_readdir+0x5>
     5c5:	55                   	push   %rbp
     5c6:	48 89 e5             	mov    %rsp,%rbp
     5c9:	41 57                	push   %r15
     5cb:	41 56                	push   %r14
     5cd:	41 55                	push   %r13
     5cf:	41 54                	push   %r12
     5d1:	53                   	push   %rbx
     5d2:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
    u32 de_pos;
    timing_t readdir_time;

    //nova_dbg("%s: inode ino %llu, dentry ino %llu",__func__, inode->i_ino, dentry->d_inode->i_ino);

    NOVA_START_TIMING(readdir_t, readdir_time);
     5d9:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 5df <dafs_readdir+0x1f>
    
}

/*遍历文件夹，dir_emit填充到用户空间*/
static int dafs_readdir(struct file *file, struct dir_context *ctx)
{
     5df:	48 89 75 98          	mov    %rsi,-0x68(%rbp)
     5e3:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     5ea:	00 00 
     5ec:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     5f0:	31 c0                	xor    %eax,%eax
     5f2:	48 8b 47 20          	mov    0x20(%rdi),%rax
    struct inode *inode = file_inode(file);
    struct super_block *sb = inode->i_sb;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct nova_inode *pidir;
    struct nova_inode *child_pi;
    struct dentry *dentry = file->f_path.dentry; 
     5f6:	48 8b 5f 18          	mov    0x18(%rdi),%rbx
    u32 de_pos;
    timing_t readdir_time;

    //nova_dbg("%s: inode ino %llu, dentry ino %llu",__func__, inode->i_ino, dentry->d_inode->i_ino);

    NOVA_START_TIMING(readdir_t, readdir_time);
     5fa:	85 d2                	test   %edx,%edx
     5fc:	48 89 45 80          	mov    %rax,-0x80(%rbp)

/*遍历文件夹，dir_emit填充到用户空间*/
static int dafs_readdir(struct file *file, struct dir_context *ctx)
{
    struct inode *inode = file_inode(file);
    struct super_block *sb = inode->i_sb;
     600:	48 8b 40 28          	mov    0x28(%rax),%rax
     604:	48 89 45 90          	mov    %rax,-0x70(%rbp)
     608:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
     60f:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    u32 de_pos;
    timing_t readdir_time;

    //nova_dbg("%s: inode ino %llu, dentry ino %llu",__func__, inode->i_ino, dentry->d_inode->i_ino);

    NOVA_START_TIMING(readdir_t, readdir_time);
     616:	0f 85 71 03 00 00    	jne    98d <dafs_readdir+0x3cd>
    
    pidir = nova_get_inode(sb ,inode);
    pos = ctx->pos;
     61c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
     620:	4c 8b 78 08          	mov    0x8(%rax),%r15

    if(pos == READDIR_END){
     624:	49 83 ff ff          	cmp    $0xffffffffffffffff,%r15
     628:	0f 84 18 03 00 00    	je     946 <dafs_readdir+0x386>
    //buf = kzalloc(sizeof(char)*SMALL_NAME_LEN,GFP_ATOMIC);
    //
    path.mnt = file->f_path.mnt;
    path.dentry = file->f_path.dentry;
    //ppath = d_path(&path, ppath,SMALL_NAME_LEN);
    ppath = get_dentry_path(dentry, 1);
     62e:	48 89 df             	mov    %rbx,%rdi
     631:	e8 ca fa ff ff       	callq  100 <get_dentry_path.isra.4>
    //nova_dbg("%s file get path innitial is %s",__func__,ppath);
     
    phlen = strlen(ppath);
     636:	48 89 c7             	mov    %rax,%rdi
    //buf = kzalloc(sizeof(char)*SMALL_NAME_LEN,GFP_ATOMIC);
    //
    path.mnt = file->f_path.mnt;
    path.dentry = file->f_path.dentry;
    //ppath = d_path(&path, ppath,SMALL_NAME_LEN);
    ppath = get_dentry_path(dentry, 1);
     639:	49 89 c6             	mov    %rax,%r14
     63c:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
    //nova_dbg("%s file get path innitial is %s",__func__,ppath);
     
    phlen = strlen(ppath);
     643:	e8 00 00 00 00       	callq  648 <dafs_readdir+0x88>
    phn = kzalloc(sizeof(char)*phlen, GFP_KERNEL);
     648:	48 89 c7             	mov    %rax,%rdi
     64b:	e8 a0 fa ff ff       	callq  f0 <kzalloc.constprop.9>
     650:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 657 <dafs_readdir+0x97>
     657:	ba 70 00 00 00       	mov    $0x70,%edx
     65c:	be d0 80 00 00       	mov    $0x80d0,%esi
     661:	49 89 c4             	mov    %rax,%r12
     664:	e8 00 00 00 00       	callq  669 <dafs_readdir+0xa9>
     669:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
     670:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
     674:	4c 89 f7             	mov    %r14,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
     677:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
     67e:	4c 8b a8 d8 01 00 00 	mov    0x1d8(%rax),%r13
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
     685:	e8 00 00 00 00       	callq  68a <dafs_readdir+0xca>
     68a:	4c 89 f6             	mov    %r14,%rsi
     68d:	48 89 c2             	mov    %rax,%rdx
     690:	4c 89 e7             	mov    %r12,%rdi
     693:	e8 00 00 00 00       	callq  698 <dafs_readdir+0xd8>
    tlen = strlen(phstr);
     698:	4c 89 f7             	mov    %r14,%rdi
     69b:	e8 00 00 00 00       	callq  6a0 <dafs_readdir+0xe0>
     6a0:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
     6a3:	be 2f 00 00 00       	mov    $0x2f,%esi
     6a8:	4c 89 e7             	mov    %r12,%rdi
     6ab:	e8 00 00 00 00       	callq  6b0 <dafs_readdir+0xf0>
        phlen = tlen -strlen(tem);
     6b0:	48 89 c7             	mov    %rax,%rdi
     6b3:	e8 00 00 00 00       	callq  6b8 <dafs_readdir+0xf8>
        tlen = phlen;
        //bug
        if(phlen==0){
     6b8:	48 29 c3             	sub    %rax,%rbx
     6bb:	0f 84 ec 02 00 00    	je     9ad <dafs_readdir+0x3ed>
            break;
        }
        memcpy(ph,phstr,tlen);
     6c1:	48 89 da             	mov    %rbx,%rdx
     6c4:	4c 89 f6             	mov    %r14,%rsi
     6c7:	4c 89 e7             	mov    %r12,%rdi
     6ca:	e8 00 00 00 00       	callq  6cf <dafs_readdir+0x10f>
	int i;

	for (i = 0; i < length; i++) {
     6cf:	85 db                	test   %ebx,%ebx
        memcpy(ph+tlen, end, 1);
     6d1:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
     6d6:	0f 8e 99 02 00 00    	jle    975 <dafs_readdir+0x3b5>
     6dc:	8d 43 ff             	lea    -0x1(%rbx),%eax
     6df:	4c 89 e2             	mov    %r12,%rdx
     6e2:	31 f6                	xor    %esi,%esi
     6e4:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
     6e9:	48 89 f0             	mov    %rsi,%rax
     6ec:	48 83 c2 01          	add    $0x1,%rdx
     6f0:	48 c1 e0 06          	shl    $0x6,%rax
     6f4:	48 01 f0             	add    %rsi,%rax
     6f7:	48 8d 04 46          	lea    (%rsi,%rax,2),%rax
     6fb:	48 0f be 72 ff       	movsbq -0x1(%rdx),%rsi
     700:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     703:	48 39 ca             	cmp    %rcx,%rdx
     706:	75 e1                	jne    6e9 <dafs_readdir+0x129>
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
     708:	4c 89 ef             	mov    %r13,%rdi
     70b:	e8 00 00 00 00       	callq  710 <dafs_readdir+0x150>
        if(dzt_ei){
     710:	48 85 c0             	test   %rax,%rax
     713:	74 8e                	je     6a3 <dafs_readdir+0xe3>
     715:	49 89 c6             	mov    %rax,%r14
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     718:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx

    ei = find_dzt(sb, ppath, phn);
    if(!ei){
        BUG();
    }
    ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->dz_addr);
     71c:	49 8b 46 10          	mov    0x10(%r14),%rax
     720:	48 8b 93 b0 03 00 00 	mov    0x3b0(%rbx),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     727:	48 89 c7             	mov    %rax,%rdi
     72a:	48 03 7a 18          	add    0x18(%rdx),%rdi
     72e:	48 85 c0             	test   %rax,%rax
     731:	b8 00 00 00 00       	mov    $0x0,%eax
     736:	48 0f 45 c7          	cmovne %rdi,%rax
    phlen = strlen(phn);
     73a:	4c 89 e7             	mov    %r12,%rdi
     73d:	48 89 45 88          	mov    %rax,-0x78(%rbp)
     741:	e8 00 00 00 00       	callq  746 <dafs_readdir+0x186>
    if(phlen==1){
     746:	48 83 f8 01          	cmp    $0x1,%rax
    ei = find_dzt(sb, ppath, phn);
    if(!ei){
        BUG();
    }
    ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->dz_addr);
    phlen = strlen(phn);
     74a:	49 89 c5             	mov    %rax,%r13
    if(phlen==1){
     74d:	0f 84 d5 04 00 00    	je     c28 <dafs_readdir+0x668>
        flen = strlen(ppath);
        memcpy(phname, ppath, flen);
    } else {
        flen = strlen(ppath)-phlen;
     753:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
     75a:	e8 00 00 00 00       	callq  75f <dafs_readdir+0x19f>
     75f:	4c 29 e8             	sub    %r13,%rax
        memcpy(phname, ppath+phlen, flen);
     762:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ppath);
        memcpy(phname, ppath, flen);
    } else {
        flen = strlen(ppath)-phlen;
     769:	48 89 c3             	mov    %rax,%rbx
        memcpy(phname, ppath+phlen, flen);
     76c:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
     773:	48 89 da             	mov    %rbx,%rdx
     776:	4a 8d 34 28          	lea    (%rax,%r13,1),%rsi
     77a:	e8 00 00 00 00       	callq  77f <dafs_readdir+0x1bf>
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     77f:	85 db                	test   %ebx,%ebx
     781:	0f 8e de 04 00 00    	jle    c65 <dafs_readdir+0x6a5>
     787:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
     78e:	8d 43 ff             	lea    -0x1(%rbx),%eax
     791:	45 31 ed             	xor    %r13d,%r13d
     794:	48 8d 4c 07 01       	lea    0x1(%rdi,%rax,1),%rcx
     799:	48 89 f8             	mov    %rdi,%rax
		hash = hash * seed + (*str++);
     79c:	4c 89 ea             	mov    %r13,%rdx
     79f:	48 83 c0 01          	add    $0x1,%rax
     7a3:	48 c1 e2 06          	shl    $0x6,%rdx
     7a7:	4c 01 ea             	add    %r13,%rdx
     7aa:	49 8d 54 55 00       	lea    0x0(%r13,%rdx,2),%rdx
     7af:	4c 0f be 68 ff       	movsbq -0x1(%rax),%r13
     7b4:	49 01 d5             	add    %rdx,%r13
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     7b7:	48 39 c8             	cmp    %rcx,%rax
     7ba:	75 e0                	jne    79c <dafs_readdir+0x1dc>
    }
    ph_hash = BKDRHash(phname, flen);
    ht_head = ei->ht_head;
    ret = lookup_in_hashtable(sb, ht_head, ph_hash, 1, &de_pos);
     7bc:	49 8b 76 18          	mov    0x18(%r14),%rsi
     7c0:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
     7c4:	4c 8d 45 a4          	lea    -0x5c(%rbp),%r8
     7c8:	b9 01 00 00 00       	mov    $0x1,%ecx
     7cd:	4c 89 ea             	mov    %r13,%rdx
     7d0:	e8 00 00 00 00       	callq  7d5 <dafs_readdir+0x215>
    if(!ret){
     7d5:	85 c0                	test   %eax,%eax
     7d7:	0f 84 00 05 00 00    	je     cdd <dafs_readdir+0x71d>
        //nova_dbg("%s not find dentry in nvm",__func__);
        BUG();
    }
    
    f_de = &ze->dentry[de_pos];
    ino = le64_to_cpu(f_de->ino);
     7dd:	8b 55 a4             	mov    -0x5c(%rbp),%edx
    if(ino!=inode->i_ino){
     7e0:	48 8b 45 80          	mov    -0x80(%rbp),%rax
        //nova_dbg("%s not find dentry in nvm",__func__);
        BUG();
    }
    
    f_de = &ze->dentry[de_pos];
    ino = le64_to_cpu(f_de->ino);
     7e4:	48 89 d3             	mov    %rdx,%rbx
     7e7:	48 c1 e3 07          	shl    $0x7,%rbx
     7eb:	48 03 5d 88          	add    -0x78(%rbp),%rbx
     7ef:	48 8b 8b 98 40 00 00 	mov    0x4098(%rbx),%rcx
    if(ino!=inode->i_ino){
     7f6:	48 3b 48 40          	cmp    0x40(%rax),%rcx
     7fa:	0f 85 df 04 00 00    	jne    cdf <dafs_readdir+0x71f>
          
        f_de = &ze->dentry[de_pos];
    }

    hashname = ph_hash;
    dir = radix_tree_lookup(&ei->dir_tree, hashname);
     800:	49 8d 7e 38          	lea    0x38(%r14),%rdi
     804:	4c 89 ee             	mov    %r13,%rsi
     807:	48 89 95 70 ff ff ff 	mov    %rdx,-0x90(%rbp)
     80e:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
     812:	e8 00 00 00 00       	callq  817 <dafs_readdir+0x257>
    BUG_ON(dir==NULL);
     817:	48 85 c0             	test   %rax,%rax
          
        f_de = &ze->dentry[de_pos];
    }

    hashname = ph_hash;
    dir = radix_tree_lookup(&ei->dir_tree, hashname);
     81a:	49 89 c5             	mov    %rax,%r13
    BUG_ON(dir==NULL);
     81d:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
     821:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
     828:	0f 84 23 04 00 00    	je     c51 <dafs_readdir+0x691>
    if(f_de->file_type==ROOT_DIRECTORY && (ino!=NOVA_ROOT_INO)){
     82e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
     832:	48 81 c2 81 00 00 00 	add    $0x81,%rdx
     839:	48 c1 e2 07          	shl    $0x7,%rdx
     83d:	80 7c 10 02 02       	cmpb   $0x2,0x2(%rax,%rdx,1)
     842:	0f 85 8e 01 00 00    	jne    9d6 <dafs_readdir+0x416>
     848:	48 83 f9 01          	cmp    $0x1,%rcx
     84c:	0f 84 84 01 00 00    	je     9d6 <dafs_readdir+0x416>
        isroot = 1;
        ei_hn = f_de->dzt_hn;
        dzt_m = sbi->dzt_m_info;
        sei = radix_tree_lookup(&dzt_m->dzt_root, ei_hn);
     852:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
     859:	48 8b b3 a8 40 00 00 	mov    0x40a8(%rbx),%rsi
     860:	48 89 4d 88          	mov    %rcx,-0x78(%rbp)
     864:	48 8b b8 d8 01 00 00 	mov    0x1d8(%rax),%rdi
     86b:	e8 00 00 00 00       	callq  870 <dafs_readdir+0x2b0>
     870:	49 89 c6             	mov    %rax,%r14
        //nova_dbg("%s:new root zone addr is %llu",__func__, sei->dz_addr);
        /*update ze*/
        ze = (struct dafs_zone_entry *)nova_get_block(sb, sei->dz_addr);
     873:	48 8b 40 10          	mov    0x10(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     877:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
     87b:	48 85 c0             	test   %rax,%rax
     87e:	0f 84 cf 03 00 00    	je     c53 <dafs_readdir+0x693>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     884:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
     888:	48 8b 93 b0 03 00 00 	mov    0x3b0(%rbx),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     88f:	48 03 42 18          	add    0x18(%rdx),%rax
     893:	48 89 45 88          	mov    %rax,-0x78(%rbp)

    hashname = ph_hash;
    dir = radix_tree_lookup(&ei->dir_tree, hashname);
    BUG_ON(dir==NULL);
    if(f_de->file_type==ROOT_DIRECTORY && (ino!=NOVA_ROOT_INO)){
        isroot = 1;
     897:	b8 01 00 00 00       	mov    $0x1,%eax
     89c:	e9 37 01 00 00       	jmpq   9d8 <dafs_readdir+0x418>

        }
        ctx->pos = pos;
        //n++
    }
	if (prev_de &&!dir_emit(ctx, prev_de->name, prev_de->name_len, 
     8a1:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
     8a8:	4c 8b a5 38 ff ff ff 	mov    -0xc8(%rbp),%r12
     8af:	48 85 c0             	test   %rax,%rax
     8b2:	74 34                	je     8e8 <dafs_readdir+0x328>

static inline bool dir_emit(struct dir_context *ctx,
			    const char *name, int namelen,
			    u64 ino, unsigned type)
{
	return ctx->actor(ctx, name, namelen, ctx->pos, ino, type) == 0;
     8b4:	48 8b 9d 60 ff ff ff 	mov    -0xa0(%rbp),%rbx
     8bb:	0f b6 50 01          	movzbl 0x1(%rax),%edx
     8bf:	48 8d 70 30          	lea    0x30(%rax),%rsi
     8c3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
     8c7:	49 89 c8             	mov    %rcx,%r8
     8ca:	4c 89 f9             	mov    %r15,%rcx
     8cd:	44 0f b7 4b 1c       	movzwl 0x1c(%rbx),%r9d
     8d2:	48 89 c7             	mov    %rax,%rdi
     8d5:	66 41 c1 e9 0c       	shr    $0xc,%r9w
     8da:	41 83 e1 0f          	and    $0xf,%r9d
     8de:	ff 10                	callq  *(%rax)
     8e0:	85 c0                	test   %eax,%eax
     8e2:	0f 85 85 03 00 00    	jne    c6d <dafs_readdir+0x6ad>
                ino, IF2DT(le16_to_cpu(prev_child_pi->i_mode)))) {
			//nova_dbg("Here: pos %llu\n", ctx->pos);
            BUG();
			return 0;
	}
    ctx->pos = READDIR_END;
     8e8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    //nova_dbg("dafs ctx pos is %llx", ctx->pos);
FREE:
    kfree(phname);
     8ec:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
                ino, IF2DT(le16_to_cpu(prev_child_pi->i_mode)))) {
			//nova_dbg("Here: pos %llu\n", ctx->pos);
            BUG();
			return 0;
	}
    ctx->pos = READDIR_END;
     8f3:	48 c7 40 08 ff ff ff 	movq   $0xffffffffffffffff,0x8(%rax)
     8fa:	ff 
    //nova_dbg("dafs ctx pos is %llx", ctx->pos);
FREE:
    kfree(phname);
     8fb:	e8 00 00 00 00       	callq  900 <dafs_readdir+0x340>
    //kfree(tem);
    kfree(phn);
     900:	4c 89 e7             	mov    %r12,%rdi
     903:	e8 00 00 00 00       	callq  908 <dafs_readdir+0x348>
    //kfree(buf);
    kfree(ppath);
     908:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
     90f:	e8 00 00 00 00       	callq  914 <dafs_readdir+0x354>
OUT:
	NOVA_END_TIMING(readdir_t, readdir_time);
     914:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 91a <dafs_readdir+0x35a>
     91a:	85 c0                	test   %eax,%eax
     91c:	74 28                	je     946 <dafs_readdir+0x386>
	getnstimeofday64(ts);
}

static inline void getrawmonotonic(struct timespec *ts)
{
	getrawmonotonic64(ts);
     91e:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
     922:	e8 00 00 00 00       	callq  927 <dafs_readdir+0x367>
     927:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
     92b:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
     92f:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
     936:	48 2b 45 b8          	sub    -0x48(%rbp),%rax
     93a:	48 03 45 c8          	add    -0x38(%rbp),%rax
     93e:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 946 <dafs_readdir+0x386>
     945:	00 
     946:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 94e <dafs_readdir+0x38e>
     94d:	00 
	//nova_dbg("%s readdir return", __func__);
	return 0;

}
     94e:	31 c0                	xor    %eax,%eax
     950:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
     954:	65 48 33 3c 25 28 00 	xor    %gs:0x28,%rdi
     95b:	00 00 
     95d:	0f 85 67 03 00 00    	jne    cca <dafs_readdir+0x70a>
     963:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
     96a:	5b                   	pop    %rbx
     96b:	41 5c                	pop    %r12
     96d:	41 5d                	pop    %r13
     96f:	41 5e                	pop    %r14
     971:	41 5f                	pop    %r15
     973:	5d                   	pop    %rbp
     974:	c3                   	retq   

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
     975:	31 f6                	xor    %esi,%esi
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
     977:	4c 89 ef             	mov    %r13,%rdi
     97a:	e8 00 00 00 00       	callq  97f <dafs_readdir+0x3bf>
        if(dzt_ei){
     97f:	48 85 c0             	test   %rax,%rax
     982:	0f 84 1b fd ff ff    	je     6a3 <dafs_readdir+0xe3>
     988:	e9 88 fd ff ff       	jmpq   715 <dafs_readdir+0x155>
     98d:	48 8d 7d b0          	lea    -0x50(%rbp),%rdi
     991:	e8 00 00 00 00       	callq  996 <dafs_readdir+0x3d6>
    //nova_dbg("%s: inode ino %llu, dentry ino %llu",__func__, inode->i_ino, dentry->d_inode->i_ino);

    NOVA_START_TIMING(readdir_t, readdir_time);
    
    pidir = nova_get_inode(sb ,inode);
    pos = ctx->pos;
     996:	48 8b 45 98          	mov    -0x68(%rbp),%rax
     99a:	4c 8b 78 08          	mov    0x8(%rax),%r15

    if(pos == READDIR_END){
     99e:	49 83 ff ff          	cmp    $0xffffffffffffffff,%r15
     9a2:	0f 85 86 fc ff ff    	jne    62e <dafs_readdir+0x6e>
     9a8:	e9 67 ff ff ff       	jmpq   914 <dafs_readdir+0x354>
            goto END;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
     9ad:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    memcpy(ph+1,end,1);
     9b2:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
     9b8:	be 2f 00 00 00       	mov    $0x2f,%esi
     9bd:	4c 89 ef             	mov    %r13,%rdi
     9c0:	e8 00 00 00 00       	callq  9c5 <dafs_readdir+0x405>
    if(!dzt_ei){
     9c5:	48 85 c0             	test   %rax,%rax

    /*root dir*/
    memcpy(ph, "/", 1);
    memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
     9c8:	49 89 c6             	mov    %rax,%r14
    if(!dzt_ei){
     9cb:	0f 85 47 fd ff ff    	jne    718 <dafs_readdir+0x158>
     9d1:	e8 00 00 00 00       	callq  9d6 <dafs_readdir+0x416>
    u64 pi_addr, hashname, ei_hn, dir_hn;
    u32 f_pos;
    u64 pos;
    ino_t ino;
    u8 type;
    int ret, isroot=0, i=0;
     9d6:	31 c0                	xor    %eax,%eax
        ei = sei;
    }

    head = &dir->sub_file;
    //nova_dbg("%s:dir_subfile num is%d, zone addr is %llu",__func__,dir->sub_num, ei->dz_addr);
    list_for_each(this, head){
     9d8:	49 8b 5d 18          	mov    0x18(%r13),%rbx
        /*update ze*/
        ze = (struct dafs_zone_entry *)nova_get_block(sb, sei->dz_addr);
        ei = sei;
    }

    head = &dir->sub_file;
     9dc:	49 8d 7d 18          	lea    0x18(%r13),%rdi
     9e0:	48 89 7d 80          	mov    %rdi,-0x80(%rbp)
    //nova_dbg("%s:dir_subfile num is%d, zone addr is %llu",__func__,dir->sub_num, ei->dz_addr);
    list_for_each(this, head){
     9e4:	48 39 df             	cmp    %rbx,%rdi
     9e7:	0f 84 fb fe ff ff    	je     8e8 <dafs_readdir+0x328>
        tem_sf = list_entry(this, struct file_p, list);
        BUG_ON(tem_sf==NULL);
     9ed:	48 85 db             	test   %rbx,%rbx
     9f0:	0f 84 28 02 00 00    	je     c1e <dafs_readdir+0x65e>
        f_pos = tem_sf->pos;
     9f6:	44 8b 5b 10          	mov    0x10(%rbx),%r11d
        if(!f_pos && !isroot){
     9fa:	83 f0 01             	xor    $0x1,%eax
     9fd:	83 e0 01             	and    $0x1,%eax
     a00:	88 85 5f ff ff ff    	mov    %al,-0xa1(%rbp)
     a06:	45 85 db             	test   %r11d,%r11d
     a09:	75 08                	jne    a13 <dafs_readdir+0x453>
     a0b:	84 c0                	test   %al,%al
     a0d:	0f 85 bc 02 00 00    	jne    ccf <dafs_readdir+0x70f>
            ctx->pos = READDIR_END;
            BUG();
            goto FREE;
        }

        de = &ze->dentry[f_pos];
     a13:	45 89 dd             	mov    %r11d,%r13d
     a16:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
     a1a:	49 8d 85 81 00 00 00 	lea    0x81(%r13),%rax
     a21:	48 c1 e0 07          	shl    $0x7,%rax
     a25:	48 01 f8             	add    %rdi,%rax
        //nova_dbg("%s:list subfile name:%s, pos id %d",__func__, de->name,f_pos);
        type = nova_get_entry_type((void *)de);
        if(type != DAFS_DIR_ENTRY){
     a28:	80 38 06             	cmpb   $0x6,(%rax)
            ctx->pos = READDIR_END;
            BUG();
            goto FREE;
        }

        de = &ze->dentry[f_pos];
     a2b:	48 89 45 88          	mov    %rax,-0x78(%rbp)
        //nova_dbg("%s:list subfile name:%s, pos id %d",__func__, de->name,f_pos);
        type = nova_get_entry_type((void *)de);
        if(type != DAFS_DIR_ENTRY){
     a2f:	0f 85 b3 01 00 00    	jne    be8 <dafs_readdir+0x628>
     a35:	4c 89 a5 38 ff ff ff 	mov    %r12,-0xc8(%rbp)
     a3c:	4c 89 b5 40 ff ff ff 	mov    %r14,-0xc0(%rbp)
     a43:	49 89 fc             	mov    %rdi,%r12
     a46:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
     a4d:	00 00 00 00 
     a51:	48 c7 85 78 ff ff ff 	movq   $0x0,-0x88(%rbp)
     a58:	00 00 00 00 
     a5c:	45 89 de             	mov    %r11d,%r14d
     a5f:	4d 89 e8             	mov    %r13,%r8
     a62:	49 c1 e0 07          	shl    $0x7,%r8
     a66:	4d 01 e0             	add    %r12,%r8
            //nova_dbg ("unknown type\n");
            BUG();
            return -EINVAL;
        }

        if(de->file_type == NORMAL_DIRECTORY){
     a69:	41 80 b8 82 40 00 00 	cmpb   $0x1,0x4082(%r8)
     a70:	01 
     a71:	0f 84 73 01 00 00    	je     bea <dafs_readdir+0x62a>
			"name %s, namelen %u, rec len %u\n", f_pos,
			de->entry_type, le64_to_cpu(de->ino),
			de->name, de->name_len,
			DAFS_DEF_DENTRY_SIZE);*/

        if(de->ino>0){
     a77:	4c 89 e8             	mov    %r13,%rax
     a7a:	48 c1 e0 07          	shl    $0x7,%rax
     a7e:	4d 8b ac 04 98 40 00 	mov    0x4098(%r12,%rax,1),%r13
     a85:	00 
     a86:	4d 85 ed             	test   %r13,%r13
     a89:	0f 84 0b 01 00 00    	je     b9a <dafs_readdir+0x5da>
            ino = __le64_to_cpu(de->ino);
            pos = BKDRHash(de->name, de->name_len);
     a8f:	41 0f b6 90 81 40 00 	movzbl 0x4081(%r8),%edx
     a96:	00 
     a97:	4d 8d 9c 04 b0 40 00 	lea    0x40b0(%r12,%rax,1),%r11
     a9e:	00 
	int i;

	for (i = 0; i < length; i++) {
     a9f:	84 d2                	test   %dl,%dl
     aa1:	0f 84 79 01 00 00    	je     c20 <dafs_readdir+0x660>
     aa7:	8d 42 ff             	lea    -0x1(%rdx),%eax
     aaa:	45 31 ff             	xor    %r15d,%r15d
     aad:	49 8d 4c 03 01       	lea    0x1(%r11,%rax,1),%rcx
     ab2:	4c 89 d8             	mov    %r11,%rax
		hash = hash * seed + (*str++);
     ab5:	4c 89 fa             	mov    %r15,%rdx
     ab8:	48 83 c0 01          	add    $0x1,%rax
     abc:	48 c1 e2 06          	shl    $0x6,%rdx
     ac0:	4c 01 fa             	add    %r15,%rdx
     ac3:	49 8d 14 57          	lea    (%r15,%rdx,2),%rdx
     ac7:	4c 0f be 78 ff       	movsbq -0x1(%rax),%r15
     acc:	49 01 d7             	add    %rdx,%r15
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     acf:	48 39 c1             	cmp    %rax,%rcx
     ad2:	75 e1                	jne    ab5 <dafs_readdir+0x4f5>
            //BUG();
            ret = nova_get_inode_address(sb, ino, &pi_addr, 0);
     ad4:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
     ad8:	48 8d 55 a8          	lea    -0x58(%rbp),%rdx
     adc:	31 c9                	xor    %ecx,%ecx
     ade:	4c 89 ee             	mov    %r13,%rsi
     ae1:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)
     ae8:	4c 89 9d 70 ff ff ff 	mov    %r11,-0x90(%rbp)
     aef:	e8 00 00 00 00       	callq  af4 <dafs_readdir+0x534>
            //BUG_ON(ret==0);
            if(ret){
     af4:	85 c0                	test   %eax,%eax
     af6:	4c 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%r11
     afd:	4c 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%r8
     b04:	0f 85 9d 01 00 00    	jne    ca7 <dafs_readdir+0x6e7>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     b0a:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
                BUG();
				ctx->pos = READDIR_END;
				return ret;
            }

            child_pi = nova_get_block(sb, pi_addr);
     b0e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
     b12:	48 8b 97 b0 03 00 00 	mov    0x3b0(%rdi),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     b19:	49 89 c2             	mov    %rax,%r10
     b1c:	4c 03 52 18          	add    0x18(%rdx),%r10
     b20:	48 85 c0             	test   %rax,%rax
     b23:	b8 00 00 00 00       	mov    $0x0,%eax
     b28:	4c 0f 44 d0          	cmove  %rax,%r10
			nova_dbgv("ctx: pos %d ino %llu, name %s, "
     b2c:	f6 05 00 00 00 00 10 	testb  $0x10,0x0(%rip)        # b33 <dafs_readdir+0x573>
     b33:	0f 85 36 01 00 00    	jne    c6f <dafs_readdir+0x6af>
				"name_len %u, de_len %u\n", f_pos,
				(u64)ino, de->name, de->name_len,
				DAFS_DEF_DENTRY_SIZE);
			if (prev_de &&!dir_emit(ctx, prev_de->name,
     b39:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
     b40:	48 85 c0             	test   %rax,%rax
     b43:	74 40                	je     b85 <dafs_readdir+0x5c5>
     b45:	48 8b bd 60 ff ff ff 	mov    -0xa0(%rbp),%rdi
     b4c:	0f b6 50 01          	movzbl 0x1(%rax),%edx
     b50:	48 8d 70 30          	lea    0x30(%rax),%rsi
     b54:	4c 89 95 78 ff ff ff 	mov    %r10,-0x88(%rbp)
     b5b:	4d 89 e8             	mov    %r13,%r8
     b5e:	44 0f b7 4f 1c       	movzwl 0x1c(%rdi),%r9d
     b63:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
     b67:	48 8b 4f 08          	mov    0x8(%rdi),%rcx
     b6b:	66 41 c1 e9 0c       	shr    $0xc,%r9w
     b70:	41 83 e1 0f          	and    $0xf,%r9d
     b74:	ff 17                	callq  *(%rdi)
     b76:	85 c0                	test   %eax,%eax
     b78:	4c 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10
     b7f:	0f 85 20 01 00 00    	jne    ca5 <dafs_readdir+0x6e5>
     b85:	48 8b 45 88          	mov    -0x78(%rbp),%rax
     b89:	4c 89 e9             	mov    %r13,%rcx
				//nova_dbg("Here: pos %llu\n", ctx->pos);
                BUG();
				return 0;
			}
            prev_de = de;
            prev_child_pi = child_pi;
     b8c:	4c 89 95 60 ff ff ff 	mov    %r10,-0xa0(%rbp)
     b93:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)

        }
        ctx->pos = pos;
     b9a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
     b9e:	4c 89 78 08          	mov    %r15,0x8(%rax)
        ei = sei;
    }

    head = &dir->sub_file;
    //nova_dbg("%s:dir_subfile num is%d, zone addr is %llu",__func__,dir->sub_num, ei->dz_addr);
    list_for_each(this, head){
     ba2:	48 8b 1b             	mov    (%rbx),%rbx
     ba5:	48 39 5d 80          	cmp    %rbx,-0x80(%rbp)
     ba9:	0f 84 f2 fc ff ff    	je     8a1 <dafs_readdir+0x2e1>
        tem_sf = list_entry(this, struct file_p, list);
        BUG_ON(tem_sf==NULL);
     baf:	48 85 db             	test   %rbx,%rbx
     bb2:	74 6a                	je     c1e <dafs_readdir+0x65e>
        f_pos = tem_sf->pos;
     bb4:	44 8b 73 10          	mov    0x10(%rbx),%r14d
        if(!f_pos && !isroot){
     bb8:	45 85 f6             	test   %r14d,%r14d
     bbb:	75 0d                	jne    bca <dafs_readdir+0x60a>
     bbd:	80 bd 5f ff ff ff 00 	cmpb   $0x0,-0xa1(%rbp)
     bc4:	0f 85 05 01 00 00    	jne    ccf <dafs_readdir+0x70f>
            ctx->pos = READDIR_END;
            BUG();
            goto FREE;
        }

        de = &ze->dentry[f_pos];
     bca:	45 89 f5             	mov    %r14d,%r13d
     bcd:	49 8d 85 81 00 00 00 	lea    0x81(%r13),%rax
     bd4:	48 c1 e0 07          	shl    $0x7,%rax
     bd8:	4c 01 e0             	add    %r12,%rax
        //nova_dbg("%s:list subfile name:%s, pos id %d",__func__, de->name,f_pos);
        type = nova_get_entry_type((void *)de);
        if(type != DAFS_DIR_ENTRY){
     bdb:	80 38 06             	cmpb   $0x6,(%rax)
            ctx->pos = READDIR_END;
            BUG();
            goto FREE;
        }

        de = &ze->dentry[f_pos];
     bde:	48 89 45 88          	mov    %rax,-0x78(%rbp)
        //nova_dbg("%s:list subfile name:%s, pos id %d",__func__, de->name,f_pos);
        type = nova_get_entry_type((void *)de);
        if(type != DAFS_DIR_ENTRY){
     be2:	0f 84 77 fe ff ff    	je     a5f <dafs_readdir+0x49f>
            //nova_dbg ("unknown type\n");
            BUG();
     be8:	0f 0b                	ud2    
            return -EINVAL;
        }

        if(de->file_type == NORMAL_DIRECTORY){
            dir_hn = le64_to_cpu(de->hname);
            update_read_hot(ei, dir_hn);
     bea:	49 8b b0 a8 40 00 00 	mov    0x40a8(%r8),%rsi
     bf1:	48 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%rdi
     bf8:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
     bff:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
     c06:	e8 00 00 00 00       	callq  c0b <dafs_readdir+0x64b>
     c0b:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
     c12:	4c 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%r8
     c19:	e9 59 fe ff ff       	jmpq   a77 <dafs_readdir+0x4b7>

    head = &dir->sub_file;
    //nova_dbg("%s:dir_subfile num is%d, zone addr is %llu",__func__,dir->sub_num, ei->dz_addr);
    list_for_each(this, head){
        tem_sf = list_entry(this, struct file_p, list);
        BUG_ON(tem_sf==NULL);
     c1e:	0f 0b                	ud2    

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
     c20:	45 31 ff             	xor    %r15d,%r15d
     c23:	e9 ac fe ff ff       	jmpq   ad4 <dafs_readdir+0x514>
        BUG();
    }
    ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ppath);
     c28:	4c 8b ad 48 ff ff ff 	mov    -0xb8(%rbp),%r13
     c2f:	4c 89 ef             	mov    %r13,%rdi
     c32:	e8 00 00 00 00       	callq  c37 <dafs_readdir+0x677>
        memcpy(phname, ppath, flen);
     c37:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
     c3e:	48 89 c2             	mov    %rax,%rdx
     c41:	4c 89 ee             	mov    %r13,%rsi
        BUG();
    }
    ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ppath);
     c44:	48 89 c3             	mov    %rax,%rbx
        memcpy(phname, ppath, flen);
     c47:	e8 00 00 00 00       	callq  c4c <dafs_readdir+0x68c>
     c4c:	e9 2e fb ff ff       	jmpq   77f <dafs_readdir+0x1bf>
        f_de = &ze->dentry[de_pos];
    }

    hashname = ph_hash;
    dir = radix_tree_lookup(&ei->dir_tree, hashname);
    BUG_ON(dir==NULL);
     c51:	0f 0b                	ud2    
    if(f_de->file_type==ROOT_DIRECTORY && (ino!=NOVA_ROOT_INO)){
        isroot = 1;
     c53:	b8 01 00 00 00       	mov    $0x1,%eax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     c58:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
     c5f:	00 
     c60:	e9 73 fd ff ff       	jmpq   9d8 <dafs_readdir+0x418>

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
     c65:	45 31 ed             	xor    %r13d,%r13d
     c68:	e9 4f fb ff ff       	jmpq   7bc <dafs_readdir+0x1fc>
        //n++
    }
	if (prev_de &&!dir_emit(ctx, prev_de->name, prev_de->name_len, 
                ino, IF2DT(le16_to_cpu(prev_child_pi->i_mode)))) {
			//nova_dbg("Here: pos %llu\n", ctx->pos);
            BUG();
     c6d:	0f 0b                	ud2    
				ctx->pos = READDIR_END;
				return ret;
            }

            child_pi = nova_get_block(sb, pi_addr);
			nova_dbgv("ctx: pos %d ino %llu, name %s, "
     c6f:	45 0f b6 80 81 40 00 	movzbl 0x4081(%r8),%r8d
     c76:	00 
     c77:	41 b9 80 00 00 00    	mov    $0x80,%r9d
     c7d:	4c 89 d9             	mov    %r11,%rcx
     c80:	4c 89 ea             	mov    %r13,%rdx
     c83:	44 89 f6             	mov    %r14d,%esi
     c86:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     c8d:	4c 89 95 70 ff ff ff 	mov    %r10,-0x90(%rbp)
     c94:	e8 00 00 00 00       	callq  c99 <dafs_readdir+0x6d9>
     c99:	4c 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10
     ca0:	e9 94 fe ff ff       	jmpq   b39 <dafs_readdir+0x579>
				DAFS_DEF_DENTRY_SIZE);
			if (prev_de &&!dir_emit(ctx, prev_de->name,
				prev_de->name_len, ino,
				IF2DT(le16_to_cpu(prev_child_pi->i_mode)))) {
				//nova_dbg("Here: pos %llu\n", ctx->pos);
                BUG();
     ca5:	0f 0b                	ud2    
            pos = BKDRHash(de->name, de->name_len);
            //BUG();
            ret = nova_get_inode_address(sb, ino, &pi_addr, 0);
            //BUG_ON(ret==0);
            if(ret){
				nova_dbgv("%s: get child inode %lu address "
     ca7:	f6 05 00 00 00 00 10 	testb  $0x10,0x0(%rip)        # cae <dafs_readdir+0x6ee>
     cae:	74 18                	je     cc8 <dafs_readdir+0x708>
     cb0:	89 c1                	mov    %eax,%ecx
     cb2:	4c 89 ea             	mov    %r13,%rdx
     cb5:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     cbc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     cc3:	e8 00 00 00 00       	callq  cc8 <dafs_readdir+0x708>
					"failed %d\n", __func__, ino, ret);
                BUG();
     cc8:	0f 0b                	ud2    
OUT:
	NOVA_END_TIMING(readdir_t, readdir_time);
	//nova_dbg("%s readdir return", __func__);
	return 0;

}
     cca:	e8 00 00 00 00       	callq  ccf <dafs_readdir+0x70f>
    list_for_each(this, head){
        tem_sf = list_entry(this, struct file_p, list);
        BUG_ON(tem_sf==NULL);
        f_pos = tem_sf->pos;
        if(!f_pos && !isroot){
            ctx->pos = READDIR_END;
     ccf:	48 8b 45 98          	mov    -0x68(%rbp),%rax
     cd3:	48 c7 40 08 ff ff ff 	movq   $0xffffffffffffffff,0x8(%rax)
     cda:	ff 
            BUG();
     cdb:	0f 0b                	ud2    
    ph_hash = BKDRHash(phname, flen);
    ht_head = ei->ht_head;
    ret = lookup_in_hashtable(sb, ht_head, ph_hash, 1, &de_pos);
    if(!ret){
        //nova_dbg("%s not find dentry in nvm",__func__);
        BUG();
     cdd:	0f 0b                	ud2    
    }
    
    f_de = &ze->dentry[de_pos];
    ino = le64_to_cpu(f_de->ino);
    if(ino!=inode->i_ino){
        BUG();
     cdf:	0f 0b                	ud2    
     ce1:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
     ce6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     ced:	00 00 00 

0000000000000cf0 <dafs_rebuild_dir_time_and_size>:
    return dzt_ei;
}

void dafs_rebuild_dir_time_and_size(struct super_block *sb,
	struct nova_inode *pi, int link_change, struct inode *dir)
{
     cf0:	e8 00 00 00 00       	callq  cf5 <dafs_rebuild_dir_time_and_size+0x5>
    unsigned short links_count;

	if (!pi)
     cf5:	48 85 f6             	test   %rsi,%rsi
     cf8:	74 46                	je     d40 <dafs_rebuild_dir_time_and_size+0x50>
    return dzt_ei;
}

void dafs_rebuild_dir_time_and_size(struct super_block *sb,
	struct nova_inode *pi, int link_change, struct inode *dir)
{
     cfa:	55                   	push   %rbp
     cfb:	48 89 e5             	mov    %rsp,%rbp
     cfe:	41 55                	push   %r13
     d00:	41 54                	push   %r12
     d02:	53                   	push   %rbx
     d03:	48 89 f3             	mov    %rsi,%rbx
     d06:	49 89 cc             	mov    %rcx,%r12
     d09:	41 89 d5             	mov    %edx,%r13d
    unsigned short links_count;

	if (!pi)
		return;

	pi->i_ctime = CURRENT_TIME_SEC.tv_sec;
     d0c:	e8 00 00 00 00       	callq  d11 <dafs_rebuild_dir_time_and_size+0x21>
     d11:	89 43 10             	mov    %eax,0x10(%rbx)
	pi->i_mtime = CURRENT_TIME_SEC.tv_sec;
     d14:	e8 00 00 00 00       	callq  d19 <dafs_rebuild_dir_time_and_size+0x29>
	pi->i_size = DAFS_DEF_DENTRY_SIZE;
     d19:	48 c7 43 08 80 00 00 	movq   $0x80,0x8(%rbx)
     d20:	00 

	if (!pi)
		return;

	pi->i_ctime = CURRENT_TIME_SEC.tv_sec;
	pi->i_mtime = CURRENT_TIME_SEC.tv_sec;
     d21:	89 43 14             	mov    %eax,0x14(%rbx)
	pi->i_size = DAFS_DEF_DENTRY_SIZE;
    links_count = cpu_to_le16(dir->i_nlink);
     d24:	41 8b 44 24 48       	mov    0x48(%r12),%eax
    //nova_dbg("%s dir links is %d", __func__, links_count);
	if (links_count == 0 && link_change == -1)
     d29:	66 85 c0             	test   %ax,%ax
     d2c:	75 14                	jne    d42 <dafs_rebuild_dir_time_and_size+0x52>
		links_count = 0;
     d2e:	31 d2                	xor    %edx,%edx
	pi->i_ctime = CURRENT_TIME_SEC.tv_sec;
	pi->i_mtime = CURRENT_TIME_SEC.tv_sec;
	pi->i_size = DAFS_DEF_DENTRY_SIZE;
    links_count = cpu_to_le16(dir->i_nlink);
    //nova_dbg("%s dir links is %d", __func__, links_count);
	if (links_count == 0 && link_change == -1)
     d30:	41 83 fd ff          	cmp    $0xffffffff,%r13d
     d34:	75 0c                	jne    d42 <dafs_rebuild_dir_time_and_size+0x52>
		links_count = 0;
	else
		links_count += link_change;
	pi->i_links_count = links_count;
     d36:	66 89 53 1e          	mov    %dx,0x1e(%rbx)
}
     d3a:	5b                   	pop    %rbx
     d3b:	41 5c                	pop    %r12
     d3d:	41 5d                	pop    %r13
     d3f:	5d                   	pop    %rbp
     d40:	f3 c3                	repz retq 
    links_count = cpu_to_le16(dir->i_nlink);
    //nova_dbg("%s dir links is %d", __func__, links_count);
	if (links_count == 0 && link_change == -1)
		links_count = 0;
	else
		links_count += link_change;
     d42:	42 8d 14 28          	lea    (%rax,%r13,1),%edx
	pi->i_links_count = links_count;
     d46:	66 89 53 1e          	mov    %dx,0x1e(%rbx)
}
     d4a:	5b                   	pop    %rbx
     d4b:	41 5c                	pop    %r12
     d4d:	41 5d                	pop    %r13
     d4f:	5d                   	pop    %rbp
     d50:	eb ee                	jmp    d40 <dafs_rebuild_dir_time_and_size+0x50>
     d52:	0f 1f 40 00          	nopl   0x0(%rax)
     d56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     d5d:	00 00 00 

0000000000000d60 <record_dir_log>:

/*record dir operation in logs*/
void record_dir_log(struct super_block *sb, struct dentry *src, struct dentry *des, int type)
{
     d60:	e8 00 00 00 00       	callq  d65 <record_dir_log+0x5>
     d65:	55                   	push   %rbp
     d66:	48 89 e5             	mov    %rsp,%rbp
     d69:	41 57                	push   %r15
     d6b:	41 56                	push   %r14
     d6d:	41 55                	push   %r13
     d6f:	41 54                	push   %r12
     d71:	49 89 f5             	mov    %rsi,%r13
     d74:	53                   	push   %rbx
     d75:	be d0 80 00 00       	mov    $0x80d0,%esi
     d7a:	48 83 ec 40          	sub    $0x40,%rsp
     d7e:	48 89 7d b0          	mov    %rdi,-0x50(%rbp)
     d82:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # d89 <record_dir_log+0x29>
     d89:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
     d8d:	ba 00 04 00 00       	mov    $0x400,%edx
     d92:	89 4d 9c             	mov    %ecx,-0x64(%rbp)
     d95:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     d9c:	00 00 
     d9e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     da2:	31 c0                	xor    %eax,%eax
     da4:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
     dab:	00 00 

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    char *ph=NULL, *buf=NULL, *tem=NULL, *mntchar= "/mnt/ramdisk", *end="", *ppath=NULL;
    struct fs_struct *fs = current->fs;
     dad:	4c 8b b8 30 06 00 00 	mov    0x630(%rax),%r15
     db4:	e8 00 00 00 00       	callq  db9 <record_dir_log+0x59>
     db9:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # dc0 <record_dir_log+0x60>
     dc0:	ba 00 04 00 00       	mov    $0x400,%edx
     dc5:	be d0 80 00 00       	mov    $0x80d0,%esi
     dca:	49 89 c6             	mov    %rax,%r14
     dcd:	e8 00 00 00 00       	callq  dd2 <record_dir_log+0x72>
     dd2:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # dd9 <record_dir_log+0x79>
     dd9:	48 89 c3             	mov    %rax,%rbx
     ddc:	ba 00 04 00 00       	mov    $0x400,%edx
     de1:	be d0 80 00 00       	mov    $0x80d0,%esi
     de6:	e8 00 00 00 00       	callq  deb <record_dir_log+0x8b>

    //nova_dbg("%s:dafs get dentry path",__func__);
    ph = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    buf = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    tem = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    if(!buf)
     deb:	48 85 db             	test   %rbx,%rbx
     dee:	0f 84 1e 01 00 00    	je     f12 <record_dir_log+0x1b2>
        goto ERR;

    read_lock(&fs->lock);
     df4:	49 8d 7f 04          	lea    0x4(%r15),%rdi
     df8:	49 89 c4             	mov    %rax,%r12
     dfb:	e8 00 00 00 00       	callq  e00 <record_dir_log+0xa0>
    vfsmnt = mntget(fs->pwd.mnt);
     e00:	49 8b 7f 28          	mov    0x28(%r15),%rdi
     e04:	e8 00 00 00 00       	callq  e09 <record_dir_log+0xa9>
    if(!vfsmnt){
     e09:	48 85 c0             	test   %rax,%rax
    tem = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    if(!buf)
        goto ERR;

    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
     e0c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    if(!vfsmnt){
     e10:	0f 84 fc 00 00 00    	je     f12 <record_dir_log+0x1b2>
     e16:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
     e1b:	f0 41 0f c1 47 04    	lock xadd %eax,0x4(%r15)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
     e21:	49 8b 75 28          	mov    0x28(%r13),%rsi
     e25:	49 c7 c7 00 00 00 00 	mov    $0x0,%r15
     e2c:	b9 02 00 00 00       	mov    $0x2,%ecx
     e31:	4c 89 ff             	mov    %r15,%rdi
     e34:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
     e36:	0f 85 c1 04 00 00    	jne    12fd <record_dir_log+0x59d>
        strcat(buf,"/");

    do{
        strcat(buf, "/");
     e3c:	48 89 df             	mov    %rbx,%rdi
     e3f:	e8 00 00 00 00       	callq  e44 <record_dir_log+0xe4>
     e44:	ba 2f 00 00 00       	mov    $0x2f,%edx
        strcat(buf, tem_dentry->d_name.name);
     e49:	48 8d 7c 03 01       	lea    0x1(%rbx,%rax,1),%rdi
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
        strcat(buf,"/");

    do{
        strcat(buf, "/");
     e4e:	66 89 14 03          	mov    %dx,(%rbx,%rax,1)
        strcat(buf, tem_dentry->d_name.name);
     e52:	49 8b 75 28          	mov    0x28(%r13),%rsi
     e56:	e8 00 00 00 00       	callq  e5b <record_dir_log+0xfb>
        p_dentry = tem_dentry->d_parent;
     e5b:	4d 8b 6d 18          	mov    0x18(%r13),%r13
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
     e5f:	b9 02 00 00 00       	mov    $0x2,%ecx
     e64:	4c 89 ff             	mov    %r15,%rdi
     e67:	49 8b 75 28          	mov    0x28(%r13),%rsi
     e6b:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
     e6d:	75 cd                	jne    e3c <record_dir_log+0xdc>
     e6f:	49 8b 45 30          	mov    0x30(%r13),%rax
     e73:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
     e78:	75 c2                	jne    e3c <record_dir_log+0xdc>
            break;
    }while(1);

    memcpy(tem, buf, strlen(buf));
     e7a:	48 89 df             	mov    %rbx,%rdi
     e7d:	e8 00 00 00 00       	callq  e82 <record_dir_log+0x122>
     e82:	48 89 de             	mov    %rbx,%rsi
     e85:	48 89 c2             	mov    %rax,%rdx
     e88:	4c 89 e7             	mov    %r12,%rdi
     e8b:	e8 00 00 00 00       	callq  e90 <record_dir_log+0x130>
    tlen = strlen(buf);
     e90:	48 89 df             	mov    %rbx,%rdi
     e93:	e8 00 00 00 00       	callq  e98 <record_dir_log+0x138>
     e98:	49 89 c5             	mov    %rax,%r13
    do{
        ppath = strrchr(tem, '/');
     e9b:	be 2f 00 00 00       	mov    $0x2f,%esi
     ea0:	4c 89 e7             	mov    %r12,%rdi
     ea3:	e8 00 00 00 00       	callq  ea8 <record_dir_log+0x148>
        phlen = tlen - strlen(ppath);
     ea8:	48 89 c7             	mov    %rax,%rdi
     eab:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
     eaf:	e8 00 00 00 00       	callq  eb4 <record_dir_log+0x154>
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        strcat(ph, ppath);
     eb4:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi

    memcpy(tem, buf, strlen(buf));
    tlen = strlen(buf);
    do{
        ppath = strrchr(tem, '/');
        phlen = tlen - strlen(ppath);
     eb8:	49 29 c5             	sub    %rax,%r13
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        strcat(ph, ppath);
     ebb:	4c 89 f7             	mov    %r14,%rdi
     ebe:	e8 00 00 00 00       	callq  ec3 <record_dir_log+0x163>
        memcpy(tem, buf, tlen);
     ec3:	48 89 de             	mov    %rbx,%rsi
     ec6:	4c 89 e7             	mov    %r12,%rdi
     ec9:	4c 89 ea             	mov    %r13,%rdx
     ecc:	e8 00 00 00 00       	callq  ed1 <record_dir_log+0x171>
        memcpy(tem+tlen, end, 1);
     ed1:	43 c6 04 2c 00       	movb   $0x0,(%r12,%r13,1)
        if(!strcmp(tem,"/"))
     ed6:	b9 02 00 00 00       	mov    $0x2,%ecx
     edb:	4c 89 e6             	mov    %r12,%rsi
     ede:	4c 89 ff             	mov    %r15,%rdi
     ee1:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
     ee3:	75 b6                	jne    e9b <record_dir_log+0x13b>
            break;
    }while(1);

    BUG_ON(strlen(ph)==1024);
     ee5:	4c 89 f7             	mov    %r14,%rdi
     ee8:	e8 00 00 00 00       	callq  eed <record_dir_log+0x18d>
     eed:	48 3d 00 04 00 00    	cmp    $0x400,%rax
     ef3:	0f 84 4a 04 00 00    	je     1343 <record_dir_log+0x5e3>
    //nova_dbg("%s ful ph is %s",__func__,ph);
    
    mntput(vfsmnt);
     ef9:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
     efd:	e8 00 00 00 00       	callq  f02 <record_dir_log+0x1a2>
    
    kfree(buf);
     f02:	48 89 df             	mov    %rbx,%rdi
     f05:	e8 00 00 00 00       	callq  f0a <record_dir_log+0x1aa>
    kfree(tem);
     f0a:	4c 89 e7             	mov    %r12,%rdi
     f0d:	e8 00 00 00 00       	callq  f12 <record_dir_log+0x1b2>
//debug
	cpu = smp_processor_id();
	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    src_pn = get_dentry_path(src,0);
    phname = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
     f12:	4c 89 f7             	mov    %r14,%rdi
     f15:	e8 00 00 00 00       	callq  f1a <record_dir_log+0x1ba>
     f1a:	48 8d 78 01          	lea    0x1(%rax),%rdi
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
     f1e:	be d0 80 00 00       	mov    $0x80d0,%esi
     f23:	e8 00 00 00 00       	callq  f28 <record_dir_log+0x1c8>
    phn = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
     f28:	4c 89 f7             	mov    %r14,%rdi
     f2b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
     f2f:	e8 00 00 00 00       	callq  f34 <record_dir_log+0x1d4>
     f34:	48 8d 78 01          	lea    0x1(%rax),%rdi
     f38:	be d0 80 00 00       	mov    $0x80d0,%esi
     f3d:	e8 00 00 00 00       	callq  f42 <record_dir_log+0x1e2>
     f42:	48 89 c3             	mov    %rax,%rbx
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
     f45:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
     f49:	4c 89 f7             	mov    %r14,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
     f4c:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
     f53:	4c 8b a8 d8 01 00 00 	mov    0x1d8(%rax),%r13
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
     f5a:	e8 00 00 00 00       	callq  f5f <record_dir_log+0x1ff>
     f5f:	4c 89 f6             	mov    %r14,%rsi
     f62:	48 89 c2             	mov    %rax,%rdx
     f65:	48 89 df             	mov    %rbx,%rdi
     f68:	e8 00 00 00 00       	callq  f6d <record_dir_log+0x20d>
    tlen = strlen(phstr);
     f6d:	4c 89 f7             	mov    %r14,%rdi
     f70:	e8 00 00 00 00       	callq  f75 <record_dir_log+0x215>
     f75:	49 89 c4             	mov    %rax,%r12
    do{
        tem = strrchr(ph, '/');
     f78:	be 2f 00 00 00       	mov    $0x2f,%esi
     f7d:	48 89 df             	mov    %rbx,%rdi
     f80:	e8 00 00 00 00       	callq  f85 <record_dir_log+0x225>
        phlen = tlen -strlen(tem);
     f85:	48 89 c7             	mov    %rax,%rdi
     f88:	e8 00 00 00 00       	callq  f8d <record_dir_log+0x22d>
        tlen = phlen;
        //bug
        if(phlen==0){
     f8d:	49 29 c4             	sub    %rax,%r12
     f90:	0f 84 ff 02 00 00    	je     1295 <record_dir_log+0x535>
            break;
        }
        memcpy(ph,phstr,tlen);
     f96:	4c 89 e2             	mov    %r12,%rdx
     f99:	4c 89 f6             	mov    %r14,%rsi
     f9c:	48 89 df             	mov    %rbx,%rdi
     f9f:	e8 00 00 00 00       	callq  fa4 <record_dir_log+0x244>
	int i;

	for (i = 0; i < length; i++) {
     fa4:	45 85 e4             	test   %r12d,%r12d
        memcpy(ph+tlen, end, 1);
     fa7:	42 c6 04 23 00       	movb   $0x0,(%rbx,%r12,1)
     fac:	0f 8e af 02 00 00    	jle    1261 <record_dir_log+0x501>
     fb2:	41 8d 44 24 ff       	lea    -0x1(%r12),%eax
     fb7:	48 89 da             	mov    %rbx,%rdx
     fba:	31 f6                	xor    %esi,%esi
     fbc:	48 8d 4c 03 01       	lea    0x1(%rbx,%rax,1),%rcx
		hash = hash * seed + (*str++);
     fc1:	48 89 f0             	mov    %rsi,%rax
     fc4:	48 83 c2 01          	add    $0x1,%rdx
     fc8:	48 c1 e0 06          	shl    $0x6,%rax
     fcc:	48 01 f0             	add    %rsi,%rax
     fcf:	48 8d 04 46          	lea    (%rsi,%rax,2),%rax
     fd3:	48 0f be 72 ff       	movsbq -0x1(%rdx),%rsi
     fd8:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     fdb:	48 39 ca             	cmp    %rcx,%rdx
     fde:	75 e1                	jne    fc1 <record_dir_log+0x261>
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
     fe0:	4c 89 ef             	mov    %r13,%rdi
     fe3:	e8 00 00 00 00       	callq  fe8 <record_dir_log+0x288>
        if(dzt_ei){
     fe8:	48 85 c0             	test   %rax,%rax
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
     feb:	49 89 c7             	mov    %rax,%r15
        if(dzt_ei){
     fee:	74 88                	je     f78 <record_dir_log+0x218>
    src_pn = get_dentry_path(src,0);
    phname = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    //memcpy(phname, src_pn, strlen(src_pn));
    src_ei = find_dzt(sb, src_pn, phn);
    phlen = strlen(phn);
     ff0:	48 89 df             	mov    %rbx,%rdi
     ff3:	e8 00 00 00 00       	callq  ff8 <record_dir_log+0x298>
    if(phlen==1){
     ff8:	48 83 f8 01          	cmp    $0x1,%rax
    src_pn = get_dentry_path(src,0);
    phname = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    //memcpy(phname, src_pn, strlen(src_pn));
    src_ei = find_dzt(sb, src_pn, phn);
    phlen = strlen(phn);
     ffc:	49 89 c5             	mov    %rax,%r13
    if(phlen==1){
        flen = strlen(src_pn);
     fff:	4c 89 f7             	mov    %r14,%rdi
    phname = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    //memcpy(phname, src_pn, strlen(src_pn));
    src_ei = find_dzt(sb, src_pn, phn);
    phlen = strlen(phn);
    if(phlen==1){
    1002:	0f 84 e2 02 00 00    	je     12ea <record_dir_log+0x58a>
        flen = strlen(src_pn);
        memcpy(phname, src_pn, flen);
        memcpy(phname+flen, end, 1);
    } else {
        flen = strlen(src_pn)-phlen;
    1008:	e8 00 00 00 00       	callq  100d <record_dir_log+0x2ad>
        memcpy(phname, src_pn+phlen, flen);
    100d:	4b 8d 34 2e          	lea    (%r14,%r13,1),%rsi
    if(phlen==1){
        flen = strlen(src_pn);
        memcpy(phname, src_pn, flen);
        memcpy(phname+flen, end, 1);
    } else {
        flen = strlen(src_pn)-phlen;
    1011:	4c 29 e8             	sub    %r13,%rax
    1014:	49 89 c4             	mov    %rax,%r12
        memcpy(phname, src_pn+phlen, flen);
    1017:	48 89 c2             	mov    %rax,%rdx
    101a:	4c 8b 6d b8          	mov    -0x48(%rbp),%r13
    101e:	4c 89 ef             	mov    %r13,%rdi
    1021:	e8 00 00 00 00       	callq  1026 <record_dir_log+0x2c6>
    1026:	45 85 e4             	test   %r12d,%r12d
        memcpy(phname+flen,end,1);
    1029:	43 c6 44 25 00 00    	movb   $0x0,0x0(%r13,%r12,1)
    102f:	0f 8e 06 03 00 00    	jle    133b <record_dir_log+0x5db>
    1035:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    1039:	41 8d 44 24 ff       	lea    -0x1(%r12),%eax
    103e:	45 31 e4             	xor    %r12d,%r12d
    1041:	48 8d 4c 07 01       	lea    0x1(%rdi,%rax,1),%rcx
    1046:	48 89 f8             	mov    %rdi,%rax
		hash = hash * seed + (*str++);
    1049:	4c 89 e2             	mov    %r12,%rdx
    104c:	48 83 c0 01          	add    $0x1,%rax
    1050:	48 c1 e2 06          	shl    $0x6,%rdx
    1054:	4c 01 e2             	add    %r12,%rdx
    1057:	49 8d 14 54          	lea    (%r12,%rdx,2),%rdx
    105b:	4c 0f be 60 ff       	movsbq -0x1(%rax),%r12
    1060:	49 01 d4             	add    %rdx,%r12
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    1063:	48 39 c8             	cmp    %rcx,%rax
    1066:	75 e1                	jne    1049 <record_dir_log+0x2e9>
    }
    src_hn = BKDRHash(phname, flen);
    sdz_hn = src_ei->hash_name;
    1068:	49 8b 47 30          	mov    0x30(%r15),%rax
    106c:	48 89 45 a8          	mov    %rax,-0x58(%rbp)

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    if(!des) {
    1070:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
    1074:	48 85 c0             	test   %rax,%rax
    1077:	0f 84 5d 02 00 00    	je     12da <record_dir_log+0x57a>
        des_hn = 0;
        des_dz_hn = 0;
    }
    else {
        ph = get_dentry_path(des,0);
    107d:	48 89 c7             	mov    %rax,%rdi
    1080:	e8 7b f0 ff ff       	callq  100 <get_dentry_path.isra.4>
    1085:	49 89 c7             	mov    %rax,%r15
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    1088:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    108c:	4c 89 ff             	mov    %r15,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    108f:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
    1096:	48 8b 80 d8 01 00 00 	mov    0x1d8(%rax),%rax
    109d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    10a1:	e8 00 00 00 00       	callq  10a6 <record_dir_log+0x346>
    10a6:	4c 89 fe             	mov    %r15,%rsi
    10a9:	48 89 c2             	mov    %rax,%rdx
    10ac:	48 89 df             	mov    %rbx,%rdi
    10af:	e8 00 00 00 00       	callq  10b4 <record_dir_log+0x354>
    tlen = strlen(phstr);
    10b4:	4c 89 ff             	mov    %r15,%rdi
    10b7:	e8 00 00 00 00       	callq  10bc <record_dir_log+0x35c>
    10bc:	49 89 c5             	mov    %rax,%r13
    do{
        tem = strrchr(ph, '/');
    10bf:	be 2f 00 00 00       	mov    $0x2f,%esi
    10c4:	48 89 df             	mov    %rbx,%rdi
    10c7:	e8 00 00 00 00       	callq  10cc <record_dir_log+0x36c>
        phlen = tlen -strlen(tem);
    10cc:	48 89 c7             	mov    %rax,%rdi
    10cf:	e8 00 00 00 00       	callq  10d4 <record_dir_log+0x374>
        tlen = phlen;
        //bug
        if(phlen==0){
    10d4:	49 29 c5             	sub    %rax,%r13
    10d7:	0f 84 dd 01 00 00    	je     12ba <record_dir_log+0x55a>
            break;
        }
        memcpy(ph,phstr,tlen);
    10dd:	4c 89 ea             	mov    %r13,%rdx
    10e0:	4c 89 fe             	mov    %r15,%rsi
    10e3:	48 89 df             	mov    %rbx,%rdi
    10e6:	e8 00 00 00 00       	callq  10eb <record_dir_log+0x38b>
    10eb:	45 85 ed             	test   %r13d,%r13d
        memcpy(ph+tlen, end, 1);
    10ee:	42 c6 04 2b 00       	movb   $0x0,(%rbx,%r13,1)
    10f3:	0f 8e 83 01 00 00    	jle    127c <record_dir_log+0x51c>
    10f9:	41 8d 45 ff          	lea    -0x1(%r13),%eax
    10fd:	48 89 da             	mov    %rbx,%rdx
    1100:	31 f6                	xor    %esi,%esi
    1102:	48 8d 4c 03 01       	lea    0x1(%rbx,%rax,1),%rcx
		hash = hash * seed + (*str++);
    1107:	48 89 f0             	mov    %rsi,%rax
    110a:	48 83 c2 01          	add    $0x1,%rdx
    110e:	48 c1 e0 06          	shl    $0x6,%rax
    1112:	48 01 f0             	add    %rsi,%rax
    1115:	48 8d 04 46          	lea    (%rsi,%rax,2),%rax
    1119:	48 0f be 72 ff       	movsbq -0x1(%rdx),%rsi
    111e:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    1121:	48 39 d1             	cmp    %rdx,%rcx
    1124:	75 e1                	jne    1107 <record_dir_log+0x3a7>
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    1126:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    112a:	e8 00 00 00 00       	callq  112f <record_dir_log+0x3cf>
        if(dzt_ei){
    112f:	48 85 c0             	test   %rax,%rax
    1132:	74 8b                	je     10bf <record_dir_log+0x35f>
    }
    else {
        ph = get_dentry_path(des,0);
        //memcpy(phname, ph, strlen(ph)+1);
        dzt_ei = find_dzt(sb, ph, phn);
        des_dz_hn = dzt_ei->hash_name;
    1134:	48 8b 40 30          	mov    0x30(%rax),%rax
        phlen = strlen(phn);
    1138:	48 89 df             	mov    %rbx,%rdi
    }
    else {
        ph = get_dentry_path(des,0);
        //memcpy(phname, ph, strlen(ph)+1);
        dzt_ei = find_dzt(sb, ph, phn);
        des_dz_hn = dzt_ei->hash_name;
    113b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        phlen = strlen(phn);
    113f:	e8 00 00 00 00       	callq  1144 <record_dir_log+0x3e4>
        if(phlen==1){
    1144:	48 83 f8 01          	cmp    $0x1,%rax
    1148:	0f 84 c5 01 00 00    	je     1313 <record_dir_log+0x5b3>
            flen = strlen(ph);
            memcpy(phname, ph, flen);
            memcpy(phname+flen, end, 1);
        } else {
            flen = strlen(ph)-phlen;
    114e:	4c 89 ff             	mov    %r15,%rdi
    1151:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    1155:	e8 00 00 00 00       	callq  115a <record_dir_log+0x3fa>
    115a:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
            memcpy(phname, ph+phlen, flen);
    115e:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
        if(phlen==1){
            flen = strlen(ph);
            memcpy(phname, ph, flen);
            memcpy(phname+flen, end, 1);
        } else {
            flen = strlen(ph)-phlen;
    1162:	48 29 d0             	sub    %rdx,%rax
            memcpy(phname, ph+phlen, flen);
    1165:	49 8d 34 17          	lea    (%r15,%rdx,1),%rsi
    1169:	48 89 c2             	mov    %rax,%rdx
        if(phlen==1){
            flen = strlen(ph);
            memcpy(phname, ph, flen);
            memcpy(phname+flen, end, 1);
        } else {
            flen = strlen(ph)-phlen;
    116c:	49 89 c5             	mov    %rax,%r13
            memcpy(phname, ph+phlen, flen);
    116f:	e8 00 00 00 00       	callq  1174 <record_dir_log+0x414>
            memcpy(phname+flen,end,1);
    1174:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    1178:	42 c6 04 28 00       	movb   $0x0,(%rax,%r13,1)
    117d:	45 85 ed             	test   %r13d,%r13d
    1180:	0f 8e bf 01 00 00    	jle    1345 <record_dir_log+0x5e5>
    1186:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    118a:	41 8d 45 ff          	lea    -0x1(%r13),%eax
    118e:	45 31 ed             	xor    %r13d,%r13d
    1191:	48 8d 74 07 01       	lea    0x1(%rdi,%rax,1),%rsi
    1196:	48 89 f8             	mov    %rdi,%rax
		hash = hash * seed + (*str++);
    1199:	4c 89 e9             	mov    %r13,%rcx
    119c:	48 83 c0 01          	add    $0x1,%rax
    11a0:	48 c1 e1 06          	shl    $0x6,%rcx
    11a4:	4c 01 e9             	add    %r13,%rcx
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    11a7:	48 39 f0             	cmp    %rsi,%rax
		hash = hash * seed + (*str++);
    11aa:	49 8d 54 4d 00       	lea    0x0(%r13,%rcx,2),%rdx
    11af:	48 0f be 48 ff       	movsbq -0x1(%rax),%rcx
    11b4:	4c 8d 2c 11          	lea    (%rcx,%rdx,1),%r13
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    11b8:	75 df                	jne    1199 <record_dir_log+0x439>
        }
        des_hn = BKDRHash(phname, flen);
        kfree(ph);
    11ba:	4c 89 ff             	mov    %r15,%rdi
    11bd:	e8 00 00 00 00       	callq  11c2 <record_dir_log+0x462>
    }

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    dzt_blk = dafs_get_dzt_block(sb);
    11c2:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    11c6:	e8 00 00 00 00       	callq  11cb <record_dir_log+0x46b>
    make_dzt_ptr(sb, &dzt_p);
    11cb:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    11cf:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
        kfree(ph);
    }

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    dzt_blk = dafs_get_dzt_block(sb);
    11d3:	49 89 c7             	mov    %rax,%r15
    make_dzt_ptr(sb, &dzt_p);
    11d6:	e8 00 00 00 00       	callq  11db <record_dir_log+0x47b>
    dlog = (struct direntry_log*)&dzt_blk->dzt_entry[DAFS_DZT_ENTRIES_IN_BLOCK];
    test_and_set_bit_le(bitpos, (void *)dzt_p->bitmap);
    11db:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    11df:	b9 48 00 00 00       	mov    $0x48,%ecx
    11e4:	48 8b 00             	mov    (%rax),%rax
    11e7:	f0 48 0f ab 08       	lock bts %rcx,(%rax)
    11ec:	72 00                	jb     11ee <record_dir_log+0x48e>

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    /*not decided*/
    dlog->type_d = type;
    11ee:	0f b6 45 9c          	movzbl -0x64(%rbp),%eax
    dlog->src_dz_hn = cpu_to_le64(sdz_hn);
    dlog->src_hashname = cpu_to_le64(src_hn);
    dlog->des_dz_hn = cpu_to_le64(des_dz_hn);
    dlog->des_hashname = cpu_to_le64(des_hn);

    kfree(src_pn);
    11f2:	4c 89 f7             	mov    %r14,%rdi
	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    /*not decided*/
    dlog->type_d = type;
    dlog->src_dz_hn = cpu_to_le64(sdz_hn);
    dlog->src_hashname = cpu_to_le64(src_hn);
    11f5:	4d 89 a7 28 10 00 00 	mov    %r12,0x1028(%r15)
    dlog->des_dz_hn = cpu_to_le64(des_dz_hn);
    dlog->des_hashname = cpu_to_le64(des_hn);
    11fc:	4d 89 af 20 10 00 00 	mov    %r13,0x1020(%r15)
    test_and_set_bit_le(bitpos, (void *)dzt_p->bitmap);

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    /*not decided*/
    dlog->type_d = type;
    1203:	41 88 87 08 10 00 00 	mov    %al,0x1008(%r15)
    dlog->src_dz_hn = cpu_to_le64(sdz_hn);
    120a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    120e:	49 89 87 10 10 00 00 	mov    %rax,0x1010(%r15)
    dlog->src_hashname = cpu_to_le64(src_hn);
    dlog->des_dz_hn = cpu_to_le64(des_dz_hn);
    1215:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    1219:	49 89 87 18 10 00 00 	mov    %rax,0x1018(%r15)
    dlog->des_hashname = cpu_to_le64(des_hn);

    kfree(src_pn);
    1220:	e8 00 00 00 00       	callq  1225 <record_dir_log+0x4c5>
    kfree(phname);
    1225:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    1229:	e8 00 00 00 00       	callq  122e <record_dir_log+0x4ce>
    kfree(phn);
    122e:	48 89 df             	mov    %rbx,%rdi
    1231:	e8 00 00 00 00       	callq  1236 <record_dir_log+0x4d6>
    kfree(dzt_p);
    1236:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    123a:	e8 00 00 00 00       	callq  123f <record_dir_log+0x4df>
    //nova_dbg("%s end record log",__func__);
}
    123f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    1243:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    124a:	00 00 
    124c:	0f 85 fb 00 00 00    	jne    134d <record_dir_log+0x5ed>
    1252:	48 83 c4 40          	add    $0x40,%rsp
    1256:	5b                   	pop    %rbx
    1257:	41 5c                	pop    %r12
    1259:	41 5d                	pop    %r13
    125b:	41 5e                	pop    %r14
    125d:	41 5f                	pop    %r15
    125f:	5d                   	pop    %rbp
    1260:	c3                   	retq   

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    1261:	31 f6                	xor    %esi,%esi
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    1263:	4c 89 ef             	mov    %r13,%rdi
    1266:	e8 00 00 00 00       	callq  126b <record_dir_log+0x50b>
        if(dzt_ei){
    126b:	48 85 c0             	test   %rax,%rax
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    126e:	49 89 c7             	mov    %rax,%r15
        if(dzt_ei){
    1271:	0f 84 01 fd ff ff    	je     f78 <record_dir_log+0x218>
    1277:	e9 74 fd ff ff       	jmpq   ff0 <record_dir_log+0x290>
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    127c:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    1280:	31 f6                	xor    %esi,%esi
    1282:	e8 00 00 00 00       	callq  1287 <record_dir_log+0x527>
        if(dzt_ei){
    1287:	48 85 c0             	test   %rax,%rax
    128a:	0f 84 2f fe ff ff    	je     10bf <record_dir_log+0x35f>
    1290:	e9 9f fe ff ff       	jmpq   1134 <record_dir_log+0x3d4>
            goto END;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    1295:	c6 03 2f             	movb   $0x2f,(%rbx)
    memcpy(ph+1,end,1);
    1298:	c6 43 01 00          	movb   $0x0,0x1(%rbx)
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    129c:	be 2f 00 00 00       	mov    $0x2f,%esi
    12a1:	4c 89 ef             	mov    %r13,%rdi
    12a4:	e8 00 00 00 00       	callq  12a9 <record_dir_log+0x549>
    if(!dzt_ei){
    12a9:	48 85 c0             	test   %rax,%rax

    /*root dir*/
    memcpy(ph, "/", 1);
    memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    12ac:	49 89 c7             	mov    %rax,%r15
    if(!dzt_ei){
    12af:	0f 85 3b fd ff ff    	jne    ff0 <record_dir_log+0x290>
    12b5:	e8 00 00 00 00       	callq  12ba <record_dir_log+0x55a>

    /*root dir*/
    memcpy(ph, "/", 1);
    memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    12ba:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
            goto END;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    12be:	c6 03 2f             	movb   $0x2f,(%rbx)
    memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    12c1:	be 2f 00 00 00       	mov    $0x2f,%esi
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    memcpy(ph+1,end,1);
    12c6:	c6 43 01 00          	movb   $0x0,0x1(%rbx)
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    12ca:	e8 00 00 00 00       	callq  12cf <record_dir_log+0x56f>
    if(!dzt_ei){
    12cf:	48 85 c0             	test   %rax,%rax
    12d2:	0f 85 5c fe ff ff    	jne    1134 <record_dir_log+0x3d4>
    12d8:	eb db                	jmp    12b5 <record_dir_log+0x555>
    sdz_hn = src_ei->hash_name;

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    if(!des) {
        des_hn = 0;
    12da:	45 31 ed             	xor    %r13d,%r13d
        des_dz_hn = 0;
    12dd:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    12e4:	00 
    12e5:	e9 d8 fe ff ff       	jmpq   11c2 <record_dir_log+0x462>
    phn = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    //memcpy(phname, src_pn, strlen(src_pn));
    src_ei = find_dzt(sb, src_pn, phn);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(src_pn);
    12ea:	e8 00 00 00 00       	callq  12ef <record_dir_log+0x58f>
        memcpy(phname, src_pn, flen);
    12ef:	4c 89 f6             	mov    %r14,%rsi
    phn = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    //memcpy(phname, src_pn, strlen(src_pn));
    src_ei = find_dzt(sb, src_pn, phn);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(src_pn);
    12f2:	49 89 c4             	mov    %rax,%r12
        memcpy(phname, src_pn, flen);
    12f5:	48 89 c2             	mov    %rax,%rdx
    12f8:	e9 1d fd ff ff       	jmpq   101a <record_dir_log+0x2ba>
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
        strcat(buf,"/");
    12fd:	48 89 df             	mov    %rbx,%rdi
    1300:	e8 00 00 00 00       	callq  1305 <record_dir_log+0x5a5>
    1305:	b9 2f 00 00 00       	mov    $0x2f,%ecx
    130a:	66 89 0c 03          	mov    %cx,(%rbx,%rax,1)
    130e:	e9 29 fb ff ff       	jmpq   e3c <record_dir_log+0xdc>
        //memcpy(phname, ph, strlen(ph)+1);
        dzt_ei = find_dzt(sb, ph, phn);
        des_dz_hn = dzt_ei->hash_name;
        phlen = strlen(phn);
        if(phlen==1){
            flen = strlen(ph);
    1313:	4c 89 ff             	mov    %r15,%rdi
    1316:	e8 00 00 00 00       	callq  131b <record_dir_log+0x5bb>
            memcpy(phname, ph, flen);
    131b:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    131f:	48 89 c2             	mov    %rax,%rdx
    1322:	4c 89 fe             	mov    %r15,%rsi
        //memcpy(phname, ph, strlen(ph)+1);
        dzt_ei = find_dzt(sb, ph, phn);
        des_dz_hn = dzt_ei->hash_name;
        phlen = strlen(phn);
        if(phlen==1){
            flen = strlen(ph);
    1325:	49 89 c5             	mov    %rax,%r13
            memcpy(phname, ph, flen);
    1328:	e8 00 00 00 00       	callq  132d <record_dir_log+0x5cd>
            memcpy(phname+flen, end, 1);
    132d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    1331:	42 c6 04 28 00       	movb   $0x0,(%rax,%r13,1)
    1336:	e9 42 fe ff ff       	jmpq   117d <record_dir_log+0x41d>
    133b:	45 31 e4             	xor    %r12d,%r12d
    133e:	e9 25 fd ff ff       	jmpq   1068 <record_dir_log+0x308>
        memcpy(tem+tlen, end, 1);
        if(!strcmp(tem,"/"))
            break;
    }while(1);

    BUG_ON(strlen(ph)==1024);
    1343:	0f 0b                	ud2    
    1345:	45 31 ed             	xor    %r13d,%r13d
    1348:	e9 6d fe ff ff       	jmpq   11ba <record_dir_log+0x45a>
    kfree(src_pn);
    kfree(phname);
    kfree(phn);
    kfree(dzt_p);
    //nova_dbg("%s end record log",__func__);
}
    134d:	e8 00 00 00 00       	callq  1352 <record_dir_log+0x5f2>
    1352:	0f 1f 40 00          	nopl   0x0(%rax)
    1356:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    135d:	00 00 00 

0000000000001360 <delete_dir_log>:

/*delete dir operation log*/
void delete_dir_log(struct super_block *sb)
{
    1360:	e8 00 00 00 00       	callq  1365 <delete_dir_log+0x5>
    1365:	55                   	push   %rbp
    1366:	48 89 e5             	mov    %rsp,%rbp
    1369:	48 83 ec 10          	sub    $0x10,%rsp
    //struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_ptr *dzt_p;
    u32 bitpos = DAFS_DZT_ENTRIES_IN_BLOCK;

    //nova_dbg("%s start",__func__);
    make_dzt_ptr(sb, &dzt_p);
    136d:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
    //nova_dbg("%s end record log",__func__);
}

/*delete dir operation log*/
void delete_dir_log(struct super_block *sb)
{
    1371:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    1378:	00 00 
    137a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    137e:	31 c0                	xor    %eax,%eax
    //struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_ptr *dzt_p;
    u32 bitpos = DAFS_DZT_ENTRIES_IN_BLOCK;

    //nova_dbg("%s start",__func__);
    make_dzt_ptr(sb, &dzt_p);
    1380:	e8 00 00 00 00       	callq  1385 <delete_dir_log+0x25>
    test_and_clear_bit_le(bitpos, (void *)dzt_p->bitmap);
    1385:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_clear_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "btr", *addr, "Ir", nr, "%0", "c");
    1389:	ba 48 00 00 00       	mov    $0x48,%edx
    138e:	48 8b 00             	mov    (%rax),%rax
    1391:	f0 48 0f b3 10       	lock btr %rdx,(%rax)
    1396:	72 00                	jb     1398 <delete_dir_log+0x38>
    kfree(dzt_p);
    1398:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
    139c:	e8 00 00 00 00       	callq  13a1 <delete_dir_log+0x41>
}
    13a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    13a5:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    13ac:	00 00 
    13ae:	75 02                	jne    13b2 <delete_dir_log+0x52>
    13b0:	c9                   	leaveq 
    13b1:	c3                   	retq   
    13b2:	e8 00 00 00 00       	callq  13b7 <delete_dir_log+0x57>
    13b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    13be:	00 00 

00000000000013c0 <ext_de_name>:
* nameflag = 0 => name
* nameflag = 1==> fulname*/
void ext_de_name(struct super_block *sb, struct dzt_entry_info *ei, struct dafs_zone_entry *ze,\
        struct zone_ptr *p, int cur_pos, int name_len, const char *name, int name_flag)

{
    13c0:	e8 00 00 00 00       	callq  13c5 <ext_de_name+0x5>
    13c5:	55                   	push   %rbp
    13c6:	48 89 e5             	mov    %rsp,%rbp
    13c9:	41 57                	push   %r15
    13cb:	41 56                	push   %r14
    13cd:	41 55                	push   %r13
    13cf:	41 54                	push   %r12
    13d1:	53                   	push   %rbx
    13d2:	48 83 ec 20          	sub    $0x20,%rsp
    //struct dzt_entry_info *ei;
    u64 ext_len;
    u32 bitpos, ext_pos, ext_num;
  
    //nova_dbg("%s start, dentry pos %d",__func__, cur_pos);
    BUG_ON(ze==NULL);
    13d6:	48 85 d2             	test   %rdx,%rdx
* nameflag = 0 => name
* nameflag = 1==> fulname*/
void ext_de_name(struct super_block *sb, struct dzt_entry_info *ei, struct dafs_zone_entry *ze,\
        struct zone_ptr *p, int cur_pos, int name_len, const char *name, int name_flag)

{
    13d9:	4c 8b 7d 10          	mov    0x10(%rbp),%r15
    //struct dzt_entry_info *ei;
    u64 ext_len;
    u32 bitpos, ext_pos, ext_num;
  
    //nova_dbg("%s start, dentry pos %d",__func__, cur_pos);
    BUG_ON(ze==NULL);
    13dd:	0f 84 60 05 00 00    	je     1943 <ext_de_name+0x583>
    13e3:	49 63 d9             	movslq %r9d,%rbx
    de = &ze->dentry[cur_pos];
    BUG_ON(de==NULL);
    //nova_dbg("%s: dentry %s: cur_pos %d", __func__, name, cur_pos);
    cur_pos ++;
    if(name_flag == 0){
    13e6:	44 8b 4d 18          	mov    0x18(%rbp),%r9d
    13ea:	49 89 ce             	mov    %rcx,%r14
    13ed:	49 89 d4             	mov    %rdx,%r12
    13f0:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
    13f4:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
    //nova_dbg("%s start, dentry pos %d",__func__, cur_pos);
    BUG_ON(ze==NULL);
    de = &ze->dentry[cur_pos];
    BUG_ON(de==NULL);
    //nova_dbg("%s: dentry %s: cur_pos %d", __func__, name, cur_pos);
    cur_pos ++;
    13f8:	41 8d 48 01          	lea    0x1(%r8),%ecx
    13fc:	44 89 45 c0          	mov    %r8d,-0x40(%rbp)
    if(name_flag == 0){
    1400:	45 85 c9             	test   %r9d,%r9d
    1403:	0f 85 34 02 00 00    	jne    163d <ext_de_name+0x27d>
        /*judge name len && set dentry name*/
        if(name_len <= LARGE_NAME_LEN){
    1409:	83 fb 70             	cmp    $0x70,%ebx
    140c:	0f 8f a4 00 00 00    	jg     14b6 <ext_de_name+0xf6>
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    1412:	4c 89 f2             	mov    %r14,%rdx
    1415:	e8 00 00 00 00       	callq  141a <ext_de_name+0x5a>
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de->next = de_ext;
    141a:	4c 63 45 c0          	movslq -0x40(%rbp),%r8
        /*judge name len && set dentry name*/
        if(name_len <= LARGE_NAME_LEN){
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
    141e:	89 c2                	mov    %eax,%edx
    1420:	48 81 c2 81 00 00 00 	add    $0x81,%rdx
    1427:	48 c1 e2 07          	shl    $0x7,%rdx
    142b:	4c 01 e2             	add    %r12,%rdx
            de->next = de_ext;
    142e:	49 c1 e0 07          	shl    $0x7,%r8
            memcpy(de_ext->name, name, name_len);
    1432:	48 83 fb 08          	cmp    $0x8,%rbx
    1436:	48 8d 4a 10          	lea    0x10(%rdx),%rcx
        if(name_len <= LARGE_NAME_LEN){
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de->next = de_ext;
    143a:	4b 89 94 04 b0 40 00 	mov    %rdx,0x40b0(%r12,%r8,1)
    1441:	00 
            memcpy(de_ext->name, name, name_len);
    1442:	0f 83 85 04 00 00    	jae    18cd <ext_de_name+0x50d>
    1448:	f6 c3 04             	test   $0x4,%bl
    144b:	0f 85 2e 05 00 00    	jne    197f <ext_de_name+0x5bf>
    1451:	48 85 db             	test   %rbx,%rbx
    1454:	74 11                	je     1467 <ext_de_name+0xa7>
    1456:	41 0f b6 37          	movzbl (%r15),%esi
    145a:	f6 c3 02             	test   $0x2,%bl
    145d:	40 88 72 10          	mov    %sil,0x10(%rdx)
    1461:	0f 85 2c 05 00 00    	jne    1993 <ext_de_name+0x5d3>
            de_ext->name[name_len]='\0';
    1467:	c6 44 1a 10 00       	movb   $0x0,0x10(%rdx,%rbx,1)
            de_ext->ext_pos = cpu_to_le32(ext_pos);
    146c:	89 42 04             	mov    %eax,0x4(%rdx)
	__clear_bit(nr ^ BITOP_LE_SWIZZLE, addr);
}

static inline int test_and_set_bit_le(int nr, void *addr)
{
	return test_and_set_bit(nr ^ BITOP_LE_SWIZZLE, addr);
    146f:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax
            //de_ext->next = NULL;
            bitpos = ext_pos*2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
    1473:	49 8b 0e             	mov    (%r14),%rcx
    1476:	48 98                	cltq   
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    1478:	f0 48 0f ab 01       	lock bts %rax,(%rcx)
    147d:	72 00                	jb     147f <ext_de_name+0xbf>

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
    147f:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # 1485 <ext_de_name+0xc5>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    1485:	89 d6                	mov    %edx,%esi
	if (support_clwb) {
    1487:	31 c9                	xor    %ecx,%ecx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    1489:	83 e6 3f             	and    $0x3f,%esi
    148c:	83 ee 80             	sub    $0xffffff80,%esi
	if (support_clwb) {
    148f:	85 ff                	test   %edi,%edi
    1491:	0f 84 22 04 00 00    	je     18b9 <ext_de_name+0x4f9>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    1497:	89 c8                	mov    %ecx,%eax
    1499:	48 01 d0             	add    %rdx,%rax
    149c:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    14a0:	83 c1 40             	add    $0x40,%ecx
    14a3:	39 ce                	cmp    %ecx,%esi
    14a5:	77 f0                	ja     1497 <ext_de_name+0xd7>
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
        }
    }
    //nova_dbg("%s end",__func__);
}
    14a7:	48 83 c4 20          	add    $0x20,%rsp
    14ab:	5b                   	pop    %rbx
    14ac:	41 5c                	pop    %r12
    14ae:	41 5d                	pop    %r13
    14b0:	41 5e                	pop    %r14
    14b2:	41 5f                	pop    %r15
    14b4:	5d                   	pop    %rbp
    14b5:	c3                   	retq   
            test_and_set_bit_le(bitpos, (void *)p->statemap);
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
        } else {
            //de->ext_flag = 1;
            ext_len = name_len - LARGE_NAME_LEN -1;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    14b6:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    14ba:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
            bitpos = ext_pos*2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
        } else {
            //de->ext_flag = 1;
            ext_len = name_len - LARGE_NAME_LEN -1;
    14be:	83 eb 71             	sub    $0x71,%ebx
    14c1:	48 63 c3             	movslq %ebx,%rax
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    14c4:	4c 89 f2             	mov    %r14,%rdx
            bitpos = ext_pos*2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
        } else {
            //de->ext_flag = 1;
            ext_len = name_len - LARGE_NAME_LEN -1;
    14c7:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    14cb:	e8 00 00 00 00       	callq  14d0 <ext_de_name+0x110>
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
    14d0:	41 89 c0             	mov    %eax,%r8d
            memcpy(de_ext->name, name, LARGE_NAME_LEN+1);
    14d3:	49 8b 0f             	mov    (%r15),%rcx
    14d6:	8d 54 00 01          	lea    0x1(%rax,%rax,1),%edx
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
        } else {
            //de->ext_flag = 1;
            ext_len = name_len - LARGE_NAME_LEN -1;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
    14da:	49 81 c0 81 00 00 00 	add    $0x81,%r8
    14e1:	49 c1 e0 07          	shl    $0x7,%r8
    14e5:	48 63 d2             	movslq %edx,%rdx
    14e8:	4b 8d 1c 04          	lea    (%r12,%r8,1),%rbx
            memcpy(de_ext->name, name, LARGE_NAME_LEN+1);
    14ec:	48 89 4b 10          	mov    %rcx,0x10(%rbx)
    14f0:	49 8b 4f 08          	mov    0x8(%r15),%rcx
    14f4:	48 89 4b 18          	mov    %rcx,0x18(%rbx)
    14f8:	49 8b 4f 10          	mov    0x10(%r15),%rcx
    14fc:	48 89 4b 20          	mov    %rcx,0x20(%rbx)
    1500:	49 8b 4f 18          	mov    0x18(%r15),%rcx
    1504:	48 89 4b 28          	mov    %rcx,0x28(%rbx)
    1508:	49 8b 4f 20          	mov    0x20(%r15),%rcx
    150c:	48 89 4b 30          	mov    %rcx,0x30(%rbx)
    1510:	49 8b 4f 28          	mov    0x28(%r15),%rcx
    1514:	48 89 4b 38          	mov    %rcx,0x38(%rbx)
    1518:	49 8b 4f 30          	mov    0x30(%r15),%rcx
    151c:	48 89 4b 40          	mov    %rcx,0x40(%rbx)
    1520:	49 8b 4f 38          	mov    0x38(%r15),%rcx
    1524:	48 89 4b 48          	mov    %rcx,0x48(%rbx)
    1528:	49 8b 4f 40          	mov    0x40(%r15),%rcx
    152c:	48 89 4b 50          	mov    %rcx,0x50(%rbx)
    1530:	49 8b 4f 48          	mov    0x48(%r15),%rcx
    1534:	48 89 4b 58          	mov    %rcx,0x58(%rbx)
    1538:	49 8b 4f 50          	mov    0x50(%r15),%rcx
    153c:	48 89 4b 60          	mov    %rcx,0x60(%rbx)
    1540:	49 8b 4f 58          	mov    0x58(%r15),%rcx
    1544:	48 89 4b 68          	mov    %rcx,0x68(%rbx)
    1548:	49 8b 4f 60          	mov    0x60(%r15),%rcx
    154c:	48 89 4b 70          	mov    %rcx,0x70(%rbx)
    1550:	49 8b 4f 68          	mov    0x68(%r15),%rcx
    1554:	48 89 4b 78          	mov    %rcx,0x78(%rbx)
    1558:	41 0f b6 4f 70       	movzbl 0x70(%r15),%ecx
            de_ext->ext_pos = cpu_to_le32(ext_pos);
    155d:	89 43 04             	mov    %eax,0x4(%rbx)
        } else {
            //de->ext_flag = 1;
            ext_len = name_len - LARGE_NAME_LEN -1;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            memcpy(de_ext->name, name, LARGE_NAME_LEN+1);
    1560:	88 8b 80 00 00 00    	mov    %cl,0x80(%rbx)
            de_ext->ext_pos = cpu_to_le32(ext_pos);
            bitpos = ext_pos*2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
    1566:	49 8b 0e             	mov    (%r14),%rcx
    1569:	f0 48 0f ab 11       	lock bts %rdx,(%rcx)
    156e:	72 00                	jb     1570 <ext_de_name+0x1b0>

            //de_ext->name[name_len]="/0";
            /*at most 2 extend dentry*/
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
    1570:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    1574:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    1578:	89 c1                	mov    %eax,%ecx
    157a:	4c 89 f2             	mov    %r14,%rdx
    157d:	e8 00 00 00 00       	callq  1582 <ext_de_name+0x1c2>
    1582:	89 c2                	mov    %eax,%edx
            //de_ext->next = cpu_to_le64(ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de_ext->next = tem_ext;
            memcpy(tem_ext->name, name + LARGE_NAME_LEN + 1, ext_len);
    1584:	49 8d 77 71          	lea    0x71(%r15),%rsi
    1588:	4c 8b 7d c0          	mov    -0x40(%rbp),%r15
            bitpos = ext_pos*2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);

            //de_ext->name[name_len]="/0";
            /*at most 2 extend dentry*/
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
    158c:	49 89 d5             	mov    %rdx,%r13
            //de_ext->next = cpu_to_le64(ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
    158f:	48 81 c2 81 00 00 00 	add    $0x81,%rdx
    1596:	48 c1 e2 07          	shl    $0x7,%rdx
    159a:	49 01 d4             	add    %rdx,%r12
            de_ext->next = tem_ext;
            memcpy(tem_ext->name, name + LARGE_NAME_LEN + 1, ext_len);
    159d:	4c 89 fa             	mov    %r15,%rdx
    15a0:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
            //de_ext->name[name_len]="/0";
            /*at most 2 extend dentry*/
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
            //de_ext->next = cpu_to_le64(ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de_ext->next = tem_ext;
    15a5:	4c 89 63 08          	mov    %r12,0x8(%rbx)
            memcpy(tem_ext->name, name + LARGE_NAME_LEN + 1, ext_len);
    15a9:	e8 00 00 00 00       	callq  15ae <ext_de_name+0x1ee>
    15ae:	43 8d 44 2d 01       	lea    0x1(%r13,%r13,1),%eax
            tem_ext->name[ext_len]='\0';
    15b3:	43 c6 44 3c 10 00    	movb   $0x0,0x10(%r12,%r15,1)
            //tem_ext->next = NULL;
            tem_ext->ext_pos = cpu_to_le32(ext_pos);
    15b9:	45 89 6c 24 04       	mov    %r13d,0x4(%r12)
            bitpos = ext_pos *2 +1;
            test_and_set_bit_le(bitpos,(void *)p->statemap);
    15be:	49 8b 16             	mov    (%r14),%rdx
    15c1:	48 98                	cltq   
    15c3:	f0 48 0f ab 02       	lock bts %rax,(%rdx)
    15c8:	72 00                	jb     15ca <ext_de_name+0x20a>

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
    15ca:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 15d0 <ext_de_name+0x210>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    15d0:	89 d9                	mov    %ebx,%ecx
	if (support_clwb) {
    15d2:	31 d2                	xor    %edx,%edx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    15d4:	83 e1 3f             	and    $0x3f,%ecx
    15d7:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    15da:	85 f6                	test   %esi,%esi
    15dc:	74 3a                	je     1618 <ext_de_name+0x258>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    15de:	89 d0                	mov    %edx,%eax
    15e0:	48 01 d8             	add    %rbx,%rax
    15e3:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    15e7:	83 c2 40             	add    $0x40,%edx
    15ea:	39 d1                	cmp    %edx,%ecx
    15ec:	77 f0                	ja     15de <ext_de_name+0x21e>

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
    15ee:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 15f4 <ext_de_name+0x234>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    15f4:	44 89 e1             	mov    %r12d,%ecx
	if (support_clwb) {
    15f7:	31 d2                	xor    %edx,%edx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    15f9:	83 e1 3f             	and    $0x3f,%ecx
    15fc:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    15ff:	85 c0                	test   %eax,%eax
    1601:	74 26                	je     1629 <ext_de_name+0x269>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    1603:	89 d0                	mov    %edx,%eax
    1605:	4c 01 e0             	add    %r12,%rax
    1608:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    160c:	83 c2 40             	add    $0x40,%edx
    160f:	39 d1                	cmp    %edx,%ecx
    1611:	77 f0                	ja     1603 <ext_de_name+0x243>
    1613:	e9 8f fe ff ff       	jmpq   14a7 <ext_de_name+0xe7>
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    1618:	89 d0                	mov    %edx,%eax
    161a:	48 01 d8             	add    %rbx,%rax
    161d:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    1620:	83 c2 40             	add    $0x40,%edx
    1623:	39 d1                	cmp    %edx,%ecx
    1625:	77 f1                	ja     1618 <ext_de_name+0x258>
    1627:	eb c5                	jmp    15ee <ext_de_name+0x22e>
			_mm_clflush(buf + i);
    1629:	89 d0                	mov    %edx,%eax
    162b:	4c 01 e0             	add    %r12,%rax
    162e:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    1631:	83 c2 40             	add    $0x40,%edx
    1634:	39 d1                	cmp    %edx,%ecx
    1636:	77 f1                	ja     1629 <ext_de_name+0x269>
    1638:	e9 6a fe ff ff       	jmpq   14a7 <ext_de_name+0xe7>
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
            nova_flush_buffer(tem_ext, DAFS_DEF_DENTRY_SIZE, 0);
        }
    } else {
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    163d:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    1641:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    1645:	4c 89 f2             	mov    %r14,%rdx
    1648:	e8 00 00 00 00       	callq  164d <ext_de_name+0x28d>
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
        de->ful_name.fn_ext = de_ext;
    164d:	4c 63 45 c0          	movslq -0x40(%rbp),%r8
            test_and_set_bit_le(bitpos,(void *)p->statemap);
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
            nova_flush_buffer(tem_ext, DAFS_DEF_DENTRY_SIZE, 0);
        }
    } else {
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    1651:	41 89 c1             	mov    %eax,%r9d
    1654:	4d 89 ca             	mov    %r9,%r10
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
    1657:	49 81 c1 81 00 00 00 	add    $0x81,%r9
    165e:	49 c1 e1 07          	shl    $0x7,%r9
    1662:	4f 8d 2c 0c          	lea    (%r12,%r9,1),%r13
        de->ful_name.fn_ext = de_ext;
    1666:	49 c1 e0 07          	shl    $0x7,%r8

        if(name_len <= (LARGE_NAME_LEN)){
    166a:	83 fb 70             	cmp    $0x70,%ebx
            nova_flush_buffer(tem_ext, DAFS_DEF_DENTRY_SIZE, 0);
        }
    } else {
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
        de->ful_name.fn_ext = de_ext;
    166d:	4f 89 ac 04 d8 40 00 	mov    %r13,0x40d8(%r12,%r8,1)
    1674:	00 

        if(name_len <= (LARGE_NAME_LEN)){
    1675:	0f 8e 83 02 00 00    	jle    18fe <ext_de_name+0x53e>
            //de_ext->next = NULL;
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
        }else {
            ext_len = 0;
            ext_num = name_len/(LARGE_NAME_LEN);
    167b:	89 d8                	mov    %ebx,%eax
    167d:	ba 93 24 49 92       	mov    $0x92492493,%edx
            //ext_pos = cur_pos;
            if(name_len%(LARGE_NAME_LEN)>ext_num)
    1682:	89 df                	mov    %ebx,%edi
            //de_ext->next = NULL;
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
        }else {
            ext_len = 0;
            ext_num = name_len/(LARGE_NAME_LEN);
    1684:	f7 ea                	imul   %edx
    1686:	89 d8                	mov    %ebx,%eax
    1688:	c1 f8 1f             	sar    $0x1f,%eax
    168b:	01 da                	add    %ebx,%edx
    168d:	c1 fa 06             	sar    $0x6,%edx
    1690:	29 c2                	sub    %eax,%edx
            //ext_pos = cur_pos;
            if(name_len%(LARGE_NAME_LEN)>ext_num)
    1692:	6b c2 70             	imul   $0x70,%edx,%eax
    1695:	29 c7                	sub    %eax,%edi
    1697:	43 8d 44 12 01       	lea    0x1(%r10,%r10,1),%eax
                ext_num++;
    169c:	39 fa                	cmp    %edi,%edx
    169e:	83 d2 00             	adc    $0x0,%edx
    16a1:	48 98                	cltq   
    16a3:	89 55 b8             	mov    %edx,-0x48(%rbp)
            memcpy(de_ext->name, name, LARGE_NAME_LEN+1);
    16a6:	49 8b 17             	mov    (%r15),%rdx
    16a9:	49 89 55 10          	mov    %rdx,0x10(%r13)
    16ad:	49 8b 57 08          	mov    0x8(%r15),%rdx
    16b1:	49 89 55 18          	mov    %rdx,0x18(%r13)
    16b5:	49 8b 57 10          	mov    0x10(%r15),%rdx
    16b9:	49 89 55 20          	mov    %rdx,0x20(%r13)
    16bd:	49 8b 57 18          	mov    0x18(%r15),%rdx
    16c1:	49 89 55 28          	mov    %rdx,0x28(%r13)
    16c5:	49 8b 57 20          	mov    0x20(%r15),%rdx
    16c9:	49 89 55 30          	mov    %rdx,0x30(%r13)
    16cd:	49 8b 57 28          	mov    0x28(%r15),%rdx
    16d1:	49 89 55 38          	mov    %rdx,0x38(%r13)
    16d5:	49 8b 57 30          	mov    0x30(%r15),%rdx
    16d9:	49 89 55 40          	mov    %rdx,0x40(%r13)
    16dd:	49 8b 57 38          	mov    0x38(%r15),%rdx
    16e1:	49 89 55 48          	mov    %rdx,0x48(%r13)
    16e5:	49 8b 57 40          	mov    0x40(%r15),%rdx
    16e9:	49 89 55 50          	mov    %rdx,0x50(%r13)
    16ed:	49 8b 57 48          	mov    0x48(%r15),%rdx
    16f1:	49 89 55 58          	mov    %rdx,0x58(%r13)
    16f5:	49 8b 57 50          	mov    0x50(%r15),%rdx
    16f9:	49 89 55 60          	mov    %rdx,0x60(%r13)
    16fd:	49 8b 57 58          	mov    0x58(%r15),%rdx
    1701:	49 89 55 68          	mov    %rdx,0x68(%r13)
    1705:	49 8b 57 60          	mov    0x60(%r15),%rdx
    1709:	49 89 55 70          	mov    %rdx,0x70(%r13)
    170d:	49 8b 57 68          	mov    0x68(%r15),%rdx
    1711:	49 89 55 78          	mov    %rdx,0x78(%r13)
    1715:	41 0f b6 57 70       	movzbl 0x70(%r15),%edx
            de_ext->ext_pos = cpu_to_le32(ext_pos);
    171a:	45 89 55 04          	mov    %r10d,0x4(%r13)
            ext_len = 0;
            ext_num = name_len/(LARGE_NAME_LEN);
            //ext_pos = cur_pos;
            if(name_len%(LARGE_NAME_LEN)>ext_num)
                ext_num++;
            memcpy(de_ext->name, name, LARGE_NAME_LEN+1);
    171e:	41 88 95 80 00 00 00 	mov    %dl,0x80(%r13)
            de_ext->ext_pos = cpu_to_le32(ext_pos);
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
    1725:	49 8b 16             	mov    (%r14),%rdx
    1728:	f0 48 0f ab 02       	lock bts %rax,(%rdx)
    172d:	72 00                	jb     172f <ext_de_name+0x36f>
            ext_num--;
            ext_len += LARGE_NAME_LEN+1;
            name_len -= LARGE_NAME_LEN+1;
            while(ext_num > 1) {
    172f:	8b 7d b8             	mov    -0x48(%rbp),%edi
            de_ext->ext_pos = cpu_to_le32(ext_pos);
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
            ext_num--;
            ext_len += LARGE_NAME_LEN+1;
            name_len -= LARGE_NAME_LEN+1;
    1732:	8d 43 8f             	lea    -0x71(%rbx),%eax
    1735:	89 45 c0             	mov    %eax,-0x40(%rbp)
            while(ext_num > 1) {
    1738:	89 f8                	mov    %edi,%eax
    173a:	83 e8 01             	sub    $0x1,%eax
    173d:	83 f8 01             	cmp    $0x1,%eax
    1740:	0f 86 2d 02 00 00    	jbe    1973 <ext_de_name+0x5b3>
    1746:	8d 57 fd             	lea    -0x3(%rdi),%edx
    1749:	49 8d 5f 71          	lea    0x71(%r15),%rbx
    174d:	48 89 d1             	mov    %rdx,%rcx
    1750:	48 89 d0             	mov    %rdx,%rax
    1753:	48 c1 e1 04          	shl    $0x4,%rcx
    1757:	48 c1 e0 07          	shl    $0x7,%rax
    175b:	48 29 c8             	sub    %rcx,%rax
    175e:	48 8d b4 02 e2 00 00 	lea    0xe2(%rdx,%rax,1),%rsi
    1765:	00 
    1766:	49 01 f7             	add    %rsi,%r15
                ext_pos =  find_invalid_id(sb, ei, p, ext_pos);
    1769:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    176d:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    1771:	44 89 d1             	mov    %r10d,%ecx
    1774:	4c 89 f2             	mov    %r14,%rdx
    1777:	e8 00 00 00 00       	callq  177c <ext_de_name+0x3bc>
    177c:	41 89 c0             	mov    %eax,%r8d
    177f:	4d 89 c2             	mov    %r8,%r10
                tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
    1782:	49 81 c0 81 00 00 00 	add    $0x81,%r8
    1789:	49 c1 e0 07          	shl    $0x7,%r8
    178d:	43 8d 44 12 01       	lea    0x1(%r10,%r10,1),%eax
    1792:	4d 01 e0             	add    %r12,%r8
                de_ext->next = tem_ext;
    1795:	4d 89 45 08          	mov    %r8,0x8(%r13)
                memcpy(tem_ext->name, name + ext_len, LARGE_NAME_LEN+1);
    1799:	48 8b 13             	mov    (%rbx),%rdx
    179c:	48 98                	cltq   
    179e:	49 89 50 10          	mov    %rdx,0x10(%r8)
    17a2:	48 8b 53 08          	mov    0x8(%rbx),%rdx
    17a6:	49 89 50 18          	mov    %rdx,0x18(%r8)
    17aa:	48 8b 53 10          	mov    0x10(%rbx),%rdx
    17ae:	49 89 50 20          	mov    %rdx,0x20(%r8)
    17b2:	48 8b 53 18          	mov    0x18(%rbx),%rdx
    17b6:	49 89 50 28          	mov    %rdx,0x28(%r8)
    17ba:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    17be:	49 89 50 30          	mov    %rdx,0x30(%r8)
    17c2:	48 8b 53 28          	mov    0x28(%rbx),%rdx
    17c6:	49 89 50 38          	mov    %rdx,0x38(%r8)
    17ca:	48 8b 53 30          	mov    0x30(%rbx),%rdx
    17ce:	49 89 50 40          	mov    %rdx,0x40(%r8)
    17d2:	48 8b 53 38          	mov    0x38(%rbx),%rdx
    17d6:	49 89 50 48          	mov    %rdx,0x48(%r8)
    17da:	48 8b 53 40          	mov    0x40(%rbx),%rdx
    17de:	49 89 50 50          	mov    %rdx,0x50(%r8)
    17e2:	48 8b 53 48          	mov    0x48(%rbx),%rdx
    17e6:	49 89 50 58          	mov    %rdx,0x58(%r8)
    17ea:	48 8b 53 50          	mov    0x50(%rbx),%rdx
    17ee:	49 89 50 60          	mov    %rdx,0x60(%r8)
    17f2:	48 8b 53 58          	mov    0x58(%rbx),%rdx
    17f6:	49 89 50 68          	mov    %rdx,0x68(%r8)
    17fa:	48 8b 53 60          	mov    0x60(%rbx),%rdx
    17fe:	49 89 50 70          	mov    %rdx,0x70(%r8)
    1802:	48 8b 53 68          	mov    0x68(%rbx),%rdx
    1806:	49 89 50 78          	mov    %rdx,0x78(%r8)
    180a:	0f b6 53 70          	movzbl 0x70(%rbx),%edx
                tem_ext->ext_pos = cpu_to_le32(ext_pos);
    180e:	45 89 50 04          	mov    %r10d,0x4(%r8)
            name_len -= LARGE_NAME_LEN+1;
            while(ext_num > 1) {
                ext_pos =  find_invalid_id(sb, ei, p, ext_pos);
                tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
                de_ext->next = tem_ext;
                memcpy(tem_ext->name, name + ext_len, LARGE_NAME_LEN+1);
    1812:	41 88 90 80 00 00 00 	mov    %dl,0x80(%r8)
                tem_ext->ext_pos = cpu_to_le32(ext_pos);
                bitpos = ext_pos *2+1;
                test_and_set_bit_le(bitpos, (void *)p->statemap);
    1819:	49 8b 16             	mov    (%r14),%rdx
    181c:	f0 48 0f ab 02       	lock bts %rax,(%rdx)
    1821:	72 00                	jb     1823 <ext_de_name+0x463>
    1823:	48 83 c3 71          	add    $0x71,%rbx
            ext_num--;
            ext_len += LARGE_NAME_LEN+1;
            name_len -= LARGE_NAME_LEN+1;
            while(ext_num > 1) {
                ext_pos =  find_invalid_id(sb, ei, p, ext_pos);
                tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
    1827:	4d 89 c5             	mov    %r8,%r13
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
            ext_num--;
            ext_len += LARGE_NAME_LEN+1;
            name_len -= LARGE_NAME_LEN+1;
            while(ext_num > 1) {
    182a:	49 39 df             	cmp    %rbx,%r15
    182d:	0f 85 36 ff ff ff    	jne    1769 <ext_de_name+0x3a9>
    1833:	6b 45 b8 8f          	imul   $0xffffff8f,-0x48(%rbp),%eax
    1837:	8b 7d c0             	mov    -0x40(%rbp),%edi
    183a:	8d 84 07 e2 00 00 00 	lea    0xe2(%rdi,%rax,1),%eax
    1841:	89 45 c0             	mov    %eax,-0x40(%rbp)
                de_ext = tem_ext;
                name_len -= LARGE_NAME_LEN+1;
                ext_len += LARGE_NAME_LEN+1;
                ext_num--;
            }
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
    1844:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    1848:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    184c:	44 89 d1             	mov    %r10d,%ecx
    184f:	4c 89 f2             	mov    %r14,%rdx
    1852:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
    1856:	e8 00 00 00 00       	callq  185b <ext_de_name+0x49b>
    185b:	89 c2                	mov    %eax,%edx
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de_ext->next = tem_ext;
            memcpy(tem_ext->name, name+ext_len, name_len);
    185d:	48 63 5d c0          	movslq -0x40(%rbp),%rbx
                ext_len += LARGE_NAME_LEN+1;
                ext_num--;
            }
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de_ext->next = tem_ext;
    1861:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
                de_ext = tem_ext;
                name_len -= LARGE_NAME_LEN+1;
                ext_len += LARGE_NAME_LEN+1;
                ext_num--;
            }
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
    1865:	49 89 d5             	mov    %rdx,%r13
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
    1868:	48 81 c2 81 00 00 00 	add    $0x81,%rdx
            de_ext->next = tem_ext;
            memcpy(tem_ext->name, name+ext_len, name_len);
    186f:	4c 89 fe             	mov    %r15,%rsi
                name_len -= LARGE_NAME_LEN+1;
                ext_len += LARGE_NAME_LEN+1;
                ext_num--;
            }
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
    1872:	48 c1 e2 07          	shl    $0x7,%rdx
    1876:	49 01 d4             	add    %rdx,%r12
            de_ext->next = tem_ext;
            memcpy(tem_ext->name, name+ext_len, name_len);
    1879:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
    187e:	48 89 da             	mov    %rbx,%rdx
                ext_len += LARGE_NAME_LEN+1;
                ext_num--;
            }
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de_ext->next = tem_ext;
    1881:	4d 89 60 08          	mov    %r12,0x8(%r8)
            memcpy(tem_ext->name, name+ext_len, name_len);
    1885:	e8 00 00 00 00       	callq  188a <ext_de_name+0x4ca>
    188a:	43 8d 44 2d 01       	lea    0x1(%r13,%r13,1),%eax
            tem_ext->ext_pos = cpu_to_le32(ext_pos);
    188f:	45 89 6c 24 04       	mov    %r13d,0x4(%r12)
            tem_ext->name[name_len] = '\0';
    1894:	41 c6 44 1c 10 00    	movb   $0x0,0x10(%r12,%rbx,1)
            //tem_ext->next = NULL;
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
    189a:	49 8b 16             	mov    (%r14),%rdx
    189d:	48 98                	cltq   
    189f:	f0 48 0f ab 02       	lock bts %rax,(%rdx)
    18a4:	0f 82 fd fb ff ff    	jb     14a7 <ext_de_name+0xe7>
        }
    }
    //nova_dbg("%s end",__func__);
}
    18aa:	48 83 c4 20          	add    $0x20,%rsp
    18ae:	5b                   	pop    %rbx
    18af:	41 5c                	pop    %r12
    18b1:	41 5d                	pop    %r13
    18b3:	41 5e                	pop    %r14
    18b5:	41 5f                	pop    %r15
    18b7:	5d                   	pop    %rbp
    18b8:	c3                   	retq   
			_mm_clflush(buf + i);
    18b9:	89 c8                	mov    %ecx,%eax
    18bb:	48 01 d0             	add    %rdx,%rax
    18be:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    18c1:	83 c1 40             	add    $0x40,%ecx
    18c4:	39 ce                	cmp    %ecx,%esi
    18c6:	77 f1                	ja     18b9 <ext_de_name+0x4f9>
    18c8:	e9 da fb ff ff       	jmpq   14a7 <ext_de_name+0xe7>
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de->next = de_ext;
            memcpy(de_ext->name, name, name_len);
    18cd:	49 8b 37             	mov    (%r15),%rsi
    18d0:	48 8d 7a 18          	lea    0x18(%rdx),%rdi
    18d4:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    18d8:	48 89 72 10          	mov    %rsi,0x10(%rdx)
    18dc:	49 8b 74 1f f8       	mov    -0x8(%r15,%rbx,1),%rsi
    18e1:	48 89 74 19 f8       	mov    %rsi,-0x8(%rcx,%rbx,1)
    18e6:	48 29 f9             	sub    %rdi,%rcx
    18e9:	4c 89 fe             	mov    %r15,%rsi
    18ec:	48 29 ce             	sub    %rcx,%rsi
    18ef:	48 01 d9             	add    %rbx,%rcx
    18f2:	48 c1 e9 03          	shr    $0x3,%rcx
    18f6:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    18f9:	e9 69 fb ff ff       	jmpq   1467 <ext_de_name+0xa7>
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
        de->ful_name.fn_ext = de_ext;

        if(name_len <= (LARGE_NAME_LEN)){
            memcpy(de_ext->name, name, name_len);
    18fe:	48 83 fb 08          	cmp    $0x8,%rbx
    1902:	49 8d 4d 10          	lea    0x10(%r13),%rcx
    1906:	73 3d                	jae    1945 <ext_de_name+0x585>
    1908:	f6 c3 04             	test   $0x4,%bl
    190b:	0f 85 92 00 00 00    	jne    19a3 <ext_de_name+0x5e3>
    1911:	48 85 db             	test   %rbx,%rbx
    1914:	74 0f                	je     1925 <ext_de_name+0x565>
    1916:	41 0f b6 07          	movzbl (%r15),%eax
    191a:	f6 c3 02             	test   $0x2,%bl
    191d:	88 01                	mov    %al,(%rcx)
    191f:	0f 85 91 00 00 00    	jne    19b6 <ext_de_name+0x5f6>
    1925:	43 8d 44 12 01       	lea    0x1(%r10,%r10,1),%eax
            de_ext->ext_pos = cpu_to_le32(ext_pos);
    192a:	45 89 55 04          	mov    %r10d,0x4(%r13)
            //de_ext->next = NULL;
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
    192e:	49 8b 16             	mov    (%r14),%rdx
    1931:	48 98                	cltq   
    1933:	f0 48 0f ab 02       	lock bts %rax,(%rdx)
    1938:	0f 82 69 fb ff ff    	jb     14a7 <ext_de_name+0xe7>
    193e:	e9 67 ff ff ff       	jmpq   18aa <ext_de_name+0x4ea>
    //struct dzt_entry_info *ei;
    u64 ext_len;
    u32 bitpos, ext_pos, ext_num;
  
    //nova_dbg("%s start, dentry pos %d",__func__, cur_pos);
    BUG_ON(ze==NULL);
    1943:	0f 0b                	ud2    
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
        de->ful_name.fn_ext = de_ext;

        if(name_len <= (LARGE_NAME_LEN)){
            memcpy(de_ext->name, name, name_len);
    1945:	49 8b 07             	mov    (%r15),%rax
    1948:	49 8d 7d 18          	lea    0x18(%r13),%rdi
    194c:	4c 89 fe             	mov    %r15,%rsi
    194f:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    1953:	49 89 45 10          	mov    %rax,0x10(%r13)
    1957:	49 8b 44 1f f8       	mov    -0x8(%r15,%rbx,1),%rax
    195c:	48 89 44 19 f8       	mov    %rax,-0x8(%rcx,%rbx,1)
    1961:	48 29 f9             	sub    %rdi,%rcx
    1964:	48 29 ce             	sub    %rcx,%rsi
    1967:	48 01 d9             	add    %rbx,%rcx
    196a:	48 c1 e9 03          	shr    $0x3,%rcx
    196e:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    1971:	eb b2                	jmp    1925 <ext_de_name+0x565>
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
            nova_flush_buffer(tem_ext, DAFS_DEF_DENTRY_SIZE, 0);
        }
    } else {
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
    1973:	4d 89 e8             	mov    %r13,%r8
    1976:	49 83 c7 71          	add    $0x71,%r15
    197a:	e9 c5 fe ff ff       	jmpq   1844 <ext_de_name+0x484>
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de->next = de_ext;
            memcpy(de_ext->name, name, name_len);
    197f:	41 8b 37             	mov    (%r15),%esi
    1982:	89 72 10             	mov    %esi,0x10(%rdx)
    1985:	41 8b 74 1f fc       	mov    -0x4(%r15,%rbx,1),%esi
    198a:	89 74 19 fc          	mov    %esi,-0x4(%rcx,%rbx,1)
    198e:	e9 d4 fa ff ff       	jmpq   1467 <ext_de_name+0xa7>
    1993:	41 0f b7 74 1f fe    	movzwl -0x2(%r15,%rbx,1),%esi
    1999:	66 89 74 19 fe       	mov    %si,-0x2(%rcx,%rbx,1)
    199e:	e9 c4 fa ff ff       	jmpq   1467 <ext_de_name+0xa7>
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
        de->ful_name.fn_ext = de_ext;

        if(name_len <= (LARGE_NAME_LEN)){
            memcpy(de_ext->name, name, name_len);
    19a3:	41 8b 07             	mov    (%r15),%eax
    19a6:	89 01                	mov    %eax,(%rcx)
    19a8:	41 8b 44 1f fc       	mov    -0x4(%r15,%rbx,1),%eax
    19ad:	89 44 19 fc          	mov    %eax,-0x4(%rcx,%rbx,1)
    19b1:	e9 6f ff ff ff       	jmpq   1925 <ext_de_name+0x565>
    19b6:	41 0f b7 44 1f fe    	movzwl -0x2(%r15,%rbx,1),%eax
    19bc:	66 89 44 19 fe       	mov    %ax,-0x2(%rcx,%rbx,1)
    19c1:	e9 5f ff ff ff       	jmpq   1925 <ext_de_name+0x565>
    19c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    19cd:	00 00 00 

00000000000019d0 <get_ext_name>:
}

/*get ext name
* fulname & name*/
void get_ext_name(struct name_ext *de_ext, char *name)
{
    19d0:	e8 00 00 00 00       	callq  19d5 <get_ext_name+0x5>
    19d5:	55                   	push   %rbp
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    19d6:	ba 70 00 00 00       	mov    $0x70,%edx
    19db:	48 89 e5             	mov    %rsp,%rbp
    19de:	41 57                	push   %r15
    19e0:	41 56                	push   %r14
    19e2:	41 55                	push   %r13
    19e4:	41 54                	push   %r12
    19e6:	49 89 fc             	mov    %rdi,%r12
    19e9:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 19f0 <get_ext_name+0x20>
    19f0:	53                   	push   %rbx
    19f1:	49 89 f6             	mov    %rsi,%r14
    19f4:	be d0 80 00 00       	mov    $0x80d0,%esi
    19f9:	e8 00 00 00 00       	callq  19fe <get_ext_name+0x2e>
    19fe:	49 89 c5             	mov    %rax,%r13
    char *tem = kzalloc(sizeof(char)*LARGE_NAME_LEN, GFP_KERNEL);
    char *end = "";

    tem_ext = de_ext;
    do{
        len =strlen(tem_ext->name);
    1a01:	4d 8d 7c 24 10       	lea    0x10(%r12),%r15
    1a06:	4c 89 ff             	mov    %r15,%rdi
    1a09:	e8 00 00 00 00       	callq  1a0e <get_ext_name+0x3e>
    1a0e:	0f b7 d8             	movzwl %ax,%ebx
        memcpy(tem, tem_ext->name, len);
    1a11:	4c 89 fe             	mov    %r15,%rsi
    1a14:	4c 89 ef             	mov    %r13,%rdi
    1a17:	48 89 da             	mov    %rbx,%rdx
    1a1a:	e8 00 00 00 00       	callq  1a1f <get_ext_name+0x4f>
        memcpy(tem+len, end, 1);
    1a1f:	41 c6 44 1d 00 00    	movb   $0x0,0x0(%r13,%rbx,1)
        strcat(name, tem);
    1a25:	4c 89 ee             	mov    %r13,%rsi
    1a28:	4c 89 f7             	mov    %r14,%rdi
    1a2b:	e8 00 00 00 00       	callq  1a30 <get_ext_name+0x60>
        tem_ext = tem_ext->next; 
    1a30:	4d 8b 64 24 08       	mov    0x8(%r12),%r12
    }while(tem_ext);
    1a35:	4d 85 e4             	test   %r12,%r12
    1a38:	75 c7                	jne    1a01 <get_ext_name+0x31>
    
    strcat(name,"/0");
    1a3a:	4c 89 f7             	mov    %r14,%rdi
    1a3d:	e8 00 00 00 00       	callq  1a42 <get_ext_name+0x72>
    1a42:	49 01 c6             	add    %rax,%r14
    1a45:	b8 2f 30 00 00       	mov    $0x302f,%eax
    kfree(tem);
    1a4a:	4c 89 ef             	mov    %r13,%rdi
        memcpy(tem+len, end, 1);
        strcat(name, tem);
        tem_ext = tem_ext->next; 
    }while(tem_ext);
    
    strcat(name,"/0");
    1a4d:	66 41 89 06          	mov    %ax,(%r14)
    1a51:	41 c6 46 02 00       	movb   $0x0,0x2(%r14)
    kfree(tem);
    1a56:	e8 00 00 00 00       	callq  1a5b <get_ext_name+0x8b>
}
    1a5b:	5b                   	pop    %rbx
    1a5c:	41 5c                	pop    %r12
    1a5e:	41 5d                	pop    %r13
    1a60:	41 5e                	pop    %r14
    1a62:	41 5f                	pop    %r15
    1a64:	5d                   	pop    %rbp
    1a65:	c3                   	retq   
    1a66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1a6d:	00 00 00 

0000000000001a70 <get_de_name>:

/*get dentry name
 * name_type 0 for name, 1 for fulname*/
void get_de_name(struct dafs_dentry *de, struct dafs_zone_entry *ze, char *name, int name_type)
{
    1a70:	e8 00 00 00 00       	callq  1a75 <get_de_name+0x5>
    1a75:	55                   	push   %rbp
    u32 par_pos;

    nlen = de->name_len;
    flen = de->fname_len;

    if(name_type == 0){
    1a76:	85 c9                	test   %ecx,%ecx
}

/*get dentry name
 * name_type 0 for name, 1 for fulname*/
void get_de_name(struct dafs_dentry *de, struct dafs_zone_entry *ze, char *name, int name_type)
{
    1a78:	48 89 e5             	mov    %rsp,%rbp
    1a7b:	41 57                	push   %r15
    1a7d:	41 56                	push   %r14
    1a7f:	41 55                	push   %r13
    1a81:	49 89 d5             	mov    %rdx,%r13
    1a84:	41 54                	push   %r12
    1a86:	53                   	push   %rbx
    1a87:	48 89 fb             	mov    %rdi,%rbx
    u64 flen;
    char *end = "";
    char *tem;
    u32 par_pos;

    nlen = de->name_len;
    1a8a:	0f b6 47 01          	movzbl 0x1(%rdi),%eax
    flen = de->fname_len;

    if(name_type == 0){
    1a8e:	75 41                	jne    1ad1 <get_de_name+0x61>
        if(de->ext_flag==1){
    1a90:	66 83 7f 04 01       	cmpw   $0x1,0x4(%rdi)
    1a95:	0f 84 97 00 00 00    	je     1b32 <get_de_name+0xc2>
            get_ext_name(de->next, name);
        } else {
            memcpy(name, de->name, nlen);
    1a9b:	83 f8 08             	cmp    $0x8,%eax
    1a9e:	48 8d 77 30          	lea    0x30(%rdi),%rsi
    1aa2:	73 5f                	jae    1b03 <get_de_name+0x93>
    1aa4:	a8 04                	test   $0x4,%al
    1aa6:	0f 85 a1 01 00 00    	jne    1c4d <get_de_name+0x1dd>
    1aac:	85 c0                	test   %eax,%eax
    1aae:	74 10                	je     1ac0 <get_de_name+0x50>
    1ab0:	0f b6 57 30          	movzbl 0x30(%rdi),%edx
    1ab4:	a8 02                	test   $0x2,%al
    1ab6:	41 88 55 00          	mov    %dl,0x0(%r13)
    1aba:	0f 85 a4 01 00 00    	jne    1c64 <get_de_name+0x1f4>
                }
            }
        }
    }

}
    1ac0:	5b                   	pop    %rbx
    if(name_type == 0){
        if(de->ext_flag==1){
            get_ext_name(de->next, name);
        } else {
            memcpy(name, de->name, nlen);
            memcpy(name+nlen, end ,1);
    1ac1:	41 c6 44 05 00 00    	movb   $0x0,0x0(%r13,%rax,1)
                }
            }
        }
    }

}
    1ac7:	41 5c                	pop    %r12
    1ac9:	41 5d                	pop    %r13
    1acb:	41 5e                	pop    %r14
    1acd:	41 5f                	pop    %r15
    1acf:	5d                   	pop    %rbp
    1ad0:	c3                   	retq   
        } else {
            memcpy(name, de->name, nlen);
            memcpy(name+nlen, end ,1);
        }
    } else {
        if(de->isr_sf==1){
    1ad1:	80 7f 03 01          	cmpb   $0x1,0x3(%rdi)
    char *end = "";
    char *tem;
    u32 par_pos;

    nlen = de->name_len;
    flen = de->fname_len;
    1ad5:	4c 8b 67 10          	mov    0x10(%rdi),%r12
        } else {
            memcpy(name, de->name, nlen);
            memcpy(name+nlen, end ,1);
        }
    } else {
        if(de->isr_sf==1){
    1ad9:	74 0a                	je     1ae5 <get_de_name+0x75>
                memcpy(name+flen, end, 1);
            } else {
                get_ext_name(de->ful_name.fn_ext, name);
            }
        } else {
            if(de->file_type==NORMAL_FILE){
    1adb:	80 7f 02 00          	cmpb   $0x0,0x2(%rdi)
    1adf:	0f 84 84 00 00 00    	je     1b69 <get_de_name+0xf9>

                strcat(name, "/");
                strcat(name, tem);
                kfree(tem);
            } else {
                if(de->ext_flag == 0){
    1ae5:	66 83 7b 04 00       	cmpw   $0x0,0x4(%rbx)
    1aea:	74 5d                	je     1b49 <get_de_name+0xd9>
        if(de->isr_sf==1){
            if(de->ext_flag==0){
                memcpy(name, de->ful_name.f_name, flen);
                memcpy(name+flen, end, 1);
            } else {
                get_ext_name(de->ful_name.fn_ext, name);
    1aec:	48 8b 7b 58          	mov    0x58(%rbx),%rdi
    1af0:	4c 89 ee             	mov    %r13,%rsi
    1af3:	e8 00 00 00 00       	callq  1af8 <get_de_name+0x88>
                }
            }
        }
    }

}
    1af8:	5b                   	pop    %rbx
    1af9:	41 5c                	pop    %r12
    1afb:	41 5d                	pop    %r13
    1afd:	41 5e                	pop    %r14
    1aff:	41 5f                	pop    %r15
    1b01:	5d                   	pop    %rbp
    1b02:	c3                   	retq   

    if(name_type == 0){
        if(de->ext_flag==1){
            get_ext_name(de->next, name);
        } else {
            memcpy(name, de->name, nlen);
    1b03:	48 8b 57 30          	mov    0x30(%rdi),%rdx
    1b07:	49 8d 7d 08          	lea    0x8(%r13),%rdi
    1b0b:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    1b0f:	49 89 55 00          	mov    %rdx,0x0(%r13)
    1b13:	89 c2                	mov    %eax,%edx
    1b15:	48 8b 4c 16 f8       	mov    -0x8(%rsi,%rdx,1),%rcx
    1b1a:	49 89 4c 15 f8       	mov    %rcx,-0x8(%r13,%rdx,1)
    1b1f:	4c 89 e9             	mov    %r13,%rcx
    1b22:	48 29 f9             	sub    %rdi,%rcx
    1b25:	48 29 ce             	sub    %rcx,%rsi
    1b28:	01 c1                	add    %eax,%ecx
    1b2a:	c1 e9 03             	shr    $0x3,%ecx
    1b2d:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    1b30:	eb 8e                	jmp    1ac0 <get_de_name+0x50>
    nlen = de->name_len;
    flen = de->fname_len;

    if(name_type == 0){
        if(de->ext_flag==1){
            get_ext_name(de->next, name);
    1b32:	48 8b 7f 30          	mov    0x30(%rdi),%rdi
    1b36:	48 89 d6             	mov    %rdx,%rsi
    1b39:	e8 00 00 00 00       	callq  1b3e <get_de_name+0xce>
                }
            }
        }
    }

}
    1b3e:	5b                   	pop    %rbx
    1b3f:	41 5c                	pop    %r12
    1b41:	41 5d                	pop    %r13
    1b43:	41 5e                	pop    %r14
    1b45:	41 5f                	pop    %r15
    1b47:	5d                   	pop    %rbp
    1b48:	c3                   	retq   
                strcat(name, "/");
                strcat(name, tem);
                kfree(tem);
            } else {
                if(de->ext_flag == 0){
                    memcpy(name, de->ful_name.f_name, flen);
    1b49:	48 8d 73 58          	lea    0x58(%rbx),%rsi
    1b4d:	4c 89 e2             	mov    %r12,%rdx
    1b50:	4c 89 ef             	mov    %r13,%rdi
    1b53:	e8 00 00 00 00       	callq  1b58 <get_de_name+0xe8>
                }
            }
        }
    }

}
    1b58:	5b                   	pop    %rbx
                strcat(name, tem);
                kfree(tem);
            } else {
                if(de->ext_flag == 0){
                    memcpy(name, de->ful_name.f_name, flen);
                    memcpy(name+flen, end, 1);
    1b59:	43 c6 44 25 00 00    	movb   $0x0,0x0(%r13,%r12,1)
                }
            }
        }
    }

}
    1b5f:	41 5c                	pop    %r12
    1b61:	41 5d                	pop    %r13
    1b63:	41 5e                	pop    %r14
    1b65:	41 5f                	pop    %r15
    1b67:	5d                   	pop    %rbp
    1b68:	c3                   	retq   
                get_ext_name(de->ful_name.fn_ext, name);
            }
        } else {
            if(de->file_type==NORMAL_FILE){
                /*get name*/
                tem = kzalloc(sizeof(char)*nlen, GFP_KERNEL);
    1b69:	44 0f b6 e0          	movzbl %al,%r12d
    1b6d:	49 89 f6             	mov    %rsi,%r14
    1b70:	4c 89 e7             	mov    %r12,%rdi
    1b73:	e8 78 e5 ff ff       	callq  f0 <kzalloc.constprop.9>
                if(de->ext_flag==1){
    1b78:	66 83 7b 04 01       	cmpw   $0x1,0x4(%rbx)
                get_ext_name(de->ful_name.fn_ext, name);
            }
        } else {
            if(de->file_type==NORMAL_FILE){
                /*get name*/
                tem = kzalloc(sizeof(char)*nlen, GFP_KERNEL);
    1b7d:	49 89 c7             	mov    %rax,%r15
                if(de->ext_flag==1){
    1b80:	0f 84 b6 00 00 00    	je     1c3c <get_de_name+0x1cc>
                    get_ext_name(de->next, tem);
                } else {
                    memcpy(tem, de->name, nlen);
    1b86:	41 83 fc 08          	cmp    $0x8,%r12d
    1b8a:	48 8d 73 30          	lea    0x30(%rbx),%rsi
    1b8e:	73 74                	jae    1c04 <get_de_name+0x194>
    1b90:	41 f6 c4 04          	test   $0x4,%r12b
    1b94:	0f 85 dc 00 00 00    	jne    1c76 <get_de_name+0x206>
    1b9a:	45 85 e4             	test   %r12d,%r12d
    1b9d:	74 11                	je     1bb0 <get_de_name+0x140>
    1b9f:	0f b6 43 30          	movzbl 0x30(%rbx),%eax
    1ba3:	41 f6 c4 02          	test   $0x2,%r12b
    1ba7:	41 88 07             	mov    %al,(%r15)
    1baa:	0f 85 dd 00 00 00    	jne    1c8d <get_de_name+0x21d>
                    memcpy(tem+nlen, end, 1);
    1bb0:	43 c6 04 27 00       	movb   $0x0,(%r15,%r12,1)
                }

                /*get par fulname*/
                par_pos = le32_to_cpu(de->par_pos);
                par_de = &ze->dentry[par_pos];
    1bb5:	8b 7b 0c             	mov    0xc(%rbx),%edi
                get_de_name(par_de, ze, name, 1);
    1bb8:	4c 89 ea             	mov    %r13,%rdx
    1bbb:	b9 01 00 00 00       	mov    $0x1,%ecx
    1bc0:	4c 89 f6             	mov    %r14,%rsi
                    memcpy(tem+nlen, end, 1);
                }

                /*get par fulname*/
                par_pos = le32_to_cpu(de->par_pos);
                par_de = &ze->dentry[par_pos];
    1bc3:	48 81 c7 81 00 00 00 	add    $0x81,%rdi
    1bca:	48 c1 e7 07          	shl    $0x7,%rdi
    1bce:	4c 01 f7             	add    %r14,%rdi
                get_de_name(par_de, ze, name, 1);
    1bd1:	e8 00 00 00 00       	callq  1bd6 <get_de_name+0x166>

                strcat(name, "/");
    1bd6:	4c 89 ef             	mov    %r13,%rdi
    1bd9:	e8 00 00 00 00       	callq  1bde <get_de_name+0x16e>
                strcat(name, tem);
    1bde:	49 8d 7c 05 01       	lea    0x1(%r13,%rax,1),%rdi
    1be3:	4c 89 fe             	mov    %r15,%rsi
                /*get par fulname*/
                par_pos = le32_to_cpu(de->par_pos);
                par_de = &ze->dentry[par_pos];
                get_de_name(par_de, ze, name, 1);

                strcat(name, "/");
    1be6:	41 c6 44 05 00 2f    	movb   $0x2f,0x0(%r13,%rax,1)
                strcat(name, tem);
    1bec:	e8 00 00 00 00       	callq  1bf1 <get_de_name+0x181>
                kfree(tem);
    1bf1:	4c 89 ff             	mov    %r15,%rdi
    1bf4:	e8 00 00 00 00       	callq  1bf9 <get_de_name+0x189>
                }
            }
        }
    }

}
    1bf9:	5b                   	pop    %rbx
    1bfa:	41 5c                	pop    %r12
    1bfc:	41 5d                	pop    %r13
    1bfe:	41 5e                	pop    %r14
    1c00:	41 5f                	pop    %r15
    1c02:	5d                   	pop    %rbp
    1c03:	c3                   	retq   
                /*get name*/
                tem = kzalloc(sizeof(char)*nlen, GFP_KERNEL);
                if(de->ext_flag==1){
                    get_ext_name(de->next, tem);
                } else {
                    memcpy(tem, de->name, nlen);
    1c04:	48 8b 43 30          	mov    0x30(%rbx),%rax
    1c08:	49 8d 7f 08          	lea    0x8(%r15),%rdi
    1c0c:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    1c10:	49 89 07             	mov    %rax,(%r15)
    1c13:	44 89 e0             	mov    %r12d,%eax
    1c16:	48 8b 54 06 f8       	mov    -0x8(%rsi,%rax,1),%rdx
    1c1b:	49 89 54 07 f8       	mov    %rdx,-0x8(%r15,%rax,1)
    1c20:	4c 89 f8             	mov    %r15,%rax
    1c23:	48 29 f8             	sub    %rdi,%rax
    1c26:	41 8d 0c 04          	lea    (%r12,%rax,1),%ecx
    1c2a:	48 29 c6             	sub    %rax,%rsi
    1c2d:	89 c8                	mov    %ecx,%eax
    1c2f:	c1 e8 03             	shr    $0x3,%eax
    1c32:	89 c1                	mov    %eax,%ecx
    1c34:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    1c37:	e9 74 ff ff ff       	jmpq   1bb0 <get_de_name+0x140>
        } else {
            if(de->file_type==NORMAL_FILE){
                /*get name*/
                tem = kzalloc(sizeof(char)*nlen, GFP_KERNEL);
                if(de->ext_flag==1){
                    get_ext_name(de->next, tem);
    1c3c:	48 8b 7b 30          	mov    0x30(%rbx),%rdi
    1c40:	48 89 c6             	mov    %rax,%rsi
    1c43:	e8 00 00 00 00       	callq  1c48 <get_de_name+0x1d8>
    1c48:	e9 68 ff ff ff       	jmpq   1bb5 <get_de_name+0x145>

    if(name_type == 0){
        if(de->ext_flag==1){
            get_ext_name(de->next, name);
        } else {
            memcpy(name, de->name, nlen);
    1c4d:	8b 57 30             	mov    0x30(%rdi),%edx
    1c50:	41 89 55 00          	mov    %edx,0x0(%r13)
    1c54:	89 c2                	mov    %eax,%edx
    1c56:	8b 4c 16 fc          	mov    -0x4(%rsi,%rdx,1),%ecx
    1c5a:	41 89 4c 15 fc       	mov    %ecx,-0x4(%r13,%rdx,1)
    1c5f:	e9 5c fe ff ff       	jmpq   1ac0 <get_de_name+0x50>
    1c64:	89 c2                	mov    %eax,%edx
    1c66:	0f b7 4c 16 fe       	movzwl -0x2(%rsi,%rdx,1),%ecx
    1c6b:	66 41 89 4c 15 fe    	mov    %cx,-0x2(%r13,%rdx,1)
    1c71:	e9 4a fe ff ff       	jmpq   1ac0 <get_de_name+0x50>
                /*get name*/
                tem = kzalloc(sizeof(char)*nlen, GFP_KERNEL);
                if(de->ext_flag==1){
                    get_ext_name(de->next, tem);
                } else {
                    memcpy(tem, de->name, nlen);
    1c76:	8b 43 30             	mov    0x30(%rbx),%eax
    1c79:	41 89 07             	mov    %eax,(%r15)
    1c7c:	44 89 e0             	mov    %r12d,%eax
    1c7f:	8b 54 06 fc          	mov    -0x4(%rsi,%rax,1),%edx
    1c83:	41 89 54 07 fc       	mov    %edx,-0x4(%r15,%rax,1)
    1c88:	e9 23 ff ff ff       	jmpq   1bb0 <get_de_name+0x140>
    1c8d:	44 89 e0             	mov    %r12d,%eax
    1c90:	0f b7 54 06 fe       	movzwl -0x2(%rsi,%rax,1),%edx
    1c95:	66 41 89 54 07 fe    	mov    %dx,-0x2(%r15,%rax,1)
    1c9b:	e9 10 ff ff ff       	jmpq   1bb0 <get_de_name+0x140>

0000000000001ca0 <get_zone_path>:
/*update sub files numbers*/

/*get zone path through root dentry
 * we get charpath when use this function*/
int get_zone_path(struct super_block *sb, struct dzt_entry_info *ei, char *pname, const char *dename)
{
    1ca0:	e8 00 00 00 00       	callq  1ca5 <get_zone_path+0x5>
    1ca5:	55                   	push   %rbp
    1ca6:	48 89 e5             	mov    %rsp,%rbp
    1ca9:	41 57                	push   %r15
    1cab:	41 56                	push   %r14
    1cad:	41 55                	push   %r13
    1caf:	41 54                	push   %r12
    1cb1:	49 89 fd             	mov    %rdi,%r13
    1cb4:	53                   	push   %rbx
    1cb5:	48 83 ec 28          	sub    $0x28,%rsp
    struct dafs_zone_entry *ze;
    struct dafs_dentry *de;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    1cb9:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
/*update sub files numbers*/

/*get zone path through root dentry
 * we get charpath when use this function*/
int get_zone_path(struct super_block *sb, struct dzt_entry_info *ei, char *pname, const char *dename)
{
    1cc0:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
    1cc4:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
    1cc8:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    struct dafs_zone_entry *ze;
    struct dafs_dentry *de;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    1ccc:	48 8b 80 d8 01 00 00 	mov    0x1d8(%rax),%rax
    1cd3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    struct dafs_dzt_block *dzt_blk = dafs_get_dzt_block(sb); 
    1cd7:	e8 00 00 00 00       	callq  1cdc <get_zone_path+0x3c>
    u32 num = ei->dzt_eno;
    1cdc:	4c 8b 55 b8          	mov    -0x48(%rbp),%r10
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    1ce0:	be d0 80 00 00       	mov    $0x80d0,%esi
{
    struct dafs_zone_entry *ze;
    struct dafs_dentry *de;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    struct dafs_dzt_block *dzt_blk = dafs_get_dzt_block(sb); 
    1ce5:	49 89 c6             	mov    %rax,%r14
    u32 de_pos;
    u64 phlen, hashname;
    char *path, *name, *end="";

    //nova_dbg("%s start",__func__);
    phlen = ei->root_len;
    1ce8:	49 8b 5a 28          	mov    0x28(%r10),%rbx
    struct dafs_zone_entry *ze;
    struct dafs_dentry *de;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    struct dafs_dzt_block *dzt_blk = dafs_get_dzt_block(sb); 
    u32 num = ei->dzt_eno;
    1cec:	41 8b 52 08          	mov    0x8(%r10),%edx
    1cf0:	48 89 df             	mov    %rbx,%rdi
    1cf3:	89 55 b4             	mov    %edx,-0x4c(%rbp)
    1cf6:	e8 00 00 00 00       	callq  1cfb <get_zone_path+0x5b>
    1cfb:	48 89 df             	mov    %rbx,%rdi
    1cfe:	be d0 80 00 00       	mov    $0x80d0,%esi
    1d03:	49 89 c4             	mov    %rax,%r12
    1d06:	e8 00 00 00 00       	callq  1d0b <get_zone_path+0x6b>

    //nova_dbg("%s start",__func__);
    phlen = ei->root_len;
    path = kzalloc((sizeof(char )*phlen), GFP_KERNEL);
    name = kzalloc((sizeof(char)*phlen), GFP_KERNEL);
    while(num!=0){
    1d0b:	8b 55 b4             	mov    -0x4c(%rbp),%edx
    1d0e:	48 89 c3             	mov    %rax,%rbx
    1d11:	4c 8b 55 b8          	mov    -0x48(%rbp),%r10
    1d15:	85 d2                	test   %edx,%edx
    1d17:	0f 84 96 00 00 00    	je     1db3 <get_zone_path+0x113>
        ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->pdz_addr);
    1d1d:	49 8b 42 20          	mov    0x20(%r10),%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    1d21:	49 8b 95 b0 03 00 00 	mov    0x3b0(%r13),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    1d28:	41 bf 00 00 00 00    	mov    $0x0,%r15d
        de_pos = ei->rden_pos;
        de = &ze->dentry[de_pos];
    1d2e:	41 8b 7a 0c          	mov    0xc(%r10),%edi
        get_de_name(de, ze, name, 1);
    1d32:	b9 01 00 00 00       	mov    $0x1,%ecx
    1d37:	49 89 c0             	mov    %rax,%r8
    1d3a:	4c 03 42 18          	add    0x18(%rdx),%r8
    1d3e:	48 85 c0             	test   %rax,%rax
    1d41:	48 89 da             	mov    %rbx,%rdx
    1d44:	4d 0f 45 f8          	cmovne %r8,%r15
    path = kzalloc((sizeof(char )*phlen), GFP_KERNEL);
    name = kzalloc((sizeof(char)*phlen), GFP_KERNEL);
    while(num!=0){
        ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->pdz_addr);
        de_pos = ei->rden_pos;
        de = &ze->dentry[de_pos];
    1d48:	48 81 c7 81 00 00 00 	add    $0x81,%rdi
    1d4f:	48 c1 e7 07          	shl    $0x7,%rdi
        get_de_name(de, ze, name, 1);
    1d53:	4c 89 fe             	mov    %r15,%rsi
    path = kzalloc((sizeof(char )*phlen), GFP_KERNEL);
    name = kzalloc((sizeof(char)*phlen), GFP_KERNEL);
    while(num!=0){
        ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->pdz_addr);
        de_pos = ei->rden_pos;
        de = &ze->dentry[de_pos];
    1d56:	4c 01 ff             	add    %r15,%rdi
        get_de_name(de, ze, name, 1);
    1d59:	e8 00 00 00 00       	callq  1d5e <get_zone_path+0xbe>
        strcat(name,path);
    1d5e:	4c 89 e6             	mov    %r12,%rsi
    1d61:	48 89 df             	mov    %rbx,%rdi
    1d64:	e8 00 00 00 00       	callq  1d69 <get_zone_path+0xc9>
        memcpy(path, name, strlen(name)+1);
    1d69:	48 89 df             	mov    %rbx,%rdi
    1d6c:	e8 00 00 00 00       	callq  1d71 <get_zone_path+0xd1>
    1d71:	48 8d 50 01          	lea    0x1(%rax),%rdx
    1d75:	48 89 de             	mov    %rbx,%rsi
    1d78:	4c 89 e7             	mov    %r12,%rdi
    1d7b:	e8 00 00 00 00       	callq  1d80 <get_zone_path+0xe0>
        num = le64_to_cpu(ze->dz_no);
    1d80:	41 8b 87 7c 40 00 00 	mov    0x407c(%r15),%eax
        hashname = le64_to_cpu(dzt_blk->dzt_entry[num].hash_name);
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    1d87:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
        de = &ze->dentry[de_pos];
        get_de_name(de, ze, name, 1);
        strcat(name,path);
        memcpy(path, name, strlen(name)+1);
        num = le64_to_cpu(ze->dz_no);
        hashname = le64_to_cpu(dzt_blk->dzt_entry[num].hash_name);
    1d8b:	48 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%rcx
    1d92:	00 
        de_pos = ei->rden_pos;
        de = &ze->dentry[de_pos];
        get_de_name(de, ze, name, 1);
        strcat(name,path);
        memcpy(path, name, strlen(name)+1);
        num = le64_to_cpu(ze->dz_no);
    1d93:	49 89 c7             	mov    %rax,%r15
        hashname = le64_to_cpu(dzt_blk->dzt_entry[num].hash_name);
    1d96:	48 c1 e0 06          	shl    $0x6,%rax
    1d9a:	48 29 c8             	sub    %rcx,%rax
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    1d9d:	49 8b 74 06 78       	mov    0x78(%r14,%rax,1),%rsi
    1da2:	e8 00 00 00 00       	callq  1da7 <get_zone_path+0x107>

    //nova_dbg("%s start",__func__);
    phlen = ei->root_len;
    path = kzalloc((sizeof(char )*phlen), GFP_KERNEL);
    name = kzalloc((sizeof(char)*phlen), GFP_KERNEL);
    while(num!=0){
    1da7:	45 85 ff             	test   %r15d,%r15d
        get_de_name(de, ze, name, 1);
        strcat(name,path);
        memcpy(path, name, strlen(name)+1);
        num = le64_to_cpu(ze->dz_no);
        hashname = le64_to_cpu(dzt_blk->dzt_entry[num].hash_name);
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    1daa:	49 89 c2             	mov    %rax,%r10

    //nova_dbg("%s start",__func__);
    phlen = ei->root_len;
    path = kzalloc((sizeof(char )*phlen), GFP_KERNEL);
    name = kzalloc((sizeof(char)*phlen), GFP_KERNEL);
    while(num!=0){
    1dad:	0f 85 6a ff ff ff    	jne    1d1d <get_zone_path+0x7d>
        memcpy(path, name, strlen(name)+1);
        num = le64_to_cpu(ze->dz_no);
        hashname = le64_to_cpu(dzt_blk->dzt_entry[num].hash_name);
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    }
    strcat(path, dename);
    1db3:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    1db7:	4c 89 e7             	mov    %r12,%rdi
    1dba:	e8 00 00 00 00       	callq  1dbf <get_zone_path+0x11f>
    memcpy(pname, path, strlen(path));
    1dbf:	4c 89 e7             	mov    %r12,%rdi
    1dc2:	e8 00 00 00 00       	callq  1dc7 <get_zone_path+0x127>
    1dc7:	4c 8b 75 c8          	mov    -0x38(%rbp),%r14
    1dcb:	4c 89 e6             	mov    %r12,%rsi
    1dce:	48 89 c2             	mov    %rax,%rdx
    1dd1:	4c 89 f7             	mov    %r14,%rdi
    1dd4:	e8 00 00 00 00       	callq  1dd9 <get_zone_path+0x139>
    memcpy(pname+strlen(path),end,1);
    1dd9:	4c 89 e7             	mov    %r12,%rdi
    1ddc:	e8 00 00 00 00       	callq  1de1 <get_zone_path+0x141>
    kfree(path);
    1de1:	4c 89 e7             	mov    %r12,%rdi
        hashname = le64_to_cpu(dzt_blk->dzt_entry[num].hash_name);
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    }
    strcat(path, dename);
    memcpy(pname, path, strlen(path));
    memcpy(pname+strlen(path),end,1);
    1de4:	41 c6 04 06 00       	movb   $0x0,(%r14,%rax,1)
    kfree(path);
    1de9:	e8 00 00 00 00       	callq  1dee <get_zone_path+0x14e>
    kfree(name);
    1dee:	48 89 df             	mov    %rbx,%rdi
    1df1:	e8 00 00 00 00       	callq  1df6 <get_zone_path+0x156>
    //nova_dbg("%s end get name %s",__func__,pname);
    return 0;

}
    1df6:	48 83 c4 28          	add    $0x28,%rsp
    1dfa:	31 c0                	xor    %eax,%eax
    1dfc:	5b                   	pop    %rbx
    1dfd:	41 5c                	pop    %r12
    1dff:	41 5d                	pop    %r13
    1e01:	41 5e                	pop    %r14
    1e03:	41 5f                	pop    %r15
    1e05:	5d                   	pop    %rbp
    1e06:	c3                   	retq   
    1e07:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    1e0e:	00 00 

0000000000001e10 <clear_ext>:

}

/*clear ext bit*/
void clear_ext(struct zone_ptr *p, struct name_ext *de_ext)
{
    1e10:	e8 00 00 00 00       	callq  1e15 <clear_ext+0x5>
}

static inline int test_and_clear_bit_le(int nr, void *addr)
{
	return test_and_clear_bit(nr ^ BITOP_LE_SWIZZLE, addr);
    1e15:	8b 46 04             	mov    0x4(%rsi),%eax
    u32 ext_pos, bitpos;
    
    ext_pos = le32_to_cpu(de_ext->ext_pos);
    bitpos = ext_pos*2+1;
    test_and_clear_bit_le(bitpos, (void *)p->statemap);
    1e18:	48 8b 17             	mov    (%rdi),%rdx
    1e1b:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax
    1e1f:	48 98                	cltq   
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_clear_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "btr", *addr, "Ir", nr, "%0", "c");
    1e21:	f0 48 0f b3 02       	lock btr %rax,(%rdx)
    1e26:	72 00                	jb     1e28 <clear_ext+0x18>
    if(de_ext->next)
    1e28:	48 8b 76 08          	mov    0x8(%rsi),%rsi
    1e2c:	48 85 f6             	test   %rsi,%rsi
    1e2f:	74 0a                	je     1e3b <clear_ext+0x2b>

}

/*clear ext bit*/
void clear_ext(struct zone_ptr *p, struct name_ext *de_ext)
{
    1e31:	55                   	push   %rbp
    1e32:	48 89 e5             	mov    %rsp,%rbp
    
    ext_pos = le32_to_cpu(de_ext->ext_pos);
    bitpos = ext_pos*2+1;
    test_and_clear_bit_le(bitpos, (void *)p->statemap);
    if(de_ext->next)
        clear_ext(p, de_ext->next);
    1e35:	e8 00 00 00 00       	callq  1e3a <clear_ext+0x2a>
}
    1e3a:	5d                   	pop    %rbp
    1e3b:	f3 c3                	repz retq 
    1e3d:	0f 1f 00             	nopl   (%rax)

0000000000001e40 <delete_ext>:

/*test and delete ext name entry*/
int delete_ext(struct zone_ptr *p, struct dafs_dentry *de)
{
    1e40:	e8 00 00 00 00       	callq  1e45 <delete_ext+0x5>
    1e45:	55                   	push   %rbp
    1e46:	48 89 e5             	mov    %rsp,%rbp
    1e49:	41 54                	push   %r12
    1e4b:	53                   	push   %rbx
    unsigned short ext_flag;
    //struct name_ext *de_ext;

    //nova_dbg("%s start",__func__);
    ext_flag = le16_to_cpu(de->ext_flag);
    switch(ext_flag) {
    1e4c:	0f b7 46 04          	movzwl 0x4(%rsi),%eax
        clear_ext(p, de_ext->next);
}

/*test and delete ext name entry*/
int delete_ext(struct zone_ptr *p, struct dafs_dentry *de)
{
    1e50:	49 89 fc             	mov    %rdi,%r12
    1e53:	48 89 f3             	mov    %rsi,%rbx
    unsigned short ext_flag;
    //struct name_ext *de_ext;

    //nova_dbg("%s start",__func__);
    ext_flag = le16_to_cpu(de->ext_flag);
    switch(ext_flag) {
    1e56:	66 83 f8 01          	cmp    $0x1,%ax
    1e5a:	74 16                	je     1e72 <delete_ext+0x32>
    1e5c:	66 83 f8 02          	cmp    $0x2,%ax
    1e60:	75 09                	jne    1e6b <delete_ext+0x2b>
    case 1:
        clear_ext(p, de->next);
        clear_ext(p, de->ful_name.fn_ext);
        break;
    case 2:
        clear_ext(p, de->ful_name.fn_ext);
    1e62:	48 8b 76 58          	mov    0x58(%rsi),%rsi
    1e66:	e8 00 00 00 00       	callq  1e6b <delete_ext+0x2b>
        break;
    }
OUT:
    //nova_dbg("%s end",__func__);
    return 0;
}
    1e6b:	5b                   	pop    %rbx
    1e6c:	31 c0                	xor    %eax,%eax
    1e6e:	41 5c                	pop    %r12
    1e70:	5d                   	pop    %rbp
    1e71:	c3                   	retq   
    ext_flag = le16_to_cpu(de->ext_flag);
    switch(ext_flag) {
    case 0:
        goto OUT;
    case 1:
        clear_ext(p, de->next);
    1e72:	48 8b 76 30          	mov    0x30(%rsi),%rsi
    1e76:	e8 00 00 00 00       	callq  1e7b <delete_ext+0x3b>
        clear_ext(p, de->ful_name.fn_ext);
    1e7b:	48 8b 73 58          	mov    0x58(%rbx),%rsi
    1e7f:	4c 89 e7             	mov    %r12,%rdi
    1e82:	e8 00 00 00 00       	callq  1e87 <delete_ext+0x47>
        break;
    }
OUT:
    //nova_dbg("%s end",__func__);
    return 0;
}
    1e87:	5b                   	pop    %rbx
    1e88:	31 c0                	xor    %eax,%eax
    1e8a:	41 5c                	pop    %r12
    1e8c:	5d                   	pop    %rbp
    1e8d:	c3                   	retq   
    1e8e:	66 90                	xchg   %ax,%ax

0000000000001e90 <__remove_direntry>:
}

/**递归删除dentry*/
static int __remove_direntry(struct super_block *sb, struct dafs_dentry *dafs_de,\
        struct dafs_zone_entry *dafs_ze, struct dzt_entry_info *dzt_ei, u32 de_pos)
{
    1e90:	e8 00 00 00 00       	callq  1e95 <__remove_direntry+0x5>
    1e95:	55                   	push   %rbp
    1e96:	48 89 e5             	mov    %rsp,%rbp
    1e99:	41 57                	push   %r15
    1e9b:	41 56                	push   %r14
    1e9d:	41 55                	push   %r13
    1e9f:	41 54                	push   %r12
    1ea1:	49 89 fd             	mov    %rdi,%r13
    1ea4:	53                   	push   %rbx
    1ea5:	49 89 f4             	mov    %rsi,%r12
    1ea8:	48 89 d3             	mov    %rdx,%rbx
    1eab:	49 89 ce             	mov    %rcx,%r14
    1eae:	45 89 c7             	mov    %r8d,%r15d
    1eb1:	48 83 ec 38          	sub    $0x38,%rsp
    1eb5:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    1ebc:	00 00 
    1ebe:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    1ec2:	31 c0                	xor    %eax,%eax
    struct zone_ptr *z_p;
    struct dzt_ptr *dzt_p;
    struct dir_info *old_dir, *par_dir;
    struct list_head *this, *head, *next;
    struct file_p *tem_sf;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    1ec4:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
    //d_hn = BKDRHash(dafs_de->ful_name->f_name,d_hlen);
    //temlen = d_hlen - le64_to_cpu(dafs_de->name_len);
    //nova_dbg("%s start",__func__);
    isr_sf = le64_to_cpu(dafs_de->isr_sf);
    
    if(isr_sf!=1){
    1ecb:	80 7e 03 01          	cmpb   $0x1,0x3(%rsi)
    struct zone_ptr *z_p;
    struct dzt_ptr *dzt_p;
    struct dir_info *old_dir, *par_dir;
    struct list_head *this, *head, *next;
    struct file_p *tem_sf;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    1ecf:	48 8b 80 d8 01 00 00 	mov    0x1d8(%rax),%rax
    1ed6:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    isr_sf = le64_to_cpu(dafs_de->isr_sf);
    
    if(isr_sf!=1){
        par_id = le64_to_cpu(dafs_de->par_pos);
        pde = &dafs_ze->dentry[par_id];
        par_hn = le64_to_cpu(pde->hname);
    1eda:	8b 46 0c             	mov    0xc(%rsi),%eax
    //d_hn = BKDRHash(dafs_de->ful_name->f_name,d_hlen);
    //temlen = d_hlen - le64_to_cpu(dafs_de->name_len);
    //nova_dbg("%s start",__func__);
    isr_sf = le64_to_cpu(dafs_de->isr_sf);
    
    if(isr_sf!=1){
    1edd:	0f 84 f1 00 00 00    	je     1fd4 <__remove_direntry+0x144>
        par_id = le64_to_cpu(dafs_de->par_pos);
        pde = &dafs_ze->dentry[par_id];
        par_hn = le64_to_cpu(pde->hname);
    1ee3:	48 c1 e0 07          	shl    $0x7,%rax

        /*delete pos in its pardir*/
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    1ee7:	48 8d 79 38          	lea    0x38(%rcx),%rdi
    1eeb:	48 8b b4 02 a8 40 00 	mov    0x40a8(%rdx,%rax,1),%rsi
    1ef2:	00 
    1ef3:	e8 00 00 00 00       	callq  1ef8 <__remove_direntry+0x68>
        head = &par_dir->sub_file;
        list_for_each_safe(this, next, head) {
    1ef8:	48 8b 70 18          	mov    0x18(%rax),%rsi
        pde = &dafs_ze->dentry[par_id];
        par_hn = le64_to_cpu(pde->hname);

        /*delete pos in its pardir*/
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
        head = &par_dir->sub_file;
    1efc:	48 8d 48 18          	lea    0x18(%rax),%rcx
        list_for_each_safe(this, next, head) {
    1f00:	48 39 f1             	cmp    %rsi,%rcx
    1f03:	48 8b 3e             	mov    (%rsi),%rdi
    1f06:	74 20                	je     1f28 <__remove_direntry+0x98>
            tem_sf = list_entry(this, struct file_p, list);
            if(tem_sf->pos == de_pos){
    1f08:	44 3b 7e 10          	cmp    0x10(%rsi),%r15d
    1f0c:	75 12                	jne    1f20 <__remove_direntry+0x90>
    1f0e:	e9 18 01 00 00       	jmpq   202b <__remove_direntry+0x19b>
    1f13:	44 39 7f 10          	cmp    %r15d,0x10(%rdi)
    1f17:	0f 84 14 01 00 00    	je     2031 <__remove_direntry+0x1a1>
        par_hn = le64_to_cpu(pde->hname);

        /*delete pos in its pardir*/
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
        head = &par_dir->sub_file;
        list_for_each_safe(this, next, head) {
    1f1d:	48 89 d7             	mov    %rdx,%rdi
    1f20:	48 39 f9             	cmp    %rdi,%rcx
    1f23:	48 8b 17             	mov    (%rdi),%rdx
    1f26:	75 eb                	jne    1f13 <__remove_direntry+0x83>
    }
    head = next = this =NULL;

NEXT:    
    //strcat(tem, dafs_ze->root_path);
    if(dafs_de->file_type == ROOT_DIRECTORY){
    1f28:	41 0f b6 44 24 02    	movzbl 0x2(%r12),%eax
    1f2e:	3c 02                	cmp    $0x2,%al
    1f30:	0f 84 41 01 00 00    	je     2077 <__remove_direntry+0x1e7>
        dafs_free_zone_blocks(sb, ei, ei->dz_addr >> PAGE_SHIFT, 1);
        kfree(pname);
        kfree(ei);
        kfree(z_p);
        kfree(dzt_p);
    }else if(dafs_de->file_type == NORMAL_DIRECTORY){
    1f36:	3c 01                	cmp    $0x1,%al

        /* delete sub files*/
        //nova_dbg("%s remove dir",__func__);
        d_hn = le64_to_cpu(dafs_de->hname);
    1f38:	49 8b 44 24 28       	mov    0x28(%r12),%rax
        dafs_free_zone_blocks(sb, ei, ei->dz_addr >> PAGE_SHIFT, 1);
        kfree(pname);
        kfree(ei);
        kfree(z_p);
        kfree(dzt_p);
    }else if(dafs_de->file_type == NORMAL_DIRECTORY){
    1f3d:	0f 84 98 02 00 00    	je     21db <__remove_direntry+0x34b>
        d_hn = le64_to_cpu(dafs_de->hname);
        
        /*delete dir itself*/
        bitpos = de_pos * 2;
        
        make_zone_ptr(&z_p, dafs_ze);
    1f43:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
    1f47:	48 89 de             	mov    %rbx,%rsi
        if(!ret)
            return -EINVAL;
    
        kfree(z_p);
    }else{
        d_hn = le64_to_cpu(dafs_de->hname);
    1f4a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        
        /*delete dir itself*/
        bitpos = de_pos * 2;
    1f4e:	45 01 ff             	add    %r15d,%r15d
        
        make_zone_ptr(&z_p, dafs_ze);
    1f51:	e8 00 00 00 00       	callq  1f56 <__remove_direntry+0xc6>
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    1f56:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    1f5a:	49 63 d7             	movslq %r15d,%rdx
    1f5d:	48 8b 00             	mov    (%rax),%rax
    1f60:	f0 48 0f b3 10       	lock btr %rdx,(%rax)
    1f65:	72 00                	jb     1f67 <__remove_direntry+0xd7>
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    1f67:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    1f6b:	45 8d 4f 01          	lea    0x1(%r15),%r9d
    1f6f:	4d 63 c9             	movslq %r9d,%r9
    1f72:	48 8b 00             	mov    (%rax),%rax
    1f75:	f0 4c 0f b3 08       	lock btr %r9,(%rax)
    1f7a:	72 00                	jb     1f7c <__remove_direntry+0xec>
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn, 1);
    1f7c:	49 8b 76 18          	mov    0x18(%r14),%rsi
    1f80:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    1f84:	b9 01 00 00 00       	mov    $0x1,%ecx
    1f89:	4c 89 ef             	mov    %r13,%rdi
    1f8c:	e8 00 00 00 00       	callq  1f91 <__remove_direntry+0x101>
        delete_ext(z_p, dafs_de);
    1f91:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
        
        make_zone_ptr(&z_p, dafs_ze);
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn, 1);
    1f95:	89 c3                	mov    %eax,%ebx
        delete_ext(z_p, dafs_de);
    1f97:	4c 89 e6             	mov    %r12,%rsi
    1f9a:	e8 00 00 00 00       	callq  1f9f <__remove_direntry+0x10f>
        /*free rf_entry*/
        //delete_rf_entry(dzt_ei, d_hn);
        if(!ret){
    1f9f:	85 db                	test   %ebx,%ebx
    1fa1:	0f 84 24 03 00 00    	je     22cb <__remove_direntry+0x43b>
            //nova_dbg("%s make invalid fail",__func__);
            return -EINVAL;
        }
        /*delete in par de*/

        kfree(z_p);
    1fa7:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    1fab:	e8 00 00 00 00       	callq  1fb0 <__remove_direntry+0x120>
    }
    //nova_dbg("%s end",__func__);
    return 0;
    1fb0:	31 c0                	xor    %eax,%eax
}
    1fb2:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    1fb6:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    1fbd:	00 00 
    1fbf:	0f 85 18 03 00 00    	jne    22dd <__remove_direntry+0x44d>
    1fc5:	48 83 c4 38          	add    $0x38,%rsp
    1fc9:	5b                   	pop    %rbx
    1fca:	41 5c                	pop    %r12
    1fcc:	41 5d                	pop    %r13
    1fce:	41 5e                	pop    %r14
    1fd0:	41 5f                	pop    %r15
    1fd2:	5d                   	pop    %rbp
    1fd3:	c3                   	retq   
        }
        //kfree(par_name);
    }else{
        par_id = le64_to_cpu(dafs_de->par_pos);
        pde = &dafs_ze->dentry[par_id];
        ino = le64_to_cpu(pde->ino);
    1fd4:	48 c1 e0 07          	shl    $0x7,%rax
    1fd8:	48 01 d0             	add    %rdx,%rax
        if(ino==NOVA_ROOT_INO){
    1fdb:	48 83 b8 98 40 00 00 	cmpq   $0x1,0x4098(%rax)
    1fe2:	01 
    1fe3:	0f 85 3f ff ff ff    	jne    1f28 <__remove_direntry+0x98>
            par_hn = le64_to_cpu(pde->hname);
            par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    1fe9:	48 8b b0 a8 40 00 00 	mov    0x40a8(%rax),%rsi
    1ff0:	48 8d 79 38          	lea    0x38(%rcx),%rdi
    1ff4:	e8 00 00 00 00       	callq  1ff9 <__remove_direntry+0x169>
            head = &par_dir->sub_file;
            list_for_each_safe(this, next, head) {
    1ff9:	48 8b 70 18          	mov    0x18(%rax),%rsi
        pde = &dafs_ze->dentry[par_id];
        ino = le64_to_cpu(pde->ino);
        if(ino==NOVA_ROOT_INO){
            par_hn = le64_to_cpu(pde->hname);
            par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
            head = &par_dir->sub_file;
    1ffd:	48 8d 48 18          	lea    0x18(%rax),%rcx
            list_for_each_safe(this, next, head) {
    2001:	48 39 f1             	cmp    %rsi,%rcx
    2004:	48 8b 3e             	mov    (%rsi),%rdi
    2007:	0f 84 1b ff ff ff    	je     1f28 <__remove_direntry+0x98>
                tem_sf = list_entry(this, struct file_p, list);
                if(tem_sf->pos == de_pos){
    200d:	44 3b 7e 10          	cmp    0x10(%rsi),%r15d
    2011:	75 0b                	jne    201e <__remove_direntry+0x18e>
    2013:	eb 16                	jmp    202b <__remove_direntry+0x19b>
    2015:	44 3b 7f 10          	cmp    0x10(%rdi),%r15d
    2019:	74 16                	je     2031 <__remove_direntry+0x1a1>
        ino = le64_to_cpu(pde->ino);
        if(ino==NOVA_ROOT_INO){
            par_hn = le64_to_cpu(pde->hname);
            par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
            head = &par_dir->sub_file;
            list_for_each_safe(this, next, head) {
    201b:	48 89 d7             	mov    %rdx,%rdi
    201e:	48 39 f9             	cmp    %rdi,%rcx
    2021:	48 8b 17             	mov    (%rdi),%rdx
    2024:	75 ef                	jne    2015 <__remove_direntry+0x185>
    2026:	e9 fd fe ff ff       	jmpq   1f28 <__remove_direntry+0x98>
                tem_sf = list_entry(this, struct file_p, list);
                if(tem_sf->pos == de_pos){
    202b:	48 89 fa             	mov    %rdi,%rdx
    202e:	48 89 f7             	mov    %rsi,%rdi
    2031:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2035:	48 8b 4f 08          	mov    0x8(%rdi),%rcx
	entry->next = LIST_POISON1;
    2039:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
    2040:	00 ad de 
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    2043:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
	prev->next = next;
    2047:	48 89 11             	mov    %rdx,(%rcx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    204a:	48 89 07             	mov    %rax,(%rdi)
	entry->prev = LIST_POISON2;
    204d:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
    2054:	00 ad de 
    2057:	48 89 47 08          	mov    %rax,0x8(%rdi)
                    list_del(&tem_sf->list);
                    kfree(tem_sf);
    205b:	e8 00 00 00 00       	callq  2060 <__remove_direntry+0x1d0>
                    par_dir->sub_num--;
    2060:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    2064:	48 83 68 08 01       	subq   $0x1,0x8(%rax)
    }
    head = next = this =NULL;

NEXT:    
    //strcat(tem, dafs_ze->root_path);
    if(dafs_de->file_type == ROOT_DIRECTORY){
    2069:	41 0f b6 44 24 02    	movzbl 0x2(%r12),%eax
    206f:	3c 02                	cmp    $0x2,%al
    2071:	0f 85 bf fe ff ff    	jne    1f36 <__remove_direntry+0xa6>

        /*delete dir*/
        bitpos = de_pos * 2;

        plen = le64_to_cpu(dafs_de->fname_len);
    2077:	4d 8b 44 24 10       	mov    0x10(%r12),%r8
NEXT:    
    //strcat(tem, dafs_ze->root_path);
    if(dafs_de->file_type == ROOT_DIRECTORY){

        /*delete dir*/
        bitpos = de_pos * 2;
    207c:	43 8d 04 3f          	lea    (%r15,%r15,1),%eax
    2080:	89 45 b0             	mov    %eax,-0x50(%rbp)

        plen = le64_to_cpu(dafs_de->fname_len);
        pname = kzalloc(sizeof(char)*(plen+1), GFP_KERNEL);
    2083:	49 8d 78 01          	lea    0x1(%r8),%rdi
    2087:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
    208b:	e8 60 e0 ff ff       	callq  f0 <kzalloc.constprop.9>
        get_de_name(dafs_de, dafs_ze, pname, 1);
    2090:	b9 01 00 00 00       	mov    $0x1,%ecx
    2095:	48 89 c2             	mov    %rax,%rdx
    2098:	48 89 de             	mov    %rbx,%rsi
    209b:	4c 89 e7             	mov    %r12,%rdi

        /*delete dir*/
        bitpos = de_pos * 2;

        plen = le64_to_cpu(dafs_de->fname_len);
        pname = kzalloc(sizeof(char)*(plen+1), GFP_KERNEL);
    209e:	49 89 c7             	mov    %rax,%r15
        get_de_name(dafs_de, dafs_ze, pname, 1);
    20a1:	e8 00 00 00 00       	callq  20a6 <__remove_direntry+0x216>
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    20a6:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
    20aa:	45 85 c0             	test   %r8d,%r8d
    20ad:	0f 8e 22 02 00 00    	jle    22d5 <__remove_direntry+0x445>
    20b3:	41 8d 40 ff          	lea    -0x1(%r8),%eax
    20b7:	45 31 c0             	xor    %r8d,%r8d
    20ba:	49 8d 4c 07 01       	lea    0x1(%r15,%rax,1),%rcx
    20bf:	4c 89 f8             	mov    %r15,%rax
		hash = hash * seed + (*str++);
    20c2:	4c 89 c2             	mov    %r8,%rdx
    20c5:	48 83 c0 01          	add    $0x1,%rax
    20c9:	48 c1 e2 06          	shl    $0x6,%rdx
    20cd:	4c 01 c2             	add    %r8,%rdx
    20d0:	49 8d 14 50          	lea    (%r8,%rdx,2),%rdx
    20d4:	4c 0f be 40 ff       	movsbq -0x1(%rax),%r8
    20d9:	49 01 d0             	add    %rdx,%r8
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    20dc:	48 39 c1             	cmp    %rax,%rcx
    20df:	75 e1                	jne    20c2 <__remove_direntry+0x232>
        d_hn = BKDRHash(pname, plen);
        
        make_zone_ptr(&z_p, dafs_ze);
    20e1:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
    20e5:	48 89 de             	mov    %rbx,%rsi
    20e8:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
    20ec:	e8 00 00 00 00       	callq  20f1 <__remove_direntry+0x261>
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    20f1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    20f5:	48 63 55 b0          	movslq -0x50(%rbp),%rdx
    20f9:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
    20fd:	48 8b 00             	mov    (%rax),%rax
    2100:	f0 48 0f b3 10       	lock btr %rdx,(%rax)
    2105:	72 00                	jb     2107 <__remove_direntry+0x277>
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    2107:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    210b:	48 8b 10             	mov    (%rax),%rdx
    210e:	8b 45 b0             	mov    -0x50(%rbp),%eax
    2111:	83 c0 01             	add    $0x1,%eax
    2114:	48 98                	cltq   
    2116:	f0 48 0f b3 02       	lock btr %rax,(%rdx)
    211b:	72 00                	jb     211d <__remove_direntry+0x28d>
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn,  1);
    211d:	49 8b 76 18          	mov    0x18(%r14),%rsi
    2121:	4c 89 c2             	mov    %r8,%rdx
    2124:	b9 01 00 00 00       	mov    $0x1,%ecx
    2129:	4c 89 ef             	mov    %r13,%rdi
    212c:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
    2130:	e8 00 00 00 00       	callq  2135 <__remove_direntry+0x2a5>
        delete_ext(z_p, dafs_de);
    2135:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    2139:	4c 89 e6             	mov    %r12,%rsi
        
        make_zone_ptr(&z_p, dafs_ze);
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn,  1);
    213c:	89 c3                	mov    %eax,%ebx
        delete_ext(z_p, dafs_de);
    213e:	e8 00 00 00 00       	callq  2143 <__remove_direntry+0x2b3>
        /*free dir_entry*/
        delete_dir_info(dzt_ei, d_hn);
    2143:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
    2147:	4c 89 f7             	mov    %r14,%rdi
    214a:	4c 89 c6             	mov    %r8,%rsi
    214d:	e8 00 00 00 00       	callq  2152 <__remove_direntry+0x2c2>
        
        if(!ret)
    2152:	85 db                	test   %ebx,%ebx
    2154:	0f 84 71 01 00 00    	je     22cb <__remove_direntry+0x43b>
         * ei free zone
         * free hash table
         * free zone
         * free ei*/
        hashname = le64_to_cpu(dafs_de->dzt_hn);
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    215a:	49 8b 74 24 28       	mov    0x28(%r12),%rsi
    215f:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    2163:	e8 00 00 00 00       	callq  2168 <__remove_direntry+0x2d8>
        dzt_rno = ei->dzt_eno;
        tail = le64_to_cpu(ei->ht_head);
        free_htable(sb, tail, 1);
    2168:	48 8b 70 18          	mov    0x18(%rax),%rsi
    216c:	ba 01 00 00 00       	mov    $0x1,%edx
    2171:	4c 89 ef             	mov    %r13,%rdi
         * ei free zone
         * free hash table
         * free zone
         * free ei*/
        hashname = le64_to_cpu(dafs_de->dzt_hn);
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    2174:	48 89 c3             	mov    %rax,%rbx
        dzt_rno = ei->dzt_eno;
    2177:	4c 63 60 08          	movslq 0x8(%rax),%r12
        tail = le64_to_cpu(ei->ht_head);
        free_htable(sb, tail, 1);
    217b:	e8 00 00 00 00       	callq  2180 <__remove_direntry+0x2f0>
        make_dzt_ptr(sb, &dzt_p);
    2180:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
    2184:	4c 89 ef             	mov    %r13,%rdi
    2187:	e8 00 00 00 00       	callq  218c <__remove_direntry+0x2fc>
        test_and_clear_bit_le(dzt_rno, (void *)dzt_p->bitmap);
    218c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    2190:	48 8b 00             	mov    (%rax),%rax
    2193:	f0 4c 0f b3 20       	lock btr %r12,(%rax)
    2198:	72 00                	jb     219a <__remove_direntry+0x30a>
        //delete_rf_tree(ei);
        dafs_free_zone_blocks(sb, ei, ei->dz_addr >> PAGE_SHIFT, 1);
    219a:	48 8b 53 10          	mov    0x10(%rbx),%rdx
    219e:	b9 01 00 00 00       	mov    $0x1,%ecx
    21a3:	48 89 de             	mov    %rbx,%rsi
    21a6:	4c 89 ef             	mov    %r13,%rdi
    21a9:	48 c1 ea 0c          	shr    $0xc,%rdx
    21ad:	e8 00 00 00 00       	callq  21b2 <__remove_direntry+0x322>
        kfree(pname);
    21b2:	4c 89 ff             	mov    %r15,%rdi
    21b5:	e8 00 00 00 00       	callq  21ba <__remove_direntry+0x32a>
        kfree(ei);
    21ba:	48 89 df             	mov    %rbx,%rdi
    21bd:	e8 00 00 00 00       	callq  21c2 <__remove_direntry+0x332>
        kfree(z_p);
    21c2:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    21c6:	e8 00 00 00 00       	callq  21cb <__remove_direntry+0x33b>
        kfree(dzt_p);
    21cb:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    21cf:	e8 00 00 00 00       	callq  21d4 <__remove_direntry+0x344>
        /*delete in par de*/

        kfree(z_p);
    }
    //nova_dbg("%s end",__func__);
    return 0;
    21d4:	31 c0                	xor    %eax,%eax
    21d6:	e9 d7 fd ff ff       	jmpq   1fb2 <__remove_direntry+0x122>
    }else if(dafs_de->file_type == NORMAL_DIRECTORY){

        /* delete sub files*/
        //nova_dbg("%s remove dir",__func__);
        d_hn = le64_to_cpu(dafs_de->hname);
        old_dir = radix_tree_lookup(&dzt_ei->dir_tree, d_hn);
    21db:	49 8d 4e 38          	lea    0x38(%r14),%rcx
    21df:	48 89 c6             	mov    %rax,%rsi
        kfree(dzt_p);
    }else if(dafs_de->file_type == NORMAL_DIRECTORY){

        /* delete sub files*/
        //nova_dbg("%s remove dir",__func__);
        d_hn = le64_to_cpu(dafs_de->hname);
    21e2:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
        old_dir = radix_tree_lookup(&dzt_ei->dir_tree, d_hn);
    21e6:	48 89 cf             	mov    %rcx,%rdi
    21e9:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    21ed:	e8 00 00 00 00       	callq  21f2 <__remove_direntry+0x362>
        if(!old_dir){
    21f2:	48 85 c0             	test   %rax,%rax
    21f5:	0f 84 d0 00 00 00    	je     22cb <__remove_direntry+0x43b>
            //nova_dbg("%s not find dir_info",__func__);
            return -EINVAL;
        }
        head = &old_dir->sub_file;
    21fb:	48 8d 48 18          	lea    0x18(%rax),%rcx
        list_for_each_safe(this, next, head) {
    21ff:	48 8b 40 18          	mov    0x18(%rax),%rax
        old_dir = radix_tree_lookup(&dzt_ei->dir_tree, d_hn);
        if(!old_dir){
            //nova_dbg("%s not find dir_info",__func__);
            return -EINVAL;
        }
        head = &old_dir->sub_file;
    2203:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
        list_for_each_safe(this, next, head) {
    2207:	48 39 c1             	cmp    %rax,%rcx
    220a:	4c 8b 10             	mov    (%rax),%r10
    220d:	75 05                	jne    2214 <__remove_direntry+0x384>
    220f:	eb 39                	jmp    224a <__remove_direntry+0x3ba>
    2211:	49 89 d2             	mov    %rdx,%r10
            tem_sf = list_entry(this, struct file_p, list);
            sub_id = tem_sf->pos;
    2214:	8b 70 10             	mov    0x10(%rax),%esi
            sde= &dafs_ze->dentry[sub_id];
            //nova_dbg("%s start to delete de %s",__func__, sde->name);
            ret = __remove_direntry(sb, sde, dafs_ze, dzt_ei, sub_id);
    2217:	48 89 da             	mov    %rbx,%rdx
    221a:	4c 89 f1             	mov    %r14,%rcx
    221d:	4c 89 ef             	mov    %r13,%rdi
    2220:	4c 89 55 b8          	mov    %r10,-0x48(%rbp)
            return -EINVAL;
        }
        head = &old_dir->sub_file;
        list_for_each_safe(this, next, head) {
            tem_sf = list_entry(this, struct file_p, list);
            sub_id = tem_sf->pos;
    2224:	49 89 f0             	mov    %rsi,%r8
            sde= &dafs_ze->dentry[sub_id];
    2227:	48 81 c6 81 00 00 00 	add    $0x81,%rsi
    222e:	48 c1 e6 07          	shl    $0x7,%rsi
    2232:	48 01 de             	add    %rbx,%rsi
            //nova_dbg("%s start to delete de %s",__func__, sde->name);
            ret = __remove_direntry(sb, sde, dafs_ze, dzt_ei, sub_id);
    2235:	e8 56 fc ff ff       	callq  1e90 <__remove_direntry>
        if(!old_dir){
            //nova_dbg("%s not find dir_info",__func__);
            return -EINVAL;
        }
        head = &old_dir->sub_file;
        list_for_each_safe(this, next, head) {
    223a:	4c 8b 55 b8          	mov    -0x48(%rbp),%r10
    223e:	4c 39 55 b0          	cmp    %r10,-0x50(%rbp)
    2242:	49 8b 12             	mov    (%r10),%rdx
    2245:	4c 89 d0             	mov    %r10,%rax
    2248:	75 c7                	jne    2211 <__remove_direntry+0x381>
        }

        /*delete dir itself*/
        bitpos = de_pos * 2;
        
        make_zone_ptr(&z_p, dafs_ze);
    224a:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
    224e:	48 89 de             	mov    %rbx,%rsi
            //old_dir->sub_num--;
            //kfree(tem_sf);
        }

        /*delete dir itself*/
        bitpos = de_pos * 2;
    2251:	45 01 ff             	add    %r15d,%r15d
        
        make_zone_ptr(&z_p, dafs_ze);
    2254:	e8 00 00 00 00       	callq  2259 <__remove_direntry+0x3c9>
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    2259:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    225d:	49 63 d7             	movslq %r15d,%rdx
    2260:	48 8b 00             	mov    (%rax),%rax
    2263:	f0 48 0f b3 10       	lock btr %rdx,(%rax)
    2268:	72 00                	jb     226a <__remove_direntry+0x3da>
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    226a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    226e:	45 8d 4f 01          	lea    0x1(%r15),%r9d
    2272:	4d 63 c9             	movslq %r9d,%r9
    2275:	48 8b 00             	mov    (%rax),%rax
    2278:	f0 4c 0f b3 08       	lock btr %r9,(%rax)
    227d:	72 00                	jb     227f <__remove_direntry+0x3ef>
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn, 1);
    227f:	49 8b 76 18          	mov    0x18(%r14),%rsi
    2283:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
    2287:	b9 01 00 00 00       	mov    $0x1,%ecx
    228c:	4c 89 ef             	mov    %r13,%rdi
    228f:	e8 00 00 00 00       	callq  2294 <__remove_direntry+0x404>
        delete_ext(z_p, dafs_de);
    2294:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
        
        make_zone_ptr(&z_p, dafs_ze);
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn, 1);
    2298:	89 c3                	mov    %eax,%ebx
        delete_ext(z_p, dafs_de);
    229a:	4c 89 e6             	mov    %r12,%rsi
    229d:	e8 00 00 00 00       	callq  22a2 <__remove_direntry+0x412>

        if(!ret)
    22a2:	85 db                	test   %ebx,%ebx
    22a4:	74 25                	je     22cb <__remove_direntry+0x43b>
            return -EINVAL;
        
        /*free dir_info_entry*/
        old_dir = radix_tree_lookup(&dzt_ei->dir_tree, d_hn);
    22a6:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    22aa:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    22ae:	e8 00 00 00 00       	callq  22b3 <__remove_direntry+0x423>
        kfree(old_dir);
    22b3:	48 89 c7             	mov    %rax,%rdi
    22b6:	e8 00 00 00 00       	callq  22bb <__remove_direntry+0x42b>

        if(!ret)
            return -EINVAL;
    
        kfree(z_p);
    22bb:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    22bf:	e8 00 00 00 00       	callq  22c4 <__remove_direntry+0x434>
        /*delete in par de*/

        kfree(z_p);
    }
    //nova_dbg("%s end",__func__);
    return 0;
    22c4:	31 c0                	xor    %eax,%eax
    22c6:	e9 e7 fc ff ff       	jmpq   1fb2 <__remove_direntry+0x122>
        delete_ext(z_p, dafs_de);
        /*free dir_entry*/
        delete_dir_info(dzt_ei, d_hn);
        
        if(!ret)
            return -EINVAL;
    22cb:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    22d0:	e9 dd fc ff ff       	jmpq   1fb2 <__remove_direntry+0x122>

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    22d5:	45 31 c0             	xor    %r8d,%r8d
    22d8:	e9 04 fe ff ff       	jmpq   20e1 <__remove_direntry+0x251>

        kfree(z_p);
    }
    //nova_dbg("%s end",__func__);
    return 0;
}
    22dd:	e8 00 00 00 00       	callq  22e2 <__remove_direntry+0x452>
    22e2:	0f 1f 40 00          	nopl   0x0(%rax)
    22e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    22ed:	00 00 00 

00000000000022f0 <dafs_add_dentry>:
}

/*dafs add dentry in the zone
* and initialize direntry without name*/
int dafs_add_dentry(struct dentry *dentry, u64 ino, int link_change, int file_type)
{
    22f0:	e8 00 00 00 00       	callq  22f5 <dafs_add_dentry+0x5>
    22f5:	55                   	push   %rbp
    22f6:	49 89 f1             	mov    %rsi,%r9
    22f9:	41 89 d0             	mov    %edx,%r8d
    22fc:	48 89 e5             	mov    %rsp,%rbp
    22ff:	41 57                	push   %r15
    2301:	41 56                	push   %r14
    2303:	41 55                	push   %r13
    2305:	41 54                	push   %r12
    2307:	41 89 cf             	mov    %ecx,%r15d
    230a:	53                   	push   %rbx
    230b:	48 89 fb             	mov    %rdi,%rbx
    230e:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
    struct nova_inode *pidir;
    unsigned short  namelen = dentry->d_name.len;
    2315:	44 8b 77 24          	mov    0x24(%rdi),%r14d
}

/*dafs add dentry in the zone
* and initialize direntry without name*/
int dafs_add_dentry(struct dentry *dentry, u64 ino, int link_change, int file_type)
{
    2319:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    2320:	00 00 
    2322:	48 89 84 24 a0 00 00 	mov    %rax,0xa0(%rsp)
    2329:	00 
    232a:	31 c0                	xor    %eax,%eax
    struct inode *dir = dentry->d_parent->d_inode;
    232c:	48 8b 47 18          	mov    0x18(%rdi),%rax
    2330:	4c 8b 60 30          	mov    0x30(%rax),%r12
    
	/*nova_dbg_verbose("%s: dir %lu new inode %llu\n",
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
    2334:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 233a <dafs_add_dentry+0x4a>
    233a:	85 c0                	test   %eax,%eax
/*dafs add dentry in the zone
* and initialize direntry without name*/
int dafs_add_dentry(struct dentry *dentry, u64 ino, int link_change, int file_type)
{
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
    233c:	4d 8b 6c 24 28       	mov    0x28(%r12),%r13
    
	/*nova_dbg_verbose("%s: dir %lu new inode %llu\n",
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
    2341:	75 30                	jne    2373 <dafs_add_dentry+0x83>
	if (namelen == 0)
    2343:	66 45 85 f6          	test   %r14w,%r14w
    2347:	75 51                	jne    239a <dafs_add_dentry+0xaa>
		return -EINVAL;
    2349:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    kfree(phn);
    kfree(zone_p);
    //nova_dbg("%s: finish, ino %llu, parent name %s",
    //     __func__, dafs_de->ino, dentry->d_parent->d_name.name);
    return ret;
}
    234e:	48 8b b4 24 a0 00 00 	mov    0xa0(%rsp),%rsi
    2355:	00 
    2356:	65 48 33 34 25 28 00 	xor    %gs:0x28,%rsi
    235d:	00 00 
    235f:	75 34                	jne    2395 <dafs_add_dentry+0xa5>
    2361:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
    2368:	5b                   	pop    %rbx
    2369:	41 5c                	pop    %r12
    236b:	41 5d                	pop    %r13
    236d:	41 5e                	pop    %r14
    236f:	41 5f                	pop    %r15
    2371:	5d                   	pop    %rbp
    2372:	c3                   	retq   
    2373:	48 8d bc 24 80 00 00 	lea    0x80(%rsp),%rdi
    237a:	00 
    237b:	89 54 24 60          	mov    %edx,0x60(%rsp)
    237f:	48 89 74 24 68       	mov    %rsi,0x68(%rsp)
    2384:	e8 00 00 00 00       	callq  2389 <dafs_add_dentry+0x99>
    2389:	44 8b 44 24 60       	mov    0x60(%rsp),%r8d
    238e:	4c 8b 4c 24 68       	mov    0x68(%rsp),%r9
    2393:	eb ae                	jmp    2343 <dafs_add_dentry+0x53>
    2395:	e8 00 00 00 00       	callq  239a <dafs_add_dentry+0xaa>
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
	if (namelen == 0)
		return -EINVAL;
    nova_dbg("%s:dafs start to add dentry",__func__);
    239a:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    23a1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    23a8:	44 89 44 24 58       	mov    %r8d,0x58(%rsp)
    23ad:	4c 89 4c 24 60       	mov    %r9,0x60(%rsp)
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    23b2:	45 31 f6             	xor    %r14d,%r14d
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
	if (namelen == 0)
		return -EINVAL;
    nova_dbg("%s:dafs start to add dentry",__func__);
    23b5:	e8 00 00 00 00       	callq  23ba <dafs_add_dentry+0xca>
    ph = get_dentry_path(dentry,0);
    23ba:	48 89 df             	mov    %rbx,%rdi
    23bd:	e8 3e dd ff ff       	callq  100 <get_dentry_path.isra.4>
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    23c2:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
	if (namelen == 0)
		return -EINVAL;
    nova_dbg("%s:dafs start to add dentry",__func__);
    ph = get_dentry_path(dentry,0);
    23c6:	48 89 c7             	mov    %rax,%rdi
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    23c9:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
    23ce:	48 89 d1             	mov    %rdx,%rcx
    23d1:	48 89 54 24 68       	mov    %rdx,0x68(%rsp)
    23d6:	44 89 f0             	mov    %r14d,%eax
    23d9:	f2 ae                	repnz scas %es:(%rdi),%al
    23db:	48 f7 d1             	not    %rcx
    23de:	48 8d 3c 11          	lea    (%rcx,%rdx,1),%rdi
    23e2:	e8 09 dd ff ff       	callq  f0 <kzalloc.constprop.9>
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    23e7:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
    23ec:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
	if (namelen == 0)
		return -EINVAL;
    nova_dbg("%s:dafs start to add dentry",__func__);
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    23f1:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    23f6:	44 89 f0             	mov    %r14d,%eax
    23f9:	48 89 d1             	mov    %rdx,%rcx
    23fc:	f2 ae                	repnz scas %es:(%rdi),%al
    23fe:	48 f7 d1             	not    %rcx
    2401:	48 89 cf             	mov    %rcx,%rdi
    2404:	e8 e7 dc ff ff       	callq  f0 <kzalloc.constprop.9>
    dzt_ei = find_dzt(sb, ph, phn);
    2409:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
    240e:	48 89 c2             	mov    %rax,%rdx
    2411:	4c 89 ef             	mov    %r13,%rdi
	if (namelen == 0)
		return -EINVAL;
    nova_dbg("%s:dafs start to add dentry",__func__);
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    2414:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    dzt_ei = find_dzt(sb, ph, phn);
    2419:	e8 e2 db ff ff       	callq  0 <find_dzt>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    241e:	49 8b 95 b0 03 00 00 	mov    0x3b0(%r13),%rdx
    2425:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb,dzt_ei->dz_addr);
    make_zone_ptr(&zone_p, dafs_ze);
    242a:	48 8d 7c 24 78       	lea    0x78(%rsp),%rdi
    nova_dbg("%s:dafs start to add dentry",__func__);
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb,dzt_ei->dz_addr);
    242f:	48 8b 40 10          	mov    0x10(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    2433:	48 89 c1             	mov    %rax,%rcx
    2436:	48 03 4a 18          	add    0x18(%rdx),%rcx
    243a:	48 85 c0             	test   %rax,%rax
    243d:	b8 00 00 00 00       	mov    $0x0,%eax
    2442:	48 0f 45 c1          	cmovne %rcx,%rax
    struct file_p *tem_sf;
    //struct name_ext *de_ext;
    char *phname, *ph, *phn, *tem;
    unsigned long phlen, temlen, flen, tm_len;
    unsigned short links_count;
    u32 bitpos = 0, cur_pos = 0, par_pos, tem_pos;
    2446:	45 31 f6             	xor    %r14d,%r14d
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb,dzt_ei->dz_addr);
    make_zone_ptr(&zone_p, dafs_ze);
    2449:	48 89 c6             	mov    %rax,%rsi
    244c:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    2451:	e8 00 00 00 00       	callq  2456 <dafs_add_dentry+0x166>
    2456:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
    struct file_p *tem_sf;
    //struct name_ext *de_ext;
    char *phname, *ph, *phn, *tem;
    unsigned long phlen, temlen, flen, tm_len;
    unsigned short links_count;
    u32 bitpos = 0, cur_pos = 0, par_pos, tem_pos;
    245b:	45 31 db             	xor    %r11d,%r11d
    245e:	4c 8b 4c 24 60       	mov    0x60(%rsp),%r9
    2463:	44 8b 44 24 58       	mov    0x58(%rsp),%r8d
    2468:	48 8b 08             	mov    (%rax),%rcx
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb,dzt_ei->dz_addr);
    make_zone_ptr(&zone_p, dafs_ze);
    246b:	31 c0                	xor    %eax,%eax
    246d:	eb 19                	jmp    2488 <dafs_add_dentry+0x198>
    //nova_dbg("%s zone beginning",__func__);
    //tes_empty_zone(sb, zone_p);
    while(cur_pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
            bitpos+=2;
    246f:	41 83 c3 02          	add    $0x2,%r11d
            cur_pos++;
    2473:	41 83 c6 01          	add    $0x1,%r14d
    2477:	48 83 c0 02          	add    $0x2,%rax
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb,dzt_ei->dz_addr);
    make_zone_ptr(&zone_p, dafs_ze);
    //nova_dbg("%s zone beginning",__func__);
    //tes_empty_zone(sb, zone_p);
    while(cur_pos<NR_DENTRY_IN_ZONE){
    247b:	41 81 fb fe ff 01 00 	cmp    $0x1fffe,%r11d
    2482:	0f 84 88 05 00 00    	je     2a10 <dafs_add_dentry+0x720>

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    2488:	48 0f a3 01          	bt     %rax,(%rcx)
    248c:	19 d2                	sbb    %edx,%edx
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
    248e:	85 d2                	test   %edx,%edx
    2490:	75 dd                	jne    246f <dafs_add_dentry+0x17f>
    2492:	48 8d 50 01          	lea    0x1(%rax),%rdx
    2496:	48 0f a3 11          	bt     %rdx,(%rcx)
    249a:	19 d2                	sbb    %edx,%edx
    249c:	85 d2                	test   %edx,%edx
    249e:	75 cf                	jne    246f <dafs_add_dentry+0x17f>
    if(cur_pos==NR_DENTRY_IN_ZONE){
        BUG();
        dafs_split_zone(sb, NULL, 0, NEGTIVE_SPLIT);
    }*/

    phlen = strlen(phn); 
    24a0:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    24a5:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
    24a9:	31 c0                	xor    %eax,%eax
    24ab:	48 89 f1             	mov    %rsi,%rcx
    24ae:	f2 ae                	repnz scas %es:(%rdi),%al
    if(phlen==1){
        flen = strlen(ph);
    24b0:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
    24b5:	44 89 44 24 30       	mov    %r8d,0x30(%rsp)
    if(cur_pos==NR_DENTRY_IN_ZONE){
        BUG();
        dafs_split_zone(sb, NULL, 0, NEGTIVE_SPLIT);
    }*/

    phlen = strlen(phn); 
    24ba:	48 f7 d1             	not    %rcx
    24bd:	4c 89 4c 24 38       	mov    %r9,0x38(%rsp)
    24c2:	44 89 5c 24 60       	mov    %r11d,0x60(%rsp)
    24c7:	48 89 ca             	mov    %rcx,%rdx
    if(phlen==1){
        flen = strlen(ph);
    24ca:	48 89 f1             	mov    %rsi,%rcx
    24cd:	f2 ae                	repnz scas %es:(%rdi),%al
    if(cur_pos==NR_DENTRY_IN_ZONE){
        BUG();
        dafs_split_zone(sb, NULL, 0, NEGTIVE_SPLIT);
    }*/

    phlen = strlen(phn); 
    24cf:	48 01 f2             	add    %rsi,%rdx
    if(phlen==1){
        flen = strlen(ph);
    24d2:	48 89 c8             	mov    %rcx,%rax
        BUG();
        dafs_split_zone(sb, NULL, 0, NEGTIVE_SPLIT);
    }*/

    phlen = strlen(phn); 
    if(phlen==1){
    24d5:	48 83 fa 01          	cmp    $0x1,%rdx
        flen = strlen(ph);
    24d9:	48 f7 d0             	not    %rax
        BUG();
        dafs_split_zone(sb, NULL, 0, NEGTIVE_SPLIT);
    }*/

    phlen = strlen(phn); 
    if(phlen==1){
    24dc:	0f 84 00 05 00 00    	je     29e2 <dafs_add_dentry+0x6f2>
        flen = strlen(ph);
        memcpy(phname, ph, flen);
    } else {
        flen = strlen(ph)-phlen;
        memcpy(phname, ph+phlen, flen);
    24e2:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
    phlen = strlen(phn); 
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
    } else {
        flen = strlen(ph)-phlen;
    24e7:	48 83 e8 01          	sub    $0x1,%rax
    24eb:	48 29 d0             	sub    %rdx,%rax
    24ee:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
        memcpy(phname, ph+phlen, flen);
    24f3:	48 8d 34 17          	lea    (%rdi,%rdx,1),%rsi
    24f7:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
    24fc:	48 89 c2             	mov    %rax,%rdx
    24ff:	e8 00 00 00 00       	callq  2504 <dafs_add_dentry+0x214>
    2504:	44 8b 44 24 30       	mov    0x30(%rsp),%r8d
    2509:	4c 8b 4c 24 38       	mov    0x38(%rsp),%r9
    250e:	44 8b 5c 24 60       	mov    0x60(%rsp),%r11d
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
    2513:	49 8b 54 24 c8       	mov    -0x38(%r12),%rdx
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    2518:	49 8b 85 b0 03 00 00 	mov    0x3b0(%r13),%rax
    251f:	44 89 44 24 10       	mov    %r8d,0x10(%rsp)
    2524:	4c 89 4c 24 18       	mov    %r9,0x18(%rsp)
    2529:	44 89 5c 24 30       	mov    %r11d,0x30(%rsp)
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    252e:	48 89 d1             	mov    %rdx,%rcx
    2531:	48 03 48 18          	add    0x18(%rax),%rcx
    2535:	48 85 d2             	test   %rdx,%rdx
    2538:	48 89 c8             	mov    %rcx,%rax
    253b:	b9 00 00 00 00       	mov    $0x0,%ecx
    2540:	48 0f 45 c8          	cmovne %rax,%rcx
    2544:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
    }

    pidir = nova_get_inode(sb, dir);
    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    2549:	e8 00 00 00 00       	callq  254e <dafs_add_dentry+0x25e>
    254e:	49 c7 84 24 80 00 00 	movq   $0x0,0x80(%r12)
    2555:	00 00 00 00 00 
    255a:	49 89 44 24 78       	mov    %rax,0x78(%r12)
    255f:	49 8b 94 24 80 00 00 	mov    0x80(%r12),%rdx
    2566:	00 
    2567:	49 8b 44 24 78       	mov    0x78(%r12),%rax
    dir->i_blocks = pidir->i_blocks;
    256c:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = dentry->d_name.len;
    //dafs_de->file_type = NORMAL_DIRECTORY;       

    links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
    2571:	44 8b 5c 24 30       	mov    0x30(%rsp),%r11d
    2576:	4c 8b 4c 24 18       	mov    0x18(%rsp),%r9
    257b:	44 8b 44 24 10       	mov    0x10(%rsp),%r8d
        flen = strlen(ph)-phlen;
        memcpy(phname, ph+phlen, flen);
    }

    pidir = nova_get_inode(sb, dir);
    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    2580:	49 89 54 24 70       	mov    %rdx,0x70(%r12)
    2585:	49 89 44 24 68       	mov    %rax,0x68(%r12)
    dir->i_blocks = pidir->i_blocks;
    258a:	48 8b 41 20          	mov    0x20(%rcx),%rax

    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    258e:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
        memcpy(phname, ph+phlen, flen);
    }

    pidir = nova_get_inode(sb, dir);
    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    dir->i_blocks = pidir->i_blocks;
    2593:	49 89 84 24 98 00 00 	mov    %rax,0x98(%r12)
    259a:	00 

    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    259b:	44 89 f0             	mov    %r14d,%eax
    259e:	48 89 c1             	mov    %rax,%rcx
    25a1:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    25a6:	48 05 81 00 00 00    	add    $0x81,%rax
    25ac:	48 c1 e0 07          	shl    $0x7,%rax
    25b0:	48 01 d0             	add    %rdx,%rax
    25b3:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    25b8:	48 89 c8             	mov    %rcx,%rax
    25bb:	48 c1 e0 07          	shl    $0x7,%rax
    25bf:	48 01 d0             	add    %rdx,%rax
    tem_pos = cur_pos;
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    25c2:	c6 80 80 40 00 00 06 	movb   $0x6,0x4080(%rax)
    25c9:	48 89 c1             	mov    %rax,%rcx
    25cc:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
    dafs_de->name_len = dentry->d_name.len;
    25d1:	8b 43 24             	mov    0x24(%rbx),%eax
    25d4:	88 81 81 40 00 00    	mov    %al,0x4081(%rcx)
    //dafs_de->file_type = NORMAL_DIRECTORY;       

    links_count = cpu_to_le16(dir->i_nlink);
    25da:	41 8b 54 24 48       	mov    0x48(%r12),%edx
	if (links_count == 0 && link_change == -1)
    25df:	66 85 d2             	test   %dx,%dx
    25e2:	0f 85 f1 03 00 00    	jne    29d9 <dafs_add_dentry+0x6e9>
		links_count = 0;
    25e8:	31 c0                	xor    %eax,%eax
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = dentry->d_name.len;
    //dafs_de->file_type = NORMAL_DIRECTORY;       

    links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
    25ea:	41 83 f8 ff          	cmp    $0xffffffff,%r8d
    25ee:	0f 85 e5 03 00 00    	jne    29d9 <dafs_add_dentry+0x6e9>
		links_count = 0;
	else
		links_count += link_change;
	dafs_de->links_count = cpu_to_le16(links_count);
    25f4:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
    25f9:	66 89 81 86 40 00 00 	mov    %ax,0x4086(%rcx)
    dafs_de->mtime = cpu_to_le32(dir->i_mtime.tv_sec);
    2600:	49 8b 44 24 68       	mov    0x68(%r12),%rax
    2605:	89 81 88 40 00 00    	mov    %eax,0x4088(%rcx)
    dafs_de->ino = cpu_to_le64(ino);
    260b:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    2610:	48 c1 e0 07          	shl    $0x7,%rax
    2614:	48 03 44 24 68       	add    0x68(%rsp),%rax
    2619:	4c 89 88 98 40 00 00 	mov    %r9,0x4098(%rax)
    dafs_de->size = cpu_to_le64(dir->i_size);
    2620:	49 8b 54 24 50       	mov    0x50(%r12),%rdx
    2625:	48 89 90 a0 40 00 00 	mov    %rdx,0x40a0(%rax)

    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    262c:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
	__clear_bit(nr ^ BITOP_LE_SWIZZLE, addr);
}

static inline int test_and_set_bit_le(int nr, void *addr)
{
	return test_and_set_bit(nr ^ BITOP_LE_SWIZZLE, addr);
    2631:	41 8d 53 01          	lea    0x1(%r11),%edx
    2635:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    2638:	f0 48 0f ab 10       	lock bts %rdx,(%rax)
    263d:	72 00                	jb     263f <dafs_add_dentry+0x34f>
    /*judge name len && set dentry name*/
    if(dentry->d_name.len <= SMALL_NAME_LEN){
    263f:	83 7b 24 27          	cmpl   $0x27,0x24(%rbx)
    2643:	0f 87 3c 03 00 00    	ja     2985 <dafs_add_dentry+0x695>
        nova_dbg("dentry not need extension");
    2649:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2650:	e8 00 00 00 00       	callq  2655 <dafs_add_dentry+0x365>
        dafs_de->ext_flag = 0;
    2655:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
    265a:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    /*judge name len && set dentry name*/
    if(dentry->d_name.len <= SMALL_NAME_LEN){
        nova_dbg("dentry not need extension");
        dafs_de->ext_flag = 0;
    265f:	66 c7 80 84 40 00 00 	movw   $0x0,0x4084(%rax)
    2666:	00 00 
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
    2668:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
    266d:	48 c1 e1 07          	shl    $0x7,%rcx
    2671:	8b 53 24             	mov    0x24(%rbx),%edx
    2674:	48 8b 73 28          	mov    0x28(%rbx),%rsi
    2678:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
    267d:	48 8d bc 08 b0 40 00 	lea    0x40b0(%rax,%rcx,1),%rdi
    2684:	00 
    2685:	e8 00 00 00 00       	callq  268a <dafs_add_dentry+0x39a>
        //nova_dbg("dentry name is %s", dafs_de->name);
        dafs_de->name[dentry->d_name.len] = '\0'; 
    268a:	8b 43 24             	mov    0x24(%rbx),%eax
    268d:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
    2692:	48 03 4c 24 68       	add    0x68(%rsp),%rcx
    2697:	c6 84 08 b0 40 00 00 	movb   $0x0,0x40b0(%rax,%rcx,1)
    269e:	00 
        nova_dbg("%s dentry need extend name entry",__func__);
        dafs_de->ext_flag = 1;
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, dentry->d_name.len, dentry->d_name.name, 0);
    }

    dafs_de->fname_len = cpu_to_le64(flen);
    269f:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    26a4:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
    26a9:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
    26ae:	48 c1 e2 07          	shl    $0x7,%rdx
    26b2:	48 01 d0             	add    %rdx,%rax
    26b5:	48 89 c7             	mov    %rax,%rdi
    26b8:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    26bd:	48 89 8f 90 40 00 00 	mov    %rcx,0x4090(%rdi)
    /*set fulname
    * use temlen to find par de*/
    temlen = flen - dentry->d_name.len;
    26c4:	8b 43 24             	mov    0x24(%rbx),%eax
    26c7:	48 29 c1             	sub    %rax,%rcx
    26ca:	48 89 c8             	mov    %rcx,%rax
    26cd:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
    tm_len = temlen;
    if(temlen ==1){
    26d2:	48 83 e8 01          	sub    $0x1,%rax
    26d6:	0f 84 1e 04 00 00    	je     2afa <dafs_add_dentry+0x80a>
        }
        dafs_de->par_pos = cpu_to_le32(par_pos);
    } else {
        /*get par de pos*/
        //nova_dbg("dentry is not root subfile");
        tem = kzalloc((temlen+1)*sizeof(char), GFP_KERNEL);
    26dc:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
    26e1:	48 8d 7b 01          	lea    0x1(%rbx),%rdi
    26e5:	e8 06 da ff ff       	callq  f0 <kzalloc.constprop.9>
        temlen--;
    26ea:	48 89 5c 24 30       	mov    %rbx,0x30(%rsp)
        memcpy(tem, phname, temlen);
    26ef:	48 8b 74 24 50       	mov    0x50(%rsp),%rsi
        dafs_de->par_pos = cpu_to_le32(par_pos);
    } else {
        /*get par de pos*/
        //nova_dbg("dentry is not root subfile");
        tem = kzalloc((temlen+1)*sizeof(char), GFP_KERNEL);
        temlen--;
    26f4:	48 8d 5b ff          	lea    -0x1(%rbx),%rbx
        memcpy(tem, phname, temlen);
    26f8:	48 89 c7             	mov    %rax,%rdi
    26fb:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    2700:	48 89 da             	mov    %rbx,%rdx
    2703:	e8 00 00 00 00       	callq  2708 <dafs_add_dentry+0x418>
        memcpy(tem+temlen, end, 1);
    2708:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    270d:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    2712:	85 db                	test   %ebx,%ebx
    2714:	c6 44 11 ff 00       	movb   $0x0,-0x1(%rcx,%rdx,1)
    2719:	0f 8e d4 03 00 00    	jle    2af3 <dafs_add_dentry+0x803>
    271f:	8d 43 ff             	lea    -0x1(%rbx),%eax
    2722:	48 89 ca             	mov    %rcx,%rdx
    2725:	31 db                	xor    %ebx,%ebx
    2727:	48 8d 4c 01 01       	lea    0x1(%rcx,%rax,1),%rcx
    272c:	48 89 d0             	mov    %rdx,%rax
		hash = hash * seed + (*str++);
    272f:	48 89 da             	mov    %rbx,%rdx
    2732:	48 83 c0 01          	add    $0x1,%rax
    2736:	48 c1 e2 06          	shl    $0x6,%rdx
    273a:	48 01 da             	add    %rbx,%rdx
    273d:	48 8d 14 53          	lea    (%rbx,%rdx,2),%rdx
    2741:	48 0f be 58 ff       	movsbq -0x1(%rax),%rbx
    2746:	48 01 d3             	add    %rdx,%rbx
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    2749:	48 39 c1             	cmp    %rax,%rcx
    274c:	75 e1                	jne    272f <dafs_add_dentry+0x43f>
        par_hn = BKDRHash(tem, temlen);
        
        //nova_dbg("%s par name %s",__func__,tem);
        //nova_dbg("%s full name %s",__func__,phname);
        dafs_de->isr_sf = 0;
    274e:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
        if(file_type == 1){
    2753:	41 83 ff 01          	cmp    $0x1,%r15d
        memcpy(tem+temlen, end, 1);
        par_hn = BKDRHash(tem, temlen);
        
        //nova_dbg("%s par name %s",__func__,tem);
        //nova_dbg("%s full name %s",__func__,phname);
        dafs_de->isr_sf = 0;
    2757:	c6 80 83 40 00 00 00 	movb   $0x0,0x4083(%rax)
        if(file_type == 1){
    275e:	0f 84 cb 02 00 00    	je     2a2f <dafs_add_dentry+0x73f>
                }
            } else {
                ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, flen, phname, 1);
            }
        } else {
            dafs_de->ful_name.f_name[0]= '\0';
    2764:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    2769:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
    276e:	48 c1 e0 07          	shl    $0x7,%rax
    2772:	c6 84 01 d8 40 00 00 	movb   $0x0,0x40d8(%rcx,%rax,1)
    2779:	00 
        }
        
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hn, 1, &par_pos);
    277a:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    277f:	4c 8d 44 24 74       	lea    0x74(%rsp),%r8
    2784:	b9 01 00 00 00       	mov    $0x1,%ecx
    2789:	4c 89 ef             	mov    %r13,%rdi
    278c:	48 89 da             	mov    %rbx,%rdx
    278f:	48 8b 70 18          	mov    0x18(%rax),%rsi
    2793:	e8 00 00 00 00       	callq  2798 <dafs_add_dentry+0x4a8>
        //nova_dbg("set par_pos %d", par_pos);
        dafs_de->par_pos = cpu_to_le32(par_pos);
    2798:	8b 44 24 74          	mov    0x74(%rsp),%eax
    279c:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
        kfree(tem); 
    27a1:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
            dafs_de->ful_name.f_name[0]= '\0';
        }
        
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hn, 1, &par_pos);
        //nova_dbg("set par_pos %d", par_pos);
        dafs_de->par_pos = cpu_to_le32(par_pos);
    27a6:	89 81 8c 40 00 00    	mov    %eax,0x408c(%rcx)
        kfree(tem); 
    27ac:	e8 00 00 00 00       	callq  27b1 <dafs_add_dentry+0x4c1>
    }

    /*debug*/
    par_de = &dafs_ze->dentry[par_pos];
    //nova_dbg("%s par name %s",__func__,tem);
    BUG_ON(le64_to_cpu(par_de->ino)!=dir->i_ino);
    27b1:	8b 44 24 74          	mov    0x74(%rsp),%eax
    27b5:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
    27ba:	49 8b 54 24 40       	mov    0x40(%r12),%rdx
    27bf:	48 c1 e0 07          	shl    $0x7,%rax
    27c3:	48 39 94 01 98 40 00 	cmp    %rdx,0x4098(%rcx,%rax,1)
    27ca:	00 
    27cb:	0f 85 20 03 00 00    	jne    2af1 <dafs_add_dentry+0x801>
    27d1:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
    27d6:	85 c0                	test   %eax,%eax
    27d8:	0f 8e 0b 03 00 00    	jle    2ae9 <dafs_add_dentry+0x7f9>
    27de:	48 8b 54 24 50       	mov    0x50(%rsp),%rdx
    27e3:	83 e8 01             	sub    $0x1,%eax
    27e6:	45 31 e4             	xor    %r12d,%r12d
    27e9:	48 8d 4c 02 01       	lea    0x1(%rdx,%rax,1),%rcx
    27ee:	48 89 d0             	mov    %rdx,%rax
		hash = hash * seed + (*str++);
    27f1:	4c 89 e2             	mov    %r12,%rdx
    27f4:	48 83 c0 01          	add    $0x1,%rax
    27f8:	48 c1 e2 06          	shl    $0x6,%rdx
    27fc:	4c 01 e2             	add    %r12,%rdx
    27ff:	49 8d 14 54          	lea    (%r12,%rdx,2),%rdx
    2803:	4c 0f be 60 ff       	movsbq -0x1(%rax),%r12
    2808:	49 01 d4             	add    %rdx,%r12
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    280b:	48 39 c8             	cmp    %rcx,%rax
    280e:	75 e1                	jne    27f1 <dafs_add_dentry+0x501>
 
    hashname = BKDRHash(phname, flen);
    ht_addr = dzt_ei->ht_head;
    ret = record_pos_htable(sb, ht_addr, hashname, tem_pos, 1);
    2810:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    2815:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    281b:	44 89 f1             	mov    %r14d,%ecx
    281e:	4c 89 e2             	mov    %r12,%rdx
    2821:	4c 89 ef             	mov    %r13,%rdi
    2824:	48 8b 70 18          	mov    0x18(%rax),%rsi
    2828:	e8 00 00 00 00       	callq  282d <dafs_add_dentry+0x53d>

    if(tm_len>1 || dzt_ei->dzt_eno==0){
    282d:	48 83 7c 24 30 01    	cmpq   $0x1,0x30(%rsp)
    //nova_dbg("%s par name %s",__func__,tem);
    BUG_ON(le64_to_cpu(par_de->ino)!=dir->i_ino);
 
    hashname = BKDRHash(phname, flen);
    ht_addr = dzt_ei->ht_head;
    ret = record_pos_htable(sb, ht_addr, hashname, tem_pos, 1);
    2833:	89 c3                	mov    %eax,%ebx

    if(tm_len>1 || dzt_ei->dzt_eno==0){
    2835:	0f 86 e0 01 00 00    	jbe    2a1b <dafs_add_dentry+0x72b>
        if(par_pos==0){
    283b:	8b 44 24 74          	mov    0x74(%rsp),%eax
		hash = hash * seed + (*str++);
    283f:	be 2f 00 00 00       	mov    $0x2f,%esi
    2844:	85 c0                	test   %eax,%eax
    2846:	74 11                	je     2859 <dafs_add_dentry+0x569>
            par_hn = BKDRHash("/",1);
        } else {
            par_de = &dafs_ze->dentry[par_pos];
            par_hn = le64_to_cpu(par_de->hname);
    2848:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
    284d:	48 c1 e0 07          	shl    $0x7,%rax
    2851:	48 8b b4 01 a8 40 00 	mov    0x40a8(%rcx,%rax,1),%rsi
    2858:	00 
        }
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    2859:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    285e:	48 8d 78 38          	lea    0x38(%rax),%rdi
    2862:	e8 00 00 00 00       	callq  2867 <dafs_add_dentry+0x577>
        if(!par_dir){
    2867:	48 85 c0             	test   %rax,%rax
            par_hn = BKDRHash("/",1);
        } else {
            par_de = &dafs_ze->dentry[par_pos];
            par_hn = le64_to_cpu(par_de->hname);
        }
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    286a:	49 89 c5             	mov    %rax,%r13
        if(!par_dir){
    286d:	0f 84 31 02 00 00    	je     2aa4 <dafs_add_dentry+0x7b4>
            BUG();
            goto OUT;

        }
        par_dir->sub_num++;
    2873:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
    2878:	bf 14 00 00 00       	mov    $0x14,%edi
        tem_sf->pos = tem_pos;
        list_add_tail(&tem_sf->list, &par_dir->sub_file);
    287d:	49 83 c5 18          	add    $0x18,%r13
            BUG();
            goto OUT;

        }
        par_dir->sub_num++;
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
    2881:	e8 6a d8 ff ff       	callq  f0 <kzalloc.constprop.9>
        tem_sf->pos = tem_pos;
    2886:	44 89 70 10          	mov    %r14d,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    288a:	49 8b 55 08          	mov    0x8(%r13),%rdx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    288e:	49 89 45 08          	mov    %rax,0x8(%r13)
        list_add_tail(&tem_sf->list, &par_dir->sub_file);
    2892:	4c 89 28             	mov    %r13,(%rax)
	new->next = next;
	new->prev = prev;
    2895:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    2899:	48 89 02             	mov    %rax,(%rdx)
    }

    dafs_de->hname = cpu_to_le64(hashname);
    289c:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    28a1:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
    28a6:	48 c1 e0 07          	shl    $0x7,%rax
    /*add dir info if dentry is dir*/
    if(file_type==1){
    28aa:	41 83 ef 01          	sub    $0x1,%r15d
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = tem_pos;
        list_add_tail(&tem_sf->list, &par_dir->sub_file);
    }

    dafs_de->hname = cpu_to_le64(hashname);
    28ae:	4c 89 a4 01 a8 40 00 	mov    %r12,0x40a8(%rcx,%rax,1)
    28b5:	00 
    /*add dir info if dentry is dir*/
    if(file_type==1){
        dafs_de->file_type = NORMAL_DIRECTORY;
    28b6:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
        list_add_tail(&tem_sf->list, &par_dir->sub_file);
    }

    dafs_de->hname = cpu_to_le64(hashname);
    /*add dir info if dentry is dir*/
    if(file_type==1){
    28bb:	0f 84 c7 01 00 00    	je     2a88 <dafs_add_dentry+0x798>
        dafs_de->file_type = NORMAL_DIRECTORY;
        add_dir_info(dzt_ei, hashname, tem_pos);
        //dafs_append_dir_init_entries(sb, tem_pos, dzt_ei, ino, dir->i_ino, phname);
    } else {
        dafs_de->file_type = NORMAL_FILE;
    28c1:	c6 80 82 40 00 00 00 	movb   $0x0,0x4082(%rax)
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    28c8:	8b 54 24 28          	mov    0x28(%rsp),%edx
	if (support_clwb) {
    28cc:	31 c0                	xor    %eax,%eax
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    28ce:	83 e2 3f             	and    $0x3f,%edx
    28d1:	83 ea 80             	sub    $0xffffff80,%edx
	if (support_clwb) {
    28d4:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 28db <dafs_add_dentry+0x5eb>
    28db:	0f 84 8e 00 00 00    	je     296f <dafs_add_dentry+0x67f>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    28e1:	89 c1                	mov    %eax,%ecx
    28e3:	48 03 4c 24 28       	add    0x28(%rsp),%rcx
    28e8:	66 0f ae 31          	clwb   (%rcx)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    28ec:	83 c0 40             	add    $0x40,%eax
    28ef:	39 c2                	cmp    %eax,%edx
    28f1:	77 ee                	ja     28e1 <dafs_add_dentry+0x5f1>
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);

    //nova_dbg("%s zone end",__func__);
    //tes_empty_zone(sb, zone_p);
OUT:
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    28f3:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 28fa <dafs_add_dentry+0x60a>
    28fa:	74 3c                	je     2938 <dafs_add_dentry+0x648>
    28fc:	48 8d bc 24 90 00 00 	lea    0x90(%rsp),%rdi
    2903:	00 
    2904:	e8 00 00 00 00       	callq  2909 <dafs_add_dentry+0x619>
    2909:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
    2910:	00 
    2911:	48 2b 84 24 80 00 00 	sub    0x80(%rsp),%rax
    2918:	00 
    2919:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    2920:	48 2b 84 24 88 00 00 	sub    0x88(%rsp),%rax
    2927:	00 
    2928:	48 03 84 24 98 00 00 	add    0x98(%rsp),%rax
    292f:	00 
    2930:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 2938 <dafs_add_dentry+0x648>
    2937:	00 
    kfree(phname);
    2938:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);

    //nova_dbg("%s zone end",__func__);
    //tes_empty_zone(sb, zone_p);
OUT:
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    293d:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 2945 <dafs_add_dentry+0x655>
    2944:	00 
    kfree(phname);
    2945:	e8 00 00 00 00       	callq  294a <dafs_add_dentry+0x65a>
    kfree(ph);
    294a:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
    294f:	e8 00 00 00 00       	callq  2954 <dafs_add_dentry+0x664>
    kfree(phn);
    2954:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    2959:	e8 00 00 00 00       	callq  295e <dafs_add_dentry+0x66e>
    kfree(zone_p);
    295e:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    2963:	e8 00 00 00 00       	callq  2968 <dafs_add_dentry+0x678>
    //nova_dbg("%s: finish, ino %llu, parent name %s",
    //     __func__, dafs_de->ino, dentry->d_parent->d_name.name);
    return ret;
    2968:	89 d8                	mov    %ebx,%eax
    296a:	e9 df f9 ff ff       	jmpq   234e <dafs_add_dentry+0x5e>
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    296f:	89 c1                	mov    %eax,%ecx
    2971:	48 03 4c 24 28       	add    0x28(%rsp),%rcx
    2976:	0f ae 39             	clflush (%rcx)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    2979:	83 c0 40             	add    $0x40,%eax
    297c:	39 c2                	cmp    %eax,%edx
    297e:	77 ef                	ja     296f <dafs_add_dentry+0x67f>
    2980:	e9 6e ff ff ff       	jmpq   28f3 <dafs_add_dentry+0x603>
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
        //nova_dbg("dentry name is %s", dafs_de->name);
        dafs_de->name[dentry->d_name.len] = '\0'; 

    } else {
        nova_dbg("%s dentry need extend name entry",__func__);
    2985:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    298c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2993:	e8 00 00 00 00       	callq  2998 <dafs_add_dentry+0x6a8>
        dafs_de->ext_flag = 1;
    2998:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, dentry->d_name.len, dentry->d_name.name, 0);
    299d:	48 8b 4c 24 78       	mov    0x78(%rsp),%rcx
    29a2:	45 89 f0             	mov    %r14d,%r8d
    29a5:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
    29aa:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
    29af:	4c 89 ef             	mov    %r13,%rdi
        //nova_dbg("dentry name is %s", dafs_de->name);
        dafs_de->name[dentry->d_name.len] = '\0'; 

    } else {
        nova_dbg("%s dentry need extend name entry",__func__);
        dafs_de->ext_flag = 1;
    29b2:	66 c7 80 84 40 00 00 	movw   $0x1,0x4084(%rax)
    29b9:	01 00 
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, dentry->d_name.len, dentry->d_name.name, 0);
    29bb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
    29c2:	00 
    29c3:	48 8b 43 28          	mov    0x28(%rbx),%rax
    29c7:	48 89 04 24          	mov    %rax,(%rsp)
    29cb:	44 8b 4b 24          	mov    0x24(%rbx),%r9d
    29cf:	e8 00 00 00 00       	callq  29d4 <dafs_add_dentry+0x6e4>
    29d4:	e9 c6 fc ff ff       	jmpq   269f <dafs_add_dentry+0x3af>

    links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
		links_count = 0;
	else
		links_count += link_change;
    29d9:	42 8d 04 02          	lea    (%rdx,%r8,1),%eax
    29dd:	e9 12 fc ff ff       	jmpq   25f4 <dafs_add_dentry+0x304>
        dafs_split_zone(sb, NULL, 0, NEGTIVE_SPLIT);
    }*/

    phlen = strlen(phn); 
    if(phlen==1){
        flen = strlen(ph);
    29e2:	48 01 f0             	add    %rsi,%rax
        memcpy(phname, ph, flen);
    29e5:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
    29ea:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
    29ef:	48 89 c2             	mov    %rax,%rdx
        dafs_split_zone(sb, NULL, 0, NEGTIVE_SPLIT);
    }*/

    phlen = strlen(phn); 
    if(phlen==1){
        flen = strlen(ph);
    29f2:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
        memcpy(phname, ph, flen);
    29f7:	e8 00 00 00 00       	callq  29fc <dafs_add_dentry+0x70c>
    29fc:	44 8b 5c 24 60       	mov    0x60(%rsp),%r11d
    2a01:	4c 8b 4c 24 38       	mov    0x38(%rsp),%r9
    2a06:	44 8b 44 24 30       	mov    0x30(%rsp),%r8d
    2a0b:	e9 03 fb ff ff       	jmpq   2513 <dafs_add_dentry+0x223>
    2a10:	41 be ff ff 00 00    	mov    $0xffff,%r14d
    2a16:	e9 85 fa ff ff       	jmpq   24a0 <dafs_add_dentry+0x1b0>
 
    hashname = BKDRHash(phname, flen);
    ht_addr = dzt_ei->ht_head;
    ret = record_pos_htable(sb, ht_addr, hashname, tem_pos, 1);

    if(tm_len>1 || dzt_ei->dzt_eno==0){
    2a1b:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    2a20:	83 78 08 00          	cmpl   $0x0,0x8(%rax)
    2a24:	0f 85 72 fe ff ff    	jne    289c <dafs_add_dentry+0x5ac>
    2a2a:	e9 0c fe ff ff       	jmpq   283b <dafs_add_dentry+0x54b>
        
        //nova_dbg("%s par name %s",__func__,tem);
        //nova_dbg("%s full name %s",__func__,phname);
        dafs_de->isr_sf = 0;
        if(file_type == 1){
           if(dafs_de->ext_flag==0){
    2a2f:	66 83 b8 84 40 00 00 	cmpw   $0x0,0x4084(%rax)
    2a36:	00 
    2a37:	75 7b                	jne    2ab4 <dafs_add_dentry+0x7c4>
                if(flen<=SMALL_NAME_LEN){
    2a39:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
    2a3e:	48 83 f8 27          	cmp    $0x27,%rax
    2a42:	77 62                	ja     2aa6 <dafs_add_dentry+0x7b6>
                    //nova_dbg("dafs not need extend fulname");
                    memcpy(dafs_de->ful_name.f_name, phname, flen);
    2a44:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    2a49:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
    2a4e:	48 8b 74 24 50       	mov    0x50(%rsp),%rsi
    2a53:	48 c1 e1 07          	shl    $0x7,%rcx
    2a57:	48 8d bc 0a d8 40 00 	lea    0x40d8(%rdx,%rcx,1),%rdi
    2a5e:	00 
    2a5f:	48 89 c2             	mov    %rax,%rdx
    2a62:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
    2a67:	e8 00 00 00 00       	callq  2a6c <dafs_add_dentry+0x77c>
                    dafs_de->ful_name.f_name[flen]='\0';
    2a6c:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
    2a71:	48 03 4c 24 68       	add    0x68(%rsp),%rcx
    2a76:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
    2a7b:	c6 84 08 d8 40 00 00 	movb   $0x0,0x40d8(%rax,%rcx,1)
    2a82:	00 
    2a83:	e9 f2 fc ff ff       	jmpq   277a <dafs_add_dentry+0x48a>

    dafs_de->hname = cpu_to_le64(hashname);
    /*add dir info if dentry is dir*/
    if(file_type==1){
        dafs_de->file_type = NORMAL_DIRECTORY;
        add_dir_info(dzt_ei, hashname, tem_pos);
    2a88:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    2a8d:	44 89 f2             	mov    %r14d,%edx
    2a90:	4c 89 e6             	mov    %r12,%rsi
    }

    dafs_de->hname = cpu_to_le64(hashname);
    /*add dir info if dentry is dir*/
    if(file_type==1){
        dafs_de->file_type = NORMAL_DIRECTORY;
    2a93:	c6 80 82 40 00 00 01 	movb   $0x1,0x4082(%rax)
        add_dir_info(dzt_ei, hashname, tem_pos);
    2a9a:	e8 00 00 00 00       	callq  2a9f <dafs_add_dentry+0x7af>
    2a9f:	e9 24 fe ff ff       	jmpq   28c8 <dafs_add_dentry+0x5d8>
            par_de = &dafs_ze->dentry[par_pos];
            par_hn = le64_to_cpu(par_de->hname);
        }
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
        if(!par_dir){
            BUG();
    2aa4:	0f 0b                	ud2    
                    //nova_dbg("dafs not need extend fulname");
                    memcpy(dafs_de->ful_name.f_name, phname, flen);
                    dafs_de->ful_name.f_name[flen]='\0';
                } else {
                    //nova_dbg("%s extend ful name %s ino %llu", __func__, phname, ino);
                    dafs_de->ext_flag = 2;
    2aa6:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
    2aab:	66 c7 80 84 40 00 00 	movw   $0x2,0x4084(%rax)
    2ab2:	02 00 
                    ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, flen, phname, 1);
                }
            } else {
                ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, flen, phname, 1);
    2ab4:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
    2ab9:	44 8b 4c 24 58       	mov    0x58(%rsp),%r9d
    2abe:	45 89 f0             	mov    %r14d,%r8d
    2ac1:	48 8b 4c 24 78       	mov    0x78(%rsp),%rcx
    2ac6:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
    2acb:	4c 89 ef             	mov    %r13,%rdi
    2ace:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
    2ad3:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    2ada:	00 
    2adb:	48 89 04 24          	mov    %rax,(%rsp)
    2adf:	e8 00 00 00 00       	callq  2ae4 <dafs_add_dentry+0x7f4>
    2ae4:	e9 91 fc ff ff       	jmpq   277a <dafs_add_dentry+0x48a>

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    2ae9:	45 31 e4             	xor    %r12d,%r12d
    2aec:	e9 1f fd ff ff       	jmpq   2810 <dafs_add_dentry+0x520>
    }

    /*debug*/
    par_de = &dafs_ze->dentry[par_pos];
    //nova_dbg("%s par name %s",__func__,tem);
    BUG_ON(le64_to_cpu(par_de->ino)!=dir->i_ino);
    2af1:	0f 0b                	ud2    
    2af3:	31 db                	xor    %ebx,%ebx
    2af5:	e9 54 fc ff ff       	jmpq   274e <dafs_add_dentry+0x45e>
    /*set fulname
    * use temlen to find par de*/
    temlen = flen - dentry->d_name.len;
    tm_len = temlen;
    if(temlen ==1){
        dafs_de->isr_sf = 1;
    2afa:	48 8b 5c 24 60       	mov    0x60(%rsp),%rbx
        nova_dbg("dentry is root subfile");
    2aff:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2b06:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
    /*set fulname
    * use temlen to find par de*/
    temlen = flen - dentry->d_name.len;
    tm_len = temlen;
    if(temlen ==1){
        dafs_de->isr_sf = 1;
    2b0b:	c6 83 83 40 00 00 01 	movb   $0x1,0x4083(%rbx)
        nova_dbg("dentry is root subfile");
    2b12:	e8 00 00 00 00       	callq  2b17 <dafs_add_dentry+0x827>
        par_pos =0;
        if(dafs_de->ext_flag==0){
    2b17:	66 83 bb 84 40 00 00 	cmpw   $0x0,0x4084(%rbx)
    2b1e:	00 
    temlen = flen - dentry->d_name.len;
    tm_len = temlen;
    if(temlen ==1){
        dafs_de->isr_sf = 1;
        nova_dbg("dentry is root subfile");
        par_pos =0;
    2b1f:	c7 44 24 74 00 00 00 	movl   $0x0,0x74(%rsp)
    2b26:	00 
        if(dafs_de->ext_flag==0){
    2b27:	75 4b                	jne    2b74 <dafs_add_dentry+0x884>
            //re_len = SMALL_NAME_LEN - dentry->d_name.len;
            if(flen<SMALL_NAME_LEN){
    2b29:	48 8b 5c 24 58       	mov    0x58(%rsp),%rbx
    2b2e:	48 83 fb 26          	cmp    $0x26,%rbx
    2b32:	77 72                	ja     2ba6 <dafs_add_dentry+0x8b6>
                memcpy(dafs_de->ful_name.f_name, phname, flen);
    2b34:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
    2b39:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
    2b3e:	48 8b 74 24 50       	mov    0x50(%rsp),%rsi
    2b43:	48 8d bc 11 d8 40 00 	lea    0x40d8(%rcx,%rdx,1),%rdi
    2b4a:	00 
    2b4b:	48 89 da             	mov    %rbx,%rdx
    2b4e:	e8 00 00 00 00       	callq  2b53 <dafs_add_dentry+0x863>
                dafs_de->ful_name.f_name[flen]= '\0';
    2b53:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    2b58:	c6 84 0b d8 40 00 00 	movb   $0x0,0x40d8(%rbx,%rcx,1)
    2b5f:	00 
                ext_de_name(sb ,dzt_ei, dafs_ze, zone_p, tem_pos, flen, phname, 1);
            }
        } else{
            ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos,flen, phname, 1);
        }
        dafs_de->par_pos = cpu_to_le32(par_pos);
    2b60:	8b 44 24 74          	mov    0x74(%rsp),%eax
    2b64:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
    2b69:	89 81 8c 40 00 00    	mov    %eax,0x408c(%rcx)
    2b6f:	e9 3d fc ff ff       	jmpq   27b1 <dafs_add_dentry+0x4c1>
                BUG();
                dafs_de->ext_flag = 2;
                ext_de_name(sb ,dzt_ei, dafs_ze, zone_p, tem_pos, flen, phname, 1);
            }
        } else{
            ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos,flen, phname, 1);
    2b74:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
    2b79:	44 8b 4c 24 58       	mov    0x58(%rsp),%r9d
    2b7e:	45 89 f0             	mov    %r14d,%r8d
    2b81:	48 8b 4c 24 78       	mov    0x78(%rsp),%rcx
    2b86:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
    2b8b:	4c 89 ef             	mov    %r13,%rdi
    2b8e:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
    2b93:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    2b9a:	00 
    2b9b:	48 89 04 24          	mov    %rax,(%rsp)
    2b9f:	e8 00 00 00 00       	callq  2ba4 <dafs_add_dentry+0x8b4>
    2ba4:	eb ba                	jmp    2b60 <dafs_add_dentry+0x870>
            if(flen<SMALL_NAME_LEN){
                memcpy(dafs_de->ful_name.f_name, phname, flen);
                dafs_de->ful_name.f_name[flen]= '\0';
            } else {
                //nova_dbg("%s ful name %s", __func__, phname);
                BUG();
    2ba6:	0f 0b                	ud2    
    2ba8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    2baf:	00 

0000000000002bb0 <dafs_find_direntry>:
 * phname full name
 * update flag for whether update
 * ISREAD for readdir flag in get path*/
struct dafs_dentry *dafs_find_direntry(struct super_block *sb, const struct dentry *dentry, int update_flag,
        u32 ISREAD)
{
    2bb0:	e8 00 00 00 00       	callq  2bb5 <dafs_find_direntry+0x5>
    2bb5:	55                   	push   %rbp
    2bb6:	49 89 f0             	mov    %rsi,%r8
    u32 de_pos, par_pos;
    char *phname, *ph, *phn, *dot=".", *pdot = "..";
    int ret;

    //nova_dbg("%s:dafs start to find direntry",__func__);
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
    2bb9:	b9 02 00 00 00       	mov    $0x2,%ecx
 * phname full name
 * update flag for whether update
 * ISREAD for readdir flag in get path*/
struct dafs_dentry *dafs_find_direntry(struct super_block *sb, const struct dentry *dentry, int update_flag,
        u32 ISREAD)
{
    2bbe:	48 89 e5             	mov    %rsp,%rbp
    2bc1:	41 57                	push   %r15
    2bc3:	41 56                	push   %r14
    2bc5:	41 55                	push   %r13
    2bc7:	41 54                	push   %r12
    2bc9:	49 89 ff             	mov    %rdi,%r15
    2bcc:	53                   	push   %rbx
    u32 de_pos, par_pos;
    char *phname, *ph, *phn, *dot=".", *pdot = "..";
    int ret;

    //nova_dbg("%s:dafs start to find direntry",__func__);
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
    2bcd:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 * phname full name
 * update flag for whether update
 * ISREAD for readdir flag in get path*/
struct dafs_dentry *dafs_find_direntry(struct super_block *sb, const struct dentry *dentry, int update_flag,
        u32 ISREAD)
{
    2bd4:	48 83 ec 28          	sub    $0x28,%rsp
    2bd8:	89 55 b4             	mov    %edx,-0x4c(%rbp)
    2bdb:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    2be2:	00 00 
    2be4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    2be8:	31 c0                	xor    %eax,%eax
    u32 de_pos, par_pos;
    char *phname, *ph, *phn, *dot=".", *pdot = "..";
    int ret;

    //nova_dbg("%s:dafs start to find direntry",__func__);
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
    2bea:	48 8b 46 28          	mov    0x28(%rsi),%rax
    2bee:	48 89 c6             	mov    %rax,%rsi
    2bf1:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    2bf3:	0f 84 96 02 00 00    	je     2e8f <dafs_find_direntry+0x2df>
    2bf9:	b9 03 00 00 00       	mov    $0x3,%ecx
    2bfe:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2c05:	48 89 c6             	mov    %rax,%rsi
    2c08:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    2c0a:	0f 84 7f 02 00 00    	je     2e8f <dafs_find_direntry+0x2df>
        //nova_dbg("%s init dentry . and ..",__func__);
        return direntry;
    }
    ph = get_dentry_path(dentry,ISREAD);
    2c10:	4c 89 c7             	mov    %r8,%rdi
    2c13:	e8 e8 d4 ff ff       	callq  100 <get_dentry_path.isra.4>
    //nova_dbg("%s ph is %s",__func__, ph);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    2c18:	48 89 c7             	mov    %rax,%rdi
    //nova_dbg("%s:dafs start to find direntry",__func__);
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
        //nova_dbg("%s init dentry . and ..",__func__);
        return direntry;
    }
    ph = get_dentry_path(dentry,ISREAD);
    2c1b:	49 89 c5             	mov    %rax,%r13
    //nova_dbg("%s ph is %s",__func__, ph);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    2c1e:	e8 00 00 00 00       	callq  2c23 <dafs_find_direntry+0x73>
    2c23:	48 89 c7             	mov    %rax,%rdi
    2c26:	e8 c5 d4 ff ff       	callq  f0 <kzalloc.constprop.9>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    2c2b:	4c 89 ef             	mov    %r13,%rdi
        //nova_dbg("%s init dentry . and ..",__func__);
        return direntry;
    }
    ph = get_dentry_path(dentry,ISREAD);
    //nova_dbg("%s ph is %s",__func__, ph);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    2c2e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    2c32:	e8 00 00 00 00       	callq  2c37 <dafs_find_direntry+0x87>
    2c37:	48 89 c7             	mov    %rax,%rdi
    2c3a:	e8 b1 d4 ff ff       	callq  f0 <kzalloc.constprop.9>
    2c3f:	49 89 c4             	mov    %rax,%r12
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    2c42:	49 8b 87 b0 03 00 00 	mov    0x3b0(%r15),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    2c49:	4c 89 ef             	mov    %r13,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    2c4c:	4c 8b b0 d8 01 00 00 	mov    0x1d8(%rax),%r14
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    2c53:	e8 00 00 00 00       	callq  2c58 <dafs_find_direntry+0xa8>
    2c58:	4c 89 ee             	mov    %r13,%rsi
    2c5b:	48 89 c2             	mov    %rax,%rdx
    2c5e:	4c 89 e7             	mov    %r12,%rdi
    2c61:	e8 00 00 00 00       	callq  2c66 <dafs_find_direntry+0xb6>
    tlen = strlen(phstr);
    2c66:	4c 89 ef             	mov    %r13,%rdi
    2c69:	e8 00 00 00 00       	callq  2c6e <dafs_find_direntry+0xbe>
    2c6e:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
    2c71:	be 2f 00 00 00       	mov    $0x2f,%esi
    2c76:	4c 89 e7             	mov    %r12,%rdi
    2c79:	e8 00 00 00 00       	callq  2c7e <dafs_find_direntry+0xce>
        phlen = tlen -strlen(tem);
    2c7e:	48 89 c7             	mov    %rax,%rdi
    2c81:	e8 00 00 00 00       	callq  2c86 <dafs_find_direntry+0xd6>
        tlen = phlen;
        //bug
        if(phlen==0){
    2c86:	48 29 c3             	sub    %rax,%rbx
    2c89:	0f 84 d7 01 00 00    	je     2e66 <dafs_find_direntry+0x2b6>
            break;
        }
        memcpy(ph,phstr,tlen);
    2c8f:	48 89 da             	mov    %rbx,%rdx
    2c92:	4c 89 ee             	mov    %r13,%rsi
    2c95:	4c 89 e7             	mov    %r12,%rdi
    2c98:	e8 00 00 00 00       	callq  2c9d <dafs_find_direntry+0xed>
	int i;

	for (i = 0; i < length; i++) {
    2c9d:	85 db                	test   %ebx,%ebx
        memcpy(ph+tlen, end, 1);
    2c9f:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
    2ca4:	0f 8e 45 01 00 00    	jle    2def <dafs_find_direntry+0x23f>
    2caa:	8d 43 ff             	lea    -0x1(%rbx),%eax
    2cad:	4c 89 e2             	mov    %r12,%rdx
    2cb0:	31 f6                	xor    %esi,%esi
    2cb2:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
    2cb7:	48 89 f0             	mov    %rsi,%rax
    2cba:	48 83 c2 01          	add    $0x1,%rdx
    2cbe:	48 c1 e0 06          	shl    $0x6,%rax
    2cc2:	48 01 f0             	add    %rsi,%rax
    2cc5:	48 8d 04 46          	lea    (%rsi,%rax,2),%rax
    2cc9:	48 0f be 72 ff       	movsbq -0x1(%rdx),%rsi
    2cce:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    2cd1:	48 39 ca             	cmp    %rcx,%rdx
    2cd4:	75 e1                	jne    2cb7 <dafs_find_direntry+0x107>
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    2cd6:	4c 89 f7             	mov    %r14,%rdi
    2cd9:	e8 00 00 00 00       	callq  2cde <dafs_find_direntry+0x12e>
        if(dzt_ei){
    2cde:	48 85 c0             	test   %rax,%rax
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    2ce1:	49 89 c1             	mov    %rax,%r9
        if(dzt_ei){
    2ce4:	74 8b                	je     2c71 <dafs_find_direntry+0xc1>
    //nova_dbg("%s ph is %s",__func__, ph);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    dzt_ei = find_dzt(sb, ph, phn);
    //nova_dbg("%s phn is %s",__func__, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    2ce6:	49 8b 41 10          	mov    0x10(%r9),%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    2cea:	49 8b 97 b0 03 00 00 	mov    0x3b0(%r15),%rdx
    //nova_dbg("the ze addr is %llu", dzt_ei->dz_addr);
    
    phlen = strlen(phn);
    2cf1:	4c 89 e7             	mov    %r12,%rdi
    //nova_dbg("%s ph is %s",__func__, ph);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    dzt_ei = find_dzt(sb, ph, phn);
    //nova_dbg("%s phn is %s",__func__, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    2cf4:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    2cf8:	48 89 c3             	mov    %rax,%rbx
    2cfb:	48 03 5a 18          	add    0x18(%rdx),%rbx
    2cff:	48 85 c0             	test   %rax,%rax
    2d02:	b8 00 00 00 00       	mov    $0x0,%eax
    2d07:	48 0f 44 d8          	cmove  %rax,%rbx
    //nova_dbg("the ze addr is %llu", dzt_ei->dz_addr);
    
    phlen = strlen(phn);
    2d0b:	e8 00 00 00 00       	callq  2d10 <dafs_find_direntry+0x160>
    //nova_dbg("full path  length is %llu", phlen);
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
    2d10:	48 83 f8 01          	cmp    $0x1,%rax
    dzt_ei = find_dzt(sb, ph, phn);
    //nova_dbg("%s phn is %s",__func__, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    //nova_dbg("the ze addr is %llu", dzt_ei->dz_addr);
    
    phlen = strlen(phn);
    2d14:	49 89 c6             	mov    %rax,%r14
    //nova_dbg("full path  length is %llu", phlen);
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
    2d17:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
    2d1b:	0f 84 76 01 00 00    	je     2e97 <dafs_find_direntry+0x2e7>
        memcpy(phname, ph, strlen(ph));
    } else {
        flen = strlen(ph)-phlen;
    2d21:	4c 89 ef             	mov    %r13,%rdi
    2d24:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
    2d28:	e8 00 00 00 00       	callq  2d2d <dafs_find_direntry+0x17d>
        memcpy(phname, ph+phlen, flen);
    2d2d:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    2d31:	4c 29 f0             	sub    %r14,%rax
    2d34:	4b 8d 74 35 00       	lea    0x0(%r13,%r14,1),%rsi
    2d39:	48 89 c2             	mov    %rax,%rdx
    2d3c:	e8 00 00 00 00       	callq  2d41 <dafs_find_direntry+0x191>
    2d41:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
    }
    
    ph_hash = BKDRHash(phname, strlen(phname));
    2d45:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
    2d49:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
    2d4d:	4c 89 f7             	mov    %r14,%rdi
    2d50:	e8 00 00 00 00       	callq  2d55 <dafs_find_direntry+0x1a5>
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    2d55:	85 c0                	test   %eax,%eax
    2d57:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
    2d5b:	0f 8e 56 01 00 00    	jle    2eb7 <dafs_find_direntry+0x307>
    2d61:	83 e8 01             	sub    $0x1,%eax
    2d64:	49 8d 4c 06 01       	lea    0x1(%r14,%rax,1),%rcx
    2d69:	4c 89 f0             	mov    %r14,%rax
    2d6c:	45 31 f6             	xor    %r14d,%r14d
		hash = hash * seed + (*str++);
    2d6f:	4c 89 f2             	mov    %r14,%rdx
    2d72:	48 83 c0 01          	add    $0x1,%rax
    2d76:	48 c1 e2 06          	shl    $0x6,%rdx
    2d7a:	4c 01 f2             	add    %r14,%rdx
    2d7d:	49 8d 14 56          	lea    (%r14,%rdx,2),%rdx
    2d81:	4c 0f be 70 ff       	movsbq -0x1(%rax),%r14
    2d86:	49 01 d6             	add    %rdx,%r14
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    2d89:	48 39 c8             	cmp    %rcx,%rax
    2d8c:	75 e1                	jne    2d6f <dafs_find_direntry+0x1bf>

    /*lookup in hash table*/
    ht_addr = dzt_ei->ht_head;
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    2d8e:	49 8b 71 18          	mov    0x18(%r9),%rsi
    2d92:	4c 8d 45 cc          	lea    -0x34(%rbp),%r8
    2d96:	4c 89 ff             	mov    %r15,%rdi
    2d99:	b9 01 00 00 00       	mov    $0x1,%ecx
    2d9e:	4c 89 f2             	mov    %r14,%rdx
    2da1:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
 * update flag for whether update
 * ISREAD for readdir flag in get path*/
struct dafs_dentry *dafs_find_direntry(struct super_block *sb, const struct dentry *dentry, int update_flag,
        u32 ISREAD)
{
    struct dafs_dentry *direntry=NULL;
    2da5:	45 31 ff             	xor    %r15d,%r15d
    
    ph_hash = BKDRHash(phname, strlen(phname));

    /*lookup in hash table*/
    ht_addr = dzt_ei->ht_head;
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    2da8:	e8 00 00 00 00       	callq  2dad <dafs_find_direntry+0x1fd>
    if(!ret){
    2dad:	85 c0                	test   %eax,%eax
    2daf:	75 59                	jne    2e0a <dafs_find_direntry+0x25a>
            ph_hash = le64_to_cpu(&dafs_ze->dentry[par_pos].hname);
            update_read_hot(dzt_ei, ph_hash);
        }
    }
OUT:
    kfree(phname);
    2db1:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    2db5:	e8 00 00 00 00       	callq  2dba <dafs_find_direntry+0x20a>
    kfree(ph);
    2dba:	4c 89 ef             	mov    %r13,%rdi
    2dbd:	e8 00 00 00 00       	callq  2dc2 <dafs_find_direntry+0x212>
    kfree(phn);
    2dc2:	4c 89 e7             	mov    %r12,%rdi
    2dc5:	e8 00 00 00 00       	callq  2dca <dafs_find_direntry+0x21a>
    //nova_dbg("%s:dafs finish find direntry",__func__);
    return direntry;
}
    2dca:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    2dce:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    2dd5:	00 00 
    2dd7:	4c 89 f8             	mov    %r15,%rax
    2dda:	0f 85 ef 00 00 00    	jne    2ecf <dafs_find_direntry+0x31f>
    2de0:	48 83 c4 28          	add    $0x28,%rsp
    2de4:	5b                   	pop    %rbx
    2de5:	41 5c                	pop    %r12
    2de7:	41 5d                	pop    %r13
    2de9:	41 5e                	pop    %r14
    2deb:	41 5f                	pop    %r15
    2ded:	5d                   	pop    %rbp
    2dee:	c3                   	retq   

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    2def:	31 f6                	xor    %esi,%esi
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    2df1:	4c 89 f7             	mov    %r14,%rdi
    2df4:	e8 00 00 00 00       	callq  2df9 <dafs_find_direntry+0x249>
        if(dzt_ei){
    2df9:	48 85 c0             	test   %rax,%rax
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    2dfc:	49 89 c1             	mov    %rax,%r9
        if(dzt_ei){
    2dff:	0f 84 6c fe ff ff    	je     2c71 <dafs_find_direntry+0xc1>
    2e05:	e9 dc fe ff ff       	jmpq   2ce6 <dafs_find_direntry+0x136>
    if(!ret){
        goto OUT;
        //nova_dbg("not found dentry in nvm");
        //goto OUT;
    }
    direntry = &dafs_ze->dentry[de_pos];
    2e0a:	8b 45 cc             	mov    -0x34(%rbp),%eax
    //nova_dbg("dir entry pos is %d", de_pos);
    
    if(update_flag){
    2e0d:	8b 55 b4             	mov    -0x4c(%rbp),%edx
    if(!ret){
        goto OUT;
        //nova_dbg("not found dentry in nvm");
        //goto OUT;
    }
    direntry = &dafs_ze->dentry[de_pos];
    2e10:	4c 8d b8 81 00 00 00 	lea    0x81(%rax),%r15
    2e17:	49 c1 e7 07          	shl    $0x7,%r15
    2e1b:	49 01 df             	add    %rbx,%r15
    //nova_dbg("dir entry pos is %d", de_pos);
    
    if(update_flag){
    2e1e:	85 d2                	test   %edx,%edx
    2e20:	74 8f                	je     2db1 <dafs_find_direntry+0x201>
    2e22:	48 c1 e0 07          	shl    $0x7,%rax
        if(direntry->file_type == NORMAL_DIRECTORY)
    2e26:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
    2e2a:	48 01 d8             	add    %rbx,%rax
    2e2d:	80 b8 82 40 00 00 01 	cmpb   $0x1,0x4082(%rax)
    2e34:	0f 84 85 00 00 00    	je     2ebf <dafs_find_direntry+0x30f>
            update_read_hot(dzt_ei, ph_hash);
        else if(direntry->isr_sf!=1){
    2e3a:	80 b8 83 40 00 00 01 	cmpb   $0x1,0x4083(%rax)
    2e41:	0f 84 6a ff ff ff    	je     2db1 <dafs_find_direntry+0x201>
            par_pos = le64_to_cpu(direntry->par_pos);
            ph_hash = le64_to_cpu(&dafs_ze->dentry[par_pos].hname);
    2e47:	8b 80 8c 40 00 00    	mov    0x408c(%rax),%eax
            update_read_hot(dzt_ei, ph_hash);
    2e4d:	4c 89 cf             	mov    %r9,%rdi
    if(update_flag){
        if(direntry->file_type == NORMAL_DIRECTORY)
            update_read_hot(dzt_ei, ph_hash);
        else if(direntry->isr_sf!=1){
            par_pos = le64_to_cpu(direntry->par_pos);
            ph_hash = le64_to_cpu(&dafs_ze->dentry[par_pos].hname);
    2e50:	48 c1 e0 07          	shl    $0x7,%rax
    2e54:	48 8d b4 03 a8 40 00 	lea    0x40a8(%rbx,%rax,1),%rsi
    2e5b:	00 
            update_read_hot(dzt_ei, ph_hash);
    2e5c:	e8 00 00 00 00       	callq  2e61 <dafs_find_direntry+0x2b1>
    2e61:	e9 4b ff ff ff       	jmpq   2db1 <dafs_find_direntry+0x201>
            goto END;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    2e66:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    memcpy(ph+1,end,1);
    2e6b:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    2e71:	be 2f 00 00 00       	mov    $0x2f,%esi
    2e76:	4c 89 f7             	mov    %r14,%rdi
    2e79:	e8 00 00 00 00       	callq  2e7e <dafs_find_direntry+0x2ce>
    if(!dzt_ei){
    2e7e:	48 85 c0             	test   %rax,%rax

    /*root dir*/
    memcpy(ph, "/", 1);
    memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    2e81:	49 89 c1             	mov    %rax,%r9
    if(!dzt_ei){
    2e84:	0f 85 5c fe ff ff    	jne    2ce6 <dafs_find_direntry+0x136>
    2e8a:	e8 00 00 00 00       	callq  2e8f <dafs_find_direntry+0x2df>
    int ret;

    //nova_dbg("%s:dafs start to find direntry",__func__);
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
        //nova_dbg("%s init dentry . and ..",__func__);
        return direntry;
    2e8f:	45 31 ff             	xor    %r15d,%r15d
    2e92:	e9 33 ff ff ff       	jmpq   2dca <dafs_find_direntry+0x21a>
    
    phlen = strlen(phn);
    //nova_dbg("full path  length is %llu", phlen);
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
        memcpy(phname, ph, strlen(ph));
    2e97:	4c 89 ef             	mov    %r13,%rdi
    2e9a:	e8 00 00 00 00       	callq  2e9f <dafs_find_direntry+0x2ef>
    2e9f:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    2ea3:	48 89 c2             	mov    %rax,%rdx
    2ea6:	4c 89 ee             	mov    %r13,%rsi
    2ea9:	e8 00 00 00 00       	callq  2eae <dafs_find_direntry+0x2fe>
    2eae:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
    2eb2:	e9 8e fe ff ff       	jmpq   2d45 <dafs_find_direntry+0x195>
    2eb7:	45 31 f6             	xor    %r14d,%r14d
    2eba:	e9 cf fe ff ff       	jmpq   2d8e <dafs_find_direntry+0x1de>
    direntry = &dafs_ze->dentry[de_pos];
    //nova_dbg("dir entry pos is %d", de_pos);
    
    if(update_flag){
        if(direntry->file_type == NORMAL_DIRECTORY)
            update_read_hot(dzt_ei, ph_hash);
    2ebf:	4c 89 f6             	mov    %r14,%rsi
    2ec2:	4c 89 cf             	mov    %r9,%rdi
    2ec5:	e8 00 00 00 00       	callq  2eca <dafs_find_direntry+0x31a>
    2eca:	e9 e2 fe ff ff       	jmpq   2db1 <dafs_find_direntry+0x201>
    kfree(phname);
    kfree(ph);
    kfree(phn);
    //nova_dbg("%s:dafs finish find direntry",__func__);
    return direntry;
}
    2ecf:	e8 00 00 00 00       	callq  2ed4 <dafs_find_direntry+0x324>
    2ed4:	66 90                	xchg   %ax,%ax
    2ed6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    2edd:	00 00 00 

0000000000002ee0 <dafs_rebuild_dir_inode_tree>:

int dafs_rebuild_dir_inode_tree(struct super_block *sb, struct nova_inode *pi, u64 pi_addr,
	struct nova_inode_info_header *sih)
{
    2ee0:	e8 00 00 00 00       	callq  2ee5 <dafs_rebuild_dir_inode_tree+0x5>
    2ee5:	55                   	push   %rbp
    2ee6:	48 89 e5             	mov    %rsp,%rbp
    2ee9:	53                   	push   %rbx
    2eea:	48 89 fb             	mov    %rdi,%rbx
    2eed:	48 83 ec 40          	sub    $0x40,%rsp
	u64 curr_p;
	//u64 next;
	u8 type;
	//int ret;

	NOVA_START_TIMING(rebuild_dir_t, rebuild_time);
    2ef1:	44 8b 0d 00 00 00 00 	mov    0x0(%rip),%r9d        # 2ef8 <dafs_rebuild_dir_inode_tree+0x18>
    return direntry;
}

int dafs_rebuild_dir_inode_tree(struct super_block *sb, struct nova_inode *pi, u64 pi_addr,
	struct nova_inode_info_header *sih)
{
    2ef8:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    2eff:	00 00 
    2f01:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    2f05:	31 c0                	xor    %eax,%eax
	u64 curr_p;
	//u64 next;
	u8 type;
	//int ret;

	NOVA_START_TIMING(rebuild_dir_t, rebuild_time);
    2f07:	45 85 c9             	test   %r9d,%r9d
    2f0a:	0f 85 b7 00 00 00    	jne    2fc7 <dafs_rebuild_dir_inode_tree+0xe7>
	//nova_dbg("Rebuild dir %llu tree\n", ino);

	sih->pi_addr = pi_addr;
    2f10:	48 89 51 40          	mov    %rdx,0x40(%rcx)

	curr_p = pi->log_head;
    2f14:	48 8b 46 48          	mov    0x48(%rsi),%rax
	}*/

	//nova_dbg("Log head 0x%llx, tail 0x%llx\n",
	//			curr_p, pi->log_tail);

    if(!curr_p){
    2f18:	48 85 c0             	test   %rax,%rax
    2f1b:	0f 85 85 00 00 00    	jne    2fa6 <dafs_rebuild_dir_inode_tree+0xc6>
        sih->log_pages = 0;
    2f21:	48 c7 41 28 00 00 00 	movq   $0x0,0x28(%rcx)
    2f28:	00 
		//curr_p += de_len;
	//}
DIR_TYPE:
    //nova_dbg("%s: it is dir type",__func__);
    //dafs_rebuild_dir_time_and_size(sb, pi, entry);
	sih->i_size = le64_to_cpu(pi->i_size);
    2f29:	48 8b 46 08          	mov    0x8(%rsi),%rax
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    2f2d:	89 f7                	mov    %esi,%edi
	if (support_clwb) {
    2f2f:	44 8b 05 00 00 00 00 	mov    0x0(%rip),%r8d        # 2f36 <dafs_rebuild_dir_inode_tree+0x56>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    2f36:	83 e7 3f             	and    $0x3f,%edi
	if (support_clwb) {
    2f39:	31 d2                	xor    %edx,%edx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    2f3b:	83 c7 5c             	add    $0x5c,%edi
    2f3e:	48 89 41 30          	mov    %rax,0x30(%rcx)
	sih->i_mode = le64_to_cpu(pi->i_mode);
    2f42:	0f b7 46 1c          	movzwl 0x1c(%rsi),%eax
	if (support_clwb) {
    2f46:	45 85 c0             	test   %r8d,%r8d
    2f49:	66 89 41 20          	mov    %ax,0x20(%rcx)
    2f4d:	74 46                	je     2f95 <dafs_rebuild_dir_inode_tree+0xb5>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    2f4f:	89 d0                	mov    %edx,%eax
    2f51:	48 01 f0             	add    %rsi,%rax
    2f54:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    2f58:	83 c2 40             	add    $0x40,%edx
    2f5b:	39 d7                	cmp    %edx,%edi
    2f5d:	77 f0                	ja     2f4f <dafs_rebuild_dir_inode_tree+0x6f>
        curr_p = next;
        curr_page = (struct nova_inode_log_page *)
        nova_get_block(sb, curr_p);
    }
    */
    pi->i_blocks = sih->log_pages;
    2f5f:	48 8b 41 28          	mov    0x28(%rcx),%rax
    2f63:	48 89 46 20          	mov    %rax,0x20(%rsi)

//	nova_print_dir_tree(sb, sih, ino);
    //dafs_rebuild_dir_time_and_size(sb, pi, entry);
	//nova_dbg("%s:dafs finish rebuild dir inode",__func__);
    NOVA_END_TIMING(rebuild_dir_t, rebuild_time);
    2f67:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 2f6d <dafs_rebuild_dir_inode_tree+0x8d>
    2f6d:	85 c0                	test   %eax,%eax
    2f6f:	75 7c                	jne    2fed <dafs_rebuild_dir_inode_tree+0x10d>
    2f71:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 2f79 <dafs_rebuild_dir_inode_tree+0x99>
    2f78:	00 
    return 0;
}
    2f79:	31 c0                	xor    %eax,%eax
    2f7b:	48 8b 5d f0          	mov    -0x10(%rbp),%rbx
    2f7f:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    2f86:	00 00 
    2f88:	0f 85 90 00 00 00    	jne    301e <dafs_rebuild_dir_inode_tree+0x13e>
    2f8e:	48 83 c4 40          	add    $0x40,%rsp
    2f92:	5b                   	pop    %rbx
    2f93:	5d                   	pop    %rbp
    2f94:	c3                   	retq   
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    2f95:	89 d0                	mov    %edx,%eax
    2f97:	48 01 f0             	add    %rsi,%rax
    2f9a:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    2f9d:	83 c2 40             	add    $0x40,%edx
    2fa0:	39 d7                	cmp    %edx,%edi
    2fa2:	77 f1                	ja     2f95 <dafs_rebuild_dir_inode_tree+0xb5>
    2fa4:	eb b9                	jmp    2f5f <dafs_rebuild_dir_inode_tree+0x7f>
    if(!curr_p){
        sih->log_pages = 0;
        goto DIR_TYPE;
    }

	sih->log_pages = 1;
    2fa6:	48 c7 41 28 01 00 00 	movq   $0x1,0x28(%rcx)
    2fad:	00 
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    2fae:	48 8b 93 b0 03 00 00 	mov    0x3b0(%rbx),%rdx
    DAFS_DIR_ENTRY,
};

static inline u8 nova_get_entry_type(void *p)
{
	return *(u8 *)p;
    2fb5:	48 8b 52 18          	mov    0x18(%rdx),%rdx
		}*/

	addr = (void *)nova_get_block(sb, curr_p);
    //find bug
    type = nova_get_entry_type(addr);
	switch (type) {
    2fb9:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
    2fbd:	3c 03                	cmp    $0x3,%al
    2fbf:	74 5b                	je     301c <dafs_rebuild_dir_inode_tree+0x13c>
    2fc1:	3c 04                	cmp    $0x4,%al
    2fc3:	75 55                	jne    301a <dafs_rebuild_dir_inode_tree+0x13a>
			sih->last_setattr = curr_p;
			curr_p += sizeof(struct nova_setattr_logentry);
				//continue;
                break;
		case LINK_CHANGE:
            BUG();
    2fc5:	0f 0b                	ud2    
    2fc7:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
    2fcb:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
    2fcf:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
    2fd3:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
    2fd7:	e8 00 00 00 00       	callq  2fdc <dafs_rebuild_dir_inode_tree+0xfc>
    2fdc:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
    2fe0:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
    2fe4:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    2fe8:	e9 23 ff ff ff       	jmpq   2f10 <dafs_rebuild_dir_inode_tree+0x30>
    2fed:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
    2ff1:	e8 00 00 00 00       	callq  2ff6 <dafs_rebuild_dir_inode_tree+0x116>
    pi->i_blocks = sih->log_pages;

//	nova_print_dir_tree(sb, sih, ino);
    //dafs_rebuild_dir_time_and_size(sb, pi, entry);
	//nova_dbg("%s:dafs finish rebuild dir inode",__func__);
    NOVA_END_TIMING(rebuild_dir_t, rebuild_time);
    2ff6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    2ffa:	48 2b 45 d0          	sub    -0x30(%rbp),%rax
    2ffe:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    3005:	48 2b 45 d8          	sub    -0x28(%rbp),%rax
    3009:	48 03 45 e8          	add    -0x18(%rbp),%rax
    300d:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 3015 <dafs_rebuild_dir_inode_tree+0x135>
    3014:	00 
    3015:	e9 57 ff ff ff       	jmpq   2f71 <dafs_rebuild_dir_inode_tree+0x91>
            break;
				//continue;
			//case DIR_LOG:
				//break;
		default:
            BUG();
    301a:	0f 0b                	ud2    
	addr = (void *)nova_get_block(sb, curr_p);
    //find bug
    type = nova_get_entry_type(addr);
	switch (type) {
		case SET_ATTR:
            BUG();
    301c:	0f 0b                	ud2    
//	nova_print_dir_tree(sb, sih, ino);
    //dafs_rebuild_dir_time_and_size(sb, pi, entry);
	//nova_dbg("%s:dafs finish rebuild dir inode",__func__);
    NOVA_END_TIMING(rebuild_dir_t, rebuild_time);
    return 0;
}
    301e:	e8 00 00 00 00       	callq  3023 <dafs_rebuild_dir_inode_tree+0x143>
    3023:	0f 1f 00             	nopl   (%rax)
    3026:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    302d:	00 00 00 

0000000000003030 <dafs_rm_dir>:
 * 只是先将对应的状态表显示无效
 * 检查是不是根节点
 * 并不含有link的变化
 */
int dafs_rm_dir(struct dentry *dentry, int link_change)
{
    3030:	e8 00 00 00 00       	callq  3035 <dafs_rm_dir+0x5>
    3035:	55                   	push   %rbp
    3036:	48 89 e5             	mov    %rsp,%rbp
    3039:	41 57                	push   %r15
    303b:	41 56                	push   %r14
    303d:	41 55                	push   %r13
    303f:	41 54                	push   %r12
    3041:	49 89 fd             	mov    %rdi,%r13
    3044:	53                   	push   %rbx
    3045:	41 89 f6             	mov    %esi,%r14d
    3048:	48 83 ec 78          	sub    $0x78,%rsp
    u64 ph_hash, ei_hash, par_hash, sub_hash;
    char *phname, *ph, *phn;
    int ret;
	timing_t remove_dentry_time;

	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    304c:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 3052 <dafs_rm_dir+0x22>
 * 只是先将对应的状态表显示无效
 * 检查是不是根节点
 * 并不含有link的变化
 */
int dafs_rm_dir(struct dentry *dentry, int link_change)
{
    3052:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    3059:	00 00 
    305b:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
    3060:	31 c0                	xor    %eax,%eax
    struct inode *dir = dentry->d_parent->d_inode;
    3062:	48 8b 47 18          	mov    0x18(%rdi),%rax
    u64 ph_hash, ei_hash, par_hash, sub_hash;
    char *phname, *ph, *phn;
    int ret;
	timing_t remove_dentry_time;

	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    3066:	85 d2                	test   %edx,%edx
 * 检查是不是根节点
 * 并不含有link的变化
 */
int dafs_rm_dir(struct dentry *dentry, int link_change)
{
    struct inode *dir = dentry->d_parent->d_inode;
    3068:	4c 8b 60 30          	mov    0x30(%rax),%r12
    struct super_block *sb = dir->i_sb;
    306c:	49 8b 5c 24 28       	mov    0x28(%r12),%rbx
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dafs_dentry *dafs_de, *par_de,*sub_de;
    struct dzt_entry_info *dzt_ei, *sub_ei;
    struct dafs_zone_entry *dafs_ze;
    struct zone_ptr *z_p;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    3071:	48 8b 83 b0 03 00 00 	mov    0x3b0(%rbx),%rax
    3078:	4c 8b b8 d8 01 00 00 	mov    0x1d8(%rax),%r15
    u64 ph_hash, ei_hash, par_hash, sub_hash;
    char *phname, *ph, *phn;
    int ret;
	timing_t remove_dentry_time;

	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    307f:	75 2c                	jne    30ad <dafs_rm_dir+0x7d>

	if (!dentry->d_name.len)
    3081:	41 8b 45 24          	mov    0x24(%r13),%eax
    3085:	85 c0                	test   %eax,%eax
    3087:	75 35                	jne    30be <dafs_rm_dir+0x8e>
		return -EINVAL;
    3089:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    kfree(z_p);
    //nova_dbg("%s end",__func__);
	return 0;
}
    308e:	48 8b 4c 24 70       	mov    0x70(%rsp),%rcx
    3093:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
    309a:	00 00 
    309c:	75 1b                	jne    30b9 <dafs_rm_dir+0x89>
    309e:	48 83 c4 78          	add    $0x78,%rsp
    30a2:	5b                   	pop    %rbx
    30a3:	41 5c                	pop    %r12
    30a5:	41 5d                	pop    %r13
    30a7:	41 5e                	pop    %r14
    30a9:	41 5f                	pop    %r15
    30ab:	5d                   	pop    %rbp
    30ac:	c3                   	retq   
    30ad:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
    30b2:	e8 00 00 00 00       	callq  30b7 <dafs_rm_dir+0x87>
    30b7:	eb c8                	jmp    3081 <dafs_rm_dir+0x51>
    30b9:	e8 00 00 00 00       	callq  30be <dafs_rm_dir+0x8e>

	if (!dentry->d_name.len)
		return -EINVAL;


	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    30be:	e8 00 00 00 00       	callq  30c3 <dafs_rm_dir+0x93>
    30c3:	49 c7 84 24 80 00 00 	movq   $0x0,0x80(%r12)
    30ca:	00 00 00 00 00 
    30cf:	49 89 44 24 78       	mov    %rax,0x78(%r12)

    /*直接rm direntry就可以
    * 先找到相应的dir*/  
    //nova_dbg("%s start",__func__);
    ph = get_dentry_path(dentry,0);
    30d4:	4c 89 ef             	mov    %r13,%rdi

	if (!dentry->d_name.len)
		return -EINVAL;


	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    30d7:	49 8b 94 24 80 00 00 	mov    0x80(%r12),%rdx
    30de:	00 
    30df:	49 8b 44 24 78       	mov    0x78(%r12),%rax
    30e4:	49 89 54 24 70       	mov    %rdx,0x70(%r12)
    30e9:	49 89 44 24 68       	mov    %rax,0x68(%r12)

    /*直接rm direntry就可以
    * 先找到相应的dir*/  
    //nova_dbg("%s start",__func__);
    ph = get_dentry_path(dentry,0);
    30ee:	e8 0d d0 ff ff       	callq  100 <get_dentry_path.isra.4>
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    30f3:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;

    /*直接rm direntry就可以
    * 先找到相应的dir*/  
    //nova_dbg("%s start",__func__);
    ph = get_dentry_path(dentry,0);
    30f7:	48 89 c7             	mov    %rax,%rdi
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    30fa:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    30ff:	31 c0                	xor    %eax,%eax
    3101:	f2 ae                	repnz scas %es:(%rdi),%al
    3103:	48 f7 d1             	not    %rcx
    3106:	48 8d 79 ff          	lea    -0x1(%rcx),%rdi
    310a:	e8 e1 cf ff ff       	callq  f0 <kzalloc.constprop.9>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    310f:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi

    /*直接rm direntry就可以
    * 先找到相应的dir*/  
    //nova_dbg("%s start",__func__);
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    3114:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    3119:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    311d:	31 c0                	xor    %eax,%eax
    311f:	f2 ae                	repnz scas %es:(%rdi),%al
    3121:	48 f7 d1             	not    %rcx
    3124:	48 8d 79 ff          	lea    -0x1(%rcx),%rdi
    3128:	e8 c3 cf ff ff       	callq  f0 <kzalloc.constprop.9>
    //memcpy(phname, ph, strlen(ph));
    nova_dbg("%s start dentry %s",__func__,ph);
    312d:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    3132:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    3139:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    /*直接rm direntry就可以
    * 先找到相应的dir*/  
    //nova_dbg("%s start",__func__);
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    3140:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    //memcpy(phname, ph, strlen(ph));
    nova_dbg("%s start dentry %s",__func__,ph);
    3145:	e8 00 00 00 00       	callq  314a <dafs_rm_dir+0x11a>
    ph = get_dentry_path(dentry,0);
    314a:	4c 89 ef             	mov    %r13,%rdi
    314d:	e8 ae cf ff ff       	callq  100 <get_dentry_path.isra.4>
    dzt_ei = find_dzt(sb, ph, phn);
    3152:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph));
    nova_dbg("%s start dentry %s",__func__,ph);
    ph = get_dentry_path(dentry,0);
    3157:	48 89 c6             	mov    %rax,%rsi
    dzt_ei = find_dzt(sb, ph, phn);
    315a:	48 89 df             	mov    %rbx,%rdi
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph));
    nova_dbg("%s start dentry %s",__func__,ph);
    ph = get_dentry_path(dentry,0);
    315d:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    dzt_ei = find_dzt(sb, ph, phn);
    3162:	4c 89 ea             	mov    %r13,%rdx
    3165:	e8 96 ce ff ff       	callq  0 <find_dzt>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    316a:	48 8b 93 b0 03 00 00 	mov    0x3b0(%rbx),%rdx
    3171:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    3176:	4c 89 ef             	mov    %r13,%rdi
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph));
    nova_dbg("%s start dentry %s",__func__,ph);
    ph = get_dentry_path(dentry,0);
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    3179:	48 8b 40 10          	mov    0x10(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    317d:	48 89 c6             	mov    %rax,%rsi
    3180:	48 03 72 18          	add    0x18(%rdx),%rsi
    3184:	48 85 c0             	test   %rax,%rax
    3187:	b8 00 00 00 00       	mov    $0x0,%eax
    318c:	48 0f 45 c6          	cmovne %rsi,%rax
    phlen = strlen(phn);
    3190:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    3194:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    3199:	31 c0                	xor    %eax,%eax
    319b:	f2 ae                	repnz scas %es:(%rdi),%al

    if(phlen==1){
        flen = strlen(ph);
    319d:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
    //memcpy(phname, ph, strlen(ph));
    nova_dbg("%s start dentry %s",__func__,ph);
    ph = get_dentry_path(dentry,0);
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    31a2:	48 89 ca             	mov    %rcx,%rdx

    if(phlen==1){
        flen = strlen(ph);
    31a5:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    //memcpy(phname, ph, strlen(ph));
    nova_dbg("%s start dentry %s",__func__,ph);
    ph = get_dentry_path(dentry,0);
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    31a9:	48 f7 d2             	not    %rdx
    31ac:	48 83 ea 01          	sub    $0x1,%rdx

    if(phlen==1){
    31b0:	48 83 fa 01          	cmp    $0x1,%rdx
    31b4:	0f 84 94 03 00 00    	je     354e <dafs_rm_dir+0x51e>
        flen = strlen(ph);
        memcpy(phname, ph, flen);
    } else {
        flen = strlen(ph)-phlen;
    31ba:	31 c0                	xor    %eax,%eax
    31bc:	f2 ae                	repnz scas %es:(%rdi),%al
        memcpy(phname, ph+phlen, flen);
    31be:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi

    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
    } else {
        flen = strlen(ph)-phlen;
    31c3:	48 f7 d1             	not    %rcx
    31c6:	49 89 cd             	mov    %rcx,%r13
        memcpy(phname, ph+phlen, flen);
    31c9:	48 8d 34 17          	lea    (%rdi,%rdx,1),%rsi

    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
    } else {
        flen = strlen(ph)-phlen;
    31cd:	49 83 ed 01          	sub    $0x1,%r13
        memcpy(phname, ph+phlen, flen);
    31d1:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi

    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
    } else {
        flen = strlen(ph)-phlen;
    31d6:	49 29 d5             	sub    %rdx,%r13
        memcpy(phname, ph+phlen, flen);
    31d9:	4c 89 ea             	mov    %r13,%rdx
    31dc:	e8 00 00 00 00       	callq  31e1 <dafs_rm_dir+0x1b1>
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    31e1:	45 85 ed             	test   %r13d,%r13d
    31e4:	0f 8e 87 03 00 00    	jle    3571 <dafs_rm_dir+0x541>
    31ea:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
    31ef:	41 8d 45 ff          	lea    -0x1(%r13),%eax
    31f3:	45 31 ed             	xor    %r13d,%r13d
    31f6:	48 8d 4c 02 01       	lea    0x1(%rdx,%rax,1),%rcx
    31fb:	48 89 d0             	mov    %rdx,%rax
		hash = hash * seed + (*str++);
    31fe:	4c 89 ea             	mov    %r13,%rdx
    3201:	48 83 c0 01          	add    $0x1,%rax
    3205:	48 c1 e2 06          	shl    $0x6,%rdx
    3209:	4c 01 ea             	add    %r13,%rdx
    320c:	49 8d 54 55 00       	lea    0x0(%r13,%rdx,2),%rdx
    3211:	4c 0f be 68 ff       	movsbq -0x1(%rax),%r13
    3216:	49 01 d5             	add    %rdx,%r13
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    3219:	48 39 c1             	cmp    %rax,%rcx
    321c:	75 e0                	jne    31fe <dafs_rm_dir+0x1ce>

    dzt_eno = dzt_ei->dzt_eno;
    ph_hash = BKDRHash(phname, flen);

    /*lookup in hash table*/
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    321e:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    3223:	4c 8d 44 24 44       	lea    0x44(%rsp),%r8
    3228:	b9 01 00 00 00       	mov    $0x1,%ecx
    322d:	4c 89 ea             	mov    %r13,%rdx
    3230:	48 89 df             	mov    %rbx,%rdi
    3233:	48 8b 70 18          	mov    0x18(%rax),%rsi
    3237:	e8 00 00 00 00       	callq  323c <dafs_rm_dir+0x20c>
    if(!ret)
    323c:	85 c0                	test   %eax,%eax
    323e:	0f 84 45 fe ff ff    	je     3089 <dafs_rm_dir+0x59>
        return -EINVAL;

    dafs_de = &dafs_ze->dentry[de_pos];
    3244:	8b 44 24 44          	mov    0x44(%rsp),%eax
        ei_hash = le64_to_cpu(dafs_de->dzt_hn);
        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
        free_zone_area(sb, sub_ei);
    }*/

	links_count = cpu_to_le16(dir->i_nlink);
    3248:	41 8b 4c 24 48       	mov    0x48(%r12),%ecx
    /*lookup in hash table*/
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    if(!ret)
        return -EINVAL;

    dafs_de = &dafs_ze->dentry[de_pos];
    324d:	48 89 c2             	mov    %rax,%rdx
    3250:	48 89 04 24          	mov    %rax,(%rsp)
    3254:	48 05 81 00 00 00    	add    $0x81,%rax
    325a:	48 c1 e0 07          	shl    $0x7,%rax
    325e:	48 03 44 24 30       	add    0x30(%rsp),%rax
        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
        free_zone_area(sb, sub_ei);
    }*/

	links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
    3263:	66 85 c9             	test   %cx,%cx
    /*lookup in hash table*/
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    if(!ret)
        return -EINVAL;

    dafs_de = &dafs_ze->dentry[de_pos];
    3266:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
        free_zone_area(sb, sub_ei);
    }*/

	links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
    326b:	0f 85 9a 02 00 00    	jne    350b <dafs_rm_dir+0x4db>
		links_count = 0;
    3271:	31 c0                	xor    %eax,%eax
        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
        free_zone_area(sb, sub_ei);
    }*/

	links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
    3273:	41 83 fe ff          	cmp    $0xffffffff,%r14d
    3277:	0f 85 8e 02 00 00    	jne    350b <dafs_rm_dir+0x4db>
    327d:	48 8b 0c 24          	mov    (%rsp),%rcx
    3281:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
    3286:	48 c1 e1 07          	shl    $0x7,%rcx
    328a:	4c 8d 34 0e          	lea    (%rsi,%rcx,1),%r14
		links_count = 0;
	else
		links_count += link_change;
	dafs_de->links_count = cpu_to_le16(links_count);
    328e:	66 41 89 86 86 40 00 	mov    %ax,0x4086(%r14)
    3295:	00 

    bitpos = de_pos * 2;
   
    /*remove from par*/
    par_pos = le32_to_cpu(dafs_de->par_pos);
    if(dir->i_ino == NOVA_ROOT_INO || par_pos!=0){
    3296:	49 83 7c 24 40 01    	cmpq   $0x1,0x40(%r12)
		links_count = 0;
	else
		links_count += link_change;
	dafs_de->links_count = cpu_to_le16(links_count);

    bitpos = de_pos * 2;
    329c:	8d 04 12             	lea    (%rdx,%rdx,1),%eax
    329f:	89 44 24 0c          	mov    %eax,0xc(%rsp)
   
    /*remove from par*/
    par_pos = le32_to_cpu(dafs_de->par_pos);
    32a3:	41 8b 86 8c 40 00 00 	mov    0x408c(%r14),%eax
    if(dir->i_ino == NOVA_ROOT_INO || par_pos!=0){
    32aa:	0f 84 d3 01 00 00    	je     3483 <dafs_rm_dir+0x453>
    32b0:	85 c0                	test   %eax,%eax
    32b2:	0f 85 cb 01 00 00    	jne    3483 <dafs_rm_dir+0x453>
            }
        }
    } 

CONT:
    make_zone_ptr(&z_p, dafs_ze);
    32b8:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
    32bd:	48 8d 7c 24 48       	lea    0x48(%rsp),%rdi
    32c2:	e8 00 00 00 00       	callq  32c7 <dafs_rm_dir+0x297>
    test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    32c7:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
}

static inline int test_and_clear_bit_le(int nr, void *addr)
{
	return test_and_clear_bit(nr ^ BITOP_LE_SWIZZLE, addr);
    32cc:	48 63 54 24 0c       	movslq 0xc(%rsp),%rdx
    32d1:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_clear_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "btr", *addr, "Ir", nr, "%0", "c");
    32d4:	f0 48 0f b3 10       	lock btr %rdx,(%rax)
    32d9:	72 00                	jb     32db <dafs_rm_dir+0x2ab>
	bitpos++;
    test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    32db:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    32e0:	48 8b 10             	mov    (%rax),%rdx
    32e3:	8b 44 24 0c          	mov    0xc(%rsp),%eax
    32e7:	83 c0 01             	add    $0x1,%eax
    32ea:	48 98                	cltq   
    32ec:	f0 48 0f b3 02       	lock btr %rax,(%rdx)
    32f1:	72 00                	jb     32f3 <dafs_rm_dir+0x2c3>
    make_invalid_htable(sb, dzt_ei->ht_head, ph_hash, 1);
    32f3:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    32f8:	b9 01 00 00 00       	mov    $0x1,%ecx
    32fd:	4c 89 ea             	mov    %r13,%rdx
    3300:	48 89 df             	mov    %rbx,%rdi
    3303:	48 8b 70 18          	mov    0x18(%rax),%rsi
    3307:	e8 00 00 00 00       	callq  330c <dafs_rm_dir+0x2dc>
    delete_ext(z_p, dafs_de);
    330c:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
    3311:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    3316:	e8 00 00 00 00       	callq  331b <dafs_rm_dir+0x2eb>

    if(dafs_de->file_type == ROOT_DIRECTORY) {
    331b:	41 80 be 82 40 00 00 	cmpb   $0x2,0x4082(%r14)
    3322:	02 
    3323:	0f 84 eb 01 00 00    	je     3514 <dafs_rm_dir+0x4e4>
    }
    /*make invalid sub file only for empty dir
     * free dir_tree*/
    this = NULL;
    next = NULL;
    rm_dir = radix_tree_delete(&dzt_ei->dir_tree, ph_hash);
    3329:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    332e:	4c 89 ee             	mov    %r13,%rsi
    3331:	48 8d 78 38          	lea    0x38(%rax),%rdi
    3335:	e8 00 00 00 00       	callq  333a <dafs_rm_dir+0x30a>
    head = &rm_dir->sub_file;
    list_for_each_safe(this, next, head){
    333a:	4c 8b 78 18          	mov    0x18(%rax),%r15
    /*make invalid sub file only for empty dir
     * free dir_tree*/
    this = NULL;
    next = NULL;
    rm_dir = radix_tree_delete(&dzt_ei->dir_tree, ph_hash);
    head = &rm_dir->sub_file;
    333e:	4c 8d 70 18          	lea    0x18(%rax),%r14
    }
    /*make invalid sub file only for empty dir
     * free dir_tree*/
    this = NULL;
    next = NULL;
    rm_dir = radix_tree_delete(&dzt_ei->dir_tree, ph_hash);
    3342:	49 89 c4             	mov    %rax,%r12
    head = &rm_dir->sub_file;
    list_for_each_safe(this, next, head){
    3345:	4d 8b 2f             	mov    (%r15),%r13
    3348:	4d 39 fe             	cmp    %r15,%r14
    334b:	4c 89 e8             	mov    %r13,%rax
    334e:	4d 89 e5             	mov    %r12,%r13
    3351:	0f 84 aa 00 00 00    	je     3401 <dafs_rm_dir+0x3d1>
        rm_sf = list_entry(this, struct file_p, list);
        sub_pos = rm_sf->pos;
    3357:	41 8b 57 10          	mov    0x10(%r15),%edx
        bitpos = sub_pos*2;
        sub_de = &dafs_ze->dentry[sub_pos];
        sub_hash = le64_to_cpu(sub_de->hname);
    335b:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
    3360:	49 89 c4             	mov    %rax,%r12
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    3363:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
    rm_dir = radix_tree_delete(&dzt_ei->dir_tree, ph_hash);
    head = &rm_dir->sub_file;
    list_for_each_safe(this, next, head){
        rm_sf = list_entry(this, struct file_p, list);
        sub_pos = rm_sf->pos;
        bitpos = sub_pos*2;
    3368:	8d 04 12             	lea    (%rdx,%rdx,1),%eax
        sub_de = &dafs_ze->dentry[sub_pos];
        sub_hash = le64_to_cpu(sub_de->hname);
    336b:	48 c1 e2 07          	shl    $0x7,%rdx
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    336f:	48 8b 09             	mov    (%rcx),%rcx
    list_for_each_safe(this, next, head){
        rm_sf = list_entry(this, struct file_p, list);
        sub_pos = rm_sf->pos;
        bitpos = sub_pos*2;
        sub_de = &dafs_ze->dentry[sub_pos];
        sub_hash = le64_to_cpu(sub_de->hname);
    3372:	48 8b 94 16 a8 40 00 	mov    0x40a8(%rsi,%rdx,1),%rdx
    3379:	00 
    337a:	48 63 f0             	movslq %eax,%rsi
    337d:	f0 48 0f b3 31       	lock btr %rsi,(%rcx)
    3382:	72 00                	jb     3384 <dafs_rm_dir+0x354>
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    3384:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
    3389:	83 c0 01             	add    $0x1,%eax
    338c:	48 98                	cltq   
    338e:	48 8b 09             	mov    (%rcx),%rcx
    3391:	f0 48 0f b3 01       	lock btr %rax,(%rcx)
    3396:	72 00                	jb     3398 <dafs_rm_dir+0x368>
        make_invalid_htable(sb, dzt_ei->ht_head, sub_hash, 1);
    3398:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    339d:	b9 01 00 00 00       	mov    $0x1,%ecx
    33a2:	48 89 df             	mov    %rbx,%rdi
    33a5:	48 8b 70 18          	mov    0x18(%rax),%rsi
    33a9:	e8 00 00 00 00       	callq  33ae <dafs_rm_dir+0x37e>
        delete_ext(z_p, dafs_de);
    33ae:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
    33b3:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    33b8:	e8 00 00 00 00       	callq  33bd <dafs_rm_dir+0x38d>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    33bd:	49 8b 47 08          	mov    0x8(%r15),%rax
    33c1:	49 8b 17             	mov    (%r15),%rdx
        list_del(&rm_sf->list);
        kfree(rm_sf);
    33c4:	4c 89 ff             	mov    %r15,%rdi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    33c7:	48 89 42 08          	mov    %rax,0x8(%rdx)
	prev->next = next;
    33cb:	48 89 10             	mov    %rdx,(%rax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    33ce:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
    33d5:	00 ad de 
    33d8:	49 89 07             	mov    %rax,(%r15)
	entry->prev = LIST_POISON2;
    33db:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
    33e2:	00 ad de 
    33e5:	49 89 47 08          	mov    %rax,0x8(%r15)
    33e9:	4d 89 e7             	mov    %r12,%r15
    33ec:	e8 00 00 00 00       	callq  33f1 <dafs_rm_dir+0x3c1>
     * free dir_tree*/
    this = NULL;
    next = NULL;
    rm_dir = radix_tree_delete(&dzt_ei->dir_tree, ph_hash);
    head = &rm_dir->sub_file;
    list_for_each_safe(this, next, head){
    33f1:	4d 39 e6             	cmp    %r12,%r14
    33f4:	49 8b 04 24          	mov    (%r12),%rax
    33f8:	0f 85 59 ff ff ff    	jne    3357 <dafs_rm_dir+0x327>
    33fe:	4d 89 ec             	mov    %r13,%r12
        delete_ext(z_p, dafs_de);
        list_del(&rm_sf->list);
        kfree(rm_sf);
    }

    kfree(rm_dir);
    3401:	4c 89 e7             	mov    %r12,%rdi
    3404:	e8 00 00 00 00       	callq  3409 <dafs_rm_dir+0x3d9>
    tes_empty_zone(sb, z_p);
    3409:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
    340e:	48 89 df             	mov    %rbx,%rdi
    3411:	e8 00 00 00 00       	callq  3416 <dafs_rm_dir+0x3e6>
    //ret = __remove_direntry(sb, dafs_de, dafs_ze, dzt_ei, de_pos);

    //if(ret)
        //return ret;
END:
    kfree(phname);
    3416:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    341b:	e8 00 00 00 00       	callq  3420 <dafs_rm_dir+0x3f0>
    kfree(ph);
    3420:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
    3425:	e8 00 00 00 00       	callq  342a <dafs_rm_dir+0x3fa>
    kfree(phn);
    342a:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
    342f:	e8 00 00 00 00       	callq  3434 <dafs_rm_dir+0x404>
    
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    3434:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 343b <dafs_rm_dir+0x40b>
    343b:	74 2d                	je     346a <dafs_rm_dir+0x43a>
    343d:	48 8d 7c 24 60       	lea    0x60(%rsp),%rdi
    3442:	e8 00 00 00 00       	callq  3447 <dafs_rm_dir+0x417>
    3447:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
    344c:	48 2b 44 24 50       	sub    0x50(%rsp),%rax
    3451:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    3458:	48 2b 44 24 58       	sub    0x58(%rsp),%rax
    345d:	48 03 44 24 68       	add    0x68(%rsp),%rax
    3462:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 346a <dafs_rm_dir+0x43a>
    3469:	00 
    kfree(z_p);
    346a:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    kfree(phname);
    kfree(ph);
    kfree(phn);
    
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    346f:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 3477 <dafs_rm_dir+0x447>
    3476:	00 
    kfree(z_p);
    3477:	e8 00 00 00 00       	callq  347c <dafs_rm_dir+0x44c>
    //nova_dbg("%s end",__func__);
	return 0;
    347c:	31 c0                	xor    %eax,%eax
    347e:	e9 0b fc ff ff       	jmpq   308e <dafs_rm_dir+0x5e>
    /*remove from par*/
    par_pos = le32_to_cpu(dafs_de->par_pos);
    if(dir->i_ino == NOVA_ROOT_INO || par_pos!=0){
        par_de = &dafs_ze->dentry[par_pos];
        par_hash = le64_to_cpu(par_de->hname);
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    3483:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
   
    /*remove from par*/
    par_pos = le32_to_cpu(dafs_de->par_pos);
    if(dir->i_ino == NOVA_ROOT_INO || par_pos!=0){
        par_de = &dafs_ze->dentry[par_pos];
        par_hash = le64_to_cpu(par_de->hname);
    3488:	48 c1 e0 07          	shl    $0x7,%rax
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    348c:	48 8b b4 02 a8 40 00 	mov    0x40a8(%rdx,%rax,1),%rsi
    3493:	00 
    3494:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    3499:	48 8d 78 38          	lea    0x38(%rax),%rdi
    349d:	e8 00 00 00 00       	callq  34a2 <dafs_rm_dir+0x472>
        head = &par_dir->sub_file;
        list_for_each_safe(this, next, head) {
    34a2:	48 8b 78 18          	mov    0x18(%rax),%rdi
    par_pos = le32_to_cpu(dafs_de->par_pos);
    if(dir->i_ino == NOVA_ROOT_INO || par_pos!=0){
        par_de = &dafs_ze->dentry[par_pos];
        par_hash = le64_to_cpu(par_de->hname);
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        head = &par_dir->sub_file;
    34a6:	48 8d 50 18          	lea    0x18(%rax),%rdx
        list_for_each_safe(this, next, head) {
    34aa:	48 39 fa             	cmp    %rdi,%rdx
    34ad:	48 8b 37             	mov    (%rdi),%rsi
    34b0:	0f 84 02 fe ff ff    	je     32b8 <dafs_rm_dir+0x288>
            rm_sf = list_entry(this, struct file_p, list);
            if(rm_sf->pos == de_pos){
    34b6:	8b 4c 24 44          	mov    0x44(%rsp),%ecx
    34ba:	3b 4f 10             	cmp    0x10(%rdi),%ecx
    34bd:	74 14                	je     34d3 <dafs_rm_dir+0x4a3>
    if(dir->i_ino == NOVA_ROOT_INO || par_pos!=0){
        par_de = &dafs_ze->dentry[par_pos];
        par_hash = le64_to_cpu(par_de->hname);
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        head = &par_dir->sub_file;
        list_for_each_safe(this, next, head) {
    34bf:	48 89 f7             	mov    %rsi,%rdi
    34c2:	48 8b 36             	mov    (%rsi),%rsi
    34c5:	48 39 fa             	cmp    %rdi,%rdx
    34c8:	0f 84 ea fd ff ff    	je     32b8 <dafs_rm_dir+0x288>
            rm_sf = list_entry(this, struct file_p, list);
            if(rm_sf->pos == de_pos){
    34ce:	39 4f 10             	cmp    %ecx,0x10(%rdi)
    34d1:	75 ec                	jne    34bf <dafs_rm_dir+0x48f>
                par_dir->sub_num--;
    34d3:	48 83 68 08 01       	subq   $0x1,0x8(%rax)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    34d8:	48 8b 47 08          	mov    0x8(%rdi),%rax
    34dc:	48 8b 17             	mov    (%rdi),%rdx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    34df:	48 89 42 08          	mov    %rax,0x8(%rdx)
	prev->next = next;
    34e3:	48 89 10             	mov    %rdx,(%rax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    34e6:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
    34ed:	00 ad de 
    34f0:	48 89 07             	mov    %rax,(%rdi)
	entry->prev = LIST_POISON2;
    34f3:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
    34fa:	00 ad de 
    34fd:	48 89 47 08          	mov    %rax,0x8(%rdi)
                list_del(&rm_sf->list);
                kfree(rm_sf);
    3501:	e8 00 00 00 00       	callq  3506 <dafs_rm_dir+0x4d6>
                goto CONT;
    3506:	e9 ad fd ff ff       	jmpq   32b8 <dafs_rm_dir+0x288>

	links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
		links_count = 0;
	else
		links_count += link_change;
    350b:	42 8d 04 31          	lea    (%rcx,%r14,1),%eax
    350f:	e9 69 fd ff ff       	jmpq   327d <dafs_rm_dir+0x24d>
    make_invalid_htable(sb, dzt_ei->ht_head, ph_hash, 1);
    delete_ext(z_p, dafs_de);

    if(dafs_de->file_type == ROOT_DIRECTORY) {
        //nova_dbg("%s dentry is root zone",__func__);
        delete_dir_info(dzt_ei, ph_hash);
    3514:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
    3519:	4c 89 ee             	mov    %r13,%rsi
    351c:	e8 00 00 00 00       	callq  3521 <dafs_rm_dir+0x4f1>
        ei_hash = le64_to_cpu(dafs_de->dzt_hn);
    3521:	48 8b 04 24          	mov    (%rsp),%rax
        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
    3525:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    352a:	4c 89 ff             	mov    %r15,%rdi
    delete_ext(z_p, dafs_de);

    if(dafs_de->file_type == ROOT_DIRECTORY) {
        //nova_dbg("%s dentry is root zone",__func__);
        delete_dir_info(dzt_ei, ph_hash);
        ei_hash = le64_to_cpu(dafs_de->dzt_hn);
    352d:	48 c1 e0 07          	shl    $0x7,%rax
        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
    3531:	48 8b b4 02 a8 40 00 	mov    0x40a8(%rdx,%rax,1),%rsi
    3538:	00 
    3539:	e8 00 00 00 00       	callq  353e <dafs_rm_dir+0x50e>
        free_zone_area(sb, sub_ei);
    353e:	48 89 df             	mov    %rbx,%rdi
    3541:	48 89 c6             	mov    %rax,%rsi
    3544:	e8 00 00 00 00       	callq  3549 <dafs_rm_dir+0x519>
        goto END;
    3549:	e9 c8 fe ff ff       	jmpq   3416 <dafs_rm_dir+0x3e6>
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);

    if(phlen==1){
        flen = strlen(ph);
    354e:	f2 ae                	repnz scas %es:(%rdi),%al
        memcpy(phname, ph, flen);
    3550:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
    3555:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);

    if(phlen==1){
        flen = strlen(ph);
    355a:	48 f7 d1             	not    %rcx
    355d:	49 89 cd             	mov    %rcx,%r13
    3560:	49 83 ed 01          	sub    $0x1,%r13
        memcpy(phname, ph, flen);
    3564:	4c 89 ea             	mov    %r13,%rdx
    3567:	e8 00 00 00 00       	callq  356c <dafs_rm_dir+0x53c>
    356c:	e9 70 fc ff ff       	jmpq   31e1 <dafs_rm_dir+0x1b1>

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    3571:	45 31 ed             	xor    %r13d,%r13d
    3574:	e9 a5 fc ff ff       	jmpq   321e <dafs_rm_dir+0x1ee>
    3579:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000003580 <dafs_remove_dentry>:
	return 0;
}

/*remove dir when use rename*/
int dafs_remove_dentry(struct dentry *dentry)
{
    3580:	e8 00 00 00 00       	callq  3585 <dafs_remove_dentry+0x5>
    3585:	55                   	push   %rbp
    3586:	48 89 e5             	mov    %rsp,%rbp
    3589:	41 57                	push   %r15
    358b:	41 56                	push   %r14
    358d:	41 55                	push   %r13
    358f:	41 54                	push   %r12
    3591:	49 89 fc             	mov    %rdi,%r12
    3594:	53                   	push   %rbx
    3595:	48 83 ec 48          	sub    $0x48,%rsp
    char *phname, *ph, *phn;
    int ret;
	timing_t remove_dentry_time;

    //nova_dbg("dafs start removing dentry");
	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    3599:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 359f <dafs_remove_dentry+0x1f>
	return 0;
}

/*remove dir when use rename*/
int dafs_remove_dentry(struct dentry *dentry)
{
    359f:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    35a6:	00 00 
    35a8:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
    35ad:	31 c0                	xor    %eax,%eax
    struct inode *dir = dentry->d_parent->d_inode;
    35af:	48 8b 47 18          	mov    0x18(%rdi),%rax
    char *phname, *ph, *phn;
    int ret;
	timing_t remove_dentry_time;

    //nova_dbg("dafs start removing dentry");
	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    35b3:	85 f6                	test   %esi,%esi
}

/*remove dir when use rename*/
int dafs_remove_dentry(struct dentry *dentry)
{
    struct inode *dir = dentry->d_parent->d_inode;
    35b5:	48 8b 58 30          	mov    0x30(%rax),%rbx
    struct super_block *sb = dir->i_sb;
    35b9:	4c 8b 7b 28          	mov    0x28(%rbx),%r15
    char *phname, *ph, *phn;
    int ret;
	timing_t remove_dentry_time;

    //nova_dbg("dafs start removing dentry");
	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    35bd:	75 2f                	jne    35ee <dafs_remove_dentry+0x6e>

	if (!dentry->d_name.len)
    35bf:	8b 47 24             	mov    0x24(%rdi),%eax
    35c2:	85 c0                	test   %eax,%eax
    35c4:	75 3b                	jne    3601 <dafs_remove_dentry+0x81>
		return -EINVAL;
    35c6:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    //nova_dbg("%s end", __func__);
	return 0;
}
    35cb:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
    35d0:	65 48 33 3c 25 28 00 	xor    %gs:0x28,%rdi
    35d7:	00 00 
    35d9:	0f 85 f9 02 00 00    	jne    38d8 <dafs_remove_dentry+0x358>
    35df:	48 83 c4 48          	add    $0x48,%rsp
    35e3:	5b                   	pop    %rbx
    35e4:	41 5c                	pop    %r12
    35e6:	41 5d                	pop    %r13
    35e8:	41 5e                	pop    %r14
    35ea:	41 5f                	pop    %r15
    35ec:	5d                   	pop    %rbp
    35ed:	c3                   	retq   
    35ee:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
    35f3:	e8 00 00 00 00       	callq  35f8 <dafs_remove_dentry+0x78>
	timing_t remove_dentry_time;

    //nova_dbg("dafs start removing dentry");
	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);

	if (!dentry->d_name.len)
    35f8:	41 8b 4c 24 24       	mov    0x24(%r12),%ecx
    35fd:	85 c9                	test   %ecx,%ecx
    35ff:	74 c5                	je     35c6 <dafs_remove_dentry+0x46>
		return -EINVAL;


	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    3601:	e8 00 00 00 00       	callq  3606 <dafs_remove_dentry+0x86>
    3606:	48 c7 83 80 00 00 00 	movq   $0x0,0x80(%rbx)
    360d:	00 00 00 00 
    3611:	48 89 43 78          	mov    %rax,0x78(%rbx)

    /*直接rm direntry就可以
    * 先找到相应的dir*/    
    ph = get_dentry_path(dentry,0);
    3615:	4c 89 e7             	mov    %r12,%rdi

	if (!dentry->d_name.len)
		return -EINVAL;


	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    3618:	48 8b 93 80 00 00 00 	mov    0x80(%rbx),%rdx
    361f:	48 8b 43 78          	mov    0x78(%rbx),%rax
    3623:	48 89 53 70          	mov    %rdx,0x70(%rbx)
    3627:	48 89 43 68          	mov    %rax,0x68(%rbx)

    /*直接rm direntry就可以
    * 先找到相应的dir*/    
    ph = get_dentry_path(dentry,0);
    362b:	e8 d0 ca ff ff       	callq  100 <get_dentry_path.isra.4>
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    3630:	48 89 c7             	mov    %rax,%rdi

	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;

    /*直接rm direntry就可以
    * 先找到相应的dir*/    
    ph = get_dentry_path(dentry,0);
    3633:	49 89 c5             	mov    %rax,%r13
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    3636:	e8 00 00 00 00       	callq  363b <dafs_remove_dentry+0xbb>
    363b:	be d0 80 00 00       	mov    $0x80d0,%esi
    3640:	48 89 c7             	mov    %rax,%rdi
    3643:	e8 00 00 00 00       	callq  3648 <dafs_remove_dentry+0xc8>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    3648:	4c 89 ef             	mov    %r13,%rdi
    364b:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    3650:	e8 00 00 00 00       	callq  3655 <dafs_remove_dentry+0xd5>
    3655:	be d0 80 00 00       	mov    $0x80d0,%esi
    365a:	48 89 c7             	mov    %rax,%rdi
    365d:	e8 00 00 00 00       	callq  3662 <dafs_remove_dentry+0xe2>
    3662:	49 89 c4             	mov    %rax,%r12
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    3665:	49 8b 87 b0 03 00 00 	mov    0x3b0(%r15),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    366c:	4c 89 ef             	mov    %r13,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    366f:	4c 8b b0 d8 01 00 00 	mov    0x1d8(%rax),%r14
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    3676:	e8 00 00 00 00       	callq  367b <dafs_remove_dentry+0xfb>
    367b:	4c 89 ee             	mov    %r13,%rsi
    367e:	48 89 c2             	mov    %rax,%rdx
    3681:	4c 89 e7             	mov    %r12,%rdi
    3684:	e8 00 00 00 00       	callq  3689 <dafs_remove_dentry+0x109>
    tlen = strlen(phstr);
    3689:	4c 89 ef             	mov    %r13,%rdi
    368c:	e8 00 00 00 00       	callq  3691 <dafs_remove_dentry+0x111>
    3691:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
    3694:	be 2f 00 00 00       	mov    $0x2f,%esi
    3699:	4c 89 e7             	mov    %r12,%rdi
    369c:	e8 00 00 00 00       	callq  36a1 <dafs_remove_dentry+0x121>
        phlen = tlen -strlen(tem);
    36a1:	48 89 c7             	mov    %rax,%rdi
    36a4:	e8 00 00 00 00       	callq  36a9 <dafs_remove_dentry+0x129>
        tlen = phlen;
        //bug
        if(phlen==0){
    36a9:	48 29 c3             	sub    %rax,%rbx
    36ac:	0f 84 9f 01 00 00    	je     3851 <dafs_remove_dentry+0x2d1>
            break;
        }
        memcpy(ph,phstr,tlen);
    36b2:	48 89 da             	mov    %rbx,%rdx
    36b5:	4c 89 ee             	mov    %r13,%rsi
    36b8:	4c 89 e7             	mov    %r12,%rdi
    36bb:	e8 00 00 00 00       	callq  36c0 <dafs_remove_dentry+0x140>
	int i;

	for (i = 0; i < length; i++) {
    36c0:	85 db                	test   %ebx,%ebx
        memcpy(ph+tlen, end, 1);
    36c2:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
    36c7:	0f 8e 69 01 00 00    	jle    3836 <dafs_remove_dentry+0x2b6>
    36cd:	8d 43 ff             	lea    -0x1(%rbx),%eax
    36d0:	4c 89 e2             	mov    %r12,%rdx
    36d3:	31 f6                	xor    %esi,%esi
    36d5:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
    36da:	48 89 f0             	mov    %rsi,%rax
    36dd:	48 83 c2 01          	add    $0x1,%rdx
    36e1:	48 c1 e0 06          	shl    $0x6,%rax
    36e5:	48 01 f0             	add    %rsi,%rax
    36e8:	48 8d 04 46          	lea    (%rsi,%rax,2),%rax
    36ec:	48 0f be 72 ff       	movsbq -0x1(%rdx),%rsi
    36f1:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    36f4:	48 39 d1             	cmp    %rdx,%rcx
    36f7:	75 e1                	jne    36da <dafs_remove_dentry+0x15a>
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    36f9:	4c 89 f7             	mov    %r14,%rdi
    36fc:	e8 00 00 00 00       	callq  3701 <dafs_remove_dentry+0x181>
        if(dzt_ei){
    3701:	48 85 c0             	test   %rax,%rax
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    3704:	49 89 c1             	mov    %rax,%r9
        if(dzt_ei){
    3707:	74 8b                	je     3694 <dafs_remove_dentry+0x114>
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph));
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    3709:	49 8b 41 10          	mov    0x10(%r9),%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    370d:	49 8b 97 b0 03 00 00 	mov    0x3b0(%r15),%rdx
    phlen = strlen(phn);
    3714:	4c 89 e7             	mov    %r12,%rdi
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph));
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    3717:	4c 89 4c 24 08       	mov    %r9,0x8(%rsp)
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    371c:	48 89 c3             	mov    %rax,%rbx
    371f:	48 03 5a 18          	add    0x18(%rdx),%rbx
    3723:	48 85 c0             	test   %rax,%rax
    3726:	b8 00 00 00 00       	mov    $0x0,%eax
    372b:	48 0f 44 d8          	cmove  %rax,%rbx
    phlen = strlen(phn);
    372f:	e8 00 00 00 00       	callq  3734 <dafs_remove_dentry+0x1b4>
    if(phlen==1){
    3734:	48 83 f8 01          	cmp    $0x1,%rax
    3738:	4c 8b 4c 24 08       	mov    0x8(%rsp),%r9
    373d:	0f 84 37 01 00 00    	je     387a <dafs_remove_dentry+0x2fa>
        flen = strlen(ph);
        memcpy(phname, ph, flen);
    } else {
        flen = strlen(ph)-phlen;
    3743:	4c 89 ef             	mov    %r13,%rdi
    3746:	4c 89 4c 24 08       	mov    %r9,0x8(%rsp)
    374b:	48 89 04 24          	mov    %rax,(%rsp)
    374f:	e8 00 00 00 00       	callq  3754 <dafs_remove_dentry+0x1d4>
    3754:	48 8b 14 24          	mov    (%rsp),%rdx
        memcpy(phname, ph+phlen, flen);
    3758:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
    } else {
        flen = strlen(ph)-phlen;
    375d:	48 29 d0             	sub    %rdx,%rax
        memcpy(phname, ph+phlen, flen);
    3760:	49 8d 74 15 00       	lea    0x0(%r13,%rdx,1),%rsi
    3765:	48 89 c2             	mov    %rax,%rdx
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
    } else {
        flen = strlen(ph)-phlen;
    3768:	49 89 c6             	mov    %rax,%r14
        memcpy(phname, ph+phlen, flen);
    376b:	e8 00 00 00 00       	callq  3770 <dafs_remove_dentry+0x1f0>
    3770:	4c 8b 4c 24 08       	mov    0x8(%rsp),%r9
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    3775:	45 85 f6             	test   %r14d,%r14d
    3778:	0f 8e 53 01 00 00    	jle    38d1 <dafs_remove_dentry+0x351>
    377e:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
    3783:	41 8d 46 ff          	lea    -0x1(%r14),%eax
    3787:	31 d2                	xor    %edx,%edx
    3789:	48 8d 74 07 01       	lea    0x1(%rdi,%rax,1),%rsi
    378e:	48 89 f9             	mov    %rdi,%rcx
		hash = hash * seed + (*str++);
    3791:	48 89 d0             	mov    %rdx,%rax
    3794:	48 83 c1 01          	add    $0x1,%rcx
    3798:	48 c1 e0 06          	shl    $0x6,%rax
    379c:	48 01 d0             	add    %rdx,%rax
    379f:	48 8d 04 42          	lea    (%rdx,%rax,2),%rax
    37a3:	48 0f be 51 ff       	movsbq -0x1(%rcx),%rdx
    37a8:	48 01 c2             	add    %rax,%rdx
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    37ab:	48 39 f1             	cmp    %rsi,%rcx
    37ae:	75 e1                	jne    3791 <dafs_remove_dentry+0x211>

    dzt_eno = dzt_ei->dzt_eno;
    ph_hash = BKDRHash(phname, flen);

    /*lookup in hash table*/
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    37b0:	49 8b 71 18          	mov    0x18(%r9),%rsi
    37b4:	4c 8d 44 24 1c       	lea    0x1c(%rsp),%r8
    37b9:	b9 01 00 00 00       	mov    $0x1,%ecx
    37be:	4c 89 ff             	mov    %r15,%rdi
    37c1:	4c 89 4c 24 08       	mov    %r9,0x8(%rsp)
    37c6:	e8 00 00 00 00       	callq  37cb <dafs_remove_dentry+0x24b>
    if(!ret){
    37cb:	85 c0                	test   %eax,%eax
    37cd:	0f 84 f3 fd ff ff    	je     35c6 <dafs_remove_dentry+0x46>
        //nova_dbg("not find in hashtable");
        return -EINVAL;
    }

    dafs_de = &dafs_ze->dentry[de_pos];
    37d3:	8b 74 24 1c          	mov    0x1c(%rsp),%esi
    /*
    de_addr = le64_to_cpu(&dafs_de);
    record_dir_log(sb, de_addr, 0, DIR_RMDIR);*/

    
    ret = __remove_direntry(sb, dafs_de, dafs_ze, dzt_ei, de_pos);
    37d7:	4c 8b 4c 24 08       	mov    0x8(%rsp),%r9
    37dc:	48 89 da             	mov    %rbx,%rdx
    37df:	4c 89 ff             	mov    %r15,%rdi
    37e2:	4c 89 c9             	mov    %r9,%rcx
    if(!ret){
        //nova_dbg("not find in hashtable");
        return -EINVAL;
    }

    dafs_de = &dafs_ze->dentry[de_pos];
    37e5:	49 89 f0             	mov    %rsi,%r8
    37e8:	48 81 c6 81 00 00 00 	add    $0x81,%rsi
    37ef:	48 c1 e6 07          	shl    $0x7,%rsi
    37f3:	48 01 de             	add    %rbx,%rsi
    /*
    de_addr = le64_to_cpu(&dafs_de);
    record_dir_log(sb, de_addr, 0, DIR_RMDIR);*/

    
    ret = __remove_direntry(sb, dafs_de, dafs_ze, dzt_ei, de_pos);
    37f6:	e8 95 e6 ff ff       	callq  1e90 <__remove_direntry>

    if(ret)
    37fb:	85 c0                	test   %eax,%eax
    37fd:	0f 85 c8 fd ff ff    	jne    35cb <dafs_remove_dentry+0x4b>
        return ret;
    kfree(phname);
    3803:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
    3808:	e8 00 00 00 00       	callq  380d <dafs_remove_dentry+0x28d>
    kfree(phn);
    380d:	4c 89 e7             	mov    %r12,%rdi
    3810:	e8 00 00 00 00       	callq  3815 <dafs_remove_dentry+0x295>
    kfree(ph);
    3815:	4c 89 ef             	mov    %r13,%rdi
    3818:	e8 00 00 00 00       	callq  381d <dafs_remove_dentry+0x29d>
    
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    381d:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 3823 <dafs_remove_dentry+0x2a3>
    3823:	85 d2                	test   %edx,%edx
    3825:	75 78                	jne    389f <dafs_remove_dentry+0x31f>
    3827:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 382f <dafs_remove_dentry+0x2af>
    382e:	00 
    //nova_dbg("%s end", __func__);
	return 0;
    382f:	31 c0                	xor    %eax,%eax
    3831:	e9 95 fd ff ff       	jmpq   35cb <dafs_remove_dentry+0x4b>

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    3836:	31 f6                	xor    %esi,%esi
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    3838:	4c 89 f7             	mov    %r14,%rdi
    383b:	e8 00 00 00 00       	callq  3840 <dafs_remove_dentry+0x2c0>
        if(dzt_ei){
    3840:	48 85 c0             	test   %rax,%rax
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    3843:	49 89 c1             	mov    %rax,%r9
        if(dzt_ei){
    3846:	0f 84 48 fe ff ff    	je     3694 <dafs_remove_dentry+0x114>
    384c:	e9 b8 fe ff ff       	jmpq   3709 <dafs_remove_dentry+0x189>
            goto END;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    3851:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    memcpy(ph+1,end,1);
    3856:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    385c:	be 2f 00 00 00       	mov    $0x2f,%esi
    3861:	4c 89 f7             	mov    %r14,%rdi
    3864:	e8 00 00 00 00       	callq  3869 <dafs_remove_dentry+0x2e9>
    if(!dzt_ei){
    3869:	48 85 c0             	test   %rax,%rax

    /*root dir*/
    memcpy(ph, "/", 1);
    memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    386c:	49 89 c1             	mov    %rax,%r9
    if(!dzt_ei){
    386f:	0f 85 94 fe ff ff    	jne    3709 <dafs_remove_dentry+0x189>
    3875:	e8 00 00 00 00       	callq  387a <dafs_remove_dentry+0x2fa>
    //memcpy(phname, ph, strlen(ph));
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
    387a:	4c 89 ef             	mov    %r13,%rdi
    387d:	e8 00 00 00 00       	callq  3882 <dafs_remove_dentry+0x302>
        memcpy(phname, ph, flen);
    3882:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
    3887:	48 89 c2             	mov    %rax,%rdx
    388a:	4c 89 ee             	mov    %r13,%rsi
    //memcpy(phname, ph, strlen(ph));
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
    388d:	49 89 c6             	mov    %rax,%r14
        memcpy(phname, ph, flen);
    3890:	e8 00 00 00 00       	callq  3895 <dafs_remove_dentry+0x315>
    3895:	4c 8b 4c 24 08       	mov    0x8(%rsp),%r9
    389a:	e9 d6 fe ff ff       	jmpq   3775 <dafs_remove_dentry+0x1f5>
    389f:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
    38a4:	e8 00 00 00 00       	callq  38a9 <dafs_remove_dentry+0x329>
    kfree(phname);
    kfree(phn);
    kfree(ph);
    
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    38a9:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    38ae:	48 2b 44 24 20       	sub    0x20(%rsp),%rax
    38b3:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    38ba:	48 2b 44 24 28       	sub    0x28(%rsp),%rax
    38bf:	48 03 44 24 38       	add    0x38(%rsp),%rax
    38c4:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 38cc <dafs_remove_dentry+0x34c>
    38cb:	00 
    38cc:	e9 56 ff ff ff       	jmpq   3827 <dafs_remove_dentry+0x2a7>
    38d1:	31 d2                	xor    %edx,%edx
    38d3:	e9 d8 fe ff ff       	jmpq   37b0 <dafs_remove_dentry+0x230>
    //nova_dbg("%s end", __func__);
	return 0;
}
    38d8:	e8 00 00 00 00       	callq  38dd <dafs_remove_dentry+0x35d>
    38dd:	0f 1f 00             	nopl   (%rax)

00000000000038e0 <dafs_append_dir_init_entries>:

/*append . and .. entries*/
int dafs_append_dir_init_entries(struct super_block *sb, u32 par_pos, struct dzt_entry_info *dzt_ei,
                                 u64 self_ino, u64 parent_ino, const char *ful_name)
{
    38e0:	e8 00 00 00 00       	callq  38e5 <dafs_append_dir_init_entries+0x5>
    38e5:	55                   	push   %rbp
    38e6:	48 89 e5             	mov    %rsp,%rbp
    38e9:	41 57                	push   %r15
    38eb:	41 56                	push   %r14
    38ed:	41 55                	push   %r13
    38ef:	41 54                	push   %r12
    38f1:	4d 89 cf             	mov    %r9,%r15
    38f4:	53                   	push   %rbx
    38f5:	48 83 ec 60          	sub    $0x60,%rsp
    38f9:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
    u32 cur_pos = 0;
    //int ret;
	

    //nova_dbg("%s start ino is %llu, par_ino is %llu", __func__, self_ino, parent_ino);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    38fd:	48 8b 42 10          	mov    0x10(%rdx),%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    3901:	48 8b 97 b0 03 00 00 	mov    0x3b0(%rdi),%rdx
}

/*append . and .. entries*/
int dafs_append_dir_init_entries(struct super_block *sb, u32 par_pos, struct dzt_entry_info *dzt_ei,
                                 u64 self_ino, u64 parent_ino, const char *ful_name)
{
    3908:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)

    //nova_dbg("%s start ino is %llu, par_ino is %llu", __func__, self_ino, parent_ino);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    //nova_dbg("par ze addr is %llu", dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    390c:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
}

/*append . and .. entries*/
int dafs_append_dir_init_entries(struct super_block *sb, u32 par_pos, struct dzt_entry_info *dzt_ei,
                                 u64 self_ino, u64 parent_ino, const char *ful_name)
{
    3910:	65 48 8b 1c 25 28 00 	mov    %gs:0x28,%rbx
    3917:	00 00 
    3919:	48 89 5d d0          	mov    %rbx,-0x30(%rbp)
    391d:	31 db                	xor    %ebx,%ebx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    391f:	49 89 c5             	mov    %rax,%r13
    3922:	89 75 a8             	mov    %esi,-0x58(%rbp)
    3925:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    3929:	4c 03 6a 18          	add    0x18(%rdx),%r13
    392d:	48 85 c0             	test   %rax,%rax
    3930:	b8 00 00 00 00       	mov    $0x0,%eax
    3935:	4c 89 45 98          	mov    %r8,-0x68(%rbp)
    3939:	4c 0f 44 e8          	cmove  %rax,%r13
    //nova_dbg("%s start ino is %llu, par_ino is %llu", __func__, self_ino, parent_ino);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    //nova_dbg("par ze addr is %llu", dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    bitpos = 0;
    393d:	45 31 e4             	xor    %r12d,%r12d

    //nova_dbg("%s start ino is %llu, par_ino is %llu", __func__, self_ino, parent_ino);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    //nova_dbg("par ze addr is %llu", dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    3940:	4c 89 ee             	mov    %r13,%rsi
    3943:	e8 00 00 00 00       	callq  3948 <dafs_append_dir_init_entries+0x68>
    3948:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    394c:	48 8b 30             	mov    (%rax),%rsi
    394f:	31 c0                	xor    %eax,%eax
    3951:	eb 18                	jmp    396b <dafs_append_dir_init_entries+0x8b>
    bitpos = 0;
    while(cur_pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
            bitpos+=2;
    3953:	41 83 c4 02          	add    $0x2,%r12d
            cur_pos++;
    3957:	83 c3 01             	add    $0x1,%ebx
    395a:	48 83 c0 02          	add    $0x2,%rax
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    //nova_dbg("par ze addr is %llu", dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    bitpos = 0;
    while(cur_pos<NR_DENTRY_IN_ZONE){
    395e:	41 81 fc fe ff 01 00 	cmp    $0x1fffe,%r12d
    3965:	0f 84 a9 04 00 00    	je     3e14 <dafs_append_dir_init_entries+0x534>

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    396b:	48 0f a3 06          	bt     %rax,(%rsi)
    396f:	19 d2                	sbb    %edx,%edx
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
    3971:	85 d2                	test   %edx,%edx
    3973:	75 de                	jne    3953 <dafs_append_dir_init_entries+0x73>
    3975:	48 8d 48 01          	lea    0x1(%rax),%rcx
    3979:	48 0f a3 0e          	bt     %rcx,(%rsi)
    397d:	19 d2                	sbb    %edx,%edx
    397f:	85 d2                	test   %edx,%edx
    3981:	75 d0                	jne    3953 <dafs_append_dir_init_entries+0x73>
    /* if not enough entries, negtive split*/
    if(cur_pos == NR_DENTRY_IN_ZONE){
        dafs_split_zone(sb, dzt_ei, 0, NEGTIVE_SPLIT);
    }

    p_len = strlen(ful_name);
    3983:	4c 89 ff             	mov    %r15,%rdi
    3986:	48 89 8d 78 ff ff ff 	mov    %rcx,-0x88(%rbp)
    398d:	e8 00 00 00 00       	callq  3992 <dafs_append_dir_init_entries+0xb2>
    phn = kzalloc(sizeof(char)*(p_len+4), GFP_KERNEL);
    3992:	48 8d 78 04          	lea    0x4(%rax),%rdi
    3996:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    399a:	e8 51 c7 ff ff       	callq  f0 <kzalloc.constprop.9>
    memcpy(phn, ful_name, p_len);
    399f:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    39a3:	4c 89 fe             	mov    %r15,%rsi
    39a6:	48 89 c7             	mov    %rax,%rdi

    dafs_de = &dafs_ze->dentry[cur_pos];
    39a9:	41 89 df             	mov    %ebx,%r15d
    if(cur_pos == NR_DENTRY_IN_ZONE){
        dafs_split_zone(sb, dzt_ei, 0, NEGTIVE_SPLIT);
    }

    p_len = strlen(ful_name);
    phn = kzalloc(sizeof(char)*(p_len+4), GFP_KERNEL);
    39ac:	49 89 c6             	mov    %rax,%r14
    memcpy(phn, ful_name, p_len);
    39af:	e8 00 00 00 00       	callq  39b4 <dafs_append_dir_init_entries+0xd4>
    39b4:	4c 89 fe             	mov    %r15,%rsi

    dafs_de = &dafs_ze->dentry[cur_pos];
    39b7:	4d 8d 97 81 00 00 00 	lea    0x81(%r15),%r10
    39be:	48 c1 e6 07          	shl    $0x7,%rsi
    39c2:	49 8d 54 35 00       	lea    0x0(%r13,%rsi,1),%rdx
    39c7:	49 c1 e2 07          	shl    $0x7,%r10
    39cb:	48 89 75 88          	mov    %rsi,-0x78(%rbp)
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 1;
    dafs_de->links_count = 1;
    39cf:	be 01 00 00 00       	mov    $0x1,%esi

    p_len = strlen(ful_name);
    phn = kzalloc(sizeof(char)*(p_len+4), GFP_KERNEL);
    memcpy(phn, ful_name, p_len);

    dafs_de = &dafs_ze->dentry[cur_pos];
    39d4:	4d 01 ea             	add    %r13,%r10
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 1;
    dafs_de->links_count = 1;
    39d7:	66 89 b2 86 40 00 00 	mov    %si,0x4086(%rdx)
    p_len = strlen(ful_name);
    phn = kzalloc(sizeof(char)*(p_len+4), GFP_KERNEL);
    memcpy(phn, ful_name, p_len);

    dafs_de = &dafs_ze->dentry[cur_pos];
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    39de:	c6 82 80 40 00 00 06 	movb   $0x6,0x4080(%rdx)
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    39e5:	c6 82 82 40 00 00 00 	movb   $0x0,0x4082(%rdx)
    dafs_de->name_len = 1;
    39ec:	c6 82 81 40 00 00 01 	movb   $0x1,0x4081(%rdx)

    p_len = strlen(ful_name);
    phn = kzalloc(sizeof(char)*(p_len+4), GFP_KERNEL);
    memcpy(phn, ful_name, p_len);

    dafs_de = &dafs_ze->dentry[cur_pos];
    39f3:	4c 89 55 80          	mov    %r10,-0x80(%rbp)
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 1;
    dafs_de->links_count = 1;
    39f7:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    39fb:	e8 00 00 00 00       	callq  3a00 <dafs_append_dir_init_entries+0x120>
    3a00:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
    /*if not super root sub init file, then isr_sf = 0*/
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(self_ino);
    3a04:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    dafs_de->size = sb->s_blocksize;
    dafs_de->par_pos = cpu_to_le32(par_pos);
    
    memcpy(dafs_de->name, ".", 1);
    3a08:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    dafs_de->name[1]='\0';

    /*set ful_name*/
    p_len += 2;
    dafs_de->fname_len = cpu_to_le64(p_len);
    if(p_len == 3)
    3a0c:	4c 8b 55 80          	mov    -0x80(%rbp),%r10
    3a10:	48 8b 8d 78 ff ff ff 	mov    -0x88(%rbp),%rcx
    dafs_de->name_len = 1;
    dafs_de->links_count = 1;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    /*if not super root sub init file, then isr_sf = 0*/
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(self_ino);
    3a17:	48 89 ba 98 40 00 00 	mov    %rdi,0x4098(%rdx)
    dafs_de->size = sb->s_blocksize;
    3a1e:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 1;
    dafs_de->links_count = 1;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    3a22:	89 82 88 40 00 00    	mov    %eax,0x4088(%rdx)
    /*if not super root sub init file, then isr_sf = 0*/
    dafs_de->isr_sf = 0;
    3a28:	c6 82 83 40 00 00 00 	movb   $0x0,0x4083(%rdx)
    3a2f:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
    3a33:	4c 89 55 90          	mov    %r10,-0x70(%rbp)
    dafs_de->ino = cpu_to_le64(self_ino);
    dafs_de->size = sb->s_blocksize;
    3a37:	48 8b 47 18          	mov    0x18(%rdi),%rax
    dafs_de->par_pos = cpu_to_le32(par_pos);
    3a3b:	8b 7d a8             	mov    -0x58(%rbp),%edi
    3a3e:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
    dafs_de->links_count = 1;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    /*if not super root sub init file, then isr_sf = 0*/
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(self_ino);
    dafs_de->size = sb->s_blocksize;
    3a42:	48 89 82 a0 40 00 00 	mov    %rax,0x40a0(%rdx)
    
    memcpy(dafs_de->name, ".", 1);
    dafs_de->name[1]='\0';

    /*set ful_name*/
    p_len += 2;
    3a49:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    /*if not super root sub init file, then isr_sf = 0*/
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(self_ino);
    dafs_de->size = sb->s_blocksize;
    dafs_de->par_pos = cpu_to_le32(par_pos);
    3a4d:	89 ba 8c 40 00 00    	mov    %edi,0x408c(%rdx)
    
    memcpy(dafs_de->name, ".", 1);
    3a53:	41 c6 84 35 b0 40 00 	movb   $0x2e,0x40b0(%r13,%rsi,1)
    3a5a:	00 2e 

    /*set ful_name*/
    p_len += 2;
    dafs_de->fname_len = cpu_to_le64(p_len);
    if(p_len == 3)
        strcat(phn, ".");
    3a5c:	4c 89 f7             	mov    %r14,%rdi
    dafs_de->ino = cpu_to_le64(self_ino);
    dafs_de->size = sb->s_blocksize;
    dafs_de->par_pos = cpu_to_le32(par_pos);
    
    memcpy(dafs_de->name, ".", 1);
    dafs_de->name[1]='\0';
    3a5f:	c6 82 b1 40 00 00 00 	movb   $0x0,0x40b1(%rdx)

    /*set ful_name*/
    p_len += 2;
    3a66:	48 8d 70 02          	lea    0x2(%rax),%rsi
    dafs_de->fname_len = cpu_to_le64(p_len);
    if(p_len == 3)
    3a6a:	48 83 fe 03          	cmp    $0x3,%rsi
    memcpy(dafs_de->name, ".", 1);
    dafs_de->name[1]='\0';

    /*set ful_name*/
    p_len += 2;
    dafs_de->fname_len = cpu_to_le64(p_len);
    3a6e:	48 89 b2 90 40 00 00 	mov    %rsi,0x4090(%rdx)
    3a75:	48 89 75 88          	mov    %rsi,-0x78(%rbp)
    if(p_len == 3)
    3a79:	0f 84 b5 03 00 00    	je     3e34 <dafs_append_dir_init_entries+0x554>
        strcat(phn, ".");
    else
        strcat(phn, "/.");
    3a7f:	e8 00 00 00 00       	callq  3a84 <dafs_append_dir_init_entries+0x1a4>
    3a84:	ba 2f 2e 00 00       	mov    $0x2e2f,%edx
    3a89:	4c 01 f0             	add    %r14,%rax
    3a8c:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
    3a90:	66 89 10             	mov    %dx,(%rax)
    3a93:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    3a97:	4c 8b 55 90          	mov    -0x70(%rbp),%r10
    3a9b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
    3a9f:	c6 40 02 00          	movb   $0x0,0x2(%rax)
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    3aa3:	4c 89 f8             	mov    %r15,%rax
    dafs_de->ext_flag=0;
    3aa6:	45 31 db             	xor    %r11d,%r11d
    if(p_len == 3)
        strcat(phn, ".");
    else
        strcat(phn, "/.");
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    3aa9:	48 c1 e0 07          	shl    $0x7,%rax
    3aad:	41 c6 84 05 d8 40 00 	movb   $0x0,0x40d8(%r13,%rax,1)
    3ab4:	00 00 
    dafs_de->ext_flag=0;
     
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    3ab6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
        strcat(phn, ".");
    else
        strcat(phn, "/.");
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    dafs_de->ext_flag=0;
    3aba:	66 44 89 9a 84 40 00 	mov    %r11w,0x4084(%rdx)
    3ac1:	00 
     
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    3ac2:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    3ac5:	f0 48 0f ab 08       	lock bts %rcx,(%rax)
    3aca:	72 00                	jb     3acc <dafs_append_dir_init_entries+0x1ec>
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    3acc:	85 f6                	test   %esi,%esi
    bitpos++;
    3ace:	45 8d 4c 24 02       	lea    0x2(%r12),%r9d
    3ad3:	0f 8e 7f 03 00 00    	jle    3e58 <dafs_append_dir_init_entries+0x578>
    3ad9:	8d 46 ff             	lea    -0x1(%rsi),%eax
    3adc:	31 d2                	xor    %edx,%edx
    3ade:	49 8d 74 06 01       	lea    0x1(%r14,%rax,1),%rsi
    3ae3:	4c 89 f0             	mov    %r14,%rax
		hash = hash * seed + (*str++);
    3ae6:	48 89 d1             	mov    %rdx,%rcx
    3ae9:	48 83 c0 01          	add    $0x1,%rax
    3aed:	48 c1 e1 06          	shl    $0x6,%rcx
    3af1:	48 01 d1             	add    %rdx,%rcx
    3af4:	48 8d 14 4a          	lea    (%rdx,%rcx,2),%rdx
    3af8:	48 0f be 48 ff       	movsbq -0x1(%rax),%rcx
    3afd:	48 01 ca             	add    %rcx,%rdx
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    3b00:	48 39 f0             	cmp    %rsi,%rax
    3b03:	75 e1                	jne    3ae6 <dafs_append_dir_init_entries+0x206>
    //h_len = phlen + 2;
    hashname = BKDRHash(phn, p_len);
    //nova_dbg("%s init entry name %s",__func__,phn);
    dafs_de->hname = cpu_to_le64(hashname);
    3b05:	49 c1 e7 07          	shl    $0x7,%r15
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    3b09:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    3b0d:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    bitpos++;
    //h_len = phlen + 2;
    hashname = BKDRHash(phn, p_len);
    //nova_dbg("%s init entry name %s",__func__,phn);
    dafs_de->hname = cpu_to_le64(hashname);
    3b13:	4b 89 94 3d a8 40 00 	mov    %rdx,0x40a8(%r13,%r15,1)
    3b1a:	00 
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    3b1b:	4c 8b 7d b0          	mov    -0x50(%rbp),%r15
    3b1f:	89 d9                	mov    %ebx,%ecx
    3b21:	4c 89 55 90          	mov    %r10,-0x70(%rbp)
    3b25:	44 89 4d a0          	mov    %r9d,-0x60(%rbp)
    3b29:	49 8b 77 18          	mov    0x18(%r15),%rsi
    3b2d:	e8 00 00 00 00       	callq  3b32 <dafs_append_dir_init_entries+0x252>

    par_de = &dafs_ze->dentry[par_pos];
    //nova_dbg("par pos is %d, cur pos is %d", par_pos,cur_pos);
    par_hn = le64_to_cpu(par_de->hname);
    3b32:	8b 45 a8             	mov    -0x58(%rbp),%eax
    /*bugbugbugbugbug*/
    //nova_dbg("parent hashname is %llu", par_hn);
    /*update dir info entry */
    par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    3b35:	49 8d 7f 38          	lea    0x38(%r15),%rdi
    dafs_de->hname = cpu_to_le64(hashname);
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);

    par_de = &dafs_ze->dentry[par_pos];
    //nova_dbg("par pos is %d, cur pos is %d", par_pos,cur_pos);
    par_hn = le64_to_cpu(par_de->hname);
    3b39:	48 c1 e0 07          	shl    $0x7,%rax
    /*bugbugbugbugbug*/
    //nova_dbg("parent hashname is %llu", par_hn);
    /*update dir info entry */
    par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    3b3d:	49 8b b4 05 a8 40 00 	mov    0x40a8(%r13,%rax,1),%rsi
    3b44:	00 
    3b45:	e8 00 00 00 00       	callq  3b4a <dafs_append_dir_init_entries+0x26a>
    if(!par_dir){
    3b4a:	48 85 c0             	test   %rax,%rax
    //nova_dbg("par pos is %d, cur pos is %d", par_pos,cur_pos);
    par_hn = le64_to_cpu(par_de->hname);
    /*bugbugbugbugbug*/
    //nova_dbg("parent hashname is %llu", par_hn);
    /*update dir info entry */
    par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    3b4d:	49 89 c7             	mov    %rax,%r15
    if(!par_dir){
    3b50:	44 8b 4d a0          	mov    -0x60(%rbp),%r9d
    3b54:	4c 8b 55 90          	mov    -0x70(%rbp),%r10
    3b58:	0f 84 17 03 00 00    	je     3e75 <dafs_append_dir_init_entries+0x595>
        nova_dbg("dafs not find dir entry");
        return -EINVAL;
    }
    par_dir->sub_num++;
    3b5e:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    3b63:	ba 14 00 00 00       	mov    $0x14,%edx
    3b68:	be d0 80 00 00       	mov    $0x80d0,%esi
    3b6d:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 3b74 <dafs_append_dir_init_entries+0x294>
    3b74:	4c 89 55 90          	mov    %r10,-0x70(%rbp)
    3b78:	44 89 4d a0          	mov    %r9d,-0x60(%rbp)
    3b7c:	e8 00 00 00 00       	callq  3b81 <dafs_append_dir_init_entries+0x2a1>
    new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
    new_sf->pos = cur_pos;
    3b81:	89 58 10             	mov    %ebx,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    3b84:	49 8b 57 20          	mov    0x20(%r15),%rdx
    list_add_tail(&new_sf->list, &par_dir->sub_file);
    3b88:	49 8d 7f 18          	lea    0x18(%r15),%rdi
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    3b8c:	4c 8b 55 90          	mov    -0x70(%rbp),%r10
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    3b90:	49 89 47 20          	mov    %rax,0x20(%r15)
	new->next = next;
    3b94:	48 89 38             	mov    %rdi,(%rax)
    3b97:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
	new->prev = prev;
    3b9b:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    3b9f:	48 89 02             	mov    %rax,(%rdx)
	if (support_clwb) {
    3ba2:	31 d2                	xor    %edx,%edx
    3ba4:	44 8b 0d 00 00 00 00 	mov    0x0(%rip),%r9d        # 3bab <dafs_append_dir_init_entries+0x2cb>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    3bab:	44 89 d1             	mov    %r10d,%ecx
    3bae:	83 e1 3f             	and    $0x3f,%ecx
    3bb1:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    3bb4:	45 85 c9             	test   %r9d,%r9d
    3bb7:	44 8b 4d a0          	mov    -0x60(%rbp),%r9d
    3bbb:	0f 84 2e 02 00 00    	je     3def <dafs_append_dir_init_entries+0x50f>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    3bc1:	89 d0                	mov    %edx,%eax
    3bc3:	4c 01 d0             	add    %r10,%rax
    3bc6:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    3bca:	83 c2 40             	add    $0x40,%edx
    3bcd:	39 d1                	cmp    %edx,%ecx
    3bcf:	77 f0                	ja     3bc1 <dafs_append_dir_init_entries+0x2e1>

    //nova_dbg("%s . pos is %d",__func__,cur_pos);
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    cur_pos++;
    3bd1:	83 c3 01             	add    $0x1,%ebx

    while(cur_pos<NR_DENTRY_IN_ZONE){
    3bd4:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
    3bda:	0f 87 86 02 00 00    	ja     3e66 <dafs_append_dir_init_entries+0x586>
    3be0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3be4:	48 8b 08             	mov    (%rax),%rcx
    3be7:	eb 03                	jmp    3bec <dafs_append_dir_init_entries+0x30c>
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
            bitpos+=2;
    3be9:	41 89 c1             	mov    %eax,%r9d

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    3bec:	49 63 c1             	movslq %r9d,%rax
    3bef:	48 0f a3 01          	bt     %rax,(%rcx)
    3bf3:	19 c0                	sbb    %eax,%eax
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    cur_pos++;

    while(cur_pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
    3bf5:	85 c0                	test   %eax,%eax
    3bf7:	75 11                	jne    3c0a <dafs_append_dir_init_entries+0x32a>
#error "Please fix <asm/byteorder.h>"
#endif

static inline int test_bit_le(int nr, const void *addr)
{
	return test_bit(nr ^ BITOP_LE_SWIZZLE, addr);
    3bf9:	41 8d 51 01          	lea    0x1(%r9),%edx
    3bfd:	48 63 d2             	movslq %edx,%rdx
    3c00:	48 0f a3 11          	bt     %rdx,(%rcx)
    3c04:	19 c0                	sbb    %eax,%eax
    3c06:	85 c0                	test   %eax,%eax
    3c08:	74 16                	je     3c20 <dafs_append_dir_init_entries+0x340>
            bitpos+=2;
            cur_pos++;
    3c0a:	83 c3 01             	add    $0x1,%ebx
    
    cur_pos++;

    while(cur_pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
            bitpos+=2;
    3c0d:	41 8d 41 02          	lea    0x2(%r9),%eax
    //nova_dbg("%s . pos is %d",__func__,cur_pos);
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    cur_pos++;

    while(cur_pos<NR_DENTRY_IN_ZONE){
    3c11:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
    3c17:	75 d0                	jne    3be9 <dafs_append_dir_init_entries+0x309>
    3c19:	41 83 c1 03          	add    $0x3,%r9d
    3c1d:	49 63 d1             	movslq %r9d,%rdx
            cur_pos++;
        }else{
            break;
        }
    }
    dafs_de = &dafs_ze->dentry[cur_pos];
    3c20:	89 d9                	mov    %ebx,%ecx
    3c22:	48 89 55 80          	mov    %rdx,-0x80(%rbp)
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 2;
    dafs_de->links_count = 2;
    3c26:	ba 02 00 00 00       	mov    $0x2,%edx
    3c2b:	48 89 cf             	mov    %rcx,%rdi
            cur_pos++;
        }else{
            break;
        }
    }
    dafs_de = &dafs_ze->dentry[cur_pos];
    3c2e:	4c 8d a1 81 00 00 00 	lea    0x81(%rcx),%r12
    3c35:	48 89 4d 88          	mov    %rcx,-0x78(%rbp)
    3c39:	48 c1 e7 07          	shl    $0x7,%rdi
    3c3d:	49 8d 74 3d 00       	lea    0x0(%r13,%rdi,1),%rsi
    3c42:	48 89 7d 90          	mov    %rdi,-0x70(%rbp)
    3c46:	49 c1 e4 07          	shl    $0x7,%r12
    3c4a:	4d 01 ec             	add    %r13,%r12
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 2;
    dafs_de->links_count = 2;
    3c4d:	66 89 96 86 40 00 00 	mov    %dx,0x4086(%rsi)
        }else{
            break;
        }
    }
    dafs_de = &dafs_ze->dentry[cur_pos];
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    3c54:	c6 86 80 40 00 00 06 	movb   $0x6,0x4080(%rsi)
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    3c5b:	c6 86 82 40 00 00 00 	movb   $0x0,0x4082(%rsi)
    dafs_de->name_len = 2;
    3c62:	c6 86 81 40 00 00 02 	movb   $0x2,0x4081(%rsi)
    dafs_de->links_count = 2;
    3c69:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    3c6d:	e8 00 00 00 00       	callq  3c72 <dafs_append_dir_init_entries+0x392>
    3c72:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(parent_ino);
    dafs_de->size = sb->s_blocksize;
    memcpy(dafs_de->name, "..", 2);
    3c76:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
    3c7a:	b9 2e 2e 00 00       	mov    $0x2e2e,%ecx
    dafs_de->name[2]='\0';
    p_len ++; 
    3c7f:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 2;
    dafs_de->links_count = 2;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    3c83:	89 86 88 40 00 00    	mov    %eax,0x4088(%rsi)
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(parent_ino);
    3c89:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 2;
    dafs_de->links_count = 2;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    dafs_de->isr_sf = 0;
    3c8d:	c6 86 83 40 00 00 00 	movb   $0x0,0x4083(%rsi)
    dafs_de->ino = cpu_to_le64(parent_ino);
    dafs_de->size = sb->s_blocksize;
    memcpy(dafs_de->name, "..", 2);
    dafs_de->name[2]='\0';
    p_len ++; 
    3c94:	49 83 c0 03          	add    $0x3,%r8
    dafs_de->fname_len = cpu_to_le64(p_len);
    3c98:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 2;
    dafs_de->links_count = 2;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(parent_ino);
    3c9c:	48 89 86 98 40 00 00 	mov    %rax,0x4098(%rsi)
    dafs_de->size = sb->s_blocksize;
    3ca3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    3ca7:	48 8b 40 18          	mov    0x18(%rax),%rax
    3cab:	48 89 86 a0 40 00 00 	mov    %rax,0x40a0(%rsi)
    memcpy(dafs_de->name, "..", 2);
    3cb2:	66 41 89 8c 3d b0 40 	mov    %cx,0x40b0(%r13,%rdi,1)
    3cb9:	00 00 
    dafs_de->name[2]='\0';
    p_len ++; 
    dafs_de->fname_len = cpu_to_le64(p_len);
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    dafs_de->ext_flag=0;
    3cbb:	31 ff                	xor    %edi,%edi
    dafs_de->ino = cpu_to_le64(parent_ino);
    dafs_de->size = sb->s_blocksize;
    memcpy(dafs_de->name, "..", 2);
    dafs_de->name[2]='\0';
    p_len ++; 
    dafs_de->fname_len = cpu_to_le64(p_len);
    3cbd:	4c 89 86 90 40 00 00 	mov    %r8,0x4090(%rsi)
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    dafs_de->ext_flag=0;
    3cc4:	66 89 be 84 40 00 00 	mov    %di,0x4084(%rsi)
    strcat(phn, ".");
    3ccb:	4c 89 f7             	mov    %r14,%rdi
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(parent_ino);
    dafs_de->size = sb->s_blocksize;
    memcpy(dafs_de->name, "..", 2);
    dafs_de->name[2]='\0';
    3cce:	c6 86 b2 40 00 00 00 	movb   $0x0,0x40b2(%rsi)
    p_len ++; 
    dafs_de->fname_len = cpu_to_le64(p_len);
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    3cd5:	c6 86 d8 40 00 00 00 	movb   $0x0,0x40d8(%rsi)
    dafs_de->ext_flag=0;
    strcat(phn, ".");
    3cdc:	e8 00 00 00 00       	callq  3ce1 <dafs_append_dir_init_entries+0x401>
    3ce1:	41 b8 2e 00 00 00    	mov    $0x2e,%r8d
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    3ce7:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
    3ceb:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
    3cef:	66 45 89 04 06       	mov    %r8w,(%r14,%rax,1)
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    3cf4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3cf8:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
    3cfc:	48 8b 00             	mov    (%rax),%rax
    3cff:	f0 48 0f ab 10       	lock bts %rdx,(%rax)
    3d04:	72 00                	jb     3d06 <dafs_append_dir_init_entries+0x426>
    3d06:	45 85 c0             	test   %r8d,%r8d
    3d09:	0f 8e 50 01 00 00    	jle    3e5f <dafs_append_dir_init_entries+0x57f>
    3d0f:	41 8d 40 ff          	lea    -0x1(%r8),%eax
    3d13:	31 d2                	xor    %edx,%edx
    3d15:	49 8d 7c 06 01       	lea    0x1(%r14,%rax,1),%rdi
    3d1a:	4c 89 f0             	mov    %r14,%rax
		hash = hash * seed + (*str++);
    3d1d:	48 89 d6             	mov    %rdx,%rsi
    3d20:	48 83 c0 01          	add    $0x1,%rax
    3d24:	48 c1 e6 06          	shl    $0x6,%rsi
    3d28:	48 01 d6             	add    %rdx,%rsi
    3d2b:	48 8d 14 72          	lea    (%rdx,%rsi,2),%rdx
    3d2f:	48 0f be 70 ff       	movsbq -0x1(%rax),%rsi
    3d34:	48 01 f2             	add    %rsi,%rdx
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    3d37:	48 39 c7             	cmp    %rax,%rdi
    3d3a:	75 e1                	jne    3d1d <dafs_append_dir_init_entries+0x43d>
    hashname = BKDRHash(phn, p_len);
    dafs_de->hname = cpu_to_le64(hashname);
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    3d3c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    hashname = BKDRHash(phn, p_len);
    dafs_de->hname = cpu_to_le64(hashname);
    3d40:	48 c1 e1 07          	shl    $0x7,%rcx
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    3d44:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    hashname = BKDRHash(phn, p_len);
    dafs_de->hname = cpu_to_le64(hashname);
    3d48:	49 89 94 0d a8 40 00 	mov    %rdx,0x40a8(%r13,%rcx,1)
    3d4f:	00 
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    3d50:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    3d56:	89 d9                	mov    %ebx,%ecx
    3d58:	48 8b 70 18          	mov    0x18(%rax),%rsi
    3d5c:	e8 00 00 00 00       	callq  3d61 <dafs_append_dir_init_entries+0x481>
    
    /*update dir info entry */
    par_dir->sub_num++;
    3d61:	49 83 47 08 01       	addq   $0x1,0x8(%r15)
    3d66:	ba 14 00 00 00       	mov    $0x14,%edx
    3d6b:	be d0 80 00 00       	mov    $0x80d0,%esi
    3d70:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 3d77 <dafs_append_dir_init_entries+0x497>
    3d77:	e8 00 00 00 00       	callq  3d7c <dafs_append_dir_init_entries+0x49c>
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
    3d7c:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
    new_sf->pos = cur_pos;
    3d80:	89 58 10             	mov    %ebx,0x10(%rax)
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    3d83:	44 89 e1             	mov    %r12d,%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    3d86:	49 8b 57 20          	mov    0x20(%r15),%rdx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    3d8a:	49 89 47 20          	mov    %rax,0x20(%r15)
    3d8e:	83 e1 3f             	and    $0x3f,%ecx
    3d91:	83 e9 80             	sub    $0xffffff80,%ecx
	new->next = next;
    3d94:	48 89 38             	mov    %rdi,(%rax)
	new->prev = prev;
    3d97:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    3d9b:	48 89 02             	mov    %rax,(%rdx)
	if (support_clwb) {
    3d9e:	31 d2                	xor    %edx,%edx
    3da0:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 3da6 <dafs_append_dir_init_entries+0x4c6>
    3da6:	85 c0                	test   %eax,%eax
    3da8:	74 59                	je     3e03 <dafs_append_dir_init_entries+0x523>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    3daa:	89 d0                	mov    %edx,%eax
    3dac:	4c 01 e0             	add    %r12,%rax
    3daf:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    3db3:	83 c2 40             	add    $0x40,%edx
    3db6:	39 d1                	cmp    %edx,%ecx
    3db8:	77 f0                	ja     3daa <dafs_append_dir_init_entries+0x4ca>
    list_add_tail(&new_sf->list, &par_dir->sub_file);

    //nova_dbg("%s .. pos is %d",__func__,cur_pos);
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    //kfree(phname);
    kfree(phn);
    3dba:	4c 89 f7             	mov    %r14,%rdi
    3dbd:	e8 00 00 00 00       	callq  3dc2 <dafs_append_dir_init_entries+0x4e2>
    kfree(zone_p);
    3dc2:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    3dc6:	e8 00 00 00 00       	callq  3dcb <dafs_append_dir_init_entries+0x4eb>
    //nova_dbg("dafs finish add initial part in dir");
    return 0;
    3dcb:	31 c0                	xor    %eax,%eax
}
    3dcd:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    3dd1:	65 48 33 3c 25 28 00 	xor    %gs:0x28,%rdi
    3dd8:	00 00 
    3dda:	0f 85 90 00 00 00    	jne    3e70 <dafs_append_dir_init_entries+0x590>
    3de0:	48 83 c4 60          	add    $0x60,%rsp
    3de4:	5b                   	pop    %rbx
    3de5:	41 5c                	pop    %r12
    3de7:	41 5d                	pop    %r13
    3de9:	41 5e                	pop    %r14
    3deb:	41 5f                	pop    %r15
    3ded:	5d                   	pop    %rbp
    3dee:	c3                   	retq   
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    3def:	89 d0                	mov    %edx,%eax
    3df1:	4c 01 d0             	add    %r10,%rax
    3df4:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    3df7:	83 c2 40             	add    $0x40,%edx
    3dfa:	39 d1                	cmp    %edx,%ecx
    3dfc:	77 f1                	ja     3def <dafs_append_dir_init_entries+0x50f>
    3dfe:	e9 ce fd ff ff       	jmpq   3bd1 <dafs_append_dir_init_entries+0x2f1>
			_mm_clflush(buf + i);
    3e03:	89 d0                	mov    %edx,%eax
    3e05:	4c 01 e0             	add    %r12,%rax
    3e08:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    3e0b:	83 c2 40             	add    $0x40,%edx
    3e0e:	39 d1                	cmp    %edx,%ecx
    3e10:	77 f1                	ja     3e03 <dafs_append_dir_init_entries+0x523>
    3e12:	eb a6                	jmp    3dba <dafs_append_dir_init_entries+0x4da>
        }
    }

    /* if not enough entries, negtive split*/
    if(cur_pos == NR_DENTRY_IN_ZONE){
        dafs_split_zone(sb, dzt_ei, 0, NEGTIVE_SPLIT);
    3e14:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    3e18:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    3e1c:	31 c9                	xor    %ecx,%ecx
    3e1e:	31 d2                	xor    %edx,%edx
    3e20:	bb ff ff 00 00       	mov    $0xffff,%ebx
    3e25:	e8 00 00 00 00       	callq  3e2a <dafs_append_dir_init_entries+0x54a>
    3e2a:	b9 ff ff 01 00       	mov    $0x1ffff,%ecx
    3e2f:	e9 4f fb ff ff       	jmpq   3983 <dafs_append_dir_init_entries+0xa3>

    /*set ful_name*/
    p_len += 2;
    dafs_de->fname_len = cpu_to_le64(p_len);
    if(p_len == 3)
        strcat(phn, ".");
    3e34:	e8 00 00 00 00       	callq  3e39 <dafs_append_dir_init_entries+0x559>
    3e39:	b9 2e 00 00 00       	mov    $0x2e,%ecx
    3e3e:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
    3e42:	4c 8b 55 90          	mov    -0x70(%rbp),%r10
    3e46:	66 41 89 0c 06       	mov    %cx,(%r14,%rax,1)
    3e4b:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    3e4f:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
    3e53:	e9 4b fc ff ff       	jmpq   3aa3 <dafs_append_dir_init_entries+0x1c3>

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    3e58:	31 d2                	xor    %edx,%edx
    3e5a:	e9 a6 fc ff ff       	jmpq   3b05 <dafs_append_dir_init_entries+0x225>
    3e5f:	31 d2                	xor    %edx,%edx
    3e61:	e9 d6 fe ff ff       	jmpq   3d3c <dafs_append_dir_init_entries+0x45c>
    3e66:	41 8d 54 24 03       	lea    0x3(%r12),%edx
    3e6b:	e9 b0 fd ff ff       	jmpq   3c20 <dafs_append_dir_init_entries+0x340>
    //kfree(phname);
    kfree(phn);
    kfree(zone_p);
    //nova_dbg("dafs finish add initial part in dir");
    return 0;
}
    3e70:	e8 00 00 00 00       	callq  3e75 <dafs_append_dir_init_entries+0x595>
    /*bugbugbugbugbug*/
    //nova_dbg("parent hashname is %llu", par_hn);
    /*update dir info entry */
    par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    if(!par_dir){
        nova_dbg("dafs not find dir entry");
    3e75:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    3e7c:	e8 00 00 00 00       	callq  3e81 <dafs_append_dir_init_entries+0x5a1>
        return -EINVAL;
    3e81:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    3e86:	e9 42 ff ff ff       	jmpq   3dcd <dafs_append_dir_init_entries+0x4ed>
    3e8b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003e90 <dafs_empty_dir>:
    return 0;
}

/*bug 应该检验一下状态图是否有效*/
int dafs_empty_dir(struct inode *inode, struct dentry *dentry)
{
    3e90:	e8 00 00 00 00       	callq  3e95 <dafs_empty_dir+0x5>
    3e95:	55                   	push   %rbp
    3e96:	ba 00 04 00 00       	mov    $0x400,%edx
    3e9b:	48 89 e5             	mov    %rsp,%rbp
    3e9e:	41 57                	push   %r15
    3ea0:	41 56                	push   %r14
    3ea2:	41 55                	push   %r13
    3ea4:	41 54                	push   %r12
    3ea6:	49 89 f5             	mov    %rsi,%r13
    3ea9:	53                   	push   %rbx
    3eaa:	be d0 80 00 00       	mov    $0x80d0,%esi
    3eaf:	48 83 ec 28          	sub    $0x28,%rsp
    3eb3:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    3eba:	00 00 
    3ebc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    3ec0:	31 c0                	xor    %eax,%eax
    struct super_block *sb = inode->i_sb;
    3ec2:	48 8b 47 28          	mov    0x28(%rdi),%rax
    3ec6:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 3ecd <dafs_empty_dir+0x3d>
    3ecd:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    3ed1:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    3ed8:	00 00 

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    char *ph=NULL, *buf=NULL, *tem=NULL, *mntchar= "/mnt/ramdisk", *end="", *ppath=NULL;
    struct fs_struct *fs = current->fs;
    3eda:	4c 8b b8 30 06 00 00 	mov    0x630(%rax),%r15
    3ee1:	e8 00 00 00 00       	callq  3ee6 <dafs_empty_dir+0x56>
    3ee6:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 3eed <dafs_empty_dir+0x5d>
    3eed:	ba 00 04 00 00       	mov    $0x400,%edx
    3ef2:	be d0 80 00 00       	mov    $0x80d0,%esi
    3ef7:	49 89 c6             	mov    %rax,%r14
    3efa:	e8 00 00 00 00       	callq  3eff <dafs_empty_dir+0x6f>
    3eff:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 3f06 <dafs_empty_dir+0x76>
    3f06:	48 89 c3             	mov    %rax,%rbx
    3f09:	ba 00 04 00 00       	mov    $0x400,%edx
    3f0e:	be d0 80 00 00       	mov    $0x80d0,%esi
    3f13:	e8 00 00 00 00       	callq  3f18 <dafs_empty_dir+0x88>

    //nova_dbg("%s:dafs get dentry path",__func__);
    ph = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    buf = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    tem = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    if(!buf)
    3f18:	48 85 db             	test   %rbx,%rbx
    3f1b:	0f 84 1e 01 00 00    	je     403f <dafs_empty_dir+0x1af>
        goto ERR;

    read_lock(&fs->lock);
    3f21:	49 8d 7f 04          	lea    0x4(%r15),%rdi
    3f25:	49 89 c4             	mov    %rax,%r12
    3f28:	e8 00 00 00 00       	callq  3f2d <dafs_empty_dir+0x9d>
    vfsmnt = mntget(fs->pwd.mnt);
    3f2d:	49 8b 7f 28          	mov    0x28(%r15),%rdi
    3f31:	e8 00 00 00 00       	callq  3f36 <dafs_empty_dir+0xa6>
    if(!vfsmnt){
    3f36:	48 85 c0             	test   %rax,%rax
    tem = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    if(!buf)
        goto ERR;

    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    3f39:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    if(!vfsmnt){
    3f3d:	0f 84 fc 00 00 00    	je     403f <dafs_empty_dir+0x1af>
    3f43:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
    3f48:	f0 41 0f c1 47 04    	lock xadd %eax,0x4(%r15)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
    3f4e:	49 8b 75 28          	mov    0x28(%r13),%rsi
    3f52:	49 c7 c7 00 00 00 00 	mov    $0x0,%r15
    3f59:	b9 02 00 00 00       	mov    $0x2,%ecx
    3f5e:	4c 89 ff             	mov    %r15,%rdi
    3f61:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    3f63:	0f 85 98 03 00 00    	jne    4301 <dafs_empty_dir+0x471>
        strcat(buf,"/");

    do{
        strcat(buf, "/");
    3f69:	48 89 df             	mov    %rbx,%rdi
    3f6c:	e8 00 00 00 00       	callq  3f71 <dafs_empty_dir+0xe1>
    3f71:	ba 2f 00 00 00       	mov    $0x2f,%edx
        strcat(buf, tem_dentry->d_name.name);
    3f76:	48 8d 7c 03 01       	lea    0x1(%rbx,%rax,1),%rdi
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
        strcat(buf,"/");

    do{
        strcat(buf, "/");
    3f7b:	66 89 14 03          	mov    %dx,(%rbx,%rax,1)
        strcat(buf, tem_dentry->d_name.name);
    3f7f:	49 8b 75 28          	mov    0x28(%r13),%rsi
    3f83:	e8 00 00 00 00       	callq  3f88 <dafs_empty_dir+0xf8>
        p_dentry = tem_dentry->d_parent;
    3f88:	4d 8b 6d 18          	mov    0x18(%r13),%r13
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
    3f8c:	b9 02 00 00 00       	mov    $0x2,%ecx
    3f91:	4c 89 ff             	mov    %r15,%rdi
    3f94:	49 8b 75 28          	mov    0x28(%r13),%rsi
    3f98:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    3f9a:	75 cd                	jne    3f69 <dafs_empty_dir+0xd9>
    3f9c:	49 8b 45 30          	mov    0x30(%r13),%rax
    3fa0:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
    3fa5:	75 c2                	jne    3f69 <dafs_empty_dir+0xd9>
            break;
    }while(1);

    memcpy(tem, buf, strlen(buf));
    3fa7:	48 89 df             	mov    %rbx,%rdi
    3faa:	e8 00 00 00 00       	callq  3faf <dafs_empty_dir+0x11f>
    3faf:	48 89 de             	mov    %rbx,%rsi
    3fb2:	48 89 c2             	mov    %rax,%rdx
    3fb5:	4c 89 e7             	mov    %r12,%rdi
    3fb8:	e8 00 00 00 00       	callq  3fbd <dafs_empty_dir+0x12d>
    tlen = strlen(buf);
    3fbd:	48 89 df             	mov    %rbx,%rdi
    3fc0:	e8 00 00 00 00       	callq  3fc5 <dafs_empty_dir+0x135>
    3fc5:	49 89 c5             	mov    %rax,%r13
    do{
        ppath = strrchr(tem, '/');
    3fc8:	be 2f 00 00 00       	mov    $0x2f,%esi
    3fcd:	4c 89 e7             	mov    %r12,%rdi
    3fd0:	e8 00 00 00 00       	callq  3fd5 <dafs_empty_dir+0x145>
        phlen = tlen - strlen(ppath);
    3fd5:	48 89 c7             	mov    %rax,%rdi
    3fd8:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    3fdc:	e8 00 00 00 00       	callq  3fe1 <dafs_empty_dir+0x151>
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        strcat(ph, ppath);
    3fe1:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi

    memcpy(tem, buf, strlen(buf));
    tlen = strlen(buf);
    do{
        ppath = strrchr(tem, '/');
        phlen = tlen - strlen(ppath);
    3fe5:	49 29 c5             	sub    %rax,%r13
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        strcat(ph, ppath);
    3fe8:	4c 89 f7             	mov    %r14,%rdi
    3feb:	e8 00 00 00 00       	callq  3ff0 <dafs_empty_dir+0x160>
        memcpy(tem, buf, tlen);
    3ff0:	48 89 de             	mov    %rbx,%rsi
    3ff3:	4c 89 e7             	mov    %r12,%rdi
    3ff6:	4c 89 ea             	mov    %r13,%rdx
    3ff9:	e8 00 00 00 00       	callq  3ffe <dafs_empty_dir+0x16e>
        memcpy(tem+tlen, end, 1);
    3ffe:	43 c6 04 2c 00       	movb   $0x0,(%r12,%r13,1)
        if(!strcmp(tem,"/"))
    4003:	b9 02 00 00 00       	mov    $0x2,%ecx
    4008:	4c 89 e6             	mov    %r12,%rsi
    400b:	4c 89 ff             	mov    %r15,%rdi
    400e:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    4010:	75 b6                	jne    3fc8 <dafs_empty_dir+0x138>
            break;
    }while(1);

    BUG_ON(strlen(ph)==1024);
    4012:	4c 89 f7             	mov    %r14,%rdi
    4015:	e8 00 00 00 00       	callq  401a <dafs_empty_dir+0x18a>
    401a:	48 3d 00 04 00 00    	cmp    $0x400,%rax
    4020:	0f 84 f9 02 00 00    	je     431f <dafs_empty_dir+0x48f>
    //nova_dbg("%s ful ph is %s",__func__,ph);
    
    mntput(vfsmnt);
    4026:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    402a:	e8 00 00 00 00       	callq  402f <dafs_empty_dir+0x19f>
    
    kfree(buf);
    402f:	48 89 df             	mov    %rbx,%rdi
    4032:	e8 00 00 00 00       	callq  4037 <dafs_empty_dir+0x1a7>
    kfree(tem);
    4037:	4c 89 e7             	mov    %r12,%rdi
    403a:	e8 00 00 00 00       	callq  403f <dafs_empty_dir+0x1af>
    unsigned long nr_de;
    int i, ret;

    //nova_dbg("%s dafs start test empty dir",__func__);
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    403f:	4c 89 f7             	mov    %r14,%rdi
    4042:	e8 00 00 00 00       	callq  4047 <dafs_empty_dir+0x1b7>
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    4047:	be d0 80 00 00       	mov    $0x80d0,%esi
    404c:	48 89 c7             	mov    %rax,%rdi
    404f:	e8 00 00 00 00       	callq  4054 <dafs_empty_dir+0x1c4>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    4054:	4c 89 f7             	mov    %r14,%rdi
    4057:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    405b:	e8 00 00 00 00       	callq  4060 <dafs_empty_dir+0x1d0>
    4060:	be d0 80 00 00       	mov    $0x80d0,%esi
    4065:	48 89 c7             	mov    %rax,%rdi
    4068:	e8 00 00 00 00       	callq  406d <dafs_empty_dir+0x1dd>
    406d:	49 89 c4             	mov    %rax,%r12
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    4070:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    4074:	4c 89 f7             	mov    %r14,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    4077:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
    407e:	4c 8b a8 d8 01 00 00 	mov    0x1d8(%rax),%r13
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    4085:	e8 00 00 00 00       	callq  408a <dafs_empty_dir+0x1fa>
    408a:	4c 89 f6             	mov    %r14,%rsi
    408d:	48 89 c2             	mov    %rax,%rdx
    4090:	4c 89 e7             	mov    %r12,%rdi
    4093:	e8 00 00 00 00       	callq  4098 <dafs_empty_dir+0x208>
    tlen = strlen(phstr);
    4098:	4c 89 f7             	mov    %r14,%rdi
    409b:	e8 00 00 00 00       	callq  40a0 <dafs_empty_dir+0x210>
    40a0:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
    40a3:	be 2f 00 00 00       	mov    $0x2f,%esi
    40a8:	4c 89 e7             	mov    %r12,%rdi
    40ab:	e8 00 00 00 00       	callq  40b0 <dafs_empty_dir+0x220>
        phlen = tlen -strlen(tem);
    40b0:	48 89 c7             	mov    %rax,%rdi
    40b3:	e8 00 00 00 00       	callq  40b8 <dafs_empty_dir+0x228>
        tlen = phlen;
        //bug
        if(phlen==0){
    40b8:	48 29 c3             	sub    %rax,%rbx
    40bb:	0f 84 fb 01 00 00    	je     42bc <dafs_empty_dir+0x42c>
            break;
        }
        memcpy(ph,phstr,tlen);
    40c1:	48 89 da             	mov    %rbx,%rdx
    40c4:	4c 89 f6             	mov    %r14,%rsi
    40c7:	4c 89 e7             	mov    %r12,%rdi
    40ca:	e8 00 00 00 00       	callq  40cf <dafs_empty_dir+0x23f>
	int i;

	for (i = 0; i < length; i++) {
    40cf:	85 db                	test   %ebx,%ebx
        memcpy(ph+tlen, end, 1);
    40d1:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
    40d6:	0f 8e c5 01 00 00    	jle    42a1 <dafs_empty_dir+0x411>
    40dc:	8d 43 ff             	lea    -0x1(%rbx),%eax
    40df:	4c 89 e2             	mov    %r12,%rdx
    40e2:	31 f6                	xor    %esi,%esi
    40e4:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
    40e9:	48 89 f0             	mov    %rsi,%rax
    40ec:	48 83 c2 01          	add    $0x1,%rdx
    40f0:	48 c1 e0 06          	shl    $0x6,%rax
    40f4:	48 01 f0             	add    %rsi,%rax
    40f7:	48 8d 04 46          	lea    (%rsi,%rax,2),%rax
    40fb:	48 0f be 72 ff       	movsbq -0x1(%rdx),%rsi
    4100:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    4103:	48 39 ca             	cmp    %rcx,%rdx
    4106:	75 e1                	jne    40e9 <dafs_empty_dir+0x259>
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    4108:	4c 89 ef             	mov    %r13,%rdi
    410b:	e8 00 00 00 00       	callq  4110 <dafs_empty_dir+0x280>
        if(dzt_ei){
    4110:	48 85 c0             	test   %rax,%rax
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    4113:	49 89 c7             	mov    %rax,%r15
        if(dzt_ei){
    4116:	74 8b                	je     40a3 <dafs_empty_dir+0x213>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    4118:	48 8b 5d b8          	mov    -0x48(%rbp),%rbx
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph));
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    411c:	49 8b 47 10          	mov    0x10(%r15),%rax
    phlen = strlen(phn);
    4120:	4c 89 e7             	mov    %r12,%rdi
    4123:	48 8b 93 b0 03 00 00 	mov    0x3b0(%rbx),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    412a:	48 89 c3             	mov    %rax,%rbx
    412d:	48 03 5a 18          	add    0x18(%rdx),%rbx
    4131:	48 85 c0             	test   %rax,%rax
    4134:	b8 00 00 00 00       	mov    $0x0,%eax
    4139:	48 0f 44 d8          	cmove  %rax,%rbx
    413d:	e8 00 00 00 00       	callq  4142 <dafs_empty_dir+0x2b2>
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
    4142:	48 83 f8 01          	cmp    $0x1,%rax
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph));
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    4146:	49 89 c5             	mov    %rax,%r13
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
        flen = strlen(ph);
    4149:	4c 89 f7             	mov    %r14,%rdi
    //memcpy(phname, ph, strlen(ph));
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
    414c:	0f 84 93 01 00 00    	je     42e5 <dafs_empty_dir+0x455>
        flen = strlen(ph);
        memcpy(phname, ph, flen);
    } else {
        flen = strlen(ph)-phlen;
    4152:	e8 00 00 00 00       	callq  4157 <dafs_empty_dir+0x2c7>
        memcpy(phname, ph+phlen, flen);
    4157:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
    } else {
        flen = strlen(ph)-phlen;
    415b:	4c 29 e8             	sub    %r13,%rax
        memcpy(phname, ph+phlen, flen);
    415e:	4b 8d 34 2e          	lea    (%r14,%r13,1),%rsi
    4162:	48 89 c2             	mov    %rax,%rdx
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
    } else {
        flen = strlen(ph)-phlen;
    4165:	49 89 c4             	mov    %rax,%r12
        memcpy(phname, ph+phlen, flen);
    4168:	e8 00 00 00 00       	callq  416d <dafs_empty_dir+0x2dd>
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    416d:	45 85 e4             	test   %r12d,%r12d
    4170:	0f 8e a1 01 00 00    	jle    4317 <dafs_empty_dir+0x487>
    4176:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    417a:	41 8d 44 24 ff       	lea    -0x1(%r12),%eax
    417f:	45 31 e4             	xor    %r12d,%r12d
    4182:	48 8d 4c 07 01       	lea    0x1(%rdi,%rax,1),%rcx
    4187:	48 89 f8             	mov    %rdi,%rax
		hash = hash * seed + (*str++);
    418a:	4c 89 e2             	mov    %r12,%rdx
    418d:	48 83 c0 01          	add    $0x1,%rax
    4191:	48 c1 e2 06          	shl    $0x6,%rdx
    4195:	4c 01 e2             	add    %r12,%rdx
    4198:	49 8d 14 54          	lea    (%r12,%rdx,2),%rdx
    419c:	4c 0f be 60 ff       	movsbq -0x1(%rax),%r12
    41a1:	49 01 d4             	add    %rdx,%r12
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    41a4:	48 39 c8             	cmp    %rcx,%rax
    41a7:	75 e1                	jne    418a <dafs_empty_dir+0x2fa>
    }

    ph_hash = BKDRHash(phname, flen);
    kfree(phname);
    41a9:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    41ad:	e8 00 00 00 00       	callq  41b2 <dafs_empty_dir+0x322>
    kfree(ph);
    41b2:	4c 89 f7             	mov    %r14,%rdi
    41b5:	e8 00 00 00 00       	callq  41ba <dafs_empty_dir+0x32a>
    /*lookup in hash table, not decided*/
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    41ba:	49 8b 77 18          	mov    0x18(%r15),%rsi
    41be:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    41c2:	4c 8d 45 cc          	lea    -0x34(%rbp),%r8
    41c6:	4c 89 e2             	mov    %r12,%rdx
    41c9:	b9 01 00 00 00       	mov    $0x1,%ecx
    41ce:	e8 00 00 00 00       	callq  41d3 <dafs_empty_dir+0x343>
    if(!ret)
    41d3:	85 c0                	test   %eax,%eax
        return -EINVAL;
    41d5:	ba ea ff ff ff       	mov    $0xffffffea,%edx
    ph_hash = BKDRHash(phname, flen);
    kfree(phname);
    kfree(ph);
    /*lookup in hash table, not decided*/
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    if(!ret)
    41da:	74 5f                	je     423b <dafs_empty_dir+0x3ab>
        return -EINVAL;

    //direntry = &dafs_ze->dentry[de_pos];
    
    par_dir = radix_tree_lookup(&dzt_ei->dir_tree, ph_hash);
    41dc:	49 8d 7f 38          	lea    0x38(%r15),%rdi
    41e0:	4c 89 e6             	mov    %r12,%rsi
    41e3:	e8 00 00 00 00       	callq  41e8 <dafs_empty_dir+0x358>
   /* if(par_dir){
        nova_dbg("%s dafs find par dir, num is %d",__func__,par_dir->sub_num);
    }*/
    nr_de = par_dir->sub_num;
    41e8:	4c 8b 58 08          	mov    0x8(%rax),%r11
    if(nr_de > 2)
    41ec:	49 83 fb 02          	cmp    $0x2,%r11
    41f0:	77 47                	ja     4239 <dafs_empty_dir+0x3a9>
        return 0;

    head = &par_dir->sub_file;

    for(i = 0; i < nr_de; i++){
    41f2:	4d 85 db             	test   %r11,%r11
    }*/
    nr_de = par_dir->sub_num;
    if(nr_de > 2)
        return 0;

    head = &par_dir->sub_file;
    41f5:	4c 8d 40 18          	lea    0x18(%rax),%r8

    for(i = 0; i < nr_de; i++){
    41f9:	0f 84 85 00 00 00    	je     4284 <dafs_empty_dir+0x3f4>
    41ff:	4c 8b 50 18          	mov    0x18(%rax),%r10
    4203:	45 31 c9             	xor    %r9d,%r9d
        list_for_each(this, head) {
    4206:	4d 39 d0             	cmp    %r10,%r8
    4209:	4c 89 d0             	mov    %r10,%rax
    420c:	8b 55 cc             	mov    -0x34(%rbp),%edx
    420f:	74 0e                	je     421f <dafs_empty_dir+0x38f>
            tem_sf = list_entry(this, struct file_p, list);
            de_pos = tem_sf->pos;
    4211:	8b 50 10             	mov    0x10(%rax),%edx
    4214:	89 55 cc             	mov    %edx,-0x34(%rbp)
        return 0;

    head = &par_dir->sub_file;

    for(i = 0; i < nr_de; i++){
        list_for_each(this, head) {
    4217:	48 8b 00             	mov    (%rax),%rax
    421a:	49 39 c0             	cmp    %rax,%r8
    421d:	75 f2                	jne    4211 <dafs_empty_dir+0x381>
}*/
/*use dafs*/
static inline int is_dir_init_entry(struct super_block *sb,
	struct dafs_dentry *entry)
{
	if (entry->name_len == 1 && strncmp(entry->name, ".", 1) == 0)
    421f:	48 8d 82 81 00 00 00 	lea    0x81(%rdx),%rax
    4226:	48 c1 e0 07          	shl    $0x7,%rax
    422a:	0f b6 4c 03 01       	movzbl 0x1(%rbx,%rax,1),%ecx
    422f:	80 f9 01             	cmp    $0x1,%cl
    4232:	74 57                	je     428b <dafs_empty_dir+0x3fb>
		return 1;
	if (entry->name_len == 2 && strncmp(entry->name, "..", 2) == 0)
    4234:	80 f9 02             	cmp    $0x2,%cl
    4237:	74 26                	je     425f <dafs_empty_dir+0x3cf>
   /* if(par_dir){
        nova_dbg("%s dafs find par dir, num is %d",__func__,par_dir->sub_num);
    }*/
    nr_de = par_dir->sub_num;
    if(nr_de > 2)
        return 0;
    4239:	31 d2                	xor    %edx,%edx
    }

    //nova_dbg("%s dir is empty",__func__);
    return 1;

}
    423b:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    423f:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    4246:	00 00 
    4248:	89 d0                	mov    %edx,%eax
    424a:	0f 85 d1 00 00 00    	jne    4321 <dafs_empty_dir+0x491>
    4250:	48 83 c4 28          	add    $0x28,%rsp
    4254:	5b                   	pop    %rbx
    4255:	41 5c                	pop    %r12
    4257:	41 5d                	pop    %r13
    4259:	41 5e                	pop    %r14
    425b:	41 5f                	pop    %r15
    425d:	5d                   	pop    %rbp
    425e:	c3                   	retq   
    425f:	48 c1 e2 07          	shl    $0x7,%rdx
    4263:	b9 02 00 00 00       	mov    $0x2,%ecx
    4268:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    426f:	48 8d b4 13 b0 40 00 	lea    0x40b0(%rbx,%rdx,1),%rsi
    4276:	00 
    4277:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    4279:	75 be                	jne    4239 <dafs_empty_dir+0x3a9>
    if(nr_de > 2)
        return 0;

    head = &par_dir->sub_file;

    for(i = 0; i < nr_de; i++){
    427b:	41 83 c1 01          	add    $0x1,%r9d
    427f:	45 39 d9             	cmp    %r11d,%r9d
    4282:	75 82                	jne    4206 <dafs_empty_dir+0x376>
        if(!is_dir_init_entry(sb, denties[i]))
            return 0;
    }

    //nova_dbg("%s dir is empty",__func__);
    return 1;
    4284:	ba 01 00 00 00       	mov    $0x1,%edx
    4289:	eb b0                	jmp    423b <dafs_empty_dir+0x3ab>
}*/
/*use dafs*/
static inline int is_dir_init_entry(struct super_block *sb,
	struct dafs_dentry *entry)
{
	if (entry->name_len == 1 && strncmp(entry->name, ".", 1) == 0)
    428b:	80 7c 03 30 2e       	cmpb   $0x2e,0x30(%rbx,%rax,1)
    4290:	75 a7                	jne    4239 <dafs_empty_dir+0x3a9>
    if(nr_de > 2)
        return 0;

    head = &par_dir->sub_file;

    for(i = 0; i < nr_de; i++){
    4292:	41 83 c1 01          	add    $0x1,%r9d
    4296:	45 39 d9             	cmp    %r11d,%r9d
    4299:	0f 85 67 ff ff ff    	jne    4206 <dafs_empty_dir+0x376>
    429f:	eb e3                	jmp    4284 <dafs_empty_dir+0x3f4>

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    42a1:	31 f6                	xor    %esi,%esi
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    42a3:	4c 89 ef             	mov    %r13,%rdi
    42a6:	e8 00 00 00 00       	callq  42ab <dafs_empty_dir+0x41b>
        if(dzt_ei){
    42ab:	48 85 c0             	test   %rax,%rax
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    42ae:	49 89 c7             	mov    %rax,%r15
        if(dzt_ei){
    42b1:	0f 84 ec fd ff ff    	je     40a3 <dafs_empty_dir+0x213>
    42b7:	e9 5c fe ff ff       	jmpq   4118 <dafs_empty_dir+0x288>
            goto END;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    42bc:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    memcpy(ph+1,end,1);
    42c1:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    42c7:	be 2f 00 00 00       	mov    $0x2f,%esi
    42cc:	4c 89 ef             	mov    %r13,%rdi
    42cf:	e8 00 00 00 00       	callq  42d4 <dafs_empty_dir+0x444>
    if(!dzt_ei){
    42d4:	48 85 c0             	test   %rax,%rax

    /*root dir*/
    memcpy(ph, "/", 1);
    memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    42d7:	49 89 c7             	mov    %rax,%r15
    if(!dzt_ei){
    42da:	0f 85 38 fe ff ff    	jne    4118 <dafs_empty_dir+0x288>
    42e0:	e8 00 00 00 00       	callq  42e5 <dafs_empty_dir+0x455>
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
        flen = strlen(ph);
    42e5:	e8 00 00 00 00       	callq  42ea <dafs_empty_dir+0x45a>
        memcpy(phname, ph, flen);
    42ea:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    42ee:	48 89 c2             	mov    %rax,%rdx
    42f1:	4c 89 f6             	mov    %r14,%rsi
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
        flen = strlen(ph);
    42f4:	49 89 c4             	mov    %rax,%r12
        memcpy(phname, ph, flen);
    42f7:	e8 00 00 00 00       	callq  42fc <dafs_empty_dir+0x46c>
    42fc:	e9 6c fe ff ff       	jmpq   416d <dafs_empty_dir+0x2dd>
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
        strcat(buf,"/");
    4301:	48 89 df             	mov    %rbx,%rdi
    4304:	e8 00 00 00 00       	callq  4309 <dafs_empty_dir+0x479>
    4309:	b9 2f 00 00 00       	mov    $0x2f,%ecx
    430e:	66 89 0c 03          	mov    %cx,(%rbx,%rax,1)
    4312:	e9 52 fc ff ff       	jmpq   3f69 <dafs_empty_dir+0xd9>
    4317:	45 31 e4             	xor    %r12d,%r12d
    431a:	e9 8a fe ff ff       	jmpq   41a9 <dafs_empty_dir+0x319>
        memcpy(tem+tlen, end, 1);
        if(!strcmp(tem,"/"))
            break;
    }while(1);

    BUG_ON(strlen(ph)==1024);
    431f:	0f 0b                	ud2    
    }

    //nova_dbg("%s dir is empty",__func__);
    return 1;

}
    4321:	e8 00 00 00 00       	callq  4326 <dafs_empty_dir+0x496>
    4326:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    432d:	00 00 00 

0000000000004330 <add_rename_zone_dir>:

/*add rename zone root dentry
 * dentry 是新的dentry*/
int add_rename_zone_dir(struct dentry *dentry, struct dafs_dentry *old_de, struct dzt_entry_info *old_ei,
        u64 *new_hn, u64 *root_len)
{
    4330:	e8 00 00 00 00       	callq  4335 <add_rename_zone_dir+0x5>
    4335:	55                   	push   %rbp
    4336:	48 89 e5             	mov    %rsp,%rbp
    4339:	41 57                	push   %r15
    433b:	41 56                	push   %r14
    433d:	41 55                	push   %r13
    433f:	41 54                	push   %r12
    4341:	49 89 fe             	mov    %rdi,%r14
    4344:	53                   	push   %rbx
    4345:	48 81 ec c0 00 00 00 	sub    $0xc0,%rsp
    
	/*nova_dbg_verbose("%s: dir %lu new inode %llu\n",
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
    434c:	44 8b 1d 00 00 00 00 	mov    0x0(%rip),%r11d        # 4353 <add_rename_zone_dir+0x23>
{
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
    struct nova_inode *pidir;
    //const char *name = dentry->d_name.name;
    unsigned short namelen = dentry->d_name.len;
    4353:	8b 5f 24             	mov    0x24(%rdi),%ebx

/*add rename zone root dentry
 * dentry 是新的dentry*/
int add_rename_zone_dir(struct dentry *dentry, struct dafs_dentry *old_de, struct dzt_entry_info *old_ei,
        u64 *new_hn, u64 *root_len)
{
    4356:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    435d:	00 00 
    435f:	48 89 84 24 b8 00 00 	mov    %rax,0xb8(%rsp)
    4366:	00 
    4367:	31 c0                	xor    %eax,%eax
    struct inode *dir = dentry->d_parent->d_inode;
    4369:	48 8b 47 18          	mov    0x18(%rdi),%rax

/*add rename zone root dentry
 * dentry 是新的dentry*/
int add_rename_zone_dir(struct dentry *dentry, struct dafs_dentry *old_de, struct dzt_entry_info *old_ei,
        u64 *new_hn, u64 *root_len)
{
    436d:	48 89 74 24 50       	mov    %rsi,0x50(%rsp)
    
	/*nova_dbg_verbose("%s: dir %lu new inode %llu\n",
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
    4372:	45 85 db             	test   %r11d,%r11d

/*add rename zone root dentry
 * dentry 是新的dentry*/
int add_rename_zone_dir(struct dentry *dentry, struct dafs_dentry *old_de, struct dzt_entry_info *old_ei,
        u64 *new_hn, u64 *root_len)
{
    4375:	48 89 54 24 48       	mov    %rdx,0x48(%rsp)
    437a:	48 89 4c 24 40       	mov    %rcx,0x40(%rsp)
    437f:	4c 89 44 24 30       	mov    %r8,0x30(%rsp)
    struct inode *dir = dentry->d_parent->d_inode;
    4384:	48 8b 40 30          	mov    0x30(%rax),%rax
    4388:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
    struct super_block *sb = dir->i_sb;
    438d:	48 8b 40 28          	mov    0x28(%rax),%rax
    4391:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
    
	/*nova_dbg_verbose("%s: dir %lu new inode %llu\n",
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
    4396:	0f 85 40 08 00 00    	jne    4bdc <add_rename_zone_dir+0x8ac>
	if (namelen == 0)
    439c:	66 85 db             	test   %bx,%bx
    439f:	0f 84 f8 08 00 00    	je     4c9d <add_rename_zone_dir+0x96d>
		return -EINVAL;
   
    ph = get_dentry_path(dentry,0);
    43a5:	4c 89 f7             	mov    %r14,%rdi
    43a8:	e8 53 bd ff ff       	callq  100 <get_dentry_path.isra.4>
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    43ad:	48 89 c7             	mov    %rax,%rdi

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
	if (namelen == 0)
		return -EINVAL;
   
    ph = get_dentry_path(dentry,0);
    43b0:	48 89 c3             	mov    %rax,%rbx
    43b3:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    43b8:	e8 00 00 00 00       	callq  43bd <add_rename_zone_dir+0x8d>
    43bd:	48 89 c7             	mov    %rax,%rdi
    43c0:	e8 2b bd ff ff       	callq  f0 <kzalloc.constprop.9>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    43c5:	48 89 df             	mov    %rbx,%rdi
	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
	if (namelen == 0)
		return -EINVAL;
   
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    43c8:	49 89 c7             	mov    %rax,%r15
    43cb:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    43d0:	e8 00 00 00 00       	callq  43d5 <add_rename_zone_dir+0xa5>
    43d5:	48 89 c7             	mov    %rax,%rdi
    43d8:	e8 13 bd ff ff       	callq  f0 <kzalloc.constprop.9>
    memcpy(phname, ph, strlen(ph));
    43dd:	48 89 df             	mov    %rbx,%rdi
	if (namelen == 0)
		return -EINVAL;
   
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    43e0:	49 89 c4             	mov    %rax,%r12
    memcpy(phname, ph, strlen(ph));
    43e3:	e8 00 00 00 00       	callq  43e8 <add_rename_zone_dir+0xb8>
    43e8:	48 89 de             	mov    %rbx,%rsi
    43eb:	48 89 c2             	mov    %rax,%rdx
    43ee:	4c 89 ff             	mov    %r15,%rdi
    43f1:	e8 00 00 00 00       	callq  43f6 <add_rename_zone_dir+0xc6>
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    43f6:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    43fb:	4c 89 ff             	mov    %r15,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    43fe:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
    4405:	4c 8b a8 d8 01 00 00 	mov    0x1d8(%rax),%r13
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    440c:	e8 00 00 00 00       	callq  4411 <add_rename_zone_dir+0xe1>
    4411:	4c 89 fe             	mov    %r15,%rsi
    4414:	48 89 c2             	mov    %rax,%rdx
    4417:	4c 89 e7             	mov    %r12,%rdi
    441a:	e8 00 00 00 00       	callq  441f <add_rename_zone_dir+0xef>
    tlen = strlen(phstr);
    441f:	4c 89 ff             	mov    %r15,%rdi
    4422:	e8 00 00 00 00       	callq  4427 <add_rename_zone_dir+0xf7>
    4427:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
    442a:	be 2f 00 00 00       	mov    $0x2f,%esi
    442f:	4c 89 e7             	mov    %r12,%rdi
    4432:	e8 00 00 00 00       	callq  4437 <add_rename_zone_dir+0x107>
        phlen = tlen -strlen(tem);
    4437:	48 89 c7             	mov    %rax,%rdi
    443a:	e8 00 00 00 00       	callq  443f <add_rename_zone_dir+0x10f>
        tlen = phlen;
        //bug
        if(phlen==0){
    443f:	48 29 c3             	sub    %rax,%rbx
    4442:	0f 84 0c 06 00 00    	je     4a54 <add_rename_zone_dir+0x724>
            break;
        }
        memcpy(ph,phstr,tlen);
    4448:	48 89 da             	mov    %rbx,%rdx
    444b:	4c 89 fe             	mov    %r15,%rsi
    444e:	4c 89 e7             	mov    %r12,%rdi
    4451:	e8 00 00 00 00       	callq  4456 <add_rename_zone_dir+0x126>
	int i;

	for (i = 0; i < length; i++) {
    4456:	85 db                	test   %ebx,%ebx
        memcpy(ph+tlen, end, 1);
    4458:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
    445d:	0f 8e 78 05 00 00    	jle    49db <add_rename_zone_dir+0x6ab>
    4463:	8d 43 ff             	lea    -0x1(%rbx),%eax
    4466:	4c 89 e2             	mov    %r12,%rdx
    4469:	31 f6                	xor    %esi,%esi
    446b:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
    4470:	48 89 f0             	mov    %rsi,%rax
    4473:	48 83 c2 01          	add    $0x1,%rdx
    4477:	48 c1 e0 06          	shl    $0x6,%rax
    447b:	48 01 f0             	add    %rsi,%rax
    447e:	48 8d 04 46          	lea    (%rsi,%rax,2),%rax
    4482:	48 0f be 72 ff       	movsbq -0x1(%rdx),%rsi
    4487:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    448a:	48 39 d1             	cmp    %rdx,%rcx
    448d:	75 e1                	jne    4470 <add_rename_zone_dir+0x140>
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    448f:	4c 89 ef             	mov    %r13,%rdi
    4492:	e8 00 00 00 00       	callq  4497 <add_rename_zone_dir+0x167>
        if(dzt_ei){
    4497:	48 85 c0             	test   %rax,%rax
    449a:	74 8e                	je     442a <add_rename_zone_dir+0xfa>
    449c:	48 89 84 24 80 00 00 	mov    %rax,0x80(%rsp)
    44a3:	00 
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    44a4:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    memcpy(phname, ph, strlen(ph));
    dzt_ei = find_dzt(sb, phname, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    44a9:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
    44b0:	00 
    44b1:	48 8b 97 b0 03 00 00 	mov    0x3b0(%rdi),%rdx
    44b8:	48 8b 40 10          	mov    0x10(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    44bc:	48 89 c7             	mov    %rax,%rdi
    44bf:	48 03 7a 18          	add    0x18(%rdx),%rdi
    44c3:	48 85 c0             	test   %rax,%rax
    44c6:	b8 00 00 00 00       	mov    $0x0,%eax
    44cb:	48 0f 45 c7          	cmovne %rdi,%rax

    make_zone_ptr(&zone_p, dafs_ze);
    44cf:	48 8d bc 24 90 00 00 	lea    0x90(%rsp),%rdi
    44d6:	00 
    struct file_p *tem_sf, *new_sf;
    struct list_head *this, *head, *next;
    char *phname, *new_pn, *ph, *phn, *par_ph, *tname;
    unsigned long phlen;
    //unsigned short delen;
    u32 bitpos = 0, cur_pos = 0, par_pos;
    44d7:	45 31 ff             	xor    %r15d,%r15d
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    memcpy(phname, ph, strlen(ph));
    dzt_ei = find_dzt(sb, phname, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    44da:	48 89 c6             	mov    %rax,%rsi
    44dd:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
    44e2:	e8 00 00 00 00       	callq  44e7 <add_rename_zone_dir+0x1b7>
    44e7:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
    44ee:	00 
    struct file_p *tem_sf, *new_sf;
    struct list_head *this, *head, *next;
    char *phname, *new_pn, *ph, *phn, *par_ph, *tname;
    unsigned long phlen;
    //unsigned short delen;
    u32 bitpos = 0, cur_pos = 0, par_pos;
    44ef:	31 d2                	xor    %edx,%edx
    44f1:	48 8b 30             	mov    (%rax),%rsi
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    memcpy(phname, ph, strlen(ph));
    dzt_ei = find_dzt(sb, phname, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    44f4:	31 c0                	xor    %eax,%eax
    44f6:	eb 17                	jmp    450f <add_rename_zone_dir+0x1df>
    while(cur_pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
            bitpos+=2;
    44f8:	83 c2 02             	add    $0x2,%edx
            cur_pos++;
    44fb:	41 83 c7 01          	add    $0x1,%r15d
    44ff:	48 83 c0 02          	add    $0x2,%rax
    memcpy(phname, ph, strlen(ph));
    dzt_ei = find_dzt(sb, phname, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    while(cur_pos<NR_DENTRY_IN_ZONE){
    4503:	81 fa fe ff 01 00    	cmp    $0x1fffe,%edx
    4509:	0f 84 bd 06 00 00    	je     4bcc <add_rename_zone_dir+0x89c>

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    450f:	48 0f a3 06          	bt     %rax,(%rsi)
    4513:	19 c9                	sbb    %ecx,%ecx
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
    4515:	85 c9                	test   %ecx,%ecx
    4517:	75 df                	jne    44f8 <add_rename_zone_dir+0x1c8>
    4519:	48 8d 58 01          	lea    0x1(%rax),%rbx
    451d:	48 0f a3 1e          	bt     %rbx,(%rsi)
    4521:	19 c9                	sbb    %ecx,%ecx
    4523:	85 c9                	test   %ecx,%ecx
    4525:	75 d1                	jne    44f8 <add_rename_zone_dir+0x1c8>
        }else{
            break;
        }
    }

    phlen = strlen(phn);
    4527:	4c 89 e7             	mov    %r12,%rdi
    452a:	e8 00 00 00 00       	callq  452f <add_rename_zone_dir+0x1ff>
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
    452f:	4c 8b 6c 24 58       	mov    0x58(%rsp),%r13
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    4534:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    4539:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    453e:	48 8b 97 b0 03 00 00 	mov    0x3b0(%rdi),%rdx
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
    4545:	49 8b 45 c8          	mov    -0x38(%r13),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    4549:	48 89 c7             	mov    %rax,%rdi
    454c:	48 03 7a 18          	add    0x18(%rdx),%rdi
    4550:	48 85 c0             	test   %rax,%rax
    4553:	b8 00 00 00 00       	mov    $0x0,%eax
    4558:	48 0f 45 c7          	cmovne %rdi,%rax
    455c:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    pidir = nova_get_inode(sb, dir);
    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    4561:	e8 00 00 00 00       	callq  4566 <add_rename_zone_dir+0x236>
    4566:	49 c7 85 80 00 00 00 	movq   $0x0,0x80(%r13)
    456d:	00 00 00 00 
    4571:	49 89 45 78          	mov    %rax,0x78(%r13)
    4575:	4c 89 ef             	mov    %r13,%rdi
    4578:	49 8b 45 78          	mov    0x78(%r13),%rax
    457c:	49 8b 95 80 00 00 00 	mov    0x80(%r13),%rdx
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = dentry->d_name.len;
    dafs_de->file_type = ROOT_DIRECTORY;       //file_type是啥？ not decided

	dafs_de->links_count = old_de->links_count;
    4583:	48 8b 74 24 50       	mov    0x50(%rsp),%rsi
        }
    }

    phlen = strlen(phn);
    pidir = nova_get_inode(sb, dir);
    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    4588:	49 89 45 68          	mov    %rax,0x68(%r13)
    458c:	49 89 55 70          	mov    %rdx,0x70(%r13)
    //delen = DAFS_DIR_LEN(namelen + phlen);  

    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    4590:	44 89 f8             	mov    %r15d,%eax
    4593:	48 8b 54 24 70       	mov    0x70(%rsp),%rdx
    4598:	48 89 c1             	mov    %rax,%rcx
    459b:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
    45a0:	48 05 81 00 00 00    	add    $0x81,%rax
    45a6:	48 c1 e0 07          	shl    $0x7,%rax
    45aa:	48 01 d0             	add    %rdx,%rax
    45ad:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    45b2:	48 89 c8             	mov    %rcx,%rax
    45b5:	48 89 d1             	mov    %rdx,%rcx
    45b8:	48 c1 e0 07          	shl    $0x7,%rax
    45bc:	4c 8d 2c 02          	lea    (%rdx,%rax,1),%r13
    //memset(dafs_de, 0, sizeof(dafs_de));
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    45c0:	41 c6 85 80 40 00 00 	movb   $0x6,0x4080(%r13)
    45c7:	06 
    dafs_de->name_len = dentry->d_name.len;
    45c8:	41 8b 56 24          	mov    0x24(%r14),%edx
    dafs_de->file_type = ROOT_DIRECTORY;       //file_type是啥？ not decided
    45cc:	41 c6 85 82 40 00 00 	movb   $0x2,0x4082(%r13)
    45d3:	02 
    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    //memset(dafs_de, 0, sizeof(dafs_de));
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = dentry->d_name.len;
    45d4:	41 88 95 81 40 00 00 	mov    %dl,0x4081(%r13)
    dafs_de->file_type = ROOT_DIRECTORY;       //file_type是啥？ not decided

	dafs_de->links_count = old_de->links_count;
    45db:	0f b7 56 06          	movzwl 0x6(%rsi),%edx
    45df:	66 41 89 95 86 40 00 	mov    %dx,0x4086(%r13)
    45e6:	00 

    dafs_de->mtime = cpu_to_le32(dir->i_mtime.tv_sec);
    45e7:	48 8b 57 68          	mov    0x68(%rdi),%rdx
    45eb:	41 89 95 88 40 00 00 	mov    %edx,0x4088(%r13)
    /*not root at first*/
    //dafs_de->isr_sf = old_de->isr_sf;
    dafs_de->ino = old_de->ino;
    45f2:	48 8b 56 18          	mov    0x18(%rsi),%rdx
    45f6:	49 89 95 98 40 00 00 	mov    %rdx,0x4098(%r13)
    dafs_de->size = cpu_to_le64(dir->i_size);
    45fd:	48 8b 57 50          	mov    0x50(%rdi),%rdx
    4601:	49 89 95 a0 40 00 00 	mov    %rdx,0x40a0(%r13)
    /*add dentry name*/
    if(dentry->d_name.len <= SMALL_NAME_LEN){
    4608:	41 83 7e 24 27       	cmpl   $0x27,0x24(%r14)
    460d:	0f 87 70 05 00 00    	ja     4b83 <add_rename_zone_dir+0x853>
        dafs_de->ext_flag = 0;
    4613:	45 31 d2             	xor    %r10d,%r10d
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
    4616:	48 8d bc 01 b0 40 00 	lea    0x40b0(%rcx,%rax,1),%rdi
    461d:	00 
    //dafs_de->isr_sf = old_de->isr_sf;
    dafs_de->ino = old_de->ino;
    dafs_de->size = cpu_to_le64(dir->i_size);
    /*add dentry name*/
    if(dentry->d_name.len <= SMALL_NAME_LEN){
        dafs_de->ext_flag = 0;
    461e:	66 45 89 95 84 40 00 	mov    %r10w,0x4084(%r13)
    4625:	00 
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
    4626:	41 8b 56 24          	mov    0x24(%r14),%edx
    462a:	49 8b 76 28          	mov    0x28(%r14),%rsi
    462e:	e8 00 00 00 00       	callq  4633 <add_rename_zone_dir+0x303>
        dafs_de->name[dentry->d_name.len] = '\0'; 
    4633:	41 8b 46 24          	mov    0x24(%r14),%eax
    4637:	41 c6 84 05 b0 40 00 	movb   $0x0,0x40b0(%r13,%rax,1)
    463e:	00 00 
    } else {
        dafs_de->ext_flag = 1;
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, cur_pos, dentry->d_name.len, dentry->d_name.name, 0);
    }

    dafs_de->fname_len = cpu_to_le64(phlen);
    4640:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
    4645:	48 8b 7c 24 68       	mov    0x68(%rsp),%rdi
    464a:	48 8b 4c 24 70       	mov    0x70(%rsp),%rcx
    464f:	48 c1 e0 07          	shl    $0x7,%rax
    4653:	48 89 bc 01 90 40 00 	mov    %rdi,0x4090(%rcx,%rax,1)
    465a:	00 

    /*set isr_sf, fulname*/
    temlen = phlen - dentry->d_name.len;
    465b:	41 8b 46 24          	mov    0x24(%r14),%eax
    465f:	49 89 fe             	mov    %rdi,%r14
    4662:	49 29 c6             	sub    %rax,%r14
    if(temlen == 1){
    4665:	49 83 fe 01          	cmp    $0x1,%r14
    4669:	0f 85 13 04 00 00    	jne    4a82 <add_rename_zone_dir+0x752>
        dafs_de->isr_sf = 1;
    466f:	41 c6 85 83 40 00 00 	movb   $0x1,0x4083(%r13)
    4676:	01 
        dafs_de->par_pos = 0;
    4677:	41 c7 85 8c 40 00 00 	movl   $0x0,0x408c(%r13)
    467e:	00 00 00 00 
        kfree(par_ph);
        
    }

    /*set root dir fulname*/
    if(dafs_de->ext_flag==0){
    4682:	66 41 83 bd 84 40 00 	cmpw   $0x0,0x4084(%r13)
    4689:	00 00 
    468b:	0f 85 85 03 00 00    	jne    4a16 <add_rename_zone_dir+0x6e6>
        //re_len = SMALL_NAME_LEN - dentry->d_name.len;
        if(phlen<SMALL_NAME_LEN){
    4691:	4c 8b 74 24 68       	mov    0x68(%rsp),%r14
    4696:	49 83 fe 26          	cmp    $0x26,%r14
    469a:	0f 87 68 03 00 00    	ja     4a08 <add_rename_zone_dir+0x6d8>
            memcpy(dafs_de->ful_name.f_name, phn, phlen);
    46a0:	4c 8b 6c 24 60       	mov    0x60(%rsp),%r13
    46a5:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    46aa:	4c 89 f2             	mov    %r14,%rdx
    46ad:	4c 89 e6             	mov    %r12,%rsi
    46b0:	49 c1 e5 07          	shl    $0x7,%r13
    46b4:	4a 8d bc 2f d8 40 00 	lea    0x40d8(%rdi,%r13,1),%rdi
    46bb:	00 
    46bc:	e8 00 00 00 00       	callq  46c1 <add_rename_zone_dir+0x391>
            dafs_de->ful_name.f_name[phlen]='\0';
    46c1:	4c 03 6c 24 70       	add    0x70(%rsp),%r13
    46c6:	43 c6 84 2e d8 40 00 	movb   $0x0,0x40d8(%r14,%r13,1)
    46cd:	00 00 
    46cf:	45 89 f5             	mov    %r14d,%r13d
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    46d2:	45 85 ed             	test   %r13d,%r13d
    46d5:	0f 8e cc 05 00 00    	jle    4ca7 <add_rename_zone_dir+0x977>
    46db:	41 83 ed 01          	sub    $0x1,%r13d
    46df:	4c 89 e0             	mov    %r12,%rax
    46e2:	45 31 f6             	xor    %r14d,%r14d
    46e5:	49 83 c5 01          	add    $0x1,%r13
    46e9:	4b 8d 0c 2c          	lea    (%r12,%r13,1),%rcx
		hash = hash * seed + (*str++);
    46ed:	4c 89 f2             	mov    %r14,%rdx
    46f0:	48 83 c0 01          	add    $0x1,%rax
    46f4:	48 c1 e2 06          	shl    $0x6,%rdx
    46f8:	4c 01 f2             	add    %r14,%rdx
    46fb:	49 8d 14 56          	lea    (%r14,%rdx,2),%rdx
    46ff:	4c 0f be 70 ff       	movsbq -0x1(%rax),%r14
    4704:	49 01 d6             	add    %rdx,%r14
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    4707:	48 39 c8             	cmp    %rcx,%rax
    470a:	75 e1                	jne    46ed <add_rename_zone_dir+0x3bd>
    /*get hash value*/
    hashname = BKDRHash(phn, phlen);


    /*get new ei path hashname*/
    if(dzt_ei->dzt_eno!=1){
    470c:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
    4713:	00 
    4714:	83 78 08 01          	cmpl   $0x1,0x8(%rax)
    4718:	0f 84 11 05 00 00    	je     4c2f <add_rename_zone_dir+0x8ff>
        newp_len =(u64)dzt_ei->root_len + phlen;
    471e:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
    4725:	00 
    4726:	4c 8b 6c 24 68       	mov    0x68(%rsp),%r13
    472b:	4c 03 68 28          	add    0x28(%rax),%r13
        new_pn = kzalloc(sizeof(char)*newp_len, GFP_KERNEL);
    472f:	4c 89 ef             	mov    %r13,%rdi
    4732:	e8 b9 b9 ff ff       	callq  f0 <kzalloc.constprop.9>
        get_zone_path(sb,dzt_ei, new_pn, phn);
    4737:	48 8b b4 24 80 00 00 	mov    0x80(%rsp),%rsi
    473e:	00 
    473f:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    4744:	4c 89 e1             	mov    %r12,%rcx
    4747:	48 89 c2             	mov    %rax,%rdx
    474a:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    474f:	e8 00 00 00 00       	callq  4754 <add_rename_zone_dir+0x424>
        *root_len = newp_len;
    4754:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    4759:	45 85 ed             	test   %r13d,%r13d
    475c:	4c 8b 44 24 68       	mov    0x68(%rsp),%r8
    4761:	4c 89 28             	mov    %r13,(%rax)
    4764:	0f 8e 81 05 00 00    	jle    4ceb <add_rename_zone_dir+0x9bb>
    476a:	41 8d 45 ff          	lea    -0x1(%r13),%eax
    476e:	4c 89 c1             	mov    %r8,%rcx
    4771:	49 8d 74 00 01       	lea    0x1(%r8,%rax,1),%rsi
    4776:	31 c0                	xor    %eax,%eax
		hash = hash * seed + (*str++);
    4778:	48 89 c2             	mov    %rax,%rdx
    477b:	48 83 c1 01          	add    $0x1,%rcx
    477f:	48 c1 e2 06          	shl    $0x6,%rdx
    4783:	48 01 c2             	add    %rax,%rdx
    4786:	48 8d 04 50          	lea    (%rax,%rdx,2),%rax
    478a:	48 0f be 51 ff       	movsbq -0x1(%rcx),%rdx
    478f:	48 01 d0             	add    %rdx,%rax
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    4792:	48 39 ce             	cmp    %rcx,%rsi
    4795:	75 e1                	jne    4778 <add_rename_zone_dir+0x448>
        *new_hn = BKDRHash(new_pn, newp_len);
    4797:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
    479c:	48 89 07             	mov    %rax,(%rdi)
        kfree(new_pn);
    479f:	4c 89 c7             	mov    %r8,%rdi
    47a2:	e8 00 00 00 00       	callq  47a7 <add_rename_zone_dir+0x477>
        *root_len = newp_len;
        *new_hn = BKDRHash(new_pn, newp_len);
        kfree(new_pn);
    }

    dafs_de->dzt_hn = cpu_to_le64(*new_hn);
    47a7:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
    47ac:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    47b1:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
    47b6:	48 8b 10             	mov    (%rax),%rdx
    47b9:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
    47be:	89 f1                	mov    %esi,%ecx
    47c0:	83 e1 3f             	and    $0x3f,%ecx
    47c3:	48 c1 e0 07          	shl    $0x7,%rax
    47c7:	83 e9 80             	sub    $0xffffff80,%ecx
    47ca:	48 89 94 07 a8 40 00 	mov    %rdx,0x40a8(%rdi,%rax,1)
    47d1:	00 
	if (support_clwb) {
    47d2:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # 47d8 <add_rename_zone_dir+0x4a8>
    47d8:	31 d2                	xor    %edx,%edx
    47da:	85 ff                	test   %edi,%edi
    47dc:	0f 85 11 02 00 00    	jne    49f3 <add_rename_zone_dir+0x6c3>
    47e2:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    47e7:	89 d0                	mov    %edx,%eax
    47e9:	48 01 f0             	add    %rsi,%rax
    47ec:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    47ef:	83 c2 40             	add    $0x40,%edx
    47f2:	39 d1                	cmp    %edx,%ecx
    47f4:	77 f1                	ja     47e7 <add_rename_zone_dir+0x4b7>
    /*not decided是不是每次写到nvm都需要这个接口*/ 
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    47f6:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
    47fd:	00 
    47fe:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    4801:	f0 48 0f ab 18       	lock bts %rbx,(%rax)
    4806:	72 00                	jb     4808 <add_rename_zone_dir+0x4d8>
    
    dir->i_blocks = pidir->i_blocks;
    4808:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    480d:	48 8b 7c 24 58       	mov    0x58(%rsp),%rdi

    /*cpy dir_info*/
    new_dir = add_dir_info(dzt_ei, hashname, cur_pos);
    4812:	44 89 fa             	mov    %r15d,%edx
    4815:	4c 89 f6             	mov    %r14,%rsi
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    
    dir->i_blocks = pidir->i_blocks;
    4818:	48 8b 40 20          	mov    0x20(%rax),%rax
    481c:	48 89 87 98 00 00 00 	mov    %rax,0x98(%rdi)

    /*cpy dir_info*/
    new_dir = add_dir_info(dzt_ei, hashname, cur_pos);
    4823:	48 8b bc 24 80 00 00 	mov    0x80(%rsp),%rdi
    482a:	00 
    482b:	e8 00 00 00 00       	callq  4830 <add_rename_zone_dir+0x500>
    phlen = le64_to_cpu(old_de->fname_len);
    4830:	4c 8b 6c 24 50       	mov    0x50(%rsp),%r13
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    
    dir->i_blocks = pidir->i_blocks;

    /*cpy dir_info*/
    new_dir = add_dir_info(dzt_ei, hashname, cur_pos);
    4835:	48 89 c3             	mov    %rax,%rbx
    phlen = le64_to_cpu(old_de->fname_len);
    4838:	4d 8b 65 10          	mov    0x10(%r13),%r12
    tname = kzalloc(sizeof(char)*phlen,GFP_KERNEL);
    483c:	4c 89 e7             	mov    %r12,%rdi
    483f:	e8 ac b8 ff ff       	callq  f0 <kzalloc.constprop.9>
    old_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    4844:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    dir->i_blocks = pidir->i_blocks;

    /*cpy dir_info*/
    new_dir = add_dir_info(dzt_ei, hashname, cur_pos);
    phlen = le64_to_cpu(old_de->fname_len);
    tname = kzalloc(sizeof(char)*phlen,GFP_KERNEL);
    4849:	49 89 c2             	mov    %rax,%r10
    484c:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    4851:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    4856:	be 00 00 00 00       	mov    $0x0,%esi
    old_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    485b:	48 8b 57 10          	mov    0x10(%rdi),%rdx
    get_de_name(old_de, old_ze, tname, 1);
    485f:	4c 89 ef             	mov    %r13,%rdi
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    4862:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    4869:	48 89 d1             	mov    %rdx,%rcx
    486c:	48 03 48 18          	add    0x18(%rax),%rcx
    4870:	48 85 d2             	test   %rdx,%rdx
    4873:	4c 89 d2             	mov    %r10,%rdx
    4876:	48 0f 45 f1          	cmovne %rcx,%rsi
    487a:	b9 01 00 00 00       	mov    $0x1,%ecx
    487f:	e8 00 00 00 00       	callq  4884 <add_rename_zone_dir+0x554>
    old_hn = BKDRHash(tname, phlen); 
    old_dir = radix_tree_delete(&old_ei->dir_tree, phlen);
    4884:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    4889:	4c 89 e6             	mov    %r12,%rsi
    488c:	48 83 c7 38          	add    $0x38,%rdi
    4890:	e8 00 00 00 00       	callq  4895 <add_rename_zone_dir+0x565>
    head = &old_dir->sub_file;
    list_for_each_safe(this, next, head){
    4895:	4c 8b 60 18          	mov    0x18(%rax),%r12
    tname = kzalloc(sizeof(char)*phlen,GFP_KERNEL);
    old_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    get_de_name(old_de, old_ze, tname, 1);
    old_hn = BKDRHash(tname, phlen); 
    old_dir = radix_tree_delete(&old_ei->dir_tree, phlen);
    head = &old_dir->sub_file;
    4899:	48 8d 78 18          	lea    0x18(%rax),%rdi
    phlen = le64_to_cpu(old_de->fname_len);
    tname = kzalloc(sizeof(char)*phlen,GFP_KERNEL);
    old_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    get_de_name(old_de, old_ze, tname, 1);
    old_hn = BKDRHash(tname, phlen); 
    old_dir = radix_tree_delete(&old_ei->dir_tree, phlen);
    489d:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    48a2:	48 8d 43 18          	lea    0x18(%rbx),%rax
    head = &old_dir->sub_file;
    list_for_each_safe(this, next, head){
    48a6:	4c 39 e7             	cmp    %r12,%rdi
    48a9:	4d 8b 2c 24          	mov    (%r12),%r13
    48ad:	0f 84 90 00 00 00    	je     4943 <add_rename_zone_dir+0x613>
    48b3:	44 89 7c 24 60       	mov    %r15d,0x60(%rsp)
    48b8:	4c 89 74 24 58       	mov    %r14,0x58(%rsp)
    48bd:	4d 89 e7             	mov    %r12,%r15
    48c0:	4d 89 ee             	mov    %r13,%r14
    48c3:	49 89 fc             	mov    %rdi,%r12
    48c6:	49 89 c5             	mov    %rax,%r13
    48c9:	eb 03                	jmp    48ce <add_rename_zone_dir+0x59e>
    48cb:	49 89 c6             	mov    %rax,%r14
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    48ce:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 48d5 <add_rename_zone_dir+0x5a5>
    48d5:	ba 14 00 00 00       	mov    $0x14,%edx
    48da:	be d0 80 00 00       	mov    $0x80d0,%esi
    48df:	e8 00 00 00 00       	callq  48e4 <add_rename_zone_dir+0x5b4>
        tem_sf = list_entry(this, struct file_p, list);
        new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        new_sf->pos = tem_sf->pos;
    48e4:	41 8b 57 10          	mov    0x10(%r15),%edx
        list_add_tail(&new_sf->list, &new_dir->sub_file);
        list_del(&tem_sf->list);
        kfree(tem_sf);
    48e8:	4c 89 ff             	mov    %r15,%rdi
    old_dir = radix_tree_delete(&old_ei->dir_tree, phlen);
    head = &old_dir->sub_file;
    list_for_each_safe(this, next, head){
        tem_sf = list_entry(this, struct file_p, list);
        new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        new_sf->pos = tem_sf->pos;
    48eb:	89 50 10             	mov    %edx,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    48ee:	48 8b 53 20          	mov    0x20(%rbx),%rdx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    48f2:	48 89 43 20          	mov    %rax,0x20(%rbx)
	new->next = next;
    48f6:	4c 89 28             	mov    %r13,(%rax)
	new->prev = prev;
    48f9:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    48fd:	48 89 02             	mov    %rax,(%rdx)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    4900:	49 8b 47 08          	mov    0x8(%r15),%rax
    4904:	49 8b 17             	mov    (%r15),%rdx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    4907:	48 89 42 08          	mov    %rax,0x8(%rdx)
	prev->next = next;
    490b:	48 89 10             	mov    %rdx,(%rax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    490e:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
    4915:	00 ad de 
    4918:	49 89 07             	mov    %rax,(%r15)
	entry->prev = LIST_POISON2;
    491b:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
    4922:	00 ad de 
    4925:	49 89 47 08          	mov    %rax,0x8(%r15)
    4929:	4d 89 f7             	mov    %r14,%r15
        list_add_tail(&new_sf->list, &new_dir->sub_file);
        list_del(&tem_sf->list);
        kfree(tem_sf);
    492c:	e8 00 00 00 00       	callq  4931 <add_rename_zone_dir+0x601>
    old_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    get_de_name(old_de, old_ze, tname, 1);
    old_hn = BKDRHash(tname, phlen); 
    old_dir = radix_tree_delete(&old_ei->dir_tree, phlen);
    head = &old_dir->sub_file;
    list_for_each_safe(this, next, head){
    4931:	4d 39 f4             	cmp    %r14,%r12
    4934:	49 8b 06             	mov    (%r14),%rax
    4937:	75 92                	jne    48cb <add_rename_zone_dir+0x59b>
    4939:	44 8b 7c 24 60       	mov    0x60(%rsp),%r15d
    493e:	4c 8b 74 24 58       	mov    0x58(%rsp),%r14
        new_sf->pos = tem_sf->pos;
        list_add_tail(&new_sf->list, &new_dir->sub_file);
        list_del(&tem_sf->list);
        kfree(tem_sf);
    }
    kfree(old_dir);
    4943:	48 8b 7c 24 68       	mov    0x68(%rsp),%rdi
    4948:	e8 00 00 00 00       	callq  494d <add_rename_zone_dir+0x61d>

    /*set pos in hash table for each zone*/
    //hashname = BKDRHash(phn, phlen);
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    494d:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
    4954:	00 
    4955:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    495a:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    4960:	44 89 f9             	mov    %r15d,%ecx
    4963:	4c 89 f2             	mov    %r14,%rdx
    4966:	48 8b 70 18          	mov    0x18(%rax),%rsi
    496a:	e8 00 00 00 00       	callq  496f <add_rename_zone_dir+0x63f>

    kfree(tname);
    496f:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    4974:	e8 00 00 00 00       	callq  4979 <add_rename_zone_dir+0x649>
    kfree(phname);
    4979:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    497e:	e8 00 00 00 00       	callq  4983 <add_rename_zone_dir+0x653>
    kfree(ph);
    4983:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
    4988:	e8 00 00 00 00       	callq  498d <add_rename_zone_dir+0x65d>
    kfree(zone_p);
    498d:	48 8b bc 24 90 00 00 	mov    0x90(%rsp),%rdi
    4994:	00 
    4995:	e8 00 00 00 00       	callq  499a <add_rename_zone_dir+0x66a>
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    499a:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 49a0 <add_rename_zone_dir+0x670>
    49a0:	85 c0                	test   %eax,%eax
    49a2:	0f 85 46 02 00 00    	jne    4bee <add_rename_zone_dir+0x8be>
    return ret;
    49a8:	31 c0                	xor    %eax,%eax

    kfree(tname);
    kfree(phname);
    kfree(ph);
    kfree(zone_p);
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    49aa:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 49b2 <add_rename_zone_dir+0x682>
    49b1:	00 
    return ret;
}
    49b2:	48 8b bc 24 b8 00 00 	mov    0xb8(%rsp),%rdi
    49b9:	00 
    49ba:	65 48 33 3c 25 28 00 	xor    %gs:0x28,%rdi
    49c1:	00 00 
    49c3:	0f 85 31 03 00 00    	jne    4cfa <add_rename_zone_dir+0x9ca>
    49c9:	48 81 c4 c0 00 00 00 	add    $0xc0,%rsp
    49d0:	5b                   	pop    %rbx
    49d1:	41 5c                	pop    %r12
    49d3:	41 5d                	pop    %r13
    49d5:	41 5e                	pop    %r14
    49d7:	41 5f                	pop    %r15
    49d9:	5d                   	pop    %rbp
    49da:	c3                   	retq   

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    49db:	31 f6                	xor    %esi,%esi
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    49dd:	4c 89 ef             	mov    %r13,%rdi
    49e0:	e8 00 00 00 00       	callq  49e5 <add_rename_zone_dir+0x6b5>
        if(dzt_ei){
    49e5:	48 85 c0             	test   %rax,%rax
    49e8:	0f 84 3c fa ff ff    	je     442a <add_rename_zone_dir+0xfa>
    49ee:	e9 a9 fa ff ff       	jmpq   449c <add_rename_zone_dir+0x16c>
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    49f3:	89 d0                	mov    %edx,%eax
    49f5:	48 01 f0             	add    %rsi,%rax
    49f8:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    49fc:	83 c2 40             	add    $0x40,%edx
    49ff:	39 d1                	cmp    %edx,%ecx
    4a01:	77 f0                	ja     49f3 <add_rename_zone_dir+0x6c3>
    4a03:	e9 ee fd ff ff       	jmpq   47f6 <add_rename_zone_dir+0x4c6>
        //re_len = SMALL_NAME_LEN - dentry->d_name.len;
        if(phlen<SMALL_NAME_LEN){
            memcpy(dafs_de->ful_name.f_name, phn, phlen);
            dafs_de->ful_name.f_name[phlen]='\0';
        } else {
            dafs_de->ext_flag = 2;
    4a08:	41 b8 02 00 00 00    	mov    $0x2,%r8d
    4a0e:	66 45 89 85 84 40 00 	mov    %r8w,0x4084(%r13)
    4a15:	00 
            ext_de_name(sb, dzt_ei, dafs_ze, zone_p, cur_pos, phlen, phn, 1);
        }
    } else
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, cur_pos, phlen, phn, 1);
    4a16:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
    4a1b:	48 8b 8c 24 90 00 00 	mov    0x90(%rsp),%rcx
    4a22:	00 
    4a23:	45 89 f8             	mov    %r15d,%r8d
    4a26:	48 8b 54 24 70       	mov    0x70(%rsp),%rdx
    4a2b:	48 8b b4 24 80 00 00 	mov    0x80(%rsp),%rsi
    4a32:	00 
    4a33:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    4a38:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    4a3f:	00 
    4a40:	4c 89 24 24          	mov    %r12,(%rsp)
    4a44:	41 89 c1             	mov    %eax,%r9d
    4a47:	41 89 c5             	mov    %eax,%r13d
    4a4a:	e8 00 00 00 00       	callq  4a4f <add_rename_zone_dir+0x71f>
    4a4f:	e9 7e fc ff ff       	jmpq   46d2 <add_rename_zone_dir+0x3a2>
            goto END;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    4a54:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    memcpy(ph+1,end,1);
    4a59:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    4a5f:	be 2f 00 00 00       	mov    $0x2f,%esi
    4a64:	4c 89 ef             	mov    %r13,%rdi
    4a67:	e8 00 00 00 00       	callq  4a6c <add_rename_zone_dir+0x73c>
    if(!dzt_ei){
    4a6c:	48 85 c0             	test   %rax,%rax

    /*root dir*/
    memcpy(ph, "/", 1);
    memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    4a6f:	48 89 84 24 80 00 00 	mov    %rax,0x80(%rsp)
    4a76:	00 
    if(!dzt_ei){
    4a77:	0f 85 27 fa ff ff    	jne    44a4 <add_rename_zone_dir+0x174>
    4a7d:	e8 00 00 00 00       	callq  4a82 <add_rename_zone_dir+0x752>
        dafs_de->isr_sf = 1;
        dafs_de->par_pos = 0;
    }else{
        dafs_de->isr_sf = 0;
        /*set par_pos*/
        par_ph = kzalloc(temlen*sizeof(char), GFP_KERNEL);
    4a82:	4c 89 f7             	mov    %r14,%rdi
    temlen = phlen - dentry->d_name.len;
    if(temlen == 1){
        dafs_de->isr_sf = 1;
        dafs_de->par_pos = 0;
    }else{
        dafs_de->isr_sf = 0;
    4a85:	41 c6 85 83 40 00 00 	movb   $0x0,0x4083(%r13)
    4a8c:	00 
        /*set par_pos*/
        par_ph = kzalloc(temlen*sizeof(char), GFP_KERNEL);
    4a8d:	e8 5e b6 ff ff       	callq  f0 <kzalloc.constprop.9>
        temlen--;
    4a92:	49 8d 4e ff          	lea    -0x1(%r14),%rcx
        memcpy(par_ph, phn, temlen);
    4a96:	4c 89 e6             	mov    %r12,%rsi
    4a99:	48 89 c7             	mov    %rax,%rdi
    4a9c:	48 89 ca             	mov    %rcx,%rdx
    4a9f:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
    4aa4:	e8 00 00 00 00       	callq  4aa9 <add_rename_zone_dir+0x779>
	int i;

	for (i = 0; i < length; i++) {
    4aa9:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
    4aae:	49 89 c1             	mov    %rax,%r9
        memcpy(par_ph+temlen, end, 1);
    4ab1:	42 c6 44 30 ff 00    	movb   $0x0,-0x1(%rax,%r14,1)
    4ab7:	85 c9                	test   %ecx,%ecx
    4ab9:	0f 8e 33 02 00 00    	jle    4cf2 <add_rename_zone_dir+0x9c2>
    4abf:	8d 41 ff             	lea    -0x1(%rcx),%eax
    4ac2:	45 31 f6             	xor    %r14d,%r14d
    4ac5:	49 8d 4c 01 01       	lea    0x1(%r9,%rax,1),%rcx
    4aca:	4c 89 c8             	mov    %r9,%rax
		hash = hash * seed + (*str++);
    4acd:	4c 89 f2             	mov    %r14,%rdx
    4ad0:	48 83 c0 01          	add    $0x1,%rax
    4ad4:	48 c1 e2 06          	shl    $0x6,%rdx
    4ad8:	4c 01 f2             	add    %r14,%rdx
    4adb:	49 8d 14 56          	lea    (%r14,%rdx,2),%rdx
    4adf:	4c 0f be 70 ff       	movsbq -0x1(%rax),%r14
    4ae4:	49 01 d6             	add    %rdx,%r14
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    4ae7:	48 39 c8             	cmp    %rcx,%rax
    4aea:	75 e1                	jne    4acd <add_rename_zone_dir+0x79d>
        par_hash = BKDRHash(par_ph, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
    4aec:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
    4af3:	00 
    4af4:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    4af9:	4c 8d 84 24 8c 00 00 	lea    0x8c(%rsp),%r8
    4b00:	00 
    4b01:	b9 01 00 00 00       	mov    $0x1,%ecx
    4b06:	4c 89 f2             	mov    %r14,%rdx
    4b09:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
    4b0e:	48 8b 70 18          	mov    0x18(%rax),%rsi
    4b12:	e8 00 00 00 00       	callq  4b17 <add_rename_zone_dir+0x7e7>
        dafs_de->par_pos = cpu_to_le32(par_pos);
    4b17:	8b 84 24 8c 00 00 00 	mov    0x8c(%rsp),%eax

        /*set sub file pos*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    4b1e:	4c 89 f6             	mov    %r14,%rsi
        temlen--;
        memcpy(par_ph, phn, temlen);
        memcpy(par_ph+temlen, end, 1);
        par_hash = BKDRHash(par_ph, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
        dafs_de->par_pos = cpu_to_le32(par_pos);
    4b21:	41 89 85 8c 40 00 00 	mov    %eax,0x408c(%r13)

        /*set sub file pos*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    4b28:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
    4b2f:	00 
    4b30:	48 8d 78 38          	lea    0x38(%rax),%rdi
    4b34:	e8 00 00 00 00       	callq  4b39 <add_rename_zone_dir+0x809>
        pdir->sub_num++;
    4b39:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
        par_hash = BKDRHash(par_ph, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
        dafs_de->par_pos = cpu_to_le32(par_pos);

        /*set sub file pos*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    4b3e:	49 89 c6             	mov    %rax,%r14
    4b41:	ba 14 00 00 00       	mov    $0x14,%edx
    4b46:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 4b4d <add_rename_zone_dir+0x81d>
    4b4d:	be d0 80 00 00       	mov    $0x80d0,%esi
        pdir->sub_num++;
        tem_sf = (struct file_p *)kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = cur_pos;
        list_add_tail(&tem_sf->list, &pdir->sub_file);
    4b52:	49 83 c6 18          	add    $0x18,%r14
    4b56:	e8 00 00 00 00       	callq  4b5b <add_rename_zone_dir+0x82b>
        kfree(par_ph);
    4b5b:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9

        /*set sub file pos*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        pdir->sub_num++;
        tem_sf = (struct file_p *)kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = cur_pos;
    4b60:	44 89 78 10          	mov    %r15d,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    4b64:	49 8b 56 08          	mov    0x8(%r14),%rdx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    4b68:	49 89 46 08          	mov    %rax,0x8(%r14)
        list_add_tail(&tem_sf->list, &pdir->sub_file);
    4b6c:	4c 89 30             	mov    %r14,(%rax)
        kfree(par_ph);
    4b6f:	4c 89 cf             	mov    %r9,%rdi
	new->next = next;
	new->prev = prev;
    4b72:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    4b76:	48 89 02             	mov    %rax,(%rdx)
    4b79:	e8 00 00 00 00       	callq  4b7e <add_rename_zone_dir+0x84e>
    4b7e:	e9 ff fa ff ff       	jmpq   4682 <add_rename_zone_dir+0x352>
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
        dafs_de->name[dentry->d_name.len] = '\0'; 

    } else {
        dafs_de->ext_flag = 1;
    4b83:	41 b9 01 00 00 00    	mov    $0x1,%r9d
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, cur_pos, dentry->d_name.len, dentry->d_name.name, 0);
    4b89:	48 8b 8c 24 90 00 00 	mov    0x90(%rsp),%rcx
    4b90:	00 
    4b91:	48 8b 54 24 70       	mov    0x70(%rsp),%rdx
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
        dafs_de->name[dentry->d_name.len] = '\0'; 

    } else {
        dafs_de->ext_flag = 1;
    4b96:	66 45 89 8d 84 40 00 	mov    %r9w,0x4084(%r13)
    4b9d:	00 
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, cur_pos, dentry->d_name.len, dentry->d_name.name, 0);
    4b9e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
    4ba5:	00 
    4ba6:	45 89 f8             	mov    %r15d,%r8d
    4ba9:	49 8b 46 28          	mov    0x28(%r14),%rax
    4bad:	48 8b b4 24 80 00 00 	mov    0x80(%rsp),%rsi
    4bb4:	00 
    4bb5:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    4bba:	48 89 04 24          	mov    %rax,(%rsp)
    4bbe:	45 8b 4e 24          	mov    0x24(%r14),%r9d
    4bc2:	e8 00 00 00 00       	callq  4bc7 <add_rename_zone_dir+0x897>
    4bc7:	e9 74 fa ff ff       	jmpq   4640 <add_rename_zone_dir+0x310>
    4bcc:	bb ff ff 01 00       	mov    $0x1ffff,%ebx
    4bd1:	41 bf ff ff 00 00    	mov    $0xffff,%r15d
    4bd7:	e9 4b f9 ff ff       	jmpq   4527 <add_rename_zone_dir+0x1f7>
    4bdc:	48 8d bc 24 98 00 00 	lea    0x98(%rsp),%rdi
    4be3:	00 
    4be4:	e8 00 00 00 00       	callq  4be9 <add_rename_zone_dir+0x8b9>
    4be9:	e9 ae f7 ff ff       	jmpq   439c <add_rename_zone_dir+0x6c>
    4bee:	48 8d bc 24 a8 00 00 	lea    0xa8(%rsp),%rdi
    4bf5:	00 
    4bf6:	e8 00 00 00 00       	callq  4bfb <add_rename_zone_dir+0x8cb>

    kfree(tname);
    kfree(phname);
    kfree(ph);
    kfree(zone_p);
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    4bfb:	48 8b 84 24 a8 00 00 	mov    0xa8(%rsp),%rax
    4c02:	00 
    4c03:	48 2b 84 24 98 00 00 	sub    0x98(%rsp),%rax
    4c0a:	00 
    4c0b:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    4c12:	48 2b 84 24 a0 00 00 	sub    0xa0(%rsp),%rax
    4c19:	00 
    4c1a:	48 03 84 24 b0 00 00 	add    0xb0(%rsp),%rax
    4c21:	00 
    4c22:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 4c2a <add_rename_zone_dir+0x8fa>
    4c29:	00 
    4c2a:	e9 79 fd ff ff       	jmpq   49a8 <add_rename_zone_dir+0x678>
        *root_len = newp_len;
        *new_hn = BKDRHash(new_pn, newp_len);
        kfree(new_pn);
    } else {
        newp_len = phlen;
        new_pn = kzalloc(sizeof(char *)*newp_len, GFP_KERNEL);
    4c2f:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
    4c34:	48 8d 3c c5 00 00 00 	lea    0x0(,%rax,8),%rdi
    4c3b:	00 
    4c3c:	e8 af b4 ff ff       	callq  f0 <kzalloc.constprop.9>
        memcpy(new_pn, phn, newp_len);
    4c41:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
    4c46:	4c 89 e6             	mov    %r12,%rsi
    4c49:	48 89 c7             	mov    %rax,%rdi
    4c4c:	e8 00 00 00 00       	callq  4c51 <add_rename_zone_dir+0x921>
        *root_len = newp_len;
    4c51:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
        *new_hn = BKDRHash(new_pn, newp_len);
        kfree(new_pn);
    } else {
        newp_len = phlen;
        new_pn = kzalloc(sizeof(char *)*newp_len, GFP_KERNEL);
        memcpy(new_pn, phn, newp_len);
    4c56:	48 89 c1             	mov    %rax,%rcx
        *root_len = newp_len;
    4c59:	48 8b 44 24 68       	mov    0x68(%rsp),%rax
    4c5e:	49 01 cd             	add    %rcx,%r13
        *root_len = newp_len;
        *new_hn = BKDRHash(new_pn, newp_len);
        kfree(new_pn);
    } else {
        newp_len = phlen;
        new_pn = kzalloc(sizeof(char *)*newp_len, GFP_KERNEL);
    4c61:	48 89 ce             	mov    %rcx,%rsi
        memcpy(new_pn, phn, newp_len);
        *root_len = newp_len;
    4c64:	48 89 07             	mov    %rax,(%rdi)
    4c67:	31 c0                	xor    %eax,%eax
		hash = hash * seed + (*str++);
    4c69:	48 89 c2             	mov    %rax,%rdx
    4c6c:	48 83 c6 01          	add    $0x1,%rsi
    4c70:	48 c1 e2 06          	shl    $0x6,%rdx
    4c74:	48 01 c2             	add    %rax,%rdx
    4c77:	48 8d 04 50          	lea    (%rax,%rdx,2),%rax
    4c7b:	48 0f be 56 ff       	movsbq -0x1(%rsi),%rdx
    4c80:	48 01 d0             	add    %rdx,%rax
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    4c83:	4c 39 ee             	cmp    %r13,%rsi
    4c86:	75 e1                	jne    4c69 <add_rename_zone_dir+0x939>
        *new_hn = BKDRHash(new_pn, newp_len);
    4c88:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
    4c8d:	48 89 07             	mov    %rax,(%rdi)
        kfree(new_pn);
    4c90:	48 89 cf             	mov    %rcx,%rdi
    4c93:	e8 00 00 00 00       	callq  4c98 <add_rename_zone_dir+0x968>
    4c98:	e9 0a fb ff ff       	jmpq   47a7 <add_rename_zone_dir+0x477>
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
	if (namelen == 0)
		return -EINVAL;
    4c9d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    4ca2:	e9 0b fd ff ff       	jmpq   49b2 <add_rename_zone_dir+0x682>
    /*get hash value*/
    hashname = BKDRHash(phn, phlen);


    /*get new ei path hashname*/
    if(dzt_ei->dzt_eno!=1){
    4ca7:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
    4cae:	00 

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    4caf:	45 31 f6             	xor    %r14d,%r14d
    4cb2:	83 78 08 01          	cmpl   $0x1,0x8(%rax)
    4cb6:	0f 85 62 fa ff ff    	jne    471e <add_rename_zone_dir+0x3ee>
        *root_len = newp_len;
        *new_hn = BKDRHash(new_pn, newp_len);
        kfree(new_pn);
    } else {
        newp_len = phlen;
        new_pn = kzalloc(sizeof(char *)*newp_len, GFP_KERNEL);
    4cbc:	4c 8b 6c 24 68       	mov    0x68(%rsp),%r13
    4cc1:	4a 8d 3c ed 00 00 00 	lea    0x0(,%r13,8),%rdi
    4cc8:	00 
    4cc9:	e8 22 b4 ff ff       	callq  f0 <kzalloc.constprop.9>
        memcpy(new_pn, phn, newp_len);
    4cce:	4c 89 ea             	mov    %r13,%rdx
    4cd1:	48 89 c7             	mov    %rax,%rdi
    4cd4:	4c 89 e6             	mov    %r12,%rsi
    4cd7:	e8 00 00 00 00       	callq  4cdc <add_rename_zone_dir+0x9ac>
        *root_len = newp_len;
    4cdc:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
        *new_hn = BKDRHash(new_pn, newp_len);
        kfree(new_pn);
    } else {
        newp_len = phlen;
        new_pn = kzalloc(sizeof(char *)*newp_len, GFP_KERNEL);
        memcpy(new_pn, phn, newp_len);
    4ce1:	48 89 c1             	mov    %rax,%rcx
    4ce4:	31 c0                	xor    %eax,%eax
        *root_len = newp_len;
    4ce6:	4c 89 2f             	mov    %r13,(%rdi)
    4ce9:	eb 9d                	jmp    4c88 <add_rename_zone_dir+0x958>
    4ceb:	31 c0                	xor    %eax,%eax
    4ced:	e9 a5 fa ff ff       	jmpq   4797 <add_rename_zone_dir+0x467>
    4cf2:	45 31 f6             	xor    %r14d,%r14d
    4cf5:	e9 f2 fd ff ff       	jmpq   4aec <add_rename_zone_dir+0x7bc>
    kfree(phname);
    kfree(ph);
    kfree(zone_p);
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    return ret;
}
    4cfa:	e8 00 00 00 00       	callq  4cff <add_rename_zone_dir+0x9cf>
    4cff:	90                   	nop

0000000000004d00 <__rename_dir>:
 * n_ze是new_dentry所在的zone
 * path是新的目录的字符串
 * name纯的文件名*/
int __rename_dir(struct super_block *sb, struct dafs_dentry *src_de, \
        struct dzt_entry_info *dzt_ei, struct dzt_entry_info *old_ei, const char *path, char *name)
{
    4d00:	e8 00 00 00 00       	callq  4d05 <__rename_dir+0x5>
    4d05:	55                   	push   %rbp
    4d06:	48 89 f8             	mov    %rdi,%rax
    4d09:	48 89 e5             	mov    %rsp,%rbp
    4d0c:	41 57                	push   %r15
    4d0e:	41 56                	push   %r14
    4d10:	41 55                	push   %r13
    4d12:	41 54                	push   %r12
    4d14:	4d 89 cf             	mov    %r9,%r15
    4d17:	53                   	push   %rbx
    4d18:	4c 89 c3             	mov    %r8,%rbx
    4d1b:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    4d22:	48 89 b5 30 ff ff ff 	mov    %rsi,-0xd0(%rbp)
    4d29:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
    4d2d:	48 89 d6             	mov    %rdx,%rsi
    4d30:	48 8b 90 b0 03 00 00 	mov    0x3b0(%rax),%rdx
    4d37:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
    4d3e:	65 48 8b 3c 25 28 00 	mov    %gs:0x28,%rdi
    4d45:	00 00 
    4d47:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
    4d4b:	31 ff                	xor    %edi,%edi
    u64 hashname, dzt_hn, ch_len, sub_len, old_hn, par_hash, rn_len;
    char *end="";

    //nova_dbg("%s start",__func__);
    ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    make_zone_ptr(&z_p, ze);
    4d4d:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
 * n_ze是new_dentry所在的zone
 * path是新的目录的字符串
 * name纯的文件名*/
int __rename_dir(struct super_block *sb, struct dafs_dentry *src_de, \
        struct dzt_entry_info *dzt_ei, struct dzt_entry_info *old_ei, const char *path, char *name)
{
    4d51:	48 89 8d 20 ff ff ff 	mov    %rcx,-0xe0(%rbp)
    4d58:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct zone_ptr *z_p;
    struct dafs_dentry *new_de, *sub_de, *par_de;
    struct dafs_zone_entry *ze, *o_ze;
    struct dzt_entry_info *ch_ei;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    4d5c:	48 8b 82 d8 01 00 00 	mov    0x1d8(%rdx),%rax
    4d63:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
    char *new_ph, *s_name, *sub_ph, *ch_ph, *tem, *r_name;
    u64 hashname, dzt_hn, ch_len, sub_len, old_hn, par_hash, rn_len;
    char *end="";

    //nova_dbg("%s start",__func__);
    ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    4d6a:	48 8b 46 10          	mov    0x10(%rsi),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    4d6e:	48 89 c6             	mov    %rax,%rsi
    4d71:	48 03 72 18          	add    0x18(%rdx),%rsi
    4d75:	48 85 c0             	test   %rax,%rax
    4d78:	b8 00 00 00 00       	mov    $0x0,%eax
    4d7d:	48 0f 45 c6          	cmovne %rsi,%rax
    make_zone_ptr(&z_p, ze);
    4d81:	48 89 c6             	mov    %rax,%rsi
    4d84:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    4d88:	e8 00 00 00 00       	callq  4d8d <__rename_dir+0x8d>

    nlen = strlen(name);
    4d8d:	4c 89 ff             	mov    %r15,%rdi
    4d90:	e8 00 00 00 00       	callq  4d95 <__rename_dir+0x95>
    flen = strlen(path);
    4d95:	48 89 df             	mov    %rbx,%rdi

    //nova_dbg("%s start",__func__);
    ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    make_zone_ptr(&z_p, ze);

    nlen = strlen(name);
    4d98:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    flen = strlen(path);
    4d9c:	e8 00 00 00 00       	callq  4da1 <__rename_dir+0xa1>
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    4da1:	48 8d 78 01          	lea    0x1(%rax),%rdi
    //nova_dbg("%s start",__func__);
    ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    make_zone_ptr(&z_p, ze);

    nlen = strlen(name);
    flen = strlen(path);
    4da5:	49 89 c6             	mov    %rax,%r14
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    4da8:	e8 43 b3 ff ff       	callq  f0 <kzalloc.constprop.9>
    memcpy(new_ph, path, flen);
    4dad:	4c 89 f2             	mov    %r14,%rdx
    4db0:	48 89 de             	mov    %rbx,%rsi
    4db3:	48 89 c7             	mov    %rax,%rdi
    ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    make_zone_ptr(&z_p, ze);

    nlen = strlen(name);
    flen = strlen(path);
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    4db6:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
    memcpy(new_ph, path, flen);
    4dbd:	e8 00 00 00 00       	callq  4dc2 <__rename_dir+0xc2>
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
    4dc2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    4dc6:	4c 8b 40 08          	mov    0x8(%rax),%r8
    4dca:	4d 85 c0             	test   %r8,%r8
    4dcd:	0f 84 f6 0e 00 00    	je     5cc9 <__rename_dir+0xfc9>
    4dd3:	48 8b 38             	mov    (%rax),%rdi
    4dd6:	31 c9                	xor    %ecx,%ecx
    4dd8:	31 d2                	xor    %edx,%edx
    4dda:	eb 05                	jmp    4de1 <__rename_dir+0xe1>
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
            bitpos+=2;
            dir_pos++;
    4ddc:	44 89 c9             	mov    %r9d,%ecx
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    memcpy(new_ph, path, flen);
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
            bitpos+=2;
    4ddf:	89 c2                	mov    %eax,%edx

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    4de1:	48 63 c2             	movslq %edx,%rax
    4de4:	48 0f a3 07          	bt     %rax,(%rdi)
    4de8:	19 c0                	sbb    %eax,%eax
    flen = strlen(path);
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    memcpy(new_ph, path, flen);
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
    4dea:	85 c0                	test   %eax,%eax
    4dec:	75 14                	jne    4e02 <__rename_dir+0x102>
    4dee:	8d 5a 01             	lea    0x1(%rdx),%ebx
    4df1:	48 63 db             	movslq %ebx,%rbx
    4df4:	48 0f a3 1f          	bt     %rbx,(%rdi)
    4df8:	19 c0                	sbb    %eax,%eax
    4dfa:	85 c0                	test   %eax,%eax
    4dfc:	0f 84 d3 0d 00 00    	je     5bd5 <__rename_dir+0xed5>
            bitpos+=2;
    4e02:	8d 72 02             	lea    0x2(%rdx),%esi
            dir_pos++;
    4e05:	44 8d 49 01          	lea    0x1(%rcx),%r9d
    nlen = strlen(name);
    flen = strlen(path);
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    memcpy(new_ph, path, flen);
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
    4e09:	4c 39 c6             	cmp    %r8,%rsi
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
            bitpos+=2;
    4e0c:	48 89 f0             	mov    %rsi,%rax
    nlen = strlen(name);
    flen = strlen(path);
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    memcpy(new_ph, path, flen);
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
    4e0f:	72 cb                	jb     4ddc <__rename_dir+0xdc>
    4e11:	8d 5a 03             	lea    0x3(%rdx),%ebx
    4e14:	44 8d 69 02          	lea    0x2(%rcx),%r13d
    4e18:	44 8d 7a 04          	lea    0x4(%rdx),%r15d
    4e1c:	44 89 8d 54 ff ff ff 	mov    %r9d,-0xac(%rbp)
    4e23:	48 63 db             	movslq %ebx,%rbx
            dir_pos++;
        }else{
            break;
        }
    }
    new_de = &ze->dentry[dir_pos];
    4e26:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
    4e2c:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    par_id = dir_pos;
    //memset(new_de, 0, sizeof(new_de));    
    new_de->entry_type = src_de->entry_type;
    4e30:	48 8b b5 30 ff ff ff 	mov    -0xd0(%rbp),%rsi
    new_de->name_len = nlen;
    4e37:	0f b6 4d b0          	movzbl -0x50(%rbp),%ecx
            dir_pos++;
        }else{
            break;
        }
    }
    new_de = &ze->dentry[dir_pos];
    4e3b:	48 89 c2             	mov    %rax,%rdx
    4e3e:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    4e42:	48 05 81 00 00 00    	add    $0x81,%rax
    4e48:	48 c1 e0 07          	shl    $0x7,%rax
    4e4c:	48 c1 e2 07          	shl    $0x7,%rdx
    4e50:	48 01 f8             	add    %rdi,%rax
    4e53:	4c 8d 24 17          	lea    (%rdi,%rdx,1),%r12
    4e57:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
    4e5b:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    par_id = dir_pos;
    //memset(new_de, 0, sizeof(new_de));    
    new_de->entry_type = src_de->entry_type;
    4e5f:	0f b6 06             	movzbl (%rsi),%eax
    new_de->name_len = nlen;
    4e62:	41 88 8c 24 81 40 00 	mov    %cl,0x4081(%r12)
    4e69:	00 
        }
    }
    new_de = &ze->dentry[dir_pos];
    par_id = dir_pos;
    //memset(new_de, 0, sizeof(new_de));    
    new_de->entry_type = src_de->entry_type;
    4e6a:	41 88 84 24 80 40 00 	mov    %al,0x4080(%r12)
    4e71:	00 
    new_de->name_len = nlen;
    new_de->file_type = src_de->file_type;       //file_type是啥？ not decided
    4e72:	0f b6 46 02          	movzbl 0x2(%rsi),%eax
    4e76:	41 88 84 24 82 40 00 	mov    %al,0x4082(%r12)
    4e7d:	00 
	new_de->links_count = src_de->links_count;
    4e7e:	0f b7 46 06          	movzwl 0x6(%rsi),%eax
    4e82:	66 41 89 84 24 86 40 	mov    %ax,0x4086(%r12)
    4e89:	00 00 
    //new_de->de_len = cpu_to_le16(delen);  
    new_de->mtime = cpu_to_le32(CURRENT_TIME_SEC.tv_sec);
    4e8b:	e8 00 00 00 00       	callq  4e90 <__rename_dir+0x190>
    //new_de->isr_sf = src_de->isr_sf;
    new_de->ino = src_de->ino;
    4e90:	48 8b b5 30 ff ff ff 	mov    -0xd0(%rbp),%rsi
    new_de->entry_type = src_de->entry_type;
    new_de->name_len = nlen;
    new_de->file_type = src_de->file_type;       //file_type是啥？ not decided
	new_de->links_count = src_de->links_count;
    //new_de->de_len = cpu_to_le16(delen);  
    new_de->mtime = cpu_to_le32(CURRENT_TIME_SEC.tv_sec);
    4e97:	41 89 84 24 88 40 00 	mov    %eax,0x4088(%r12)
    4e9e:	00 
    //new_de->isr_sf = src_de->isr_sf;
    new_de->ino = src_de->ino;
    4e9f:	48 8b 46 18          	mov    0x18(%rsi),%rax
    4ea3:	49 89 84 24 98 40 00 	mov    %rax,0x4098(%r12)
    4eaa:	00 
    
    new_de->size = src_de->size;
    4eab:	48 8b 46 20          	mov    0x20(%rsi),%rax
    4eaf:	49 89 84 24 a0 40 00 	mov    %rax,0x40a0(%r12)
    4eb6:	00 
    /*set name*/
    if(nlen<=SMALL_NAME_LEN){
    4eb7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    4ebb:	48 83 f8 27          	cmp    $0x27,%rax
    4ebf:	0f 87 8e 07 00 00    	ja     5653 <__rename_dir+0x953>
        new_de->ext_flag = 0;
        memcpy(new_de->name, name, nlen);
    4ec5:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
    4ec9:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
    new_de->ino = src_de->ino;
    
    new_de->size = src_de->size;
    /*set name*/
    if(nlen<=SMALL_NAME_LEN){
        new_de->ext_flag = 0;
    4ecd:	45 31 d2             	xor    %r10d,%r10d
    4ed0:	66 45 89 94 24 84 40 	mov    %r10w,0x4084(%r12)
    4ed7:	00 00 
        memcpy(new_de->name, name, nlen);
    4ed9:	48 8d bc 16 b0 40 00 	lea    0x40b0(%rsi,%rdx,1),%rdi
    4ee0:	00 
    4ee1:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
    4ee5:	48 89 c2             	mov    %rax,%rdx
    4ee8:	e8 00 00 00 00       	callq  4eed <__rename_dir+0x1ed>
        new_de->name[nlen] = '\0';
    4eed:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    4ef1:	41 c6 84 04 b0 40 00 	movb   $0x0,0x40b0(%r12,%rax,1)
    4ef8:	00 00 
    } else {
        new_de->ext_flag = 1;
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, nlen, name, 0);
    }
    new_de->fname_len = cpu_to_le64(flen);
    4efa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    4efe:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    4f02:	48 c1 e0 07          	shl    $0x7,%rax
    4f06:	48 8d 0c 07          	lea    (%rdi,%rax,1),%rcx
    4f0a:	4c 89 b1 90 40 00 00 	mov    %r14,0x4090(%rcx)
    
    /*set dir fulname*/
    if(new_de->ext_flag==0){
    4f11:	66 41 83 bc 24 84 40 	cmpw   $0x0,0x4084(%r12)
    4f18:	00 00 00 
        new_de->name[nlen] = '\0';
    } else {
        new_de->ext_flag = 1;
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, nlen, name, 0);
    }
    new_de->fname_len = cpu_to_le64(flen);
    4f1b:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
    
    /*set dir fulname*/
    if(new_de->ext_flag==0){
    4f1f:	75 7b                	jne    4f9c <__rename_dir+0x29c>
        if(flen<SMALL_NAME_LEN){
    4f21:	49 83 fe 26          	cmp    $0x26,%r14
    4f25:	77 66                	ja     4f8d <__rename_dir+0x28d>
            memcpy(new_de->ful_name.f_name, new_ph, flen);
    4f27:	48 8b b5 58 ff ff ff 	mov    -0xa8(%rbp),%rsi
    4f2e:	48 8d bc 07 d8 40 00 	lea    0x40d8(%rdi,%rax,1),%rdi
    4f35:	00 
    4f36:	4c 89 f2             	mov    %r14,%rdx
    4f39:	e8 00 00 00 00       	callq  4f3e <__rename_dir+0x23e>
            new_de->ful_name.f_name[flen]='\0';
    4f3e:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
    4f42:	41 c6 84 0e d8 40 00 	movb   $0x0,0x40d8(%r14,%rcx,1)
    4f49:	00 00 
    } else
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, flen, new_ph, 1);

    /*set par_pos and subpos in par
     * set isr_sf*/
    temlen = flen - nlen;
    4f4b:	4c 2b 75 b0          	sub    -0x50(%rbp),%r14
    if(temlen == 1){
    4f4f:	49 83 fe 01          	cmp    $0x1,%r14
    4f53:	0f 85 86 00 00 00    	jne    4fdf <__rename_dir+0x2df>
        new_de->isr_sf = 1;
        new_de->par_pos = 0;
        par_de = &ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
    4f59:	48 8b 45 b8          	mov    -0x48(%rbp),%rax

    /*set par_pos and subpos in par
     * set isr_sf*/
    temlen = flen - nlen;
    if(temlen == 1){
        new_de->isr_sf = 1;
    4f5d:	41 c6 84 24 83 40 00 	movb   $0x1,0x4083(%r12)
    4f64:	00 01 
        new_de->par_pos = 0;
    4f66:	41 c7 84 24 8c 40 00 	movl   $0x0,0x408c(%r12)
    4f6d:	00 00 00 00 00 
        par_de = &ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
    4f72:	48 83 b8 98 40 00 00 	cmpq   $0x1,0x4098(%rax)
    4f79:	01 
    4f7a:	0f 84 cb 0c 00 00    	je     5c4b <__rename_dir+0xf4b>
    4f80:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    4f84:	4c 8d 60 38          	lea    0x38(%rax),%r12
    4f88:	e9 4a 01 00 00       	jmpq   50d7 <__rename_dir+0x3d7>
    if(new_de->ext_flag==0){
        if(flen<SMALL_NAME_LEN){
            memcpy(new_de->ful_name.f_name, new_ph, flen);
            new_de->ful_name.f_name[flen]='\0';
        } else {
            new_de->ext_flag = 2;
    4f8d:	41 b8 02 00 00 00    	mov    $0x2,%r8d
    4f93:	66 45 89 84 24 84 40 	mov    %r8w,0x4084(%r12)
    4f9a:	00 00 
            ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, flen, new_ph, 1);
        }
    } else
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, flen, new_ph, 1);
    4f9c:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
    4fa3:	44 8b 85 54 ff ff ff 	mov    -0xac(%rbp),%r8d
    4faa:	45 89 f1             	mov    %r14d,%r9d
    4fad:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    4fb1:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    4fb5:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    4fb9:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
    4fc0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    4fc7:	00 
    4fc8:	48 89 04 24          	mov    %rax,(%rsp)
    4fcc:	e8 00 00 00 00       	callq  4fd1 <__rename_dir+0x2d1>

    /*set par_pos and subpos in par
     * set isr_sf*/
    temlen = flen - nlen;
    4fd1:	4c 2b 75 b0          	sub    -0x50(%rbp),%r14
    if(temlen == 1){
    4fd5:	49 83 fe 01          	cmp    $0x1,%r14
    4fd9:	0f 84 7a ff ff ff    	je     4f59 <__rename_dir+0x259>
            list_add_tail(&tem_sf->list, &pdir->sub_file);
            pdir->sub_num++;
        }
    } else {
        new_de->isr_sf = 0;
        tem = kzalloc(sizeof(char)*temlen, GFP_KERNEL);
    4fdf:	4c 89 f7             	mov    %r14,%rdi
            tem_sf->pos = cpu_to_le32(dir_pos);
            list_add_tail(&tem_sf->list, &pdir->sub_file);
            pdir->sub_num++;
        }
    } else {
        new_de->isr_sf = 0;
    4fe2:	41 c6 84 24 83 40 00 	movb   $0x0,0x4083(%r12)
    4fe9:	00 00 
        tem = kzalloc(sizeof(char)*temlen, GFP_KERNEL);
    4feb:	e8 00 b1 ff ff       	callq  f0 <kzalloc.constprop.9>
        temlen--;
    4ff0:	49 8d 4e ff          	lea    -0x1(%r14),%rcx
        memcpy(tem, new_ph, temlen);
    4ff4:	48 8b b5 58 ff ff ff 	mov    -0xa8(%rbp),%rsi
    4ffb:	48 89 c7             	mov    %rax,%rdi
    4ffe:	48 89 ca             	mov    %rcx,%rdx
    5001:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    5005:	e8 00 00 00 00       	callq  500a <__rename_dir+0x30a>
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    500a:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
    500e:	49 89 c1             	mov    %rax,%r9
        memcpy(tem+temlen,end,1);
    5011:	42 c6 44 30 ff 00    	movb   $0x0,-0x1(%rax,%r14,1)
    5017:	85 c9                	test   %ecx,%ecx
    5019:	0f 8e e1 0b 00 00    	jle    5c00 <__rename_dir+0xf00>
    501f:	8d 41 ff             	lea    -0x1(%rcx),%eax
    5022:	45 31 f6             	xor    %r14d,%r14d
    5025:	49 8d 4c 01 01       	lea    0x1(%r9,%rax,1),%rcx
    502a:	4c 89 c8             	mov    %r9,%rax
		hash = hash * seed + (*str++);
    502d:	4c 89 f2             	mov    %r14,%rdx
    5030:	48 83 c0 01          	add    $0x1,%rax
    5034:	48 c1 e2 06          	shl    $0x6,%rdx
    5038:	4c 01 f2             	add    %r14,%rdx
    503b:	49 8d 14 56          	lea    (%r14,%rdx,2),%rdx
    503f:	4c 0f be 70 ff       	movsbq -0x1(%rax),%r14
    5044:	49 01 d6             	add    %rdx,%r14
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    5047:	48 39 c8             	cmp    %rcx,%rax
    504a:	75 e1                	jne    502d <__rename_dir+0x32d>
        par_hash = BKDRHash(tem, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
    504c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    5050:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
    5057:	4c 8d 45 c4          	lea    -0x3c(%rbp),%r8
    505b:	4c 89 f2             	mov    %r14,%rdx
    505e:	b9 01 00 00 00       	mov    $0x1,%ecx
    5063:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
    5067:	48 8b 70 18          	mov    0x18(%rax),%rsi
    506b:	e8 00 00 00 00       	callq  5070 <__rename_dir+0x370>
        new_de->par_pos = cpu_to_le64(par_pos);
    5070:	8b 45 c4             	mov    -0x3c(%rbp),%eax

        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    5073:	4c 89 f6             	mov    %r14,%rsi
        temlen--;
        memcpy(tem, new_ph, temlen);
        memcpy(tem+temlen,end,1);
        par_hash = BKDRHash(tem, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
        new_de->par_pos = cpu_to_le64(par_pos);
    5076:	41 89 84 24 8c 40 00 	mov    %eax,0x408c(%r12)
    507d:	00 

        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    507e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    5082:	4c 8d 60 38          	lea    0x38(%rax),%r12
    5086:	4c 89 e7             	mov    %r12,%rdi
    5089:	e8 00 00 00 00       	callq  508e <__rename_dir+0x38e>
        pdir->sub_num++;
    508e:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
    5093:	ba 14 00 00 00       	mov    $0x14,%edx
    5098:	be d0 80 00 00       	mov    $0x80d0,%esi
    509d:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 50a4 <__rename_dir+0x3a4>
        par_hash = BKDRHash(tem, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
        new_de->par_pos = cpu_to_le64(par_pos);

        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    50a4:	49 89 c6             	mov    %rax,%r14
        pdir->sub_num++;
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = dir_pos;
        list_add_tail(&tem_sf->list, &pdir->sub_file);
    50a7:	49 83 c6 18          	add    $0x18,%r14
    50ab:	e8 00 00 00 00       	callq  50b0 <__rename_dir+0x3b0>

        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        pdir->sub_num++;
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = dir_pos;
    50b0:	8b b5 54 ff ff ff    	mov    -0xac(%rbp),%esi
        list_add_tail(&tem_sf->list, &pdir->sub_file);
        kfree(tem);
    50b6:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9

        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        pdir->sub_num++;
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = dir_pos;
    50ba:	89 70 10             	mov    %esi,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    50bd:	49 8b 56 08          	mov    0x8(%r14),%rdx
        list_add_tail(&tem_sf->list, &pdir->sub_file);
        kfree(tem);
    50c1:	4c 89 cf             	mov    %r9,%rdi
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    50c4:	49 89 46 08          	mov    %rax,0x8(%r14)
        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        pdir->sub_num++;
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = dir_pos;
        list_add_tail(&tem_sf->list, &pdir->sub_file);
    50c8:	4c 89 30             	mov    %r14,(%rax)
	new->next = next;
	new->prev = prev;
    50cb:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    50cf:	48 89 02             	mov    %rax,(%rdx)
        kfree(tem);
    50d2:	e8 00 00 00 00       	callq  50d7 <__rename_dir+0x3d7>
    }

    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)z_p->statemap);
    50d7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    50db:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    50de:	f0 48 0f ab 18       	lock bts %rbx,(%rax)
    50e3:	72 00                	jb     50e5 <__rename_dir+0x3e5>
    bitpos++;
    hashname = BKDRHash(new_ph, strlen(new_ph));
    50e5:	48 8b 9d 58 ff ff ff 	mov    -0xa8(%rbp),%rbx
    50ec:	48 89 df             	mov    %rbx,%rdi
    50ef:	e8 00 00 00 00       	callq  50f4 <__rename_dir+0x3f4>
    50f4:	85 c0                	test   %eax,%eax
    50f6:	0f 8e 47 0b 00 00    	jle    5c43 <__rename_dir+0xf43>
    50fc:	83 e8 01             	sub    $0x1,%eax
    50ff:	45 31 f6             	xor    %r14d,%r14d
    5102:	48 8d 74 03 01       	lea    0x1(%rbx,%rax,1),%rsi
    5107:	48 89 d8             	mov    %rbx,%rax
		hash = hash * seed + (*str++);
    510a:	4c 89 f2             	mov    %r14,%rdx
    510d:	48 83 c0 01          	add    $0x1,%rax
    5111:	48 c1 e2 06          	shl    $0x6,%rdx
    5115:	4c 01 f2             	add    %r14,%rdx
    5118:	49 8d 14 56          	lea    (%r14,%rdx,2),%rdx
    511c:	4c 0f be 70 ff       	movsbq -0x1(%rax),%r14
    5121:	49 01 d6             	add    %rdx,%r14
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    5124:	48 39 f0             	cmp    %rsi,%rax
    5127:	75 e1                	jne    510a <__rename_dir+0x40a>
    record_pos_htable(sb, dzt_ei->ht_head, hashname, dir_pos, 1);
    5129:	48 8b 5d 88          	mov    -0x78(%rbp),%rbx
    512d:	8b 8d 54 ff ff ff    	mov    -0xac(%rbp),%ecx
    5133:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    5139:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
    5140:	4c 89 f2             	mov    %r14,%rdx
    5143:	48 8b 73 18          	mov    0x18(%rbx),%rsi
    5147:	e8 00 00 00 00       	callq  514c <__rename_dir+0x44c>
    new_de->hname = cpu_to_le64(hashname);
    514c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    5150:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi

    dir_pos++;

    /*new dir_info_entry*/
    new_dir = add_dir_info(dzt_ei, hashname, dir_pos);
    5154:	44 89 ea             	mov    %r13d,%edx
    5157:	48 89 df             	mov    %rbx,%rdi
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)z_p->statemap);
    bitpos++;
    hashname = BKDRHash(new_ph, strlen(new_ph));
    record_pos_htable(sb, dzt_ei->ht_head, hashname, dir_pos, 1);
    new_de->hname = cpu_to_le64(hashname);
    515a:	48 c1 e0 07          	shl    $0x7,%rax
    515e:	4c 89 b4 06 a8 40 00 	mov    %r14,0x40a8(%rsi,%rax,1)
    5165:	00 

    dir_pos++;

    /*new dir_info_entry*/
    new_dir = add_dir_info(dzt_ei, hashname, dir_pos);
    5166:	4c 89 f6             	mov    %r14,%rsi
    5169:	e8 00 00 00 00       	callq  516e <__rename_dir+0x46e>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    516e:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
    new_dir->f_s = DENTRY_FREQUENCY_WRITE;
    5172:	c6 40 02 02          	movb   $0x2,0x2(%rax)
	if (support_clwb) {
    5176:	31 d2                	xor    %edx,%edx
    5178:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # 517e <__rename_dir+0x47e>
    new_de->hname = cpu_to_le64(hashname);

    dir_pos++;

    /*new dir_info_entry*/
    new_dir = add_dir_info(dzt_ei, hashname, dir_pos);
    517e:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    5185:	89 f1                	mov    %esi,%ecx
    5187:	83 e1 3f             	and    $0x3f,%ecx
    518a:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    518d:	85 ff                	test   %edi,%edi
    518f:	0f 85 05 05 00 00    	jne    569a <__rename_dir+0x99a>
    5195:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    5199:	89 d0                	mov    %edx,%eax
    519b:	48 01 f0             	add    %rsi,%rax
    519e:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    51a1:	83 c2 40             	add    $0x40,%edx
    51a4:	39 d1                	cmp    %edx,%ecx
    51a6:	77 f1                	ja     5199 <__rename_dir+0x499>
        return -EINVAL;
    
    nova_flush_buffer(new_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    old_hn = le64_to_cpu(src_de->hname);
    old_dir = radix_tree_lookup(&dzt_ei->dir_tree, old_hn);
    51a8:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
    51af:	4c 89 e7             	mov    %r12,%rdi
    51b2:	48 8b 70 28          	mov    0x28(%rax),%rsi
    51b6:	e8 00 00 00 00       	callq  51bb <__rename_dir+0x4bb>
    head = &old_dir->sub_file;
    51bb:	48 8d 58 18          	lea    0x18(%rax),%rbx
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
    51bf:	c7 85 1c ff ff ff 00 	movl   $0x0,-0xe4(%rbp)
    51c6:	00 00 00 
    
    nova_flush_buffer(new_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    old_hn = le64_to_cpu(src_de->hname);
    old_dir = radix_tree_lookup(&dzt_ei->dir_tree, old_hn);
    head = &old_dir->sub_file;
    51c9:	48 89 de             	mov    %rbx,%rsi
    51cc:	48 89 9d 48 ff ff ff 	mov    %rbx,-0xb8(%rbp)
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
    51d3:	48 8b 58 18          	mov    0x18(%rax),%rbx
    51d7:	48 8b 03             	mov    (%rbx),%rax
    51da:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
            
            /*add in dir subpos*/
            new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            new_sf->pos = dir_pos;
            new_dir->sub_num++;
            list_add_tail(&new_sf->list, &new_dir->sub_file);
    51de:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
    51e5:	48 83 c0 18          	add    $0x18,%rax
    51e9:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
                o_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
                rn_len = le64_to_cpu(src_de->fname_len); 
                r_name = kzalloc(sizeof(char)*(rn_len+1),GFP_KERNEL);
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
    51f0:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
    51f7:	48 83 c0 38          	add    $0x38,%rax
    old_hn = le64_to_cpu(src_de->hname);
    old_dir = radix_tree_lookup(&dzt_ei->dir_tree, old_hn);
    head = &old_dir->sub_file;
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
    51fb:	48 39 de             	cmp    %rbx,%rsi
                o_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
                rn_len = le64_to_cpu(src_de->fname_len); 
                r_name = kzalloc(sizeof(char)*(rn_len+1),GFP_KERNEL);
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
    51fe:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
    old_hn = le64_to_cpu(src_de->hname);
    old_dir = radix_tree_lookup(&dzt_ei->dir_tree, old_hn);
    head = &old_dir->sub_file;
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
    5205:	0f 84 08 04 00 00    	je     5613 <__rename_dir+0x913>
        tem_sf = list_entry(this, struct file_p, list);
        s_pos = tem_sf->pos;
    520b:	8b 5b 10             	mov    0x10(%rbx),%ebx
    520e:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 5215 <__rename_dir+0x515>
    5215:	ba 70 00 00 00       	mov    $0x70,%edx
    521a:	be d0 80 00 00       	mov    $0x80d0,%esi
    521f:	e8 00 00 00 00       	callq  5224 <__rename_dir+0x524>
    5224:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    5228:	89 d8                	mov    %ebx,%eax
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    522a:	be d0 80 00 00       	mov    $0x80d0,%esi
    522f:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    5233:	49 89 c4             	mov    %rax,%r12
    5236:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    523a:	49 c1 e4 07          	shl    $0x7,%r12
    523e:	4e 8d 1c 20          	lea    (%rax,%r12,1),%r11
        sub_de = &ze->dentry[s_pos];
        sub_ph = kzalloc(sizeof(char )*LARGE_NAME_LEN, GFP_KERNEL);
        sub_len = le64_to_cpu(sub_de->name_len);
    5242:	41 0f b6 83 81 40 00 	movzbl 0x4081(%r11),%eax
    5249:	00 
    524a:	4c 89 5d 90          	mov    %r11,-0x70(%rbp)
        s_name = kzalloc(sizeof(char )*(sub_len+1), GFP_KERNEL);
    524e:	48 8d 58 01          	lea    0x1(%rax),%rbx
    list_for_each_safe(this, next, head) {
        tem_sf = list_entry(this, struct file_p, list);
        s_pos = tem_sf->pos;
        sub_de = &ze->dentry[s_pos];
        sub_ph = kzalloc(sizeof(char )*LARGE_NAME_LEN, GFP_KERNEL);
        sub_len = le64_to_cpu(sub_de->name_len);
    5252:	88 85 53 ff ff ff    	mov    %al,-0xad(%rbp)
    5258:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    525c:	48 89 df             	mov    %rbx,%rdi
    525f:	e8 00 00 00 00       	callq  5264 <__rename_dir+0x564>
        s_name = kzalloc(sizeof(char )*(sub_len+1), GFP_KERNEL);
        if(sub_de->ext_flag==1)
    5264:	4c 8b 5d 90          	mov    -0x70(%rbp),%r11
    5268:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    526c:	66 41 83 bb 84 40 00 	cmpw   $0x1,0x4084(%r11)
    5273:	00 01 
    5275:	0f 84 ba 04 00 00    	je     5735 <__rename_dir+0xa35>
            get_ext_name(sub_de->next, s_name);
        else
            memcpy(s_name, sub_de->name, sub_len+1);
    527b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    527f:	83 fb 08             	cmp    $0x8,%ebx
    5282:	4a 8d b4 20 b0 40 00 	lea    0x40b0(%rax,%r12,1),%rsi
    5289:	00 
    528a:	0f 83 33 04 00 00    	jae    56c3 <__rename_dir+0x9c3>
    5290:	f6 c3 04             	test   $0x4,%bl
    5293:	0f 85 25 09 00 00    	jne    5bbe <__rename_dir+0xebe>
    5299:	85 db                	test   %ebx,%ebx
    529b:	74 12                	je     52af <__rename_dir+0x5af>
    529d:	0f b6 06             	movzbl (%rsi),%eax
    52a0:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    52a4:	f6 c3 02             	test   $0x2,%bl
    52a7:	88 07                	mov    %al,(%rdi)
    52a9:	0f 85 59 09 00 00    	jne    5c08 <__rename_dir+0xf08>
        memcpy(sub_ph, new_ph, strlen(new_ph));
    52af:	48 8b 9d 58 ff ff ff 	mov    -0xa8(%rbp),%rbx
    52b6:	4c 89 5d 90          	mov    %r11,-0x70(%rbp)
    52ba:	48 89 df             	mov    %rbx,%rdi
    52bd:	e8 00 00 00 00       	callq  52c2 <__rename_dir+0x5c2>
    52c2:	48 89 de             	mov    %rbx,%rsi
    52c5:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
    52c9:	48 89 c2             	mov    %rax,%rdx
    52cc:	48 89 df             	mov    %rbx,%rdi
    52cf:	e8 00 00 00 00       	callq  52d4 <__rename_dir+0x5d4>
        strcat(sub_ph, "/");
    52d4:	48 89 df             	mov    %rbx,%rdi
    52d7:	e8 00 00 00 00       	callq  52dc <__rename_dir+0x5dc>
        strcat(sub_ph, s_name);
    52dc:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    52e0:	48 8d 7c 03 01       	lea    0x1(%rbx,%rax,1),%rdi
        if(sub_de->ext_flag==1)
            get_ext_name(sub_de->next, s_name);
        else
            memcpy(s_name, sub_de->name, sub_len+1);
        memcpy(sub_ph, new_ph, strlen(new_ph));
        strcat(sub_ph, "/");
    52e5:	c6 04 03 2f          	movb   $0x2f,(%rbx,%rax,1)
        strcat(sub_ph, s_name);
    52e9:	e8 00 00 00 00       	callq  52ee <__rename_dir+0x5ee>

        if(sub_de->file_type == NORMAL_DIRECTORY){
    52ee:	4c 8b 5d 90          	mov    -0x70(%rbp),%r11
    52f2:	41 80 bb 82 40 00 00 	cmpb   $0x1,0x4082(%r11)
    52f9:	01 
    52fa:	0f 84 29 06 00 00    	je     5929 <__rename_dir+0xc29>
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);

        } else {
            //delen = DAFS_DIR_LEN(str(s_name)+str(sub_ph));
            /*set dir entry*/
            while(bitpos<z_p->zone_max){
    5300:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    5304:	44 89 fa             	mov    %r15d,%edx
    5307:	45 8d 67 01          	lea    0x1(%r15),%r12d
    530b:	4d 63 e4             	movslq %r12d,%r12
    530e:	48 8b 70 08          	mov    0x8(%rax),%rsi
    5312:	48 39 f2             	cmp    %rsi,%rdx
    5315:	73 40                	jae    5357 <__rename_dir+0x657>
    5317:	48 8b 08             	mov    (%rax),%rcx
    531a:	eb 03                	jmp    531f <__rename_dir+0x61f>
                if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
                    bitpos+=2;
    531c:	41 89 c7             	mov    %eax,%r15d

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    531f:	49 63 c7             	movslq %r15d,%rax
    5322:	48 0f a3 01          	bt     %rax,(%rcx)
    5326:	19 c0                	sbb    %eax,%eax

        } else {
            //delen = DAFS_DIR_LEN(str(s_name)+str(sub_ph));
            /*set dir entry*/
            while(bitpos<z_p->zone_max){
                if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
    5328:	85 c0                	test   %eax,%eax
    532a:	75 11                	jne    533d <__rename_dir+0x63d>
    532c:	45 8d 67 01          	lea    0x1(%r15),%r12d
    5330:	4d 63 e4             	movslq %r12d,%r12
    5333:	4c 0f a3 21          	bt     %r12,(%rcx)
    5337:	19 c0                	sbb    %eax,%eax
    5339:	85 c0                	test   %eax,%eax
    533b:	74 1a                	je     5357 <__rename_dir+0x657>
                    bitpos+=2;
    533d:	41 8d 57 02          	lea    0x2(%r15),%edx
                    dir_pos++;
    5341:	41 83 c5 01          	add    $0x1,%r13d
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);

        } else {
            //delen = DAFS_DIR_LEN(str(s_name)+str(sub_ph));
            /*set dir entry*/
            while(bitpos<z_p->zone_max){
    5345:	48 39 f2             	cmp    %rsi,%rdx
                if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
                    bitpos+=2;
    5348:	48 89 d0             	mov    %rdx,%rax
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);

        } else {
            //delen = DAFS_DIR_LEN(str(s_name)+str(sub_ph));
            /*set dir entry*/
            while(bitpos<z_p->zone_max){
    534b:	72 cf                	jb     531c <__rename_dir+0x61c>
    534d:	41 83 c7 03          	add    $0x3,%r15d
    5351:	4d 63 e7             	movslq %r15d,%r12
                if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
                    bitpos+=2;
    5354:	41 89 d7             	mov    %edx,%r15d
                    dir_pos++;
                }else{
                    break;
                }
            }
            new_de = &ze->dentry[dir_pos]; 
    5357:	44 89 e8             	mov    %r13d,%eax
    535a:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
            //memset(new_de, 0, sizeof(new_de));    
            new_de->entry_type = sub_de->entry_type;
            new_de->name_len = sub_de->name_len;
            new_de->file_type = sub_de->file_type;       //file_type是啥？ not decided
	        new_de->links_count = sub_de->links_count;
    535e:	4c 89 9d 68 ff ff ff 	mov    %r11,-0x98(%rbp)
                    dir_pos++;
                }else{
                    break;
                }
            }
            new_de = &ze->dentry[dir_pos]; 
    5365:	48 89 c2             	mov    %rax,%rdx
    5368:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    536c:	48 8d 98 81 00 00 00 	lea    0x81(%rax),%rbx
            //memset(new_de, 0, sizeof(new_de));    
            new_de->entry_type = sub_de->entry_type;
    5373:	41 0f b6 83 80 40 00 	movzbl 0x4080(%r11),%eax
    537a:	00 
    537b:	48 c1 e2 07          	shl    $0x7,%rdx
    537f:	4c 8d 14 17          	lea    (%rdi,%rdx,1),%r10
                    dir_pos++;
                }else{
                    break;
                }
            }
            new_de = &ze->dentry[dir_pos]; 
    5383:	48 c1 e3 07          	shl    $0x7,%rbx
    5387:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
    538e:	48 01 fb             	add    %rdi,%rbx
            //memset(new_de, 0, sizeof(new_de));    
            new_de->entry_type = sub_de->entry_type;
            new_de->name_len = sub_de->name_len;
            new_de->file_type = sub_de->file_type;       //file_type是啥？ not decided
	        new_de->links_count = sub_de->links_count;
    5391:	4c 89 95 70 ff ff ff 	mov    %r10,-0x90(%rbp)
                    break;
                }
            }
            new_de = &ze->dentry[dir_pos]; 
            //memset(new_de, 0, sizeof(new_de));    
            new_de->entry_type = sub_de->entry_type;
    5398:	41 88 82 80 40 00 00 	mov    %al,0x4080(%r10)
            new_de->name_len = sub_de->name_len;
    539f:	41 0f b6 83 81 40 00 	movzbl 0x4081(%r11),%eax
    53a6:	00 
    53a7:	41 88 82 81 40 00 00 	mov    %al,0x4081(%r10)
            new_de->file_type = sub_de->file_type;       //file_type是啥？ not decided
    53ae:	41 0f b6 83 82 40 00 	movzbl 0x4082(%r11),%eax
    53b5:	00 
    53b6:	41 88 82 82 40 00 00 	mov    %al,0x4082(%r10)
	        new_de->links_count = sub_de->links_count;
    53bd:	41 0f b7 83 86 40 00 	movzwl 0x4086(%r11),%eax
    53c4:	00 
    53c5:	66 41 89 82 86 40 00 	mov    %ax,0x4086(%r10)
    53cc:	00 
            //new_de->de_len = cpu_to_le16(delen);  
            new_de->mtime = cpu_to_le32(CURRENT_TIME_SEC.tv_sec);
    53cd:	e8 00 00 00 00       	callq  53d2 <__rename_dir+0x6d2>
    53d2:	4c 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10
            //new_de->isr_sf = sub_de->isr_sf;
            new_de->ino = sub_de->ino;
              
            new_de->size = sub_de->size;
            if(sub_de->ext_flag==1){
    53d9:	4c 8b 9d 68 ff ff ff 	mov    -0x98(%rbp),%r11
    53e0:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
            new_de->entry_type = sub_de->entry_type;
            new_de->name_len = sub_de->name_len;
            new_de->file_type = sub_de->file_type;       //file_type是啥？ not decided
	        new_de->links_count = sub_de->links_count;
            //new_de->de_len = cpu_to_le16(delen);  
            new_de->mtime = cpu_to_le32(CURRENT_TIME_SEC.tv_sec);
    53e7:	41 89 82 88 40 00 00 	mov    %eax,0x4088(%r10)
            //new_de->isr_sf = sub_de->isr_sf;
            new_de->ino = sub_de->ino;
    53ee:	48 8b 45 80          	mov    -0x80(%rbp),%rax
    53f2:	48 c1 e0 07          	shl    $0x7,%rax
    53f6:	48 03 45 b8          	add    -0x48(%rbp),%rax
    53fa:	48 8b 88 98 40 00 00 	mov    0x4098(%rax),%rcx
    5401:	49 89 8a 98 40 00 00 	mov    %rcx,0x4098(%r10)
              
            new_de->size = sub_de->size;
    5408:	48 8b 80 a0 40 00 00 	mov    0x40a0(%rax),%rax
    540f:	49 89 82 a0 40 00 00 	mov    %rax,0x40a0(%r10)
            if(sub_de->ext_flag==1){
    5416:	41 0f b7 83 84 40 00 	movzwl 0x4084(%r11),%eax
    541d:	00 
    541e:	66 83 f8 01          	cmp    $0x1,%ax
    5422:	0f 84 ae 04 00 00    	je     58d6 <__rename_dir+0xbd6>
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);

            }else{

                new_de->ext_flag = sub_de->ext_flag;
                memcpy(new_de->name, s_name, sub_len);
    5428:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
                new_de->ext_flag=1;
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);

            }else{

                new_de->ext_flag = sub_de->ext_flag;
    542c:	66 41 89 82 84 40 00 	mov    %ax,0x4084(%r10)
    5433:	00 
                memcpy(new_de->name, s_name, sub_len);
    5434:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    5438:	83 ff 08             	cmp    $0x8,%edi
    543b:	48 8d 84 10 b0 40 00 	lea    0x40b0(%rax,%rdx,1),%rax
    5442:	00 
    5443:	0f 83 b3 02 00 00    	jae    56fc <__rename_dir+0x9fc>
    5449:	83 e7 04             	and    $0x4,%edi
    544c:	0f 85 96 07 00 00    	jne    5be8 <__rename_dir+0xee8>
    5452:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
    5456:	85 ff                	test   %edi,%edi
    5458:	74 12                	je     546c <__rename_dir+0x76c>
    545a:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    545e:	83 e7 02             	and    $0x2,%edi
    5461:	0f b6 16             	movzbl (%rsi),%edx
    5464:	88 10                	mov    %dl,(%rax)
    5466:	0f 85 b1 07 00 00    	jne    5c1d <__rename_dir+0xf1d>
                new_de->name[sub_len] = '\0';
    546c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    5470:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
    5474:	48 c1 e0 07          	shl    $0x7,%rax
    5478:	48 03 45 b8          	add    -0x48(%rbp),%rax
    547c:	c6 84 06 b0 40 00 00 	movb   $0x0,0x40b0(%rsi,%rax,1)
    5483:	00 
            }

            sub_plen = strlen(sub_ph);
    5484:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    5488:	4c 89 95 68 ff ff ff 	mov    %r10,-0x98(%rbp)
    548f:	4c 89 9d 70 ff ff ff 	mov    %r11,-0x90(%rbp)
    5496:	e8 00 00 00 00       	callq  549b <__rename_dir+0x79b>
            new_de->fname_len = cpu_to_le64(sub_plen);
    549b:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
    549f:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
            //new_de->par_pos = sub_de->par_pos;
            /*set isr_sf, new_de is not root*/
            new_de->isr_sf = 0;
    54a3:	4c 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%r10
            new_de->par_pos = cpu_to_le32(par_id);
    54aa:	8b bd 54 ff ff ff    	mov    -0xac(%rbp),%edi

            /*set fulname*/
            /*ROOT_DIRECTORY set fulname and update ei*/
            if(new_de->file_type==ROOT_DIRECTORY) {
    54b0:	4c 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%r11
                memcpy(new_de->name, s_name, sub_len);
                new_de->name[sub_len] = '\0';
            }

            sub_plen = strlen(sub_ph);
            new_de->fname_len = cpu_to_le64(sub_plen);
    54b7:	48 c1 e2 07          	shl    $0x7,%rdx
    54bb:	48 8d 0c 16          	lea    (%rsi,%rdx,1),%rcx
    54bf:	48 89 81 90 40 00 00 	mov    %rax,0x4090(%rcx)
            new_de->isr_sf = 0;
            new_de->par_pos = cpu_to_le32(par_id);

            /*set fulname*/
            /*ROOT_DIRECTORY set fulname and update ei*/
            if(new_de->file_type==ROOT_DIRECTORY) {
    54c6:	41 80 ba 82 40 00 00 	cmpb   $0x2,0x4082(%r10)
    54cd:	02 

            sub_plen = strlen(sub_ph);
            new_de->fname_len = cpu_to_le64(sub_plen);
            //new_de->par_pos = sub_de->par_pos;
            /*set isr_sf, new_de is not root*/
            new_de->isr_sf = 0;
    54ce:	41 c6 82 83 40 00 00 	movb   $0x0,0x4083(%r10)
    54d5:	00 
            new_de->par_pos = cpu_to_le32(par_id);
    54d6:	41 89 ba 8c 40 00 00 	mov    %edi,0x408c(%r10)

            /*set fulname*/
            /*ROOT_DIRECTORY set fulname and update ei*/
            if(new_de->file_type==ROOT_DIRECTORY) {
    54dd:	0f 84 6a 02 00 00    	je     574d <__rename_dir+0xa4d>
                radix_tree_insert(&dzt_m->dzt_root, dzt_hn, ch_ei);
                radix_tree_tag_set(&dzt_m->dzt_root, dzt_hn, 1);
                kfree(ch_ph);
                new_de->dzt_hn = cpu_to_le64(dzt_hn);
            } else {
                new_de->ful_name.f_name[0]='\0';
    54e3:	c6 81 d8 40 00 00 00 	movb   $0x0,0x40d8(%rcx)
                new_de->hname = cpu_to_le64(hashname);
    54ea:	4c 89 b1 a8 40 00 00 	mov    %r14,0x40a8(%rcx)
                //new_de->dzt_hn = sub_de->dzt_hn;
            }

            /*make valid*/
            bitpos++;
            test_and_set_bit_le(bitpos, (void *)z_p->statemap);
    54f1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    54f5:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    54f8:	f0 4c 0f ab 20       	lock bts %r12,(%rax)
    54fd:	72 00                	jb     54ff <__rename_dir+0x7ff>
            hashname = BKDRHash(sub_ph, strlen(sub_ph));
    54ff:	4c 8b 75 b0          	mov    -0x50(%rbp),%r14
    5503:	4c 89 55 98          	mov    %r10,-0x68(%rbp)
    5507:	4c 89 f7             	mov    %r14,%rdi
    550a:	e8 00 00 00 00       	callq  550f <__rename_dir+0x80f>
    550f:	85 c0                	test   %eax,%eax
    5511:	4c 8b 55 98          	mov    -0x68(%rbp),%r10
    5515:	0f 8e 35 06 00 00    	jle    5b50 <__rename_dir+0xe50>
    551b:	83 e8 01             	sub    $0x1,%eax
    551e:	49 8d 4c 06 01       	lea    0x1(%r14,%rax,1),%rcx
    5523:	4c 89 f0             	mov    %r14,%rax
    5526:	45 31 f6             	xor    %r14d,%r14d
		hash = hash * seed + (*str++);
    5529:	4c 89 f2             	mov    %r14,%rdx
    552c:	48 83 c0 01          	add    $0x1,%rax
    5530:	48 c1 e2 06          	shl    $0x6,%rdx
    5534:	4c 01 f2             	add    %r14,%rdx
    5537:	49 8d 14 56          	lea    (%r14,%rdx,2),%rdx
    553b:	4c 0f be 70 ff       	movsbq -0x1(%rax),%r14
    5540:	49 01 d6             	add    %rdx,%r14
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    5543:	48 39 c8             	cmp    %rcx,%rax
    5546:	75 e1                	jne    5529 <__rename_dir+0x829>
           
            /*rename dir_info*/
            if(new_de->file_type==ROOT_DIRECTORY){
    5548:	41 80 ba 82 40 00 00 	cmpb   $0x2,0x4082(%r10)
    554f:	02 
    5550:	0f 84 1b 04 00 00    	je     5971 <__rename_dir+0xc71>
            if(new_de->file_type==NORMAL_DIRECTORY){
                new_de->ful_name->f_name[0]="/0";
                new_de->hname = cpu_to_le64(hashname);
            } */

            record_pos_htable(sb, dzt_ei->ht_head, hashname,  dir_pos, 1);
    5556:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    555a:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
    5561:	44 89 e9             	mov    %r13d,%ecx
    5564:	4c 89 f2             	mov    %r14,%rdx
    5567:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    556d:	48 8b 70 18          	mov    0x18(%rax),%rsi
    5571:	e8 00 00 00 00       	callq  5576 <__rename_dir+0x876>

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
    5576:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 557c <__rename_dir+0x87c>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    557c:	89 d9                	mov    %ebx,%ecx
	if (support_clwb) {
    557e:	31 d2                	xor    %edx,%edx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    5580:	83 e1 3f             	and    $0x3f,%ecx
    5583:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    5586:	85 c0                	test   %eax,%eax
    5588:	0f 84 21 01 00 00    	je     56af <__rename_dir+0x9af>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    558e:	89 d0                	mov    %edx,%eax
    5590:	48 01 d8             	add    %rbx,%rax
    5593:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    5597:	83 c2 40             	add    $0x40,%edx
    559a:	39 d1                	cmp    %edx,%ecx
    559c:	77 f0                	ja     558e <__rename_dir+0x88e>
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    559e:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 55a5 <__rename_dir+0x8a5>
    55a5:	ba 14 00 00 00       	mov    $0x14,%edx
    55aa:	be d0 80 00 00       	mov    $0x80d0,%esi
            new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            new_sf->pos = dir_pos;
            new_dir->sub_num++;
            list_add_tail(&new_sf->list, &new_dir->sub_file);

            bitpos++;
    55af:	41 83 c7 02          	add    $0x2,%r15d
    55b3:	e8 00 00 00 00       	callq  55b8 <__rename_dir+0x8b8>
            nova_flush_buffer(new_de, DAFS_DEF_DENTRY_SIZE, 0);
            
            /*add in dir subpos*/
            new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            new_sf->pos = dir_pos;
            new_dir->sub_num++;
    55b8:	48 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%rdi
            list_add_tail(&new_sf->list, &new_dir->sub_file);
    55bf:	48 8b 9d 38 ff ff ff 	mov    -0xc8(%rbp),%rbx
            record_pos_htable(sb, dzt_ei->ht_head, hashname,  dir_pos, 1);
            nova_flush_buffer(new_de, DAFS_DEF_DENTRY_SIZE, 0);
            
            /*add in dir subpos*/
            new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            new_sf->pos = dir_pos;
    55c6:	44 89 68 10          	mov    %r13d,0x10(%rax)
            new_dir->sub_num++;
            list_add_tail(&new_sf->list, &new_dir->sub_file);

            bitpos++;
            dir_pos++;
    55ca:	41 83 c5 01          	add    $0x1,%r13d
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    55ce:	48 8b 57 20          	mov    0x20(%rdi),%rdx
            nova_flush_buffer(new_de, DAFS_DEF_DENTRY_SIZE, 0);
            
            /*add in dir subpos*/
            new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            new_sf->pos = dir_pos;
            new_dir->sub_num++;
    55d2:	48 83 47 08 01       	addq   $0x1,0x8(%rdi)
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    55d7:	48 89 47 20          	mov    %rax,0x20(%rdi)
            list_add_tail(&new_sf->list, &new_dir->sub_file);
    55db:	48 89 18             	mov    %rbx,(%rax)

            bitpos++;
            dir_pos++;
    55de:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
	new->next = next;
	new->prev = prev;
    55e2:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    55e6:	48 89 02             	mov    %rax,(%rdx)
            
        }
        //list_del(&tem_sf->list);
        //old_dir->sub_num--;
        //kfree(tem_sf);
        kfree(s_name);
    55e9:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    55ed:	e8 00 00 00 00       	callq  55f2 <__rename_dir+0x8f2>
        kfree(sub_ph);
    55f2:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    55f6:	e8 00 00 00 00       	callq  55fb <__rename_dir+0x8fb>
    old_hn = le64_to_cpu(src_de->hname);
    old_dir = radix_tree_lookup(&dzt_ei->dir_tree, old_hn);
    head = &old_dir->sub_file;
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
    55fb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
    55ff:	48 39 9d 48 ff ff ff 	cmp    %rbx,-0xb8(%rbp)
    5606:	48 8b 00             	mov    (%rax),%rax
    5609:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    560d:	0f 85 f8 fb ff ff    	jne    520b <__rename_dir+0x50b>
        //old_dir->sub_num--;
        //kfree(tem_sf);
        kfree(s_name);
        kfree(sub_ph);
    }
    kfree(z_p);
    5613:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    5617:	e8 00 00 00 00       	callq  561c <__rename_dir+0x91c>
    kfree(new_ph);
    561c:	48 8b bd 58 ff ff ff 	mov    -0xa8(%rbp),%rdi
    5623:	e8 00 00 00 00       	callq  5628 <__rename_dir+0x928>
    //nova_dbg("%s end",__func__);
    return ret;

}
    5628:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    562c:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    5633:	00 00 
    5635:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
    563b:	0f 85 a8 06 00 00    	jne    5ce9 <__rename_dir+0xfe9>
    5641:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    5648:	5b                   	pop    %rbx
    5649:	41 5c                	pop    %r12
    564b:	41 5d                	pop    %r13
    564d:	41 5e                	pop    %r14
    564f:	41 5f                	pop    %r15
    5651:	5d                   	pop    %rbp
    5652:	c3                   	retq   
    if(nlen<=SMALL_NAME_LEN){
        new_de->ext_flag = 0;
        memcpy(new_de->name, name, nlen);
        new_de->name[nlen] = '\0';
    } else {
        new_de->ext_flag = 1;
    5653:	41 b9 01 00 00 00    	mov    $0x1,%r9d
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, nlen, name, 0);
    5659:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    565d:	44 8b 85 54 ff ff ff 	mov    -0xac(%rbp),%r8d
    if(nlen<=SMALL_NAME_LEN){
        new_de->ext_flag = 0;
        memcpy(new_de->name, name, nlen);
        new_de->name[nlen] = '\0';
    } else {
        new_de->ext_flag = 1;
    5664:	66 45 89 8c 24 84 40 	mov    %r9w,0x4084(%r12)
    566b:	00 00 
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, nlen, name, 0);
    566d:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    5671:	44 8b 4d b0          	mov    -0x50(%rbp),%r9d
    5675:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    5679:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    567d:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
    5684:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
    568b:	00 
    568c:	48 89 04 24          	mov    %rax,(%rsp)
    5690:	e8 00 00 00 00       	callq  5695 <__rename_dir+0x995>
    5695:	e9 60 f8 ff ff       	jmpq   4efa <__rename_dir+0x1fa>
			_mm_clwb(buf + i);
    569a:	89 d0                	mov    %edx,%eax
    569c:	48 01 f0             	add    %rsi,%rax
    569f:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    56a3:	83 c2 40             	add    $0x40,%edx
    56a6:	39 d1                	cmp    %edx,%ecx
    56a8:	77 f0                	ja     569a <__rename_dir+0x99a>
    56aa:	e9 f9 fa ff ff       	jmpq   51a8 <__rename_dir+0x4a8>
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    56af:	89 d0                	mov    %edx,%eax
    56b1:	48 01 d8             	add    %rbx,%rax
    56b4:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    56b7:	83 c2 40             	add    $0x40,%edx
    56ba:	39 d1                	cmp    %edx,%ecx
    56bc:	77 f1                	ja     56af <__rename_dir+0x9af>
    56be:	e9 db fe ff ff       	jmpq   559e <__rename_dir+0x89e>
        sub_len = le64_to_cpu(sub_de->name_len);
        s_name = kzalloc(sizeof(char )*(sub_len+1), GFP_KERNEL);
        if(sub_de->ext_flag==1)
            get_ext_name(sub_de->next, s_name);
        else
            memcpy(s_name, sub_de->name, sub_len+1);
    56c3:	48 8b 06             	mov    (%rsi),%rax
    56c6:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    56ca:	48 89 07             	mov    %rax,(%rdi)
    56cd:	89 d8                	mov    %ebx,%eax
    56cf:	48 8b 54 06 f8       	mov    -0x8(%rsi,%rax,1),%rdx
    56d4:	48 89 54 07 f8       	mov    %rdx,-0x8(%rdi,%rax,1)
    56d9:	48 89 f8             	mov    %rdi,%rax
    56dc:	48 83 c7 08          	add    $0x8,%rdi
    56e0:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    56e4:	48 29 f8             	sub    %rdi,%rax
    56e7:	8d 0c 03             	lea    (%rbx,%rax,1),%ecx
    56ea:	48 29 c6             	sub    %rax,%rsi
    56ed:	89 cb                	mov    %ecx,%ebx
    56ef:	c1 eb 03             	shr    $0x3,%ebx
    56f2:	89 d9                	mov    %ebx,%ecx
    56f4:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    56f7:	e9 b3 fb ff ff       	jmpq   52af <__rename_dir+0x5af>
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);

            }else{

                new_de->ext_flag = sub_de->ext_flag;
                memcpy(new_de->name, s_name, sub_len);
    56fc:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    5700:	48 8d 78 08          	lea    0x8(%rax),%rdi
    5704:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    5708:	48 8b 16             	mov    (%rsi),%rdx
    570b:	48 89 10             	mov    %rdx,(%rax)
    570e:	4c 8b 45 98          	mov    -0x68(%rbp),%r8
    5712:	44 89 c2             	mov    %r8d,%edx
    5715:	48 8b 4c 16 f8       	mov    -0x8(%rsi,%rdx,1),%rcx
    571a:	48 89 4c 10 f8       	mov    %rcx,-0x8(%rax,%rdx,1)
    571f:	48 29 f8             	sub    %rdi,%rax
    5722:	48 29 c6             	sub    %rax,%rsi
    5725:	44 01 c0             	add    %r8d,%eax
    5728:	c1 e8 03             	shr    $0x3,%eax
    572b:	89 c1                	mov    %eax,%ecx
    572d:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    5730:	e9 37 fd ff ff       	jmpq   546c <__rename_dir+0x76c>
        sub_de = &ze->dentry[s_pos];
        sub_ph = kzalloc(sizeof(char )*LARGE_NAME_LEN, GFP_KERNEL);
        sub_len = le64_to_cpu(sub_de->name_len);
        s_name = kzalloc(sizeof(char )*(sub_len+1), GFP_KERNEL);
        if(sub_de->ext_flag==1)
            get_ext_name(sub_de->next, s_name);
    5735:	49 8b bb b0 40 00 00 	mov    0x40b0(%r11),%rdi
    573c:	48 89 c6             	mov    %rax,%rsi
    573f:	e8 00 00 00 00       	callq  5744 <__rename_dir+0xa44>
    5744:	4c 8b 5d 90          	mov    -0x70(%rbp),%r11
    5748:	e9 62 fb ff ff       	jmpq   52af <__rename_dir+0x5af>

            /*set fulname*/
            /*ROOT_DIRECTORY set fulname and update ei*/
            if(new_de->file_type==ROOT_DIRECTORY) {
                /*set_ful name*/
                if(sub_de->ext_flag==0){
    574d:	66 41 83 bb 84 40 00 	cmpw   $0x0,0x4084(%r11)
    5754:	00 00 
    5756:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
    575d:	0f 85 f5 03 00 00    	jne    5b58 <__rename_dir+0xe58>
                    if(sub_plen<SMALL_NAME_LEN){
    5763:	48 83 f8 26          	cmp    $0x26,%rax
    5767:	0f 87 9b 03 00 00    	ja     5b08 <__rename_dir+0xe08>
                        memcpy(new_de->ful_name.f_name, sub_ph, sub_plen);
    576d:	48 8d bc 16 d8 40 00 	lea    0x40d8(%rsi,%rdx,1),%rdi
    5774:	00 
    5775:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    5779:	48 89 c2             	mov    %rax,%rdx
    577c:	e8 00 00 00 00       	callq  5781 <__rename_dir+0xa81>
                        new_de->ful_name.f_name[sub_len]='\0';
    5781:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    5785:	48 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%rcx
    578c:	4c 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%r10
    5793:	c6 84 08 d8 40 00 00 	movb   $0x0,0x40d8(%rax,%rcx,1)
    579a:	00 
                        ext_de_name(sb ,dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);
                    }
                } else
                    ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);

                dzt_hn = le64_to_cpu(sub_de->dzt_hn);
    579b:	48 8b 45 80          	mov    -0x80(%rbp),%rax
                ch_ei = radix_tree_delete(&dzt_m->dzt_root, dzt_hn);
    579f:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    57a3:	4c 89 55 98          	mov    %r10,-0x68(%rbp)
                        ext_de_name(sb ,dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);
                    }
                } else
                    ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);

                dzt_hn = le64_to_cpu(sub_de->dzt_hn);
    57a7:	48 c1 e0 07          	shl    $0x7,%rax
                ch_ei = radix_tree_delete(&dzt_m->dzt_root, dzt_hn);
    57ab:	48 8b b4 07 a8 40 00 	mov    0x40a8(%rdi,%rax,1),%rsi
    57b2:	00 
    57b3:	48 8b bd 28 ff ff ff 	mov    -0xd8(%rbp),%rdi
    57ba:	e8 00 00 00 00       	callq  57bf <__rename_dir+0xabf>
                if(dzt_ei->dzt_eno!=1) {
    57bf:	4c 8b 75 88          	mov    -0x78(%rbp),%r14
                    }
                } else
                    ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);

                dzt_hn = le64_to_cpu(sub_de->dzt_hn);
                ch_ei = radix_tree_delete(&dzt_m->dzt_root, dzt_hn);
    57c3:	49 89 c1             	mov    %rax,%r9
                if(dzt_ei->dzt_eno!=1) {
    57c6:	4c 8b 55 98          	mov    -0x68(%rbp),%r10
    57ca:	41 83 7e 08 01       	cmpl   $0x1,0x8(%r14)
    57cf:	0f 84 99 03 00 00    	je     5b6e <__rename_dir+0xe6e>
                    ch_len =(u64)dzt_ei->root_len + strlen(sub_ph);
    57d5:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    57d9:	4c 89 95 70 ff ff ff 	mov    %r10,-0x90(%rbp)
    57e0:	4c 89 4d 80          	mov    %r9,-0x80(%rbp)
    57e4:	e8 00 00 00 00       	callq  57e9 <__rename_dir+0xae9>
    57e9:	49 03 46 28          	add    0x28(%r14),%rax
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    57ed:	be d0 80 00 00       	mov    $0x80d0,%esi
    57f2:	48 8d 3c c5 00 00 00 	lea    0x0(,%rax,8),%rdi
    57f9:	00 
    57fa:	49 89 c6             	mov    %rax,%r14
    57fd:	e8 00 00 00 00       	callq  5802 <__rename_dir+0xb02>
                    ch_ph = kzalloc(sizeof(char *)*ch_len, GFP_KERNEL);
                    get_zone_path(sb, dzt_ei, ch_ph, sub_ph);
    5802:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
    5806:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    580a:	48 89 c2             	mov    %rax,%rdx
    580d:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
    5814:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    5818:	e8 00 00 00 00       	callq  581d <__rename_dir+0xb1d>
    581d:	45 85 f6             	test   %r14d,%r14d
    5820:	4c 8b 45 98          	mov    -0x68(%rbp),%r8
    5824:	4c 8b 4d 80          	mov    -0x80(%rbp),%r9
    5828:	4c 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10
    582f:	0f 8e 82 03 00 00    	jle    5bb7 <__rename_dir+0xeb7>
    5835:	41 8d 46 ff          	lea    -0x1(%r14),%eax
    5839:	31 c9                	xor    %ecx,%ecx
    583b:	49 8d 74 00 01       	lea    0x1(%r8,%rax,1),%rsi
    5840:	4c 89 c0             	mov    %r8,%rax
		hash = hash * seed + (*str++);
    5843:	48 89 ca             	mov    %rcx,%rdx
    5846:	48 83 c0 01          	add    $0x1,%rax
    584a:	48 c1 e2 06          	shl    $0x6,%rdx
    584e:	48 01 ca             	add    %rcx,%rdx
    5851:	48 8d 14 51          	lea    (%rcx,%rdx,2),%rdx
    5855:	48 0f be 48 ff       	movsbq -0x1(%rax),%rcx
    585a:	48 01 d1             	add    %rdx,%rcx
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    585d:	48 39 f0             	cmp    %rsi,%rax
    5860:	75 e1                	jne    5843 <__rename_dir+0xb43>
                    ch_ph = kzalloc(sizeof(char *)*ch_len, GFP_KERNEL);
                    memcpy(ch_ph, sub_ph, ch_len);
                    memcpy(ch_ph+ch_len,end,1);
                }
                dzt_hn = BKDRHash(ch_ph, ch_len);
                ch_ei->root_len = (u32)ch_len;
    5862:	41 83 e6 ff          	and    $0xffffffff,%r14d
                ch_ei->hash_name = dzt_hn;
    5866:	49 89 49 30          	mov    %rcx,0x30(%r9)
                radix_tree_insert(&dzt_m->dzt_root, dzt_hn, ch_ei);
    586a:	4c 89 ca             	mov    %r9,%rdx
                    ch_ph = kzalloc(sizeof(char *)*ch_len, GFP_KERNEL);
                    memcpy(ch_ph, sub_ph, ch_len);
                    memcpy(ch_ph+ch_len,end,1);
                }
                dzt_hn = BKDRHash(ch_ph, ch_len);
                ch_ei->root_len = (u32)ch_len;
    586d:	4d 89 71 28          	mov    %r14,0x28(%r9)
                ch_ei->hash_name = dzt_hn;
                radix_tree_insert(&dzt_m->dzt_root, dzt_hn, ch_ei);
    5871:	4c 8b b5 28 ff ff ff 	mov    -0xd8(%rbp),%r14
    5878:	48 89 ce             	mov    %rcx,%rsi
    587b:	4c 89 95 70 ff ff ff 	mov    %r10,-0x90(%rbp)
    5882:	4c 89 45 80          	mov    %r8,-0x80(%rbp)
    5886:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
    588a:	4c 89 f7             	mov    %r14,%rdi
    588d:	e8 00 00 00 00       	callq  5892 <__rename_dir+0xb92>
                radix_tree_tag_set(&dzt_m->dzt_root, dzt_hn, 1);
    5892:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
    5896:	ba 01 00 00 00       	mov    $0x1,%edx
    589b:	4c 89 f7             	mov    %r14,%rdi
    589e:	48 89 ce             	mov    %rcx,%rsi
    58a1:	e8 00 00 00 00       	callq  58a6 <__rename_dir+0xba6>
                kfree(ch_ph);
    58a6:	4c 8b 45 80          	mov    -0x80(%rbp),%r8
    58aa:	4c 89 c7             	mov    %r8,%rdi
    58ad:	e8 00 00 00 00       	callq  58b2 <__rename_dir+0xbb2>
                new_de->dzt_hn = cpu_to_le64(dzt_hn);
    58b2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    58b6:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
    58ba:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
    58be:	4c 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10
    58c5:	48 c1 e0 07          	shl    $0x7,%rax
    58c9:	48 89 8c 06 a8 40 00 	mov    %rcx,0x40a8(%rsi,%rax,1)
    58d0:	00 
    58d1:	e9 1b fc ff ff       	jmpq   54f1 <__rename_dir+0x7f1>
            //new_de->isr_sf = sub_de->isr_sf;
            new_de->ino = sub_de->ino;
              
            new_de->size = sub_de->size;
            if(sub_de->ext_flag==1){
                new_de->ext_flag=1;
    58d6:	b9 01 00 00 00       	mov    $0x1,%ecx
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);
    58db:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    58df:	44 0f b6 8d 53 ff ff 	movzbl -0xad(%rbp),%r9d
    58e6:	ff 
            //new_de->isr_sf = sub_de->isr_sf;
            new_de->ino = sub_de->ino;
              
            new_de->size = sub_de->size;
            if(sub_de->ext_flag==1){
                new_de->ext_flag=1;
    58e7:	66 41 89 8a 84 40 00 	mov    %cx,0x4084(%r10)
    58ee:	00 
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);
    58ef:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    58f3:	45 89 e8             	mov    %r13d,%r8d
    58f6:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    58fa:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    58fe:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
    5905:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
    590c:	00 
    590d:	48 89 04 24          	mov    %rax,(%rsp)
    5911:	e8 00 00 00 00       	callq  5916 <__rename_dir+0xc16>
    5916:	4c 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10
    591d:	4c 8b 9d 68 ff ff ff 	mov    -0x98(%rbp),%r11
    5924:	e9 5b fb ff ff       	jmpq   5484 <__rename_dir+0x784>
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
        tem_sf = list_entry(this, struct file_p, list);
        s_pos = tem_sf->pos;
        sub_de = &ze->dentry[s_pos];
    5929:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
    592d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
        memcpy(sub_ph, new_ph, strlen(new_ph));
        strcat(sub_ph, "/");
        strcat(sub_ph, s_name);

        if(sub_de->file_type == NORMAL_DIRECTORY){
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);
    5931:	4c 8b 4d a8          	mov    -0x58(%rbp),%r9
    5935:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
    5939:	48 8b 8d 20 ff ff ff 	mov    -0xe0(%rbp),%rcx
    5940:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
        tem_sf = list_entry(this, struct file_p, list);
        s_pos = tem_sf->pos;
        sub_de = &ze->dentry[s_pos];
    5944:	48 81 c6 81 00 00 00 	add    $0x81,%rsi
        memcpy(sub_ph, new_ph, strlen(new_ph));
        strcat(sub_ph, "/");
        strcat(sub_ph, s_name);

        if(sub_de->file_type == NORMAL_DIRECTORY){
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);
    594b:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
        tem_sf = list_entry(this, struct file_p, list);
        s_pos = tem_sf->pos;
        sub_de = &ze->dentry[s_pos];
    5952:	48 89 f3             	mov    %rsi,%rbx
    5955:	48 c1 e3 07          	shl    $0x7,%rbx
    5959:	48 8d 34 18          	lea    (%rax,%rbx,1),%rsi
        memcpy(sub_ph, new_ph, strlen(new_ph));
        strcat(sub_ph, "/");
        strcat(sub_ph, s_name);

        if(sub_de->file_type == NORMAL_DIRECTORY){
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);
    595d:	e8 00 00 00 00       	callq  5962 <__rename_dir+0xc62>
    5962:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
    5966:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
    596c:	e9 78 fc ff ff       	jmpq   55e9 <__rename_dir+0x8e9>
            test_and_set_bit_le(bitpos, (void *)z_p->statemap);
            hashname = BKDRHash(sub_ph, strlen(sub_ph));
           
            /*rename dir_info*/
            if(new_de->file_type==ROOT_DIRECTORY){
                nr_dir = add_dir_info(dzt_ei, hashname, dir_pos);
    5971:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
    5975:	44 89 ea             	mov    %r13d,%edx
    5978:	4c 89 f6             	mov    %r14,%rsi
    597b:	e8 00 00 00 00       	callq  5980 <__rename_dir+0xc80>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    5980:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
    5987:	49 89 c4             	mov    %rax,%r12
                o_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    598a:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
    5991:	48 8b 97 b0 03 00 00 	mov    0x3b0(%rdi),%rdx
    5998:	48 8b 40 10          	mov    0x10(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    599c:	48 89 c6             	mov    %rax,%rsi
    599f:	48 03 72 18          	add    0x18(%rdx),%rsi
    59a3:	48 85 c0             	test   %rax,%rax
    59a6:	b8 00 00 00 00       	mov    $0x0,%eax
    59ab:	48 0f 44 f0          	cmove  %rax,%rsi
                rn_len = le64_to_cpu(src_de->fname_len); 
    59af:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
    59b6:	48 89 75 98          	mov    %rsi,-0x68(%rbp)
    59ba:	4c 8b 40 10          	mov    0x10(%rax),%r8
                r_name = kzalloc(sizeof(char)*(rn_len+1),GFP_KERNEL);
    59be:	49 8d 78 01          	lea    0x1(%r8),%rdi
    59c2:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
    59c6:	e8 25 a7 ff ff       	callq  f0 <kzalloc.constprop.9>
                get_de_name(src_de, o_ze, r_name, 1);
    59cb:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
    59cf:	48 8b bd 30 ff ff ff 	mov    -0xd0(%rbp),%rdi
    59d6:	b9 01 00 00 00       	mov    $0x1,%ecx
    59db:	48 89 c2             	mov    %rax,%rdx
    59de:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    59e2:	e8 00 00 00 00       	callq  59e7 <__rename_dir+0xce7>
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    59e7:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
    59eb:	45 85 c0             	test   %r8d,%r8d
    59ee:	0f 8e 48 02 00 00    	jle    5c3c <__rename_dir+0xf3c>
    59f4:	4c 8b 4d 90          	mov    -0x70(%rbp),%r9
    59f8:	41 8d 40 ff          	lea    -0x1(%r8),%eax
    59fc:	31 f6                	xor    %esi,%esi
    59fe:	49 8d 4c 01 01       	lea    0x1(%r9,%rax,1),%rcx
		hash = hash * seed + (*str++);
    5a03:	48 89 f0             	mov    %rsi,%rax
    5a06:	49 83 c1 01          	add    $0x1,%r9
    5a0a:	48 c1 e0 06          	shl    $0x6,%rax
    5a0e:	48 01 f0             	add    %rsi,%rax
    5a11:	48 8d 04 46          	lea    (%rsi,%rax,2),%rax
    5a15:	49 0f be 71 ff       	movsbq -0x1(%r9),%rsi
    5a1a:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    5a1d:	49 39 c9             	cmp    %rcx,%r9
    5a20:	75 e1                	jne    5a03 <__rename_dir+0xd03>
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
    5a22:	48 8b bd 10 ff ff ff 	mov    -0xf0(%rbp),%rdi
    5a29:	e8 00 00 00 00       	callq  5a2e <__rename_dir+0xd2e>
                this = head = next =NULL;
                head = &old_dir->sub_file;
                list_for_each_safe(this, next, head){
    5a2e:	48 8b 48 18          	mov    0x18(%rax),%rcx
                r_name = kzalloc(sizeof(char)*(rn_len+1),GFP_KERNEL);
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
                this = head = next =NULL;
                head = &old_dir->sub_file;
    5a32:	48 8d 78 18          	lea    0x18(%rax),%rdi
                o_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
                rn_len = le64_to_cpu(src_de->fname_len); 
                r_name = kzalloc(sizeof(char)*(rn_len+1),GFP_KERNEL);
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
    5a36:	48 89 45 98          	mov    %rax,-0x68(%rbp)
                this = head = next =NULL;
                head = &old_dir->sub_file;
    5a3a:	48 89 bd 48 ff ff ff 	mov    %rdi,-0xb8(%rbp)
                list_for_each_safe(this, next, head){
    5a41:	48 39 cf             	cmp    %rcx,%rdi
    5a44:	4c 8b 01             	mov    (%rcx),%r8
    5a47:	0f 84 e6 01 00 00    	je     5c33 <__rename_dir+0xf33>
    5a4d:	49 8d 44 24 18       	lea    0x18(%r12),%rax
    5a52:	44 89 7d a0          	mov    %r15d,-0x60(%rbp)
    5a56:	44 89 6d 90          	mov    %r13d,-0x70(%rbp)
    5a5a:	48 89 5d 80          	mov    %rbx,-0x80(%rbp)
    5a5e:	4c 89 b5 70 ff ff ff 	mov    %r14,-0x90(%rbp)
    5a65:	49 89 fd             	mov    %rdi,%r13
    5a68:	4c 89 c3             	mov    %r8,%rbx
    5a6b:	49 89 ce             	mov    %rcx,%r14
    5a6e:	49 89 c7             	mov    %rax,%r15
    5a71:	eb 03                	jmp    5a76 <__rename_dir+0xd76>
    5a73:	48 89 c3             	mov    %rax,%rbx
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    5a76:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 5a7d <__rename_dir+0xd7d>
    5a7d:	ba 14 00 00 00       	mov    $0x14,%edx
    5a82:	be d0 80 00 00       	mov    $0x80d0,%esi
    5a87:	e8 00 00 00 00       	callq  5a8c <__rename_dir+0xd8c>
                    tem_sf = list_entry(this, struct file_p, list);
                    new_sf = kzalloc(sizeof(struct file_p),GFP_KERNEL);
                    new_sf->pos = tem_sf->pos;
    5a8c:	41 8b 56 10          	mov    0x10(%r14),%edx
                    list_add_tail(&new_sf->list, &nr_dir->sub_file);
                    list_del(&tem_sf->list);
                    kfree(tem_sf);
    5a90:	4c 89 f7             	mov    %r14,%rdi
                this = head = next =NULL;
                head = &old_dir->sub_file;
                list_for_each_safe(this, next, head){
                    tem_sf = list_entry(this, struct file_p, list);
                    new_sf = kzalloc(sizeof(struct file_p),GFP_KERNEL);
                    new_sf->pos = tem_sf->pos;
    5a93:	89 50 10             	mov    %edx,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    5a96:	49 8b 54 24 20       	mov    0x20(%r12),%rdx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    5a9b:	49 89 44 24 20       	mov    %rax,0x20(%r12)
	new->next = next;
    5aa0:	4c 89 38             	mov    %r15,(%rax)
	new->prev = prev;
    5aa3:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    5aa7:	48 89 02             	mov    %rax,(%rdx)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    5aaa:	49 8b 46 08          	mov    0x8(%r14),%rax
    5aae:	49 8b 16             	mov    (%r14),%rdx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    5ab1:	48 89 42 08          	mov    %rax,0x8(%rdx)
	prev->next = next;
    5ab5:	48 89 10             	mov    %rdx,(%rax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    5ab8:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
    5abf:	00 ad de 
    5ac2:	49 89 06             	mov    %rax,(%r14)
	entry->prev = LIST_POISON2;
    5ac5:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
    5acc:	00 ad de 
    5acf:	49 89 46 08          	mov    %rax,0x8(%r14)
    5ad3:	49 89 de             	mov    %rbx,%r14
                    list_add_tail(&new_sf->list, &nr_dir->sub_file);
                    list_del(&tem_sf->list);
                    kfree(tem_sf);
    5ad6:	e8 00 00 00 00       	callq  5adb <__rename_dir+0xddb>
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
                this = head = next =NULL;
                head = &old_dir->sub_file;
                list_for_each_safe(this, next, head){
    5adb:	49 39 dd             	cmp    %rbx,%r13
    5ade:	48 8b 03             	mov    (%rbx),%rax
    5ae1:	75 90                	jne    5a73 <__rename_dir+0xd73>
    5ae3:	44 8b 6d 90          	mov    -0x70(%rbp),%r13d
    5ae7:	48 8b 5d 80          	mov    -0x80(%rbp),%rbx
    5aeb:	4c 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%r14
    5af2:	44 8b 7d a0          	mov    -0x60(%rbp),%r15d
    5af6:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                    new_sf->pos = tem_sf->pos;
                    list_add_tail(&new_sf->list, &nr_dir->sub_file);
                    list_del(&tem_sf->list);
                    kfree(tem_sf);
                }
                kfree(old_dir);
    5afa:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
    5afe:	e8 00 00 00 00       	callq  5b03 <__rename_dir+0xe03>
    5b03:	e9 4e fa ff ff       	jmpq   5556 <__rename_dir+0x856>
                    if(sub_plen<SMALL_NAME_LEN){
                        memcpy(new_de->ful_name.f_name, sub_ph, sub_plen);
                        new_de->ful_name.f_name[sub_len]='\0';
                    } else {
                        new_de->ext_flag = 2;
                        ext_de_name(sb ,dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);
    5b08:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
                if(sub_de->ext_flag==0){
                    if(sub_plen<SMALL_NAME_LEN){
                        memcpy(new_de->ful_name.f_name, sub_ph, sub_plen);
                        new_de->ful_name.f_name[sub_len]='\0';
                    } else {
                        new_de->ext_flag = 2;
    5b0c:	ba 02 00 00 00       	mov    $0x2,%edx
    5b11:	4c 89 55 98          	mov    %r10,-0x68(%rbp)
    5b15:	66 41 89 92 84 40 00 	mov    %dx,0x4084(%r10)
    5b1c:	00 
                        ext_de_name(sb ,dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);
    5b1d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    5b24:	00 
    5b25:	48 89 34 24          	mov    %rsi,(%rsp)
                    }
                } else
                    ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);
    5b29:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    5b2d:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    5b31:	41 89 c1             	mov    %eax,%r9d
    5b34:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    5b38:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
    5b3f:	45 89 e8             	mov    %r13d,%r8d
    5b42:	e8 00 00 00 00       	callq  5b47 <__rename_dir+0xe47>
    5b47:	4c 8b 55 98          	mov    -0x68(%rbp),%r10
    5b4b:	e9 4b fc ff ff       	jmpq   579b <__rename_dir+0xa9b>

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    5b50:	45 31 f6             	xor    %r14d,%r14d
    5b53:	e9 f0 f9 ff ff       	jmpq   5548 <__rename_dir+0x848>
    5b58:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    5b5c:	4c 89 55 98          	mov    %r10,-0x68(%rbp)
    5b60:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    5b67:	00 
    5b68:	48 89 3c 24          	mov    %rdi,(%rsp)
    5b6c:	eb bb                	jmp    5b29 <__rename_dir+0xe29>
                if(dzt_ei->dzt_eno!=1) {
                    ch_len =(u64)dzt_ei->root_len + strlen(sub_ph);
                    ch_ph = kzalloc(sizeof(char *)*ch_len, GFP_KERNEL);
                    get_zone_path(sb, dzt_ei, ch_ph, sub_ph);
                } else {
                    ch_len = strlen(sub_ph);
    5b6e:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    5b72:	4c 89 55 80          	mov    %r10,-0x80(%rbp)
    5b76:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
    5b7a:	e8 00 00 00 00       	callq  5b7f <__rename_dir+0xe7f>
                    ch_ph = kzalloc(sizeof(char *)*ch_len, GFP_KERNEL);
    5b7f:	48 8d 3c c5 00 00 00 	lea    0x0(,%rax,8),%rdi
    5b86:	00 
                if(dzt_ei->dzt_eno!=1) {
                    ch_len =(u64)dzt_ei->root_len + strlen(sub_ph);
                    ch_ph = kzalloc(sizeof(char *)*ch_len, GFP_KERNEL);
                    get_zone_path(sb, dzt_ei, ch_ph, sub_ph);
                } else {
                    ch_len = strlen(sub_ph);
    5b87:	49 89 c6             	mov    %rax,%r14
                    ch_ph = kzalloc(sizeof(char *)*ch_len, GFP_KERNEL);
    5b8a:	e8 61 a5 ff ff       	callq  f0 <kzalloc.constprop.9>
                    memcpy(ch_ph, sub_ph, ch_len);
    5b8f:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    5b93:	4c 89 f2             	mov    %r14,%rdx
    5b96:	48 89 c7             	mov    %rax,%rdi
    5b99:	e8 00 00 00 00       	callq  5b9e <__rename_dir+0xe9e>
	int i;

	for (i = 0; i < length; i++) {
    5b9e:	45 85 f6             	test   %r14d,%r14d
    5ba1:	49 89 c0             	mov    %rax,%r8
                    memcpy(ch_ph+ch_len,end,1);
    5ba4:	42 c6 04 30 00       	movb   $0x0,(%rax,%r14,1)
    5ba9:	4c 8b 55 80          	mov    -0x80(%rbp),%r10
    5bad:	4c 8b 4d 98          	mov    -0x68(%rbp),%r9
    5bb1:	0f 8f 7e fc ff ff    	jg     5835 <__rename_dir+0xb35>

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    5bb7:	31 c9                	xor    %ecx,%ecx
    5bb9:	e9 a4 fc ff ff       	jmpq   5862 <__rename_dir+0xb62>
        sub_len = le64_to_cpu(sub_de->name_len);
        s_name = kzalloc(sizeof(char )*(sub_len+1), GFP_KERNEL);
        if(sub_de->ext_flag==1)
            get_ext_name(sub_de->next, s_name);
        else
            memcpy(s_name, sub_de->name, sub_len+1);
    5bbe:	8b 06                	mov    (%rsi),%eax
    5bc0:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    5bc4:	89 db                	mov    %ebx,%ebx
    5bc6:	89 07                	mov    %eax,(%rdi)
    5bc8:	8b 44 1e fc          	mov    -0x4(%rsi,%rbx,1),%eax
    5bcc:	89 44 1f fc          	mov    %eax,-0x4(%rdi,%rbx,1)
    5bd0:	e9 da f6 ff ff       	jmpq   52af <__rename_dir+0x5af>
    flen = strlen(path);
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    memcpy(new_ph, path, flen);
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
    5bd5:	44 8d 69 01          	lea    0x1(%rcx),%r13d
    5bd9:	44 8d 7a 02          	lea    0x2(%rdx),%r15d
    5bdd:	89 8d 54 ff ff ff    	mov    %ecx,-0xac(%rbp)
    5be3:	e9 3e f2 ff ff       	jmpq   4e26 <__rename_dir+0x126>
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);

            }else{

                new_de->ext_flag = sub_de->ext_flag;
                memcpy(new_de->name, s_name, sub_len);
    5be8:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    5bec:	8b 16                	mov    (%rsi),%edx
    5bee:	89 10                	mov    %edx,(%rax)
    5bf0:	8b 55 98             	mov    -0x68(%rbp),%edx
    5bf3:	8b 4c 16 fc          	mov    -0x4(%rsi,%rdx,1),%ecx
    5bf7:	89 4c 10 fc          	mov    %ecx,-0x4(%rax,%rdx,1)
    5bfb:	e9 6c f8 ff ff       	jmpq   546c <__rename_dir+0x76c>
    5c00:	45 31 f6             	xor    %r14d,%r14d
    5c03:	e9 44 f4 ff ff       	jmpq   504c <__rename_dir+0x34c>
        sub_len = le64_to_cpu(sub_de->name_len);
        s_name = kzalloc(sizeof(char )*(sub_len+1), GFP_KERNEL);
        if(sub_de->ext_flag==1)
            get_ext_name(sub_de->next, s_name);
        else
            memcpy(s_name, sub_de->name, sub_len+1);
    5c08:	89 db                	mov    %ebx,%ebx
    5c0a:	0f b7 44 1e fe       	movzwl -0x2(%rsi,%rbx,1),%eax
    5c0f:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    5c13:	66 89 44 1e fe       	mov    %ax,-0x2(%rsi,%rbx,1)
    5c18:	e9 92 f6 ff ff       	jmpq   52af <__rename_dir+0x5af>
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);

            }else{

                new_de->ext_flag = sub_de->ext_flag;
                memcpy(new_de->name, s_name, sub_len);
    5c1d:	8b 55 98             	mov    -0x68(%rbp),%edx
    5c20:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    5c24:	0f b7 4c 16 fe       	movzwl -0x2(%rsi,%rdx,1),%ecx
    5c29:	66 89 4c 10 fe       	mov    %cx,-0x2(%rax,%rdx,1)
    5c2e:	e9 39 f8 ff ff       	jmpq   546c <__rename_dir+0x76c>
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
                this = head = next =NULL;
                head = &old_dir->sub_file;
                list_for_each_safe(this, next, head){
    5c33:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
    5c37:	e9 be fe ff ff       	jmpq   5afa <__rename_dir+0xdfa>
    5c3c:	31 f6                	xor    %esi,%esi
    5c3e:	e9 df fd ff ff       	jmpq   5a22 <__rename_dir+0xd22>
    5c43:	45 31 f6             	xor    %r14d,%r14d
    5c46:	e9 de f4 ff ff       	jmpq   5129 <__rename_dir+0x429>
        new_de->par_pos = 0;
        par_de = &ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
            //nova_dbg("new par is root");
            par_hash = le64_to_cpu(par_de->hname);
    5c4b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
            lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
    5c4f:	4c 8b 65 88          	mov    -0x78(%rbp),%r12
    5c53:	4c 8d 45 c4          	lea    -0x3c(%rbp),%r8
    5c57:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
    5c5e:	b9 01 00 00 00       	mov    $0x1,%ecx
        new_de->par_pos = 0;
        par_de = &ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
            //nova_dbg("new par is root");
            par_hash = le64_to_cpu(par_de->hname);
    5c63:	4c 8b b0 a8 40 00 00 	mov    0x40a8(%rax),%r14
            lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
    5c6a:	49 8b 74 24 18       	mov    0x18(%r12),%rsi
            pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    5c6f:	4d 8d 64 24 38       	lea    0x38(%r12),%r12
        par_de = &ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
            //nova_dbg("new par is root");
            par_hash = le64_to_cpu(par_de->hname);
            lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
    5c74:	4c 89 f2             	mov    %r14,%rdx
    5c77:	e8 00 00 00 00       	callq  5c7c <__rename_dir+0xf7c>
            pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    5c7c:	4c 89 f6             	mov    %r14,%rsi
    5c7f:	4c 89 e7             	mov    %r12,%rdi
    5c82:	e8 00 00 00 00       	callq  5c87 <__rename_dir+0xf87>
    5c87:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 5c8e <__rename_dir+0xf8e>
    5c8e:	ba 14 00 00 00       	mov    $0x14,%edx
    5c93:	be d0 80 00 00       	mov    $0x80d0,%esi
    5c98:	49 89 c6             	mov    %rax,%r14
    5c9b:	e8 00 00 00 00       	callq  5ca0 <__rename_dir+0xfa0>
            tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            tem_sf->pos = cpu_to_le32(dir_pos);
    5ca0:	8b b5 54 ff ff ff    	mov    -0xac(%rbp),%esi
            list_add_tail(&tem_sf->list, &pdir->sub_file);
    5ca6:	49 8d 4e 18          	lea    0x18(%r14),%rcx
            //nova_dbg("new par is root");
            par_hash = le64_to_cpu(par_de->hname);
            lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
            pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
            tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            tem_sf->pos = cpu_to_le32(dir_pos);
    5caa:	89 70 10             	mov    %esi,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    5cad:	49 8b 56 20          	mov    0x20(%r14),%rdx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    5cb1:	49 89 46 20          	mov    %rax,0x20(%r14)
            list_add_tail(&tem_sf->list, &pdir->sub_file);
    5cb5:	48 89 08             	mov    %rcx,(%rax)
	new->next = next;
	new->prev = prev;
    5cb8:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    5cbc:	48 89 02             	mov    %rax,(%rdx)
            pdir->sub_num++;
    5cbf:	49 83 46 08 01       	addq   $0x1,0x8(%r14)
    5cc4:	e9 0e f4 ff ff       	jmpq   50d7 <__rename_dir+0x3d7>
    nlen = strlen(name);
    flen = strlen(path);
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    memcpy(new_ph, path, flen);
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
    5cc9:	bb 01 00 00 00       	mov    $0x1,%ebx
    5cce:	41 bd 01 00 00 00    	mov    $0x1,%r13d
    5cd4:	41 bf 02 00 00 00    	mov    $0x2,%r15d
    struct dzt_entry_info *ch_ei;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    struct dir_info *new_dir, *old_dir, *pdir, *nr_dir;
    struct list_head *this, *head, *next;
    struct file_p *tem_sf, *new_sf;
    u32 bitpos = 0, dir_pos = 0, s_pos, par_pos, par_id;
    5cda:	c7 85 54 ff ff ff 00 	movl   $0x0,-0xac(%rbp)
    5ce1:	00 00 00 
    5ce4:	e9 3d f1 ff ff       	jmpq   4e26 <__rename_dir+0x126>
    kfree(z_p);
    kfree(new_ph);
    //nova_dbg("%s end",__func__);
    return ret;

}
    5ce9:	e8 00 00 00 00       	callq  5cee <__rename_dir+0xfee>
    5cee:	66 90                	xchg   %ax,%ax

0000000000005cf0 <add_rename_dir>:

/*rename directories*/
int add_rename_dir(struct dentry *o_dentry, struct dentry *n_dentry, struct dafs_dentry *old_de,
                   struct dzt_entry_info *old_ei)
{
    5cf0:	e8 00 00 00 00       	callq  5cf5 <add_rename_dir+0x5>
    5cf5:	55                   	push   %rbp
    5cf6:	48 89 e5             	mov    %rsp,%rbp
    5cf9:	41 57                	push   %r15
    5cfb:	41 56                	push   %r14
    5cfd:	41 55                	push   %r13
    5cff:	41 54                	push   %r12
    5d01:	49 89 f7             	mov    %rsi,%r15
    5d04:	53                   	push   %rbx
    5d05:	48 83 ec 38          	sub    $0x38,%rsp
    struct super_block *sb = o_dentry->d_sb;
    5d09:	48 8b 5f 68          	mov    0x68(%rdi),%rbx
    //struct dafs_dentry *new_de;
    struct dzt_entry_info *n_ei;
    struct dafs_zone_entry *n_ze;
    char *n_phname, *ph, *phn, *n_name;
    u32 namelen = n_dentry->d_name.len;
    5d0d:	8b 46 24             	mov    0x24(%rsi),%eax
    5d10:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 5d17 <add_rename_dir+0x27>
}

/*rename directories*/
int add_rename_dir(struct dentry *o_dentry, struct dentry *n_dentry, struct dafs_dentry *old_de,
                   struct dzt_entry_info *old_ei)
{
    5d17:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    5d1b:	be d0 80 00 00       	mov    $0x80d0,%esi
    5d20:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
    5d24:	ba 00 04 00 00       	mov    $0x400,%edx
    5d29:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
    struct super_block *sb = o_dentry->d_sb;
    5d2d:	48 89 5d c8          	mov    %rbx,-0x38(%rbp)
    //struct dafs_dentry *new_de;
    struct dzt_entry_info *n_ei;
    struct dafs_zone_entry *n_ze;
    char *n_phname, *ph, *phn, *n_name;
    u32 namelen = n_dentry->d_name.len;
    5d31:	89 45 bc             	mov    %eax,-0x44(%rbp)
    5d34:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    5d3b:	00 00 

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    char *ph=NULL, *buf=NULL, *tem=NULL, *mntchar= "/mnt/ramdisk", *end="", *ppath=NULL;
    struct fs_struct *fs = current->fs;
    5d3d:	4c 8b a8 30 06 00 00 	mov    0x630(%rax),%r13
    5d44:	e8 00 00 00 00       	callq  5d49 <add_rename_dir+0x59>
    5d49:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 5d50 <add_rename_dir+0x60>
    5d50:	ba 00 04 00 00       	mov    $0x400,%edx
    5d55:	be d0 80 00 00       	mov    $0x80d0,%esi
    5d5a:	49 89 c6             	mov    %rax,%r14
    5d5d:	e8 00 00 00 00       	callq  5d62 <add_rename_dir+0x72>
    5d62:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 5d69 <add_rename_dir+0x79>
    5d69:	48 89 c3             	mov    %rax,%rbx
    5d6c:	ba 00 04 00 00       	mov    $0x400,%edx
    5d71:	be d0 80 00 00       	mov    $0x80d0,%esi
    5d76:	e8 00 00 00 00       	callq  5d7b <add_rename_dir+0x8b>

    //nova_dbg("%s:dafs get dentry path",__func__);
    ph = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    buf = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    tem = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    if(!buf)
    5d7b:	48 85 db             	test   %rbx,%rbx
    5d7e:	0f 84 22 01 00 00    	je     5ea6 <add_rename_dir+0x1b6>
        goto ERR;

    read_lock(&fs->lock);
    5d84:	49 8d 7d 04          	lea    0x4(%r13),%rdi
    5d88:	49 89 c4             	mov    %rax,%r12
    5d8b:	e8 00 00 00 00       	callq  5d90 <add_rename_dir+0xa0>
    vfsmnt = mntget(fs->pwd.mnt);
    5d90:	49 8b 7d 28          	mov    0x28(%r13),%rdi
    5d94:	e8 00 00 00 00       	callq  5d99 <add_rename_dir+0xa9>
    if(!vfsmnt){
    5d99:	48 85 c0             	test   %rax,%rax
    tem = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    if(!buf)
        goto ERR;

    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    5d9c:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    if(!vfsmnt){
    5da0:	0f 84 00 01 00 00    	je     5ea6 <add_rename_dir+0x1b6>
    5da6:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
    5dab:	f0 41 0f c1 45 04    	lock xadd %eax,0x4(%r13)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
    5db1:	49 8b 77 28          	mov    0x28(%r15),%rsi
    5db5:	49 c7 c7 00 00 00 00 	mov    $0x0,%r15
    5dbc:	b9 02 00 00 00       	mov    $0x2,%ecx
    5dc1:	4c 89 ff             	mov    %r15,%rdi
    5dc4:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    5dc6:	0f 85 9f 02 00 00    	jne    606b <add_rename_dir+0x37b>
}

/*rename directories*/
int add_rename_dir(struct dentry *o_dentry, struct dentry *n_dentry, struct dafs_dentry *old_de,
                   struct dzt_entry_info *old_ei)
{
    5dcc:	4c 8b 6d c0          	mov    -0x40(%rbp),%r13
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
        strcat(buf,"/");

    do{
        strcat(buf, "/");
    5dd0:	48 89 df             	mov    %rbx,%rdi
    5dd3:	e8 00 00 00 00       	callq  5dd8 <add_rename_dir+0xe8>
    5dd8:	ba 2f 00 00 00       	mov    $0x2f,%edx
        strcat(buf, tem_dentry->d_name.name);
    5ddd:	48 8d 7c 03 01       	lea    0x1(%rbx,%rax,1),%rdi
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
        strcat(buf,"/");

    do{
        strcat(buf, "/");
    5de2:	66 89 14 03          	mov    %dx,(%rbx,%rax,1)
        strcat(buf, tem_dentry->d_name.name);
    5de6:	49 8b 75 28          	mov    0x28(%r13),%rsi
    5dea:	e8 00 00 00 00       	callq  5def <add_rename_dir+0xff>
        p_dentry = tem_dentry->d_parent;
    5def:	4d 8b 6d 18          	mov    0x18(%r13),%r13
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
    5df3:	b9 02 00 00 00       	mov    $0x2,%ecx
    5df8:	4c 89 ff             	mov    %r15,%rdi
    5dfb:	49 8b 75 28          	mov    0x28(%r13),%rsi
    5dff:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    5e01:	75 cd                	jne    5dd0 <add_rename_dir+0xe0>
    5e03:	49 8b 45 30          	mov    0x30(%r13),%rax
    5e07:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
    5e0c:	75 c2                	jne    5dd0 <add_rename_dir+0xe0>
            break;
    }while(1);

    memcpy(tem, buf, strlen(buf));
    5e0e:	48 89 df             	mov    %rbx,%rdi
    5e11:	e8 00 00 00 00       	callq  5e16 <add_rename_dir+0x126>
    5e16:	48 89 de             	mov    %rbx,%rsi
    5e19:	48 89 c2             	mov    %rax,%rdx
    5e1c:	4c 89 e7             	mov    %r12,%rdi
    5e1f:	e8 00 00 00 00       	callq  5e24 <add_rename_dir+0x134>
    tlen = strlen(buf);
    5e24:	48 89 df             	mov    %rbx,%rdi
    5e27:	e8 00 00 00 00       	callq  5e2c <add_rename_dir+0x13c>
    5e2c:	49 89 c5             	mov    %rax,%r13
    do{
        ppath = strrchr(tem, '/');
    5e2f:	be 2f 00 00 00       	mov    $0x2f,%esi
    5e34:	4c 89 e7             	mov    %r12,%rdi
    5e37:	e8 00 00 00 00       	callq  5e3c <add_rename_dir+0x14c>
        phlen = tlen - strlen(ppath);
    5e3c:	48 89 c7             	mov    %rax,%rdi
    5e3f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    5e43:	e8 00 00 00 00       	callq  5e48 <add_rename_dir+0x158>
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        strcat(ph, ppath);
    5e48:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi

    memcpy(tem, buf, strlen(buf));
    tlen = strlen(buf);
    do{
        ppath = strrchr(tem, '/');
        phlen = tlen - strlen(ppath);
    5e4c:	49 29 c5             	sub    %rax,%r13
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        strcat(ph, ppath);
    5e4f:	4c 89 f7             	mov    %r14,%rdi
    5e52:	e8 00 00 00 00       	callq  5e57 <add_rename_dir+0x167>
        memcpy(tem, buf, tlen);
    5e57:	48 89 de             	mov    %rbx,%rsi
    5e5a:	4c 89 e7             	mov    %r12,%rdi
    5e5d:	4c 89 ea             	mov    %r13,%rdx
    5e60:	e8 00 00 00 00       	callq  5e65 <add_rename_dir+0x175>
        memcpy(tem+tlen, end, 1);
    5e65:	43 c6 04 2c 00       	movb   $0x0,(%r12,%r13,1)
        if(!strcmp(tem,"/"))
    5e6a:	b9 02 00 00 00       	mov    $0x2,%ecx
    5e6f:	4c 89 e6             	mov    %r12,%rsi
    5e72:	4c 89 ff             	mov    %r15,%rdi
    5e75:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    5e77:	75 b6                	jne    5e2f <add_rename_dir+0x13f>
            break;
    }while(1);

    BUG_ON(strlen(ph)==1024);
    5e79:	4c 89 f7             	mov    %r14,%rdi
    5e7c:	e8 00 00 00 00       	callq  5e81 <add_rename_dir+0x191>
    5e81:	48 3d 00 04 00 00    	cmp    $0x400,%rax
    5e87:	0f 84 0d 02 00 00    	je     609a <add_rename_dir+0x3aa>
    //nova_dbg("%s ful ph is %s",__func__,ph);
    
    mntput(vfsmnt);
    5e8d:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    5e91:	e8 00 00 00 00       	callq  5e96 <add_rename_dir+0x1a6>
    
    kfree(buf);
    5e96:	48 89 df             	mov    %rbx,%rdi
    5e99:	e8 00 00 00 00       	callq  5e9e <add_rename_dir+0x1ae>
    kfree(tem);
    5e9e:	4c 89 e7             	mov    %r12,%rdi
    5ea1:	e8 00 00 00 00       	callq  5ea6 <add_rename_dir+0x1b6>
    //int i;
    int ret= 0;

    //nova_dbg("%s start",__func__); 
    ph = get_dentry_path(n_dentry,0);
    n_phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    5ea6:	4c 89 f7             	mov    %r14,%rdi
    5ea9:	e8 00 00 00 00       	callq  5eae <add_rename_dir+0x1be>
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    5eae:	be d0 80 00 00       	mov    $0x80d0,%esi
    5eb3:	48 89 c7             	mov    %rax,%rdi
    5eb6:	e8 00 00 00 00       	callq  5ebb <add_rename_dir+0x1cb>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    5ebb:	4c 89 f7             	mov    %r14,%rdi
    5ebe:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    5ec2:	e8 00 00 00 00       	callq  5ec7 <add_rename_dir+0x1d7>
    5ec7:	be d0 80 00 00       	mov    $0x80d0,%esi
    5ecc:	48 89 c7             	mov    %rax,%rdi
    5ecf:	e8 00 00 00 00       	callq  5ed4 <add_rename_dir+0x1e4>
    5ed4:	49 89 c4             	mov    %rax,%r12
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    5ed7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    5edb:	4c 89 f7             	mov    %r14,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    5ede:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
    5ee5:	4c 8b a8 d8 01 00 00 	mov    0x1d8(%rax),%r13
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    5eec:	e8 00 00 00 00       	callq  5ef1 <add_rename_dir+0x201>
    5ef1:	4c 89 f6             	mov    %r14,%rsi
    5ef4:	48 89 c2             	mov    %rax,%rdx
    5ef7:	4c 89 e7             	mov    %r12,%rdi
    5efa:	e8 00 00 00 00       	callq  5eff <add_rename_dir+0x20f>
    tlen = strlen(phstr);
    5eff:	4c 89 f7             	mov    %r14,%rdi
    5f02:	e8 00 00 00 00       	callq  5f07 <add_rename_dir+0x217>
    5f07:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
    5f0a:	be 2f 00 00 00       	mov    $0x2f,%esi
    5f0f:	4c 89 e7             	mov    %r12,%rdi
    5f12:	e8 00 00 00 00       	callq  5f17 <add_rename_dir+0x227>
        phlen = tlen -strlen(tem);
    5f17:	48 89 c7             	mov    %rax,%rdi
    5f1a:	e8 00 00 00 00       	callq  5f1f <add_rename_dir+0x22f>
        tlen = phlen;
        //bug
        if(phlen==0){
    5f1f:	48 29 c3             	sub    %rax,%rbx
    5f22:	0f 84 1a 01 00 00    	je     6042 <add_rename_dir+0x352>
            break;
        }
        memcpy(ph,phstr,tlen);
    5f28:	48 89 da             	mov    %rbx,%rdx
    5f2b:	4c 89 f6             	mov    %r14,%rsi
    5f2e:	4c 89 e7             	mov    %r12,%rdi
    5f31:	e8 00 00 00 00       	callq  5f36 <add_rename_dir+0x246>
	int i;

	for (i = 0; i < length; i++) {
    5f36:	85 db                	test   %ebx,%ebx
        memcpy(ph+tlen, end, 1);
    5f38:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
    5f3d:	0f 8e e4 00 00 00    	jle    6027 <add_rename_dir+0x337>
    5f43:	8d 43 ff             	lea    -0x1(%rbx),%eax
    5f46:	4c 89 e2             	mov    %r12,%rdx
    5f49:	31 f6                	xor    %esi,%esi
    5f4b:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
    5f50:	48 89 f0             	mov    %rsi,%rax
    5f53:	48 83 c2 01          	add    $0x1,%rdx
    5f57:	48 c1 e0 06          	shl    $0x6,%rax
    5f5b:	48 01 f0             	add    %rsi,%rax
    5f5e:	48 8d 04 46          	lea    (%rsi,%rax,2),%rax
    5f62:	48 0f be 72 ff       	movsbq -0x1(%rdx),%rsi
    5f67:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    5f6a:	48 39 ca             	cmp    %rcx,%rdx
    5f6d:	75 e1                	jne    5f50 <add_rename_dir+0x260>
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    5f6f:	4c 89 ef             	mov    %r13,%rdi
    5f72:	e8 00 00 00 00       	callq  5f77 <add_rename_dir+0x287>
        if(dzt_ei){
    5f77:	48 85 c0             	test   %rax,%rax
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    5f7a:	49 89 c7             	mov    %rax,%r15
        if(dzt_ei){
    5f7d:	74 8b                	je     5f0a <add_rename_dir+0x21a>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(n_phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    
    phlen = strlen(phn);
    5f7f:	4c 89 e7             	mov    %r12,%rdi
    5f82:	e8 00 00 00 00       	callq  5f87 <add_rename_dir+0x297>
    if(phlen==1){
    5f87:	48 83 f8 01          	cmp    $0x1,%rax
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(n_phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    
    phlen = strlen(phn);
    5f8b:	48 89 c3             	mov    %rax,%rbx
    if(phlen==1){
        flen = strlen(ph);
    5f8e:	4c 89 f7             	mov    %r14,%rdi
    //memcpy(n_phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    
    phlen = strlen(phn);
    if(phlen==1){
    5f91:	0f 84 ea 00 00 00    	je     6081 <add_rename_dir+0x391>
        flen = strlen(ph);
        memcpy(n_phname, ph, flen);
    } else {
        flen = strlen(ph)-phlen;
    5f97:	e8 00 00 00 00       	callq  5f9c <add_rename_dir+0x2ac>
        memcpy(n_phname, ph+phlen, flen);
    5f9c:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    5fa0:	48 29 d8             	sub    %rbx,%rax
    5fa3:	49 8d 34 1e          	lea    (%r14,%rbx,1),%rsi
    5fa7:	48 89 c2             	mov    %rax,%rdx
    5faa:	e8 00 00 00 00       	callq  5faf <add_rename_dir+0x2bf>
    }

    n_name = kzalloc(sizeof(char)*namelen, GFP_KERNEL);
    5faf:	44 8b 6d bc          	mov    -0x44(%rbp),%r13d
    5fb3:	be d0 80 00 00       	mov    $0x80d0,%esi
    5fb8:	4c 89 ef             	mov    %r13,%rdi
    5fbb:	e8 00 00 00 00       	callq  5fc0 <add_rename_dir+0x2d0>
    5fc0:	48 89 c3             	mov    %rax,%rbx
    memcpy(n_name, n_dentry->d_name.name, namelen);
    5fc3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    5fc7:	4c 89 ea             	mov    %r13,%rdx
    5fca:	48 89 df             	mov    %rbx,%rdi
    5fcd:	48 8b 70 28          	mov    0x28(%rax),%rsi
    5fd1:	e8 00 00 00 00       	callq  5fd6 <add_rename_dir+0x2e6>

    ret = __rename_dir(sb, old_de, n_ei, old_ei,n_phname, n_name);
    5fd6:	4c 8b 45 d0          	mov    -0x30(%rbp),%r8
    5fda:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
    5fde:	49 89 d9             	mov    %rbx,%r9
    5fe1:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    5fe5:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    5fe9:	4c 89 fa             	mov    %r15,%rdx
    5fec:	e8 00 00 00 00       	callq  5ff1 <add_rename_dir+0x301>
    
    kfree(n_phname);
    5ff1:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    }

    n_name = kzalloc(sizeof(char)*namelen, GFP_KERNEL);
    memcpy(n_name, n_dentry->d_name.name, namelen);

    ret = __rename_dir(sb, old_de, n_ei, old_ei,n_phname, n_name);
    5ff5:	41 89 c5             	mov    %eax,%r13d
    
    kfree(n_phname);
    5ff8:	e8 00 00 00 00       	callq  5ffd <add_rename_dir+0x30d>
    kfree(phn);
    5ffd:	4c 89 e7             	mov    %r12,%rdi
    6000:	e8 00 00 00 00       	callq  6005 <add_rename_dir+0x315>
    kfree(ph);
    6005:	4c 89 f7             	mov    %r14,%rdi
    6008:	e8 00 00 00 00       	callq  600d <add_rename_dir+0x31d>
    kfree(n_name);
    600d:	48 89 df             	mov    %rbx,%rdi
    6010:	e8 00 00 00 00       	callq  6015 <add_rename_dir+0x325>
    //nova_dbg("%s end",__func__);
    return ret;
}
    6015:	48 83 c4 38          	add    $0x38,%rsp
    6019:	44 89 e8             	mov    %r13d,%eax
    601c:	5b                   	pop    %rbx
    601d:	41 5c                	pop    %r12
    601f:	41 5d                	pop    %r13
    6021:	41 5e                	pop    %r14
    6023:	41 5f                	pop    %r15
    6025:	5d                   	pop    %rbp
    6026:	c3                   	retq   

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    6027:	31 f6                	xor    %esi,%esi
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    6029:	4c 89 ef             	mov    %r13,%rdi
    602c:	e8 00 00 00 00       	callq  6031 <add_rename_dir+0x341>
        if(dzt_ei){
    6031:	48 85 c0             	test   %rax,%rax
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    6034:	49 89 c7             	mov    %rax,%r15
        if(dzt_ei){
    6037:	0f 84 cd fe ff ff    	je     5f0a <add_rename_dir+0x21a>
    603d:	e9 3d ff ff ff       	jmpq   5f7f <add_rename_dir+0x28f>
            goto END;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    6042:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    memcpy(ph+1,end,1);
    6047:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    604d:	be 2f 00 00 00       	mov    $0x2f,%esi
    6052:	4c 89 ef             	mov    %r13,%rdi
    6055:	e8 00 00 00 00       	callq  605a <add_rename_dir+0x36a>
    if(!dzt_ei){
    605a:	48 85 c0             	test   %rax,%rax

    /*root dir*/
    memcpy(ph, "/", 1);
    memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    605d:	49 89 c7             	mov    %rax,%r15
    if(!dzt_ei){
    6060:	0f 85 19 ff ff ff    	jne    5f7f <add_rename_dir+0x28f>
    6066:	e8 00 00 00 00       	callq  606b <add_rename_dir+0x37b>
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
        strcat(buf,"/");
    606b:	48 89 df             	mov    %rbx,%rdi
    606e:	e8 00 00 00 00       	callq  6073 <add_rename_dir+0x383>
    6073:	b9 2f 00 00 00       	mov    $0x2f,%ecx
    6078:	66 89 0c 03          	mov    %cx,(%rbx,%rax,1)
    607c:	e9 4b fd ff ff       	jmpq   5dcc <add_rename_dir+0xdc>
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
    6081:	e8 00 00 00 00       	callq  6086 <add_rename_dir+0x396>
        memcpy(n_phname, ph, flen);
    6086:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    608a:	48 89 c2             	mov    %rax,%rdx
    608d:	4c 89 f6             	mov    %r14,%rsi
    6090:	e8 00 00 00 00       	callq  6095 <add_rename_dir+0x3a5>
    6095:	e9 15 ff ff ff       	jmpq   5faf <add_rename_dir+0x2bf>
        memcpy(tem+tlen, end, 1);
        if(!strcmp(tem,"/"))
            break;
    }while(1);

    BUG_ON(strlen(ph)==1024);
    609a:	0f 0b                	ud2    
    609c:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000060a0 <__rename_dir_direntry>:
/*rename_s 是父文件夹是否变化的标志
 * 0不变化父文件夹
 * ch_link inc or dec links
 * not decided 标记log*/
int __rename_dir_direntry(struct dentry *old_dentry, struct dentry *new_dentry)
{ 
    60a0:	e8 00 00 00 00       	callq  60a5 <__rename_dir_direntry+0x5>
    60a5:	55                   	push   %rbp
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    60a6:	ba 00 04 00 00       	mov    $0x400,%edx
    60ab:	48 89 e5             	mov    %rsp,%rbp
    60ae:	41 57                	push   %r15
    60b0:	41 56                	push   %r14
    60b2:	41 55                	push   %r13
    60b4:	41 54                	push   %r12
    60b6:	49 89 ff             	mov    %rdi,%r15
    60b9:	53                   	push   %rbx
    60ba:	48 83 ec 50          	sub    $0x50,%rsp
    struct super_block *sb = old_dentry->d_sb;
    60be:	48 8b 47 68          	mov    0x68(%rdi),%rax
/*rename_s 是父文件夹是否变化的标志
 * 0不变化父文件夹
 * ch_link inc or dec links
 * not decided 标记log*/
int __rename_dir_direntry(struct dentry *old_dentry, struct dentry *new_dentry)
{ 
    60c2:	48 89 7d a0          	mov    %rdi,-0x60(%rbp)
    60c6:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 60cd <__rename_dir_direntry+0x2d>
    60cd:	48 89 75 98          	mov    %rsi,-0x68(%rbp)
    60d1:	be d0 80 00 00       	mov    $0x80d0,%esi
    60d6:	65 48 8b 1c 25 28 00 	mov    %gs:0x28,%rbx
    60dd:	00 00 
    60df:	48 89 5d d0          	mov    %rbx,-0x30(%rbp)
    60e3:	31 db                	xor    %ebx,%ebx
    struct super_block *sb = old_dentry->d_sb;
    60e5:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dafs_dentry *old_de;
    struct dzt_entry_info *ch_ei, *old_ei;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    60e9:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
    60f0:	48 8b 80 d8 01 00 00 	mov    0x1d8(%rax),%rax
    60f7:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    60fb:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    6102:	00 00 

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    char *ph=NULL, *buf=NULL, *tem=NULL, *mntchar= "/mnt/ramdisk", *end="", *ppath=NULL;
    struct fs_struct *fs = current->fs;
    6104:	4c 8b a8 30 06 00 00 	mov    0x630(%rax),%r13
    610b:	e8 00 00 00 00       	callq  6110 <__rename_dir_direntry+0x70>
    6110:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 6117 <__rename_dir_direntry+0x77>
    6117:	ba 00 04 00 00       	mov    $0x400,%edx
    611c:	be d0 80 00 00       	mov    $0x80d0,%esi
    6121:	49 89 c6             	mov    %rax,%r14
    6124:	e8 00 00 00 00       	callq  6129 <__rename_dir_direntry+0x89>
    6129:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 6130 <__rename_dir_direntry+0x90>
    6130:	48 89 c3             	mov    %rax,%rbx
    6133:	ba 00 04 00 00       	mov    $0x400,%edx
    6138:	be d0 80 00 00       	mov    $0x80d0,%esi
    613d:	e8 00 00 00 00       	callq  6142 <__rename_dir_direntry+0xa2>

    //nova_dbg("%s:dafs get dentry path",__func__);
    ph = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    buf = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    tem = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    if(!buf)
    6142:	48 85 db             	test   %rbx,%rbx
    6145:	0f 84 22 01 00 00    	je     626d <__rename_dir_direntry+0x1cd>
        goto ERR;

    read_lock(&fs->lock);
    614b:	49 8d 7d 04          	lea    0x4(%r13),%rdi
    614f:	49 89 c4             	mov    %rax,%r12
    6152:	e8 00 00 00 00       	callq  6157 <__rename_dir_direntry+0xb7>
    vfsmnt = mntget(fs->pwd.mnt);
    6157:	49 8b 7d 28          	mov    0x28(%r13),%rdi
    615b:	e8 00 00 00 00       	callq  6160 <__rename_dir_direntry+0xc0>
    if(!vfsmnt){
    6160:	48 85 c0             	test   %rax,%rax
    tem = kzalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    if(!buf)
        goto ERR;

    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    6163:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    if(!vfsmnt){
    6167:	0f 84 00 01 00 00    	je     626d <__rename_dir_direntry+0x1cd>
    616d:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
    6172:	f0 41 0f c1 45 04    	lock xadd %eax,0x4(%r13)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
    6178:	49 8b 77 28          	mov    0x28(%r15),%rsi
    617c:	49 c7 c7 00 00 00 00 	mov    $0x0,%r15
    6183:	b9 02 00 00 00       	mov    $0x2,%ecx
    6188:	4c 89 ff             	mov    %r15,%rdi
    618b:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    618d:	0f 85 c6 03 00 00    	jne    6559 <__rename_dir_direntry+0x4b9>
/*rename_s 是父文件夹是否变化的标志
 * 0不变化父文件夹
 * ch_link inc or dec links
 * not decided 标记log*/
int __rename_dir_direntry(struct dentry *old_dentry, struct dentry *new_dentry)
{ 
    6193:	4c 8b 6d a0          	mov    -0x60(%rbp),%r13
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
        strcat(buf,"/");

    do{
        strcat(buf, "/");
    6197:	48 89 df             	mov    %rbx,%rdi
    619a:	e8 00 00 00 00       	callq  619f <__rename_dir_direntry+0xff>
    619f:	ba 2f 00 00 00       	mov    $0x2f,%edx
        strcat(buf, tem_dentry->d_name.name);
    61a4:	48 8d 7c 03 01       	lea    0x1(%rbx,%rax,1),%rdi
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
        strcat(buf,"/");

    do{
        strcat(buf, "/");
    61a9:	66 89 14 03          	mov    %dx,(%rbx,%rax,1)
        strcat(buf, tem_dentry->d_name.name);
    61ad:	49 8b 75 28          	mov    0x28(%r13),%rsi
    61b1:	e8 00 00 00 00       	callq  61b6 <__rename_dir_direntry+0x116>
        p_dentry = tem_dentry->d_parent;
    61b6:	4d 8b 6d 18          	mov    0x18(%r13),%r13
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
    61ba:	b9 02 00 00 00       	mov    $0x2,%ecx
    61bf:	4c 89 ff             	mov    %r15,%rdi
    61c2:	49 8b 75 28          	mov    0x28(%r13),%rsi
    61c6:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    61c8:	75 cd                	jne    6197 <__rename_dir_direntry+0xf7>
    61ca:	49 8b 45 30          	mov    0x30(%r13),%rax
    61ce:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
    61d3:	75 c2                	jne    6197 <__rename_dir_direntry+0xf7>
            break;
    }while(1);

    memcpy(tem, buf, strlen(buf));
    61d5:	48 89 df             	mov    %rbx,%rdi
    61d8:	e8 00 00 00 00       	callq  61dd <__rename_dir_direntry+0x13d>
    61dd:	48 89 de             	mov    %rbx,%rsi
    61e0:	48 89 c2             	mov    %rax,%rdx
    61e3:	4c 89 e7             	mov    %r12,%rdi
    61e6:	e8 00 00 00 00       	callq  61eb <__rename_dir_direntry+0x14b>
    tlen = strlen(buf);
    61eb:	48 89 df             	mov    %rbx,%rdi
    61ee:	e8 00 00 00 00       	callq  61f3 <__rename_dir_direntry+0x153>
    61f3:	49 89 c5             	mov    %rax,%r13
    do{
        ppath = strrchr(tem, '/');
    61f6:	be 2f 00 00 00       	mov    $0x2f,%esi
    61fb:	4c 89 e7             	mov    %r12,%rdi
    61fe:	e8 00 00 00 00       	callq  6203 <__rename_dir_direntry+0x163>
        phlen = tlen - strlen(ppath);
    6203:	48 89 c7             	mov    %rax,%rdi
    6206:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    620a:	e8 00 00 00 00       	callq  620f <__rename_dir_direntry+0x16f>
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        strcat(ph, ppath);
    620f:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi

    memcpy(tem, buf, strlen(buf));
    tlen = strlen(buf);
    do{
        ppath = strrchr(tem, '/');
        phlen = tlen - strlen(ppath);
    6213:	49 29 c5             	sub    %rax,%r13
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        strcat(ph, ppath);
    6216:	4c 89 f7             	mov    %r14,%rdi
    6219:	e8 00 00 00 00       	callq  621e <__rename_dir_direntry+0x17e>
        memcpy(tem, buf, tlen);
    621e:	48 89 de             	mov    %rbx,%rsi
    6221:	4c 89 e7             	mov    %r12,%rdi
    6224:	4c 89 ea             	mov    %r13,%rdx
    6227:	e8 00 00 00 00       	callq  622c <__rename_dir_direntry+0x18c>
        memcpy(tem+tlen, end, 1);
    622c:	43 c6 04 2c 00       	movb   $0x0,(%r12,%r13,1)
        if(!strcmp(tem,"/"))
    6231:	b9 02 00 00 00       	mov    $0x2,%ecx
    6236:	4c 89 e6             	mov    %r12,%rsi
    6239:	4c 89 ff             	mov    %r15,%rdi
    623c:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    623e:	75 b6                	jne    61f6 <__rename_dir_direntry+0x156>
            break;
    }while(1);

    BUG_ON(strlen(ph)==1024);
    6240:	4c 89 f7             	mov    %r14,%rdi
    6243:	e8 00 00 00 00       	callq  6248 <__rename_dir_direntry+0x1a8>
    6248:	48 3d 00 04 00 00    	cmp    $0x400,%rax
    624e:	0f 84 22 03 00 00    	je     6576 <__rename_dir_direntry+0x4d6>
    //nova_dbg("%s ful ph is %s",__func__,ph);
    
    mntput(vfsmnt);
    6254:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
    6258:	e8 00 00 00 00       	callq  625d <__rename_dir_direntry+0x1bd>
    
    kfree(buf);
    625d:	48 89 df             	mov    %rbx,%rdi
    6260:	e8 00 00 00 00       	callq  6265 <__rename_dir_direntry+0x1c5>
    kfree(tem);
    6265:	4c 89 e7             	mov    %r12,%rdi
    6268:	e8 00 00 00 00       	callq  626d <__rename_dir_direntry+0x1cd>

    //nova_dbg("%s start",__func__);
    ph = get_dentry_path(old_dentry, 0);
    //nova_dbg("strictly full name is %s", ph);
    //nova_dbg("strictly full name length is %llu", strlen(ph));
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    626d:	4c 89 f7             	mov    %r14,%rdi
    6270:	e8 00 00 00 00       	callq  6275 <__rename_dir_direntry+0x1d5>
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    6275:	be d0 80 00 00       	mov    $0x80d0,%esi
    627a:	48 89 c7             	mov    %rax,%rdi
    627d:	e8 00 00 00 00       	callq  6282 <__rename_dir_direntry+0x1e2>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    6282:	4c 89 f7             	mov    %r14,%rdi
    6285:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    6289:	e8 00 00 00 00       	callq  628e <__rename_dir_direntry+0x1ee>
    628e:	be d0 80 00 00       	mov    $0x80d0,%esi
    6293:	48 89 c7             	mov    %rax,%rdi
    6296:	e8 00 00 00 00       	callq  629b <__rename_dir_direntry+0x1fb>
    629b:	49 89 c4             	mov    %rax,%r12
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    629e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    62a2:	4c 89 f7             	mov    %r14,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    62a5:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
    62ac:	4c 8b a8 d8 01 00 00 	mov    0x1d8(%rax),%r13
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    62b3:	e8 00 00 00 00       	callq  62b8 <__rename_dir_direntry+0x218>
    62b8:	4c 89 f6             	mov    %r14,%rsi
    62bb:	48 89 c2             	mov    %rax,%rdx
    62be:	4c 89 e7             	mov    %r12,%rdi
    62c1:	e8 00 00 00 00       	callq  62c6 <__rename_dir_direntry+0x226>
    tlen = strlen(phstr);
    62c6:	4c 89 f7             	mov    %r14,%rdi
    62c9:	e8 00 00 00 00       	callq  62ce <__rename_dir_direntry+0x22e>
    62ce:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
    62d1:	be 2f 00 00 00       	mov    $0x2f,%esi
    62d6:	4c 89 e7             	mov    %r12,%rdi
    62d9:	e8 00 00 00 00       	callq  62de <__rename_dir_direntry+0x23e>
        phlen = tlen -strlen(tem);
    62de:	48 89 c7             	mov    %rax,%rdi
    62e1:	e8 00 00 00 00       	callq  62e6 <__rename_dir_direntry+0x246>
        tlen = phlen;
        //bug
        if(phlen==0){
    62e6:	48 29 c3             	sub    %rax,%rbx
    62e9:	0f 84 af 01 00 00    	je     649e <__rename_dir_direntry+0x3fe>
            break;
        }
        memcpy(ph,phstr,tlen);
    62ef:	48 89 da             	mov    %rbx,%rdx
    62f2:	4c 89 f6             	mov    %r14,%rsi
    62f5:	4c 89 e7             	mov    %r12,%rdi
    62f8:	e8 00 00 00 00       	callq  62fd <__rename_dir_direntry+0x25d>
	int i;

	for (i = 0; i < length; i++) {
    62fd:	85 db                	test   %ebx,%ebx
        memcpy(ph+tlen, end, 1);
    62ff:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
    6304:	0f 8e 6e 01 00 00    	jle    6478 <__rename_dir_direntry+0x3d8>
    630a:	8d 43 ff             	lea    -0x1(%rbx),%eax
    630d:	4c 89 e2             	mov    %r12,%rdx
    6310:	31 f6                	xor    %esi,%esi
    6312:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
    6317:	48 89 f0             	mov    %rsi,%rax
    631a:	48 83 c2 01          	add    $0x1,%rdx
    631e:	48 c1 e0 06          	shl    $0x6,%rax
    6322:	48 01 f0             	add    %rsi,%rax
    6325:	48 8d 04 46          	lea    (%rsi,%rax,2),%rax
    6329:	48 0f be 72 ff       	movsbq -0x1(%rdx),%rsi
    632e:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    6331:	48 39 ca             	cmp    %rcx,%rdx
    6334:	75 e1                	jne    6317 <__rename_dir_direntry+0x277>
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    6336:	4c 89 ef             	mov    %r13,%rdi
    6339:	e8 00 00 00 00       	callq  633e <__rename_dir_direntry+0x29e>
        if(dzt_ei){
    633e:	48 85 c0             	test   %rax,%rax
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    6341:	49 89 c7             	mov    %rax,%r15
        if(dzt_ei){
    6344:	74 8b                	je     62d1 <__rename_dir_direntry+0x231>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    6346:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
    //nova_dbg("strictly full name is %s", ph);
    //nova_dbg("strictly full name length is %llu", strlen(ph));
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    old_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    634a:	49 8b 47 10          	mov    0x10(%r15),%rax
    phlen = strlen(phn);
    634e:	4c 89 e7             	mov    %r12,%rdi
    6351:	48 8b 93 b0 03 00 00 	mov    0x3b0(%rbx),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    6358:	48 89 c3             	mov    %rax,%rbx
    635b:	48 03 5a 18          	add    0x18(%rdx),%rbx
    635f:	48 85 c0             	test   %rax,%rax
    6362:	b8 00 00 00 00       	mov    $0x0,%eax
    6367:	48 0f 44 d8          	cmove  %rax,%rbx
    636b:	e8 00 00 00 00       	callq  6370 <__rename_dir_direntry+0x2d0>
    dzt_eno = old_ei->dzt_eno;
    if(phlen==1){
    6370:	48 83 f8 01          	cmp    $0x1,%rax
    //nova_dbg("strictly full name length is %llu", strlen(ph));
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    old_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    phlen = strlen(phn);
    6374:	49 89 c5             	mov    %rax,%r13
    dzt_eno = old_ei->dzt_eno;
    if(phlen==1){
        memcpy(phname, ph, strlen(ph));
    6377:	4c 89 f7             	mov    %r14,%rdi
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    old_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    phlen = strlen(phn);
    dzt_eno = old_ei->dzt_eno;
    if(phlen==1){
    637a:	0f 84 47 01 00 00    	je     64c7 <__rename_dir_direntry+0x427>
        memcpy(phname, ph, strlen(ph));
    } else {
        flen = strlen(ph)-phlen;
    6380:	e8 00 00 00 00       	callq  6385 <__rename_dir_direntry+0x2e5>
        memcpy(phname, ph+phlen, flen);
    6385:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    6389:	4c 29 e8             	sub    %r13,%rax
    638c:	4b 8d 34 2e          	lea    (%r14,%r13,1),%rsi
    6390:	48 89 c2             	mov    %rax,%rdx
    6393:	e8 00 00 00 00       	callq  6398 <__rename_dir_direntry+0x2f8>
    }
    ph_hash = BKDRHash(phname, strlen(phname));
    6398:	4c 8b 6d b0          	mov    -0x50(%rbp),%r13
    639c:	4c 89 ef             	mov    %r13,%rdi
    639f:	e8 00 00 00 00       	callq  63a4 <__rename_dir_direntry+0x304>
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    63a4:	85 c0                	test   %eax,%eax
    63a6:	0f 8e c3 01 00 00    	jle    656f <__rename_dir_direntry+0x4cf>
    63ac:	83 e8 01             	sub    $0x1,%eax
    63af:	4c 89 e9             	mov    %r13,%rcx
    63b2:	31 d2                	xor    %edx,%edx
    63b4:	49 8d 74 05 01       	lea    0x1(%r13,%rax,1),%rsi
		hash = hash * seed + (*str++);
    63b9:	48 89 d0             	mov    %rdx,%rax
    63bc:	48 83 c1 01          	add    $0x1,%rcx
    63c0:	48 c1 e0 06          	shl    $0x6,%rax
    63c4:	48 01 d0             	add    %rdx,%rax
    63c7:	48 8d 04 42          	lea    (%rdx,%rax,2),%rax
    63cb:	48 0f be 51 ff       	movsbq -0x1(%rcx),%rdx
    63d0:	48 01 c2             	add    %rax,%rdx
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    63d3:	48 39 f1             	cmp    %rsi,%rcx
    63d6:	75 e1                	jne    63b9 <__rename_dir_direntry+0x319>
    ht_addr = old_ei->ht_head;
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    63d8:	49 8b 77 18          	mov    0x18(%r15),%rsi
    63dc:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    63e0:	4c 8d 45 bc          	lea    -0x44(%rbp),%r8
    63e4:	b9 01 00 00 00       	mov    $0x1,%ecx
    63e9:	e8 00 00 00 00       	callq  63ee <__rename_dir_direntry+0x34e>
    63ee:	89 c2                	mov    %eax,%edx
    struct dafs_zone_entry *dafs_ze;
    char *phname, *ph, *phn;
    u32 dzt_eno, de_pos;
    u64 old_hn, new_hn, root_len;
    u64 ph_hash, ht_addr, flen, phlen;
    int err = -ENOENT;
    63f0:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        memcpy(phname, ph+phlen, flen);
    }
    ph_hash = BKDRHash(phname, strlen(phname));
    ht_addr = old_ei->ht_head;
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    if(!ret){
    63f5:	85 d2                	test   %edx,%edx
    63f7:	74 5d                	je     6456 <__rename_dir_direntry+0x3b6>
        //nova_dbg("not found dentry in nvm");
        goto OUT;
    }
    old_de = &dafs_ze->dentry[de_pos];
    63f9:	8b 45 bc             	mov    -0x44(%rbp),%eax
    kfree(phname);
    63fc:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    if(!ret){
        //nova_dbg("not found dentry in nvm");
        goto OUT;
    }
    old_de = &dafs_ze->dentry[de_pos];
    6400:	4c 8d a8 81 00 00 00 	lea    0x81(%rax),%r13
    6407:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    kfree(phname);
    640b:	e8 00 00 00 00       	callq  6410 <__rename_dir_direntry+0x370>
    kfree(ph);
    6410:	4c 89 f7             	mov    %r14,%rdi
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    if(!ret){
        //nova_dbg("not found dentry in nvm");
        goto OUT;
    }
    old_de = &dafs_ze->dentry[de_pos];
    6413:	49 c1 e5 07          	shl    $0x7,%r13
    kfree(phname);
    kfree(ph);
    6417:	e8 00 00 00 00       	callq  641c <__rename_dir_direntry+0x37c>
    kfree(phn);
    641c:	4c 89 e7             	mov    %r12,%rdi
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    if(!ret){
        //nova_dbg("not found dentry in nvm");
        goto OUT;
    }
    old_de = &dafs_ze->dentry[de_pos];
    641f:	49 01 dd             	add    %rbx,%r13
    kfree(phname);
    kfree(ph);
    kfree(phn);
    6422:	e8 00 00 00 00       	callq  6427 <__rename_dir_direntry+0x387>
    6427:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    642b:	48 c1 e0 07          	shl    $0x7,%rax
    642f:	48 01 c3             	add    %rax,%rbx
    //old_de = dafs_find_direntry(sb, old_dentry,0,0);
    //dz_no = le64_to_cpu(old_de->zone_no);
    
    if(old_de->file_type == ROOT_DIRECTORY){
    6432:	80 bb 82 40 00 00 02 	cmpb   $0x2,0x4082(%rbx)
    6439:	0f 84 a1 00 00 00    	je     64e0 <__rename_dir_direntry+0x440>
        old_de->file_type = NORMAL_FILE;
        err = dafs_remove_dentry(old_dentry);

    } else {
        
        err = add_rename_dir(old_dentry, new_dentry, old_de, old_ei); 
    643f:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
    6443:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    6447:	4c 89 f9             	mov    %r15,%rcx
    644a:	4c 89 ea             	mov    %r13,%rdx
    644d:	e8 00 00 00 00       	callq  6452 <__rename_dir_direntry+0x3b2>
        if(err)
    6452:	85 c0                	test   %eax,%eax
    6454:	74 3d                	je     6493 <__rename_dir_direntry+0x3f3>
            return err;
        err = dafs_remove_dentry(old_dentry);
    }
OUT:
   return err;
}
    6456:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    645a:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    6461:	00 00 
    6463:	0f 85 0f 01 00 00    	jne    6578 <__rename_dir_direntry+0x4d8>
    6469:	48 83 c4 50          	add    $0x50,%rsp
    646d:	5b                   	pop    %rbx
    646e:	41 5c                	pop    %r12
    6470:	41 5d                	pop    %r13
    6472:	41 5e                	pop    %r14
    6474:	41 5f                	pop    %r15
    6476:	5d                   	pop    %rbp
    6477:	c3                   	retq   

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    6478:	31 f6                	xor    %esi,%esi
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    647a:	4c 89 ef             	mov    %r13,%rdi
    647d:	e8 00 00 00 00       	callq  6482 <__rename_dir_direntry+0x3e2>
        if(dzt_ei){
    6482:	48 85 c0             	test   %rax,%rax
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    6485:	49 89 c7             	mov    %rax,%r15
        if(dzt_ei){
    6488:	0f 84 43 fe ff ff    	je     62d1 <__rename_dir_direntry+0x231>
    648e:	e9 b3 fe ff ff       	jmpq   6346 <__rename_dir_direntry+0x2a6>
    } else {
        
        err = add_rename_dir(old_dentry, new_dentry, old_de, old_ei); 
        if(err)
            return err;
        err = dafs_remove_dentry(old_dentry);
    6493:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    6497:	e8 00 00 00 00       	callq  649c <__rename_dir_direntry+0x3fc>
    649c:	eb b8                	jmp    6456 <__rename_dir_direntry+0x3b6>
            goto END;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    649e:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    memcpy(ph+1,end,1);
    64a3:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    64a9:	be 2f 00 00 00       	mov    $0x2f,%esi
    64ae:	4c 89 ef             	mov    %r13,%rdi
    64b1:	e8 00 00 00 00       	callq  64b6 <__rename_dir_direntry+0x416>
    if(!dzt_ei){
    64b6:	48 85 c0             	test   %rax,%rax

    /*root dir*/
    memcpy(ph, "/", 1);
    memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    64b9:	49 89 c7             	mov    %rax,%r15
    if(!dzt_ei){
    64bc:	0f 85 84 fe ff ff    	jne    6346 <__rename_dir_direntry+0x2a6>
    64c2:	e8 00 00 00 00       	callq  64c7 <__rename_dir_direntry+0x427>
    old_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    phlen = strlen(phn);
    dzt_eno = old_ei->dzt_eno;
    if(phlen==1){
        memcpy(phname, ph, strlen(ph));
    64c7:	e8 00 00 00 00       	callq  64cc <__rename_dir_direntry+0x42c>
    64cc:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    64d0:	48 89 c2             	mov    %rax,%rdx
    64d3:	4c 89 f6             	mov    %r14,%rsi
    64d6:	e8 00 00 00 00       	callq  64db <__rename_dir_direntry+0x43b>
    64db:	e9 b8 fe ff ff       	jmpq   6398 <__rename_dir_direntry+0x2f8>
    //old_de = dafs_find_direntry(sb, old_dentry,0,0);
    //dz_no = le64_to_cpu(old_de->zone_no);
    
    if(old_de->file_type == ROOT_DIRECTORY){
        old_hn = le64_to_cpu(old_de->hname);
        ch_ei = radix_tree_delete(&dzt_m->dzt_root, old_hn);
    64e0:	48 8b b3 a8 40 00 00 	mov    0x40a8(%rbx),%rsi
    64e7:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
    64eb:	e8 00 00 00 00       	callq  64f0 <__rename_dir_direntry+0x450>
        err = add_rename_zone_dir(new_dentry, old_de, old_ei, &new_hn, &root_len);
    64f0:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
    64f4:	4c 8d 45 c8          	lea    -0x38(%rbp),%r8
    64f8:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
    64fc:	4c 89 fa             	mov    %r15,%rdx
    64ff:	4c 89 ee             	mov    %r13,%rsi
    //old_de = dafs_find_direntry(sb, old_dentry,0,0);
    //dz_no = le64_to_cpu(old_de->zone_no);
    
    if(old_de->file_type == ROOT_DIRECTORY){
        old_hn = le64_to_cpu(old_de->hname);
        ch_ei = radix_tree_delete(&dzt_m->dzt_root, old_hn);
    6502:	49 89 c4             	mov    %rax,%r12
        err = add_rename_zone_dir(new_dentry, old_de, old_ei, &new_hn, &root_len);
    6505:	e8 00 00 00 00       	callq  650a <__rename_dir_direntry+0x46a>
        /*防止zone被删除*/
        if(err)
    650a:	85 c0                	test   %eax,%eax
    650c:	0f 85 44 ff ff ff    	jne    6456 <__rename_dir_direntry+0x3b6>
            return err;
        ch_ei->root_len = root_len;
        ch_ei->hash_name = new_hn;
    6512:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
        /*update ei hashname, root len and set dirty bit*/
        radix_tree_insert(&dzt_m->dzt_root, new_hn, ch_ei);
    6516:	4c 8b 75 88          	mov    -0x78(%rbp),%r14
    651a:	4c 89 e2             	mov    %r12,%rdx
        ch_ei = radix_tree_delete(&dzt_m->dzt_root, old_hn);
        err = add_rename_zone_dir(new_dentry, old_de, old_ei, &new_hn, &root_len);
        /*防止zone被删除*/
        if(err)
            return err;
        ch_ei->root_len = root_len;
    651d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
        ch_ei->hash_name = new_hn;
    6521:	49 89 74 24 30       	mov    %rsi,0x30(%r12)
        /*update ei hashname, root len and set dirty bit*/
        radix_tree_insert(&dzt_m->dzt_root, new_hn, ch_ei);
    6526:	4c 89 f7             	mov    %r14,%rdi
        ch_ei = radix_tree_delete(&dzt_m->dzt_root, old_hn);
        err = add_rename_zone_dir(new_dentry, old_de, old_ei, &new_hn, &root_len);
        /*防止zone被删除*/
        if(err)
            return err;
        ch_ei->root_len = root_len;
    6529:	49 89 44 24 28       	mov    %rax,0x28(%r12)
        ch_ei->hash_name = new_hn;
        /*update ei hashname, root len and set dirty bit*/
        radix_tree_insert(&dzt_m->dzt_root, new_hn, ch_ei);
    652e:	e8 00 00 00 00       	callq  6533 <__rename_dir_direntry+0x493>
        radix_tree_tag_set(&dzt_m->dzt_root, new_hn, 1);
    6533:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    6537:	4c 89 f7             	mov    %r14,%rdi
    653a:	ba 01 00 00 00       	mov    $0x1,%edx
    653f:	e8 00 00 00 00       	callq  6544 <__rename_dir_direntry+0x4a4>

        old_de->file_type = NORMAL_FILE;
        err = dafs_remove_dentry(old_dentry);
    6544:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
        ch_ei->hash_name = new_hn;
        /*update ei hashname, root len and set dirty bit*/
        radix_tree_insert(&dzt_m->dzt_root, new_hn, ch_ei);
        radix_tree_tag_set(&dzt_m->dzt_root, new_hn, 1);

        old_de->file_type = NORMAL_FILE;
    6548:	c6 83 82 40 00 00 00 	movb   $0x0,0x4082(%rbx)
        err = dafs_remove_dentry(old_dentry);
    654f:	e8 00 00 00 00       	callq  6554 <__rename_dir_direntry+0x4b4>
    6554:	e9 fd fe ff ff       	jmpq   6456 <__rename_dir_direntry+0x3b6>
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/"))
        strcat(buf,"/");
    6559:	48 89 df             	mov    %rbx,%rdi
    655c:	e8 00 00 00 00       	callq  6561 <__rename_dir_direntry+0x4c1>
    6561:	b9 2f 00 00 00       	mov    $0x2f,%ecx
    6566:	66 89 0c 03          	mov    %cx,(%rbx,%rax,1)
    656a:	e9 24 fc ff ff       	jmpq   6193 <__rename_dir_direntry+0xf3>
    656f:	31 d2                	xor    %edx,%edx
    6571:	e9 62 fe ff ff       	jmpq   63d8 <__rename_dir_direntry+0x338>
        memcpy(tem+tlen, end, 1);
        if(!strcmp(tem,"/"))
            break;
    }while(1);

    BUG_ON(strlen(ph)==1024);
    6576:	0f 0b                	ud2    
            return err;
        err = dafs_remove_dentry(old_dentry);
    }
OUT:
   return err;
}
    6578:	e8 00 00 00 00       	callq  657d <__rename_dir_direntry+0x4dd>
    657d:	0f 1f 00             	nopl   (%rax)

0000000000006580 <__rename_file_dentry>:

int __rename_file_dentry(struct dentry *old_dentry, struct dentry *new_dentry)
{
    6580:	e8 00 00 00 00       	callq  6585 <__rename_file_dentry+0x5>
    6585:	55                   	push   %rbp
    u64 temlen, phlen, flen;
    u64 hashname, par_hn, ino;
    int ret = 0;
    char *end ="";

    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);
    6586:	31 c9                	xor    %ecx,%ecx
    6588:	31 d2                	xor    %edx,%edx
OUT:
   return err;
}

int __rename_file_dentry(struct dentry *old_dentry, struct dentry *new_dentry)
{
    658a:	48 89 e5             	mov    %rsp,%rbp
    658d:	41 57                	push   %r15
    658f:	41 56                	push   %r14
    6591:	41 55                	push   %r13
    6593:	41 54                	push   %r12
    6595:	49 89 f6             	mov    %rsi,%r14
    6598:	53                   	push   %rbx
    u64 temlen, phlen, flen;
    u64 hashname, par_hn, ino;
    int ret = 0;
    char *end ="";

    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);
    6599:	48 89 fe             	mov    %rdi,%rsi
OUT:
   return err;
}

int __rename_file_dentry(struct dentry *old_dentry, struct dentry *new_dentry)
{
    659c:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
    65a0:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    65a7:	00 00 
    65a9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    65ad:	31 c0                	xor    %eax,%eax
    struct super_block *sb = old_dentry->d_sb;
    65af:	48 8b 47 68          	mov    0x68(%rdi),%rax
    u64 temlen, phlen, flen;
    u64 hashname, par_hn, ino;
    int ret = 0;
    char *end ="";

    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);
    65b3:	48 89 c7             	mov    %rax,%rdi
   return err;
}

int __rename_file_dentry(struct dentry *old_dentry, struct dentry *new_dentry)
{
    struct super_block *sb = old_dentry->d_sb;
    65b6:	48 89 c3             	mov    %rax,%rbx
    65b9:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    u64 temlen, phlen, flen;
    u64 hashname, par_hn, ino;
    int ret = 0;
    char *end ="";

    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);
    65bd:	e8 00 00 00 00       	callq  65c2 <__rename_file_dentry+0x42>

    //nova_dbg("dafs start rename file dentry");

    ph = get_dentry_path(new_dentry,0);
    65c2:	4c 89 f7             	mov    %r14,%rdi
    u64 temlen, phlen, flen;
    u64 hashname, par_hn, ino;
    int ret = 0;
    char *end ="";

    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);
    65c5:	48 89 45 a8          	mov    %rax,-0x58(%rbp)

    //nova_dbg("dafs start rename file dentry");

    ph = get_dentry_path(new_dentry,0);
    65c9:	e8 32 9b ff ff       	callq  100 <get_dentry_path.isra.4>
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    65ce:	48 89 c7             	mov    %rax,%rdi

    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);

    //nova_dbg("dafs start rename file dentry");

    ph = get_dentry_path(new_dentry,0);
    65d1:	49 89 c5             	mov    %rax,%r13
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    65d4:	e8 00 00 00 00       	callq  65d9 <__rename_file_dentry+0x59>
    65d9:	48 89 c7             	mov    %rax,%rdi
    65dc:	e8 0f 9b ff ff       	callq  f0 <kzalloc.constprop.9>
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    65e1:	4c 89 ef             	mov    %r13,%rdi
    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);

    //nova_dbg("dafs start rename file dentry");

    ph = get_dentry_path(new_dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    65e4:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    65e8:	e8 00 00 00 00       	callq  65ed <__rename_file_dentry+0x6d>
    65ed:	48 89 c7             	mov    %rax,%rdi
    65f0:	e8 fb 9a ff ff       	callq  f0 <kzalloc.constprop.9>
    65f5:	49 89 c4             	mov    %rax,%r12
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    65f8:	48 8b 83 b0 03 00 00 	mov    0x3b0(%rbx),%rax
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    65ff:	4c 89 ef             	mov    %r13,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    6602:	4c 8b b8 d8 01 00 00 	mov    0x1d8(%rax),%r15
    char *end = "";
    int i = 0;

    //nova_dbg("%s start",__func__);
    //ph = kzalloc(LARGE_NAME_LEN*(char *), GFP_KERNEL);
    memcpy(ph, phstr, strlen(phstr));
    6609:	e8 00 00 00 00       	callq  660e <__rename_file_dentry+0x8e>
    660e:	4c 89 ee             	mov    %r13,%rsi
    6611:	48 89 c2             	mov    %rax,%rdx
    6614:	4c 89 e7             	mov    %r12,%rdi
    6617:	e8 00 00 00 00       	callq  661c <__rename_file_dentry+0x9c>
    tlen = strlen(phstr);
    661c:	4c 89 ef             	mov    %r13,%rdi
    661f:	e8 00 00 00 00       	callq  6624 <__rename_file_dentry+0xa4>
    6624:	48 89 c3             	mov    %rax,%rbx
    do{
        tem = strrchr(ph, '/');
    6627:	be 2f 00 00 00       	mov    $0x2f,%esi
    662c:	4c 89 e7             	mov    %r12,%rdi
    662f:	e8 00 00 00 00       	callq  6634 <__rename_file_dentry+0xb4>
        phlen = tlen -strlen(tem);
    6634:	48 89 c7             	mov    %rax,%rdi
    6637:	e8 00 00 00 00       	callq  663c <__rename_file_dentry+0xbc>
        tlen = phlen;
        //bug
        if(phlen==0){
    663c:	48 29 c3             	sub    %rax,%rbx
    663f:	0f 84 4c 04 00 00    	je     6a91 <__rename_file_dentry+0x511>
            break;
        }
        memcpy(ph,phstr,tlen);
    6645:	48 89 da             	mov    %rbx,%rdx
    6648:	4c 89 ee             	mov    %r13,%rsi
    664b:	4c 89 e7             	mov    %r12,%rdi
    664e:	e8 00 00 00 00       	callq  6653 <__rename_file_dentry+0xd3>
	int i;

	for (i = 0; i < length; i++) {
    6653:	85 db                	test   %ebx,%ebx
        memcpy(ph+tlen, end, 1);
    6655:	41 c6 04 1c 00       	movb   $0x0,(%r12,%rbx,1)
    665a:	0f 8e 19 04 00 00    	jle    6a79 <__rename_file_dentry+0x4f9>
    6660:	8d 43 ff             	lea    -0x1(%rbx),%eax
    6663:	4c 89 e2             	mov    %r12,%rdx
    6666:	31 f6                	xor    %esi,%esi
    6668:	49 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%rcx
		hash = hash * seed + (*str++);
    666d:	48 89 f0             	mov    %rsi,%rax
    6670:	48 83 c2 01          	add    $0x1,%rdx
    6674:	48 c1 e0 06          	shl    $0x6,%rax
    6678:	48 01 f0             	add    %rsi,%rax
    667b:	48 8d 04 46          	lea    (%rsi,%rax,2),%rax
    667f:	48 0f be 72 ff       	movsbq -0x1(%rdx),%rsi
    6684:	48 01 c6             	add    %rax,%rsi
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    6687:	48 39 ca             	cmp    %rcx,%rdx
    668a:	75 e1                	jne    666d <__rename_file_dentry+0xed>
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    668c:	4c 89 ff             	mov    %r15,%rdi
    668f:	e8 00 00 00 00       	callq  6694 <__rename_file_dentry+0x114>
        if(dzt_ei){
    6694:	48 85 c0             	test   %rax,%rax
    6697:	74 8e                	je     6627 <__rename_file_dentry+0xa7>
    6699:	49 89 c2             	mov    %rax,%r10
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    669c:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
    ph = get_dentry_path(new_dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    66a0:	49 8b 42 10          	mov    0x10(%r10),%rax
    phlen = strlen(phn);
    66a4:	4c 89 e7             	mov    %r12,%rdi
    ph = get_dentry_path(new_dentry,0);
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    66a7:	4c 89 55 98          	mov    %r10,-0x68(%rbp)
    66ab:	48 8b 93 b0 03 00 00 	mov    0x3b0(%rbx),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    66b2:	48 89 c3             	mov    %rax,%rbx
    66b5:	48 03 5a 18          	add    0x18(%rdx),%rbx
    66b9:	48 85 c0             	test   %rax,%rax
    66bc:	b8 00 00 00 00       	mov    $0x0,%eax
    66c1:	48 0f 45 c3          	cmovne %rbx,%rax
    66c5:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    phlen = strlen(phn);
    66c9:	e8 00 00 00 00       	callq  66ce <__rename_file_dentry+0x14e>
    if(phlen==1){
    66ce:	48 83 f8 01          	cmp    $0x1,%rax
    phname = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*strlen(ph), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    phlen = strlen(phn);
    66d2:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    if(phlen==1){
    66d6:	4c 8b 55 98          	mov    -0x68(%rbp),%r10
    66da:	0f 84 8c 04 00 00    	je     6b6c <__rename_file_dentry+0x5ec>
        flen = strlen(ph);
        memcpy(phname, ph, flen);
    } else {
        flen = strlen(ph)-phlen;
    66e0:	4c 89 ef             	mov    %r13,%rdi
    66e3:	4c 89 55 98          	mov    %r10,-0x68(%rbp)
    66e7:	e8 00 00 00 00       	callq  66ec <__rename_file_dentry+0x16c>
    66ec:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
        memcpy(phname, ph+phlen, flen);
    66f0:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
    } else {
        flen = strlen(ph)-phlen;
    66f4:	48 29 d8             	sub    %rbx,%rax
        memcpy(phname, ph+phlen, flen);
    66f7:	49 8d 74 1d 00       	lea    0x0(%r13,%rbx,1),%rsi
    66fc:	48 89 c2             	mov    %rax,%rdx
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
    } else {
        flen = strlen(ph)-phlen;
    66ff:	48 89 45 80          	mov    %rax,-0x80(%rbp)
        memcpy(phname, ph+phlen, flen);
    6703:	e8 00 00 00 00       	callq  6708 <__rename_file_dentry+0x188>
    6708:	4c 8b 55 98          	mov    -0x68(%rbp),%r10
    }
    make_zone_ptr(&z_p, n_ze);
    670c:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
    6710:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
    6714:	4c 89 55 98          	mov    %r10,-0x68(%rbp)
    6718:	e8 00 00 00 00       	callq  671d <__rename_file_dentry+0x19d>
    while(bitpos<z_p->zone_max){
    671d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6721:	4c 8b 55 98          	mov    -0x68(%rbp),%r10
    6725:	48 8b 78 08          	mov    0x8(%rax),%rdi
    6729:	48 85 ff             	test   %rdi,%rdi
    672c:	0f 84 6d 04 00 00    	je     6b9f <__rename_file_dentry+0x61f>
    6732:	48 8b 30             	mov    (%rax),%rsi
    6735:	45 31 ff             	xor    %r15d,%r15d
    6738:	31 c9                	xor    %ecx,%ecx
    673a:	eb 02                	jmp    673e <__rename_file_dentry+0x1be>
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
            bitpos+=2;
    673c:	89 c1                	mov    %eax,%ecx

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    673e:	48 63 c1             	movslq %ecx,%rax
    6741:	48 0f a3 06          	bt     %rax,(%rsi)
    6745:	19 c0                	sbb    %eax,%eax
        flen = strlen(ph)-phlen;
        memcpy(phname, ph+phlen, flen);
    }
    make_zone_ptr(&z_p, n_ze);
    while(bitpos<z_p->zone_max){
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
    6747:	85 c0                	test   %eax,%eax
    6749:	75 10                	jne    675b <__rename_file_dentry+0x1db>
    674b:	8d 59 01             	lea    0x1(%rcx),%ebx
    674e:	48 63 db             	movslq %ebx,%rbx
    6751:	48 0f a3 1e          	bt     %rbx,(%rsi)
    6755:	19 c0                	sbb    %eax,%eax
    6757:	85 c0                	test   %eax,%eax
    6759:	74 15                	je     6770 <__rename_file_dentry+0x1f0>
            bitpos+=2;
    675b:	8d 51 02             	lea    0x2(%rcx),%edx
            cur_pos++;
    675e:	41 83 c7 01          	add    $0x1,%r15d
    } else {
        flen = strlen(ph)-phlen;
        memcpy(phname, ph+phlen, flen);
    }
    make_zone_ptr(&z_p, n_ze);
    while(bitpos<z_p->zone_max){
    6762:	48 39 fa             	cmp    %rdi,%rdx
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
            bitpos+=2;
    6765:	48 89 d0             	mov    %rdx,%rax
    } else {
        flen = strlen(ph)-phlen;
        memcpy(phname, ph+phlen, flen);
    }
    make_zone_ptr(&z_p, n_ze);
    while(bitpos<z_p->zone_max){
    6768:	72 d2                	jb     673c <__rename_file_dentry+0x1bc>
    676a:	8d 59 03             	lea    0x3(%rcx),%ebx
    676d:	48 63 db             	movslq %ebx,%rbx
    //pidir = nova_get_inode(sb, dir);
    //dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    //de_len = DAFS_DIR_LEN(namelen + phlen); 

    /*get dentry on nvm*/
    dafs_de = &n_ze->dentry[cur_pos];
    6770:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    6774:	44 89 f8             	mov    %r15d,%eax
    6777:	4c 89 95 70 ff ff ff 	mov    %r10,-0x90(%rbp)
    677e:	48 89 c2             	mov    %rax,%rdx
    6781:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    6785:	48 05 81 00 00 00    	add    $0x81,%rax
    678b:	48 c1 e2 07          	shl    $0x7,%rdx
    678f:	48 c1 e0 07          	shl    $0x7,%rax
    6793:	4c 8d 1c 17          	lea    (%rdi,%rdx,1),%r11
    6797:	48 01 f8             	add    %rdi,%rax
    //memset(dafs_de, 0, sizeof(dafs_de));
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = new_dentry->d_name.len;
    dafs_de->file_type = o_de->file_type;       //file_type是啥？ not decided
    679a:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    //pidir = nova_get_inode(sb, dir);
    //dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    //de_len = DAFS_DIR_LEN(namelen + phlen); 

    /*get dentry on nvm*/
    dafs_de = &n_ze->dentry[cur_pos];
    679e:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    67a2:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
    //memset(dafs_de, 0, sizeof(dafs_de));
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    67a9:	41 c6 83 80 40 00 00 	movb   $0x6,0x4080(%r11)
    67b0:	06 
    dafs_de->name_len = new_dentry->d_name.len;
    67b1:	41 8b 46 24          	mov    0x24(%r14),%eax
    dafs_de->file_type = o_de->file_type;       //file_type是啥？ not decided

	dafs_de->links_count = o_de->links_count;
    67b5:	4c 89 9d 78 ff ff ff 	mov    %r11,-0x88(%rbp)
    /*get dentry on nvm*/
    dafs_de = &n_ze->dentry[cur_pos];
    //memset(dafs_de, 0, sizeof(dafs_de));
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = new_dentry->d_name.len;
    67bc:	41 88 83 81 40 00 00 	mov    %al,0x4081(%r11)
    dafs_de->file_type = o_de->file_type;       //file_type是啥？ not decided
    67c3:	0f b6 47 02          	movzbl 0x2(%rdi),%eax
    67c7:	41 88 83 82 40 00 00 	mov    %al,0x4082(%r11)

	dafs_de->links_count = o_de->links_count;
    67ce:	0f b7 47 06          	movzwl 0x6(%rdi),%eax
    67d2:	66 41 89 83 86 40 00 	mov    %ax,0x4086(%r11)
    67d9:	00 

    //dafs_de->de_len = cpu_to_le16(de_len);  
    dafs_de->mtime = cpu_to_le32(CURRENT_TIME_SEC.tv_sec);
    67da:	e8 00 00 00 00       	callq  67df <__rename_file_dentry+0x25f>
    67df:	4c 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11
    /*not root at first*/
    //dafs_de->isr_sf = o_de->isr_sf;
    dafs_de->ino = o_de->ino;
    67e6:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    
    dafs_de->size = o_de->size;
     
    /*judge name len && set dentry name*/
    if(new_dentry->d_name.len <= SMALL_NAME_LEN){
    67ea:	4c 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10
    dafs_de->file_type = o_de->file_type;       //file_type是啥？ not decided

	dafs_de->links_count = o_de->links_count;

    //dafs_de->de_len = cpu_to_le16(de_len);  
    dafs_de->mtime = cpu_to_le32(CURRENT_TIME_SEC.tv_sec);
    67f1:	41 89 83 88 40 00 00 	mov    %eax,0x4088(%r11)
    /*not root at first*/
    //dafs_de->isr_sf = o_de->isr_sf;
    dafs_de->ino = o_de->ino;
    67f8:	48 8b 47 18          	mov    0x18(%rdi),%rax
    67fc:	49 89 83 98 40 00 00 	mov    %rax,0x4098(%r11)
    
    dafs_de->size = o_de->size;
    6803:	48 8b 47 20          	mov    0x20(%rdi),%rax
    6807:	49 89 83 a0 40 00 00 	mov    %rax,0x40a0(%r11)
     
    /*judge name len && set dentry name*/
    if(new_dentry->d_name.len <= SMALL_NAME_LEN){
    680e:	41 83 7e 24 27       	cmpl   $0x27,0x24(%r14)
    6813:	0f 87 a1 02 00 00    	ja     6aba <__rename_file_dentry+0x53a>
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,new_dentry->d_name.name,new_dentry->d_name.len);
    6819:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
    6820:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    
    dafs_de->size = o_de->size;
     
    /*judge name len && set dentry name*/
    if(new_dentry->d_name.len <= SMALL_NAME_LEN){
        dafs_de->ext_flag = 0;
    6824:	31 c9                	xor    %ecx,%ecx
    6826:	66 41 89 8b 84 40 00 	mov    %cx,0x4084(%r11)
    682d:	00 
        memcpy(dafs_de->name,new_dentry->d_name.name,new_dentry->d_name.len);
    682e:	49 8b 76 28          	mov    0x28(%r14),%rsi
    6832:	4c 89 95 78 ff ff ff 	mov    %r10,-0x88(%rbp)
    
    dafs_de->size = o_de->size;
     
    /*judge name len && set dentry name*/
    if(new_dentry->d_name.len <= SMALL_NAME_LEN){
        dafs_de->ext_flag = 0;
    6839:	4c 89 5d a8          	mov    %r11,-0x58(%rbp)
        memcpy(dafs_de->name,new_dentry->d_name.name,new_dentry->d_name.len);
    683d:	48 8d bc 17 b0 40 00 	lea    0x40b0(%rdi,%rdx,1),%rdi
    6844:	00 
    6845:	41 8b 56 24          	mov    0x24(%r14),%edx
    6849:	e8 00 00 00 00       	callq  684e <__rename_file_dentry+0x2ce>
        dafs_de->name[new_dentry->d_name.len] = '\0'; 
    684e:	41 8b 46 24          	mov    0x24(%r14),%eax
    6852:	4c 8b 5d a8          	mov    -0x58(%rbp),%r11
    6856:	4c 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10
    685d:	41 c6 84 03 b0 40 00 	movb   $0x0,0x40b0(%r11,%rax,1)
    6864:	00 00 

    } else {
        dafs_de->ext_flag = 1;
        ext_de_name(sb, n_ei, n_ze, z_p, cur_pos, new_dentry->d_name.len, new_dentry->d_name.name, 0);
    }
    dafs_de->fname_len = cpu_to_le64(flen);
    6866:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    686a:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
    686e:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
    6872:	48 c1 e0 07          	shl    $0x7,%rax
    6876:	48 01 c8             	add    %rcx,%rax
    6879:	48 89 b8 90 40 00 00 	mov    %rdi,0x4090(%rax)
    /*fulname is null for NORMAL_FILE*/
    dafs_de->ful_name.f_name[0]= '\0';
    6880:	c6 80 d8 40 00 00 00 	movb   $0x0,0x40d8(%rax)

    /*set isr_sf and par_pos*/
    temlen = flen-new_dentry->d_name.len;
    6887:	41 8b 46 24          	mov    0x24(%r14),%eax
    688b:	49 89 fe             	mov    %rdi,%r14
    688e:	49 29 c6             	sub    %rax,%r14
    if(temlen == 1){
    6891:	49 83 fe 01          	cmp    $0x1,%r14
    6895:	0f 84 87 02 00 00    	je     6b22 <__rename_file_dentry+0x5a2>
            new_sf->pos = cpu_to_le32(cur_pos);
            list_add_tail(&new_sf->list, &par_dir->sub_file);
            par_dir->sub_num++;
        }
    } else {
        dafs_de->isr_sf = 0;
    689b:	41 c6 83 83 40 00 00 	movb   $0x0,0x4083(%r11)
    68a2:	00 
        tem = kzalloc(sizeof(char)*temlen, GFP_KERNEL);
    68a3:	4c 89 f7             	mov    %r14,%rdi
    68a6:	4c 89 95 78 ff ff ff 	mov    %r10,-0x88(%rbp)
            new_sf->pos = cpu_to_le32(cur_pos);
            list_add_tail(&new_sf->list, &par_dir->sub_file);
            par_dir->sub_num++;
        }
    } else {
        dafs_de->isr_sf = 0;
    68ad:	4c 89 5d 80          	mov    %r11,-0x80(%rbp)
        tem = kzalloc(sizeof(char)*temlen, GFP_KERNEL);
    68b1:	e8 3a 98 ff ff       	callq  f0 <kzalloc.constprop.9>
        temlen--;
    68b6:	4d 8d 46 ff          	lea    -0x1(%r14),%r8
        memcpy(tem, phname, temlen);
    68ba:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
    68be:	48 89 c7             	mov    %rax,%rdi
    68c1:	4c 89 c2             	mov    %r8,%rdx
    68c4:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
    68c8:	e8 00 00 00 00       	callq  68cd <__rename_file_dentry+0x34d>
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    68cd:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
    68d1:	48 89 c1             	mov    %rax,%rcx
        memcpy(tem+temlen, end, 1);
    68d4:	42 c6 44 30 ff 00    	movb   $0x0,-0x1(%rax,%r14,1)
    68da:	4c 8b 5d 80          	mov    -0x80(%rbp),%r11
    68de:	4c 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10
    68e5:	45 85 c0             	test   %r8d,%r8d
    68e8:	0f 8e a2 02 00 00    	jle    6b90 <__rename_file_dentry+0x610>
    68ee:	41 8d 40 ff          	lea    -0x1(%r8),%eax
    68f2:	45 31 f6             	xor    %r14d,%r14d
    68f5:	48 8d 54 01 01       	lea    0x1(%rcx,%rax,1),%rdx
		hash = hash * seed + (*str++);
    68fa:	4c 89 f0             	mov    %r14,%rax
    68fd:	48 83 c1 01          	add    $0x1,%rcx
    6901:	48 c1 e0 06          	shl    $0x6,%rax
    6905:	4c 01 f0             	add    %r14,%rax
    6908:	49 8d 04 46          	lea    (%r14,%rax,2),%rax
    690c:	4c 0f be 71 ff       	movsbq -0x1(%rcx),%r14
    6911:	49 01 c6             	add    %rax,%r14
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    6914:	48 39 d1             	cmp    %rdx,%rcx
    6917:	75 e1                	jne    68fa <__rename_file_dentry+0x37a>
        par_hn = BKDRHash(tem, temlen);
        lookup_in_hashtable(sb, n_ei->ht_head, par_hn, 1, &par_pos);
    6919:	49 8b 72 18          	mov    0x18(%r10),%rsi
    691d:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    6921:	4c 8d 45 c4          	lea    -0x3c(%rbp),%r8
    6925:	b9 01 00 00 00       	mov    $0x1,%ecx
    692a:	4c 89 f2             	mov    %r14,%rdx
    692d:	4c 89 5d 80          	mov    %r11,-0x80(%rbp)
    6931:	4c 89 55 a8          	mov    %r10,-0x58(%rbp)
    6935:	e8 00 00 00 00       	callq  693a <__rename_file_dentry+0x3ba>
        dafs_de->par_pos = cpu_to_le32(par_pos);
    693a:	8b 45 c4             	mov    -0x3c(%rbp),%eax
    693d:	4c 8b 5d 80          	mov    -0x80(%rbp),%r11
    6941:	41 89 83 8c 40 00 00 	mov    %eax,0x408c(%r11)
        //nova_dbg("%s new dentry par name %s, pos%d",__func__, tem, par_pos);
        /*set subpos*/
        par_dir = radix_tree_lookup(&n_ei->dir_tree, par_hn);
    6948:	4c 8b 55 a8          	mov    -0x58(%rbp),%r10
    694c:	4c 89 f6             	mov    %r14,%rsi
    694f:	49 8d 7a 38          	lea    0x38(%r10),%rdi
    6953:	e8 00 00 00 00       	callq  6958 <__rename_file_dentry+0x3d8>
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    6958:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 695f <__rename_file_dentry+0x3df>
    695f:	49 89 c6             	mov    %rax,%r14
    6962:	ba 14 00 00 00       	mov    $0x14,%edx
    6967:	be d0 80 00 00       	mov    $0x80d0,%esi
    696c:	e8 00 00 00 00       	callq  6971 <__rename_file_dentry+0x3f1>
        new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        new_sf->pos = cpu_to_le32(cur_pos);
    6971:	44 89 78 10          	mov    %r15d,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    6975:	49 8b 56 20          	mov    0x20(%r14),%rdx
        list_add_tail(&new_sf->list, &par_dir->sub_file);
    6979:	49 8d 4e 18          	lea    0x18(%r14),%rcx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    697d:	49 89 46 20          	mov    %rax,0x20(%r14)
    6981:	48 89 08             	mov    %rcx,(%rax)
	new->next = next;
	new->prev = prev;
    6984:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    6988:	48 89 02             	mov    %rax,(%rdx)
        par_dir->sub_num++;
    698b:	49 83 46 08 01       	addq   $0x1,0x8(%r14)
    6990:	4c 8b 55 a8          	mov    -0x58(%rbp),%r10
    }
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)z_p->statemap);
    6994:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6998:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    699b:	f0 48 0f ab 18       	lock bts %rbx,(%rax)
    69a0:	72 00                	jb     69a2 <__rename_file_dentry+0x422>
    69a2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    69a6:	85 c0                	test   %eax,%eax
    69a8:	0f 8e ea 01 00 00    	jle    6b98 <__rename_file_dentry+0x618>
    69ae:	83 e8 01             	sub    $0x1,%eax
    69b1:	31 d2                	xor    %edx,%edx
    69b3:	49 8d 74 04 01       	lea    0x1(%r12,%rax,1),%rsi
    69b8:	4c 89 e0             	mov    %r12,%rax
		hash = hash * seed + (*str++);
    69bb:	48 89 d1             	mov    %rdx,%rcx
    69be:	48 83 c0 01          	add    $0x1,%rax
    69c2:	48 c1 e1 06          	shl    $0x6,%rcx
    69c6:	48 01 d1             	add    %rdx,%rcx
    69c9:	48 8d 14 4a          	lea    (%rdx,%rcx,2),%rdx
    69cd:	48 0f be 48 ff       	movsbq -0x1(%rax),%rcx
    69d2:	48 01 ca             	add    %rcx,%rdx
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    69d5:	48 39 f0             	cmp    %rsi,%rax
    69d8:	75 e1                	jne    69bb <__rename_file_dentry+0x43b>
   
    /*set pos in hash table for each zone*/
    hashname = BKDRHash(phn, phlen);
    dafs_de->hname = cpu_to_le64(hashname);
    69da:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    69de:	48 8b 5d b8          	mov    -0x48(%rbp),%rbx
    record_pos_htable(sb, n_ei->ht_head, hashname, cur_pos, 1);
    69e2:	44 89 f9             	mov    %r15d,%ecx
    69e5:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    69e9:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)z_p->statemap);
   
    /*set pos in hash table for each zone*/
    hashname = BKDRHash(phn, phlen);
    dafs_de->hname = cpu_to_le64(hashname);
    69ef:	48 c1 e0 07          	shl    $0x7,%rax
    69f3:	48 89 94 03 a8 40 00 	mov    %rdx,0x40a8(%rbx,%rax,1)
    69fa:	00 
    record_pos_htable(sb, n_ei->ht_head, hashname, cur_pos, 1);
    69fb:	49 8b 72 18          	mov    0x18(%r10),%rsi
    69ff:	e8 00 00 00 00       	callq  6a04 <__rename_file_dentry+0x484>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    6a04:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
	if (support_clwb) {
    6a08:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 6a0e <__rename_file_dentry+0x48e>
    6a0e:	31 d2                	xor    %edx,%edx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    6a10:	89 f1                	mov    %esi,%ecx
    6a12:	83 e1 3f             	and    $0x3f,%ecx
    6a15:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    6a18:	85 c0                	test   %eax,%eax
    6a1a:	0f 85 ed 00 00 00    	jne    6b0d <__rename_file_dentry+0x58d>
    6a20:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    6a24:	89 d0                	mov    %edx,%eax
    6a26:	48 01 f0             	add    %rsi,%rax
    6a29:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    6a2c:	83 c2 40             	add    $0x40,%edx
    6a2f:	39 d1                	cmp    %edx,%ecx
    6a31:	77 f1                	ja     6a24 <__rename_file_dentry+0x4a4>

    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    //dafs_remove_dentry(old_dentry);
    
    kfree(phname);
    6a33:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    6a37:	e8 00 00 00 00       	callq  6a3c <__rename_file_dentry+0x4bc>
    kfree(ph);
    6a3c:	4c 89 ef             	mov    %r13,%rdi
    6a3f:	e8 00 00 00 00       	callq  6a44 <__rename_file_dentry+0x4c4>
    kfree(phn);
    6a44:	4c 89 e7             	mov    %r12,%rdi
    6a47:	e8 00 00 00 00       	callq  6a4c <__rename_file_dentry+0x4cc>
    kfree(z_p);
    6a4c:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    6a50:	e8 00 00 00 00       	callq  6a55 <__rename_file_dentry+0x4d5>
    //NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    //nova_dbg("%s end",__func__);

    return ret;
    
}
    6a55:	31 c0                	xor    %eax,%eax
    6a57:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    6a5b:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    6a62:	00 00 
    6a64:	0f 85 42 01 00 00    	jne    6bac <__rename_file_dentry+0x62c>
    6a6a:	48 83 ec 80          	sub    $0xffffffffffffff80,%rsp
    6a6e:	5b                   	pop    %rbx
    6a6f:	41 5c                	pop    %r12
    6a71:	41 5d                	pop    %r13
    6a73:	41 5e                	pop    %r14
    6a75:	41 5f                	pop    %r15
    6a77:	5d                   	pop    %rbp
    6a78:	c3                   	retq   

// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    6a79:	31 f6                	xor    %esi,%esi
        }
        memcpy(ph,phstr,tlen);
        memcpy(ph+tlen, end, 1);
        hashname = BKDRHash(ph,tlen);
        //nova_dbg("%s:par path is %s",__func__, ph);
        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    6a7b:	4c 89 ff             	mov    %r15,%rdi
    6a7e:	e8 00 00 00 00       	callq  6a83 <__rename_file_dentry+0x503>
        if(dzt_ei){
    6a83:	48 85 c0             	test   %rax,%rax
    6a86:	0f 84 9b fb ff ff    	je     6627 <__rename_file_dentry+0xa7>
    6a8c:	e9 08 fc ff ff       	jmpq   6699 <__rename_file_dentry+0x119>
            goto END;
        }
    }while(1);

    /*root dir*/
    memcpy(ph, "/", 1);
    6a91:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    memcpy(ph+1,end,1);
    6a96:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    6a9c:	be 2f 00 00 00       	mov    $0x2f,%esi
    6aa1:	4c 89 ff             	mov    %r15,%rdi
    6aa4:	e8 00 00 00 00       	callq  6aa9 <__rename_file_dentry+0x529>
    if(!dzt_ei){
    6aa9:	48 85 c0             	test   %rax,%rax

    /*root dir*/
    memcpy(ph, "/", 1);
    memcpy(ph+1,end,1);
    hashname = BKDRHash(ph ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    6aac:	49 89 c2             	mov    %rax,%r10
    if(!dzt_ei){
    6aaf:	0f 85 e7 fb ff ff    	jne    669c <__rename_file_dentry+0x11c>
    6ab5:	e8 00 00 00 00       	callq  6aba <__rename_file_dentry+0x53a>
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,new_dentry->d_name.name,new_dentry->d_name.len);
        dafs_de->name[new_dentry->d_name.len] = '\0'; 

    } else {
        dafs_de->ext_flag = 1;
    6aba:	ba 01 00 00 00       	mov    $0x1,%edx
        ext_de_name(sb, n_ei, n_ze, z_p, cur_pos, new_dentry->d_name.len, new_dentry->d_name.name, 0);
    6abf:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    6ac3:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,new_dentry->d_name.name,new_dentry->d_name.len);
        dafs_de->name[new_dentry->d_name.len] = '\0'; 

    } else {
        dafs_de->ext_flag = 1;
    6ac7:	66 41 89 93 84 40 00 	mov    %dx,0x4084(%r11)
    6ace:	00 
        ext_de_name(sb, n_ei, n_ze, z_p, cur_pos, new_dentry->d_name.len, new_dentry->d_name.name, 0);
    6acf:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
    6ad6:	00 
    6ad7:	4c 89 d6             	mov    %r10,%rsi
    6ada:	49 8b 46 28          	mov    0x28(%r14),%rax
    6ade:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    6ae2:	45 89 f8             	mov    %r15d,%r8d
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,new_dentry->d_name.name,new_dentry->d_name.len);
        dafs_de->name[new_dentry->d_name.len] = '\0'; 

    } else {
        dafs_de->ext_flag = 1;
    6ae5:	4c 89 9d 78 ff ff ff 	mov    %r11,-0x88(%rbp)
        ext_de_name(sb, n_ei, n_ze, z_p, cur_pos, new_dentry->d_name.len, new_dentry->d_name.name, 0);
    6aec:	4c 89 55 a8          	mov    %r10,-0x58(%rbp)
    6af0:	48 89 04 24          	mov    %rax,(%rsp)
    6af4:	45 8b 4e 24          	mov    0x24(%r14),%r9d
    6af8:	e8 00 00 00 00       	callq  6afd <__rename_file_dentry+0x57d>
    6afd:	4c 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11
    6b04:	4c 8b 55 a8          	mov    -0x58(%rbp),%r10
    6b08:	e9 59 fd ff ff       	jmpq   6866 <__rename_file_dentry+0x2e6>
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    6b0d:	89 d0                	mov    %edx,%eax
    6b0f:	48 01 f0             	add    %rsi,%rax
    6b12:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    6b16:	83 c2 40             	add    $0x40,%edx
    6b19:	39 d1                	cmp    %edx,%ecx
    6b1b:	77 f0                	ja     6b0d <__rename_file_dentry+0x58d>
    6b1d:	e9 11 ff ff ff       	jmpq   6a33 <__rename_file_dentry+0x4b3>
    dafs_de->ful_name.f_name[0]= '\0';

    /*set isr_sf and par_pos*/
    temlen = flen-new_dentry->d_name.len;
    if(temlen == 1){
        dafs_de->isr_sf = 1;
    6b22:	41 c6 83 83 40 00 00 	movb   $0x1,0x4083(%r11)
    6b29:	01 
        dafs_de->par_pos = 0;
    6b2a:	41 c7 83 8c 40 00 00 	movl   $0x0,0x408c(%r11)
    6b31:	00 00 00 00 
        par_de = &n_ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
    6b35:	48 83 b9 98 40 00 00 	cmpq   $0x1,0x4098(%rcx)
    6b3c:	01 
    6b3d:	0f 85 51 fe ff ff    	jne    6994 <__rename_file_dentry+0x414>
            //nova_dbg("new par is root");
            par_hn = le64_to_cpu(par_de->hname);
    6b43:	4c 8b b1 a8 40 00 00 	mov    0x40a8(%rcx),%r14
            lookup_in_hashtable(sb, n_ei->ht_head, par_hn, 1, &par_pos);
    6b4a:	49 8b 72 18          	mov    0x18(%r10),%rsi
    6b4e:	4c 8d 45 c4          	lea    -0x3c(%rbp),%r8
    6b52:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    6b56:	b9 01 00 00 00       	mov    $0x1,%ecx
    6b5b:	4c 89 55 a8          	mov    %r10,-0x58(%rbp)
    6b5f:	4c 89 f2             	mov    %r14,%rdx
    6b62:	e8 00 00 00 00       	callq  6b67 <__rename_file_dentry+0x5e7>
    6b67:	e9 dc fd ff ff       	jmpq   6948 <__rename_file_dentry+0x3c8>
    //memcpy(phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
    6b6c:	4c 89 ef             	mov    %r13,%rdi
    6b6f:	e8 00 00 00 00       	callq  6b74 <__rename_file_dentry+0x5f4>
        memcpy(phname, ph, flen);
    6b74:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    6b78:	48 89 c2             	mov    %rax,%rdx
    6b7b:	4c 89 ee             	mov    %r13,%rsi
    //memcpy(phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
    6b7e:	48 89 45 80          	mov    %rax,-0x80(%rbp)
        memcpy(phname, ph, flen);
    6b82:	e8 00 00 00 00       	callq  6b87 <__rename_file_dentry+0x607>
    6b87:	4c 8b 55 98          	mov    -0x68(%rbp),%r10
    6b8b:	e9 7c fb ff ff       	jmpq   670c <__rename_file_dentry+0x18c>
    6b90:	45 31 f6             	xor    %r14d,%r14d
    6b93:	e9 81 fd ff ff       	jmpq   6919 <__rename_file_dentry+0x399>
    6b98:	31 d2                	xor    %edx,%edx
    6b9a:	e9 3b fe ff ff       	jmpq   69da <__rename_file_dentry+0x45a>
    } else {
        flen = strlen(ph)-phlen;
        memcpy(phname, ph+phlen, flen);
    }
    make_zone_ptr(&z_p, n_ze);
    while(bitpos<z_p->zone_max){
    6b9f:	bb 01 00 00 00       	mov    $0x1,%ebx
    struct dzt_entry_info *n_ei;
    struct zone_ptr *z_p;
    struct dir_info *par_dir;
    struct file_p *new_sf;
    char *phname, *ph, *phn, *tem;
    u32 bitpos=0, cur_pos=0, par_pos;
    6ba4:	45 31 ff             	xor    %r15d,%r15d
    6ba7:	e9 c4 fb ff ff       	jmpq   6770 <__rename_file_dentry+0x1f0>
    //NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    //nova_dbg("%s end",__func__);

    return ret;
    
}
    6bac:	e8 00 00 00 00       	callq  6bb1 <__rename_file_dentry+0x631>

Disassembly of section .text.unlikely:

0000000000000000 <find_dzt.part.3>:
/* find currect zone
 * ph record file ful name
 * 反向查找
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, const char *phstr, char *ph)
{
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	0f 0b                	ud2    
