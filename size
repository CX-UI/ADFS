bbuild.c:4: * Copyright 2015-2016 Regents of the University of California,
bbuild.c:5: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
bbuild.c:6: * Copyright 2012-2013 Intel Corporation
bbuild.c:7: * Copyright 2009-2011 Marco Stornelli <marco.stornelli@gmail.com>
bbuild.c:10: * 2003-2004 (c) MontaVista Software, Inc. , Steve Longerbeam
bbuild.c:23: * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
bbuild.c:36:	set_bit(bit, scan_bm->bitmap);
bbuild.c:44:			set_scan_bm(bit, &bm->scan_bm_4K);
bbuild.c:47:			set_scan_bm(bit, &bm->scan_bm_2M);
bbuild.c:50:			set_scan_bm(bit, &bm->scan_bm_1G);
bbuild.c:61:	cpuid = blocknr / sbi->per_list_blocks;
bbuild.c:63:	if (cpuid >= sbi->cpus)
bbuild.c:87:	cpu = ino_low % sbi->cpus;
bbuild.c:88:	if (ino_high % sbi->cpus != cpu) {
bbuild.c:94:	internal_low = ino_low / sbi->cpus;
bbuild.c:95:	internal_high = ino_high / sbi->cpus;
bbuild.c:96:	inode_map = &sbi->inode_maps[cpu];
bbuild.c:97:	tree = &inode_map->inode_inuse_tree;
bbuild.c:98:	mutex_lock(&inode_map->inode_table_mutex);
bbuild.c:103:		nova_dbg("%s: ino %lu - %lu already exists!: %d\n",
bbuild.c:105:		mutex_unlock(&inode_map->inode_table_mutex);
bbuild.c:109:	if (prev && next && (internal_low == prev->range_high + 1) &&
bbuild.c:110:			(internal_high + 1 == next->range_low)) {
bbuild.c:112:		rb_erase(&next->node, tree);
bbuild.c:113:		inode_map->num_range_node_inode--;
bbuild.c:114:		prev->range_high = next->range_high;
bbuild.c:118:	if (prev && (internal_low == prev->range_high + 1)) {
bbuild.c:120:		prev->range_high += internal_high - internal_low + 1;
bbuild.c:123:	if (next && (internal_high + 1 == next->range_low)) {
bbuild.c:125:		next->range_low -= internal_high - internal_low + 1;
bbuild.c:132:	new_node->range_low = internal_low;
bbuild.c:133:	new_node->range_high = internal_high;
bbuild.c:140:	inode_map->num_range_node_inode++;
bbuild.c:143:	mutex_unlock(&inode_map->inode_table_mutex);
bbuild.c:157:		rb_erase(&curr->node, tree);
bbuild.c:167:	nova_destroy_range_node_tree(sb, &free_list->block_free_tree);
bbuild.c:175:	for (i = 0; i < sbi->cpus; i++) {
bbuild.c:194:	curr_p = pi->log_head;
bbuild.c:197:		return -EINVAL;
bbuild.c:200:	while (curr_p != pi->log_tail) {
bbuild.c:208:			ret = -EINVAL;
bbuild.c:217:		blknode->range_low = le64_to_cpu(entry->range_low);
bbuild.c:218:		blknode->range_high = le64_to_cpu(entry->range_high);
bbuild.c:219:		cpuid = get_cpuid(sbi, blknode->range_low);
bbuild.c:224:				&free_list->block_free_tree, blknode);
bbuild.c:232:		free_list->num_blocknode++;
bbuild.c:233:		if (free_list->num_blocknode == 1)
bbuild.c:234:			free_list->first_node = blknode;
bbuild.c:235:		free_list->num_free_blocks +=
bbuild.c:236:			blknode->range_high - blknode->range_low + 1;
bbuild.c:250:	for (i = 0; i < sbi->cpus; i++) {
bbuild.c:251:		inode_map = &sbi->inode_maps[i];
bbuild.c:253:					&inode_map->inode_inuse_tree);
bbuild.c:272:	sbi->s_inodes_used_count = 0;
bbuild.c:273:	curr_p = pi->log_head;
bbuild.c:276:		return -EINVAL;
bbuild.c:279:	while (curr_p != pi->log_tail) {
bbuild.c:295:		cpuid = (entry->range_low & CPUID_MASK) >> 56;
bbuild.c:296:		if (cpuid >= sbi->cpus) {
bbuild.c:304:		range_node->range_low = entry->range_low & ~CPUID_MASK;
bbuild.c:305:		range_node->range_high = entry->range_high;
bbuild.c:315:		sbi->s_inodes_used_count +=
bbuild.c:316:			range_node->range_high - range_node->range_low + 1;
bbuild.c:319:		inode_map = &sbi->inode_maps[cpuid];
bbuild.c:320:		inode_map->num_range_node_inode++;
bbuild.c:321:		if (!inode_map->first_inode_range)
bbuild.c:322:			inode_map->first_inode_range = range_node;
bbuild.c:338:	if (pi->log_head == 0 || pi->log_tail == 0)
bbuild.c:378:	entry->range_low = cpu_to_le64(curr->range_low);
bbuild.c:380:		entry->range_low |= cpu_to_le64(cpuid << 56);
bbuild.c:381:	entry->range_high = cpu_to_le64(curr->range_high);
bbuild.c:383:			curr->range_low, curr->range_high);
bbuild.c:406:		rb_erase(&curr->node, tree);
bbuild.c:419:	temp_tail = nova_save_range_nodes_to_log(sb, &free_list->block_free_tree,
bbuild.c:436:	for (i = 0; i < sbi->cpus; i++) {
bbuild.c:437:		inode_map = &sbi->inode_maps[i];
bbuild.c:438:		num_nodes += inode_map->num_range_node_inode;
bbuild.c:452:	pi->log_head = new_block;
bbuild.c:453:	nova_flush_buffer(&pi->log_head, CACHELINE_SIZE, 0);
bbuild.c:456:	for (i = 0; i < sbi->cpus; i++) {
bbuild.c:457:		inode_map = &sbi->inode_maps[i];
bbuild.c:459:				&inode_map->inode_inuse_tree, temp_tail, i);
bbuild.c:465:		__func__, num_nodes, pi->log_head, pi->log_tail);
bbuild.c:482:	for (i = 0; i < sbi->cpus; i++) {
bbuild.c:484:		num_blocknode += free_list->num_blocknode;
bbuild.c:486:				i, free_list->num_blocknode);
bbuild.c:490:	num_blocknode += free_list->num_blocknode;
bbuild.c:492:				free_list->num_blocknode);
bbuild.c:513:	nova_memunlock_range(sb, &super->s_wtime, NOVA_FAST_MOUNT_FIELD_SIZE);
bbuild.c:515:	super->s_wtime = cpu_to_le32(get_seconds());
bbuild.c:517:	nova_memlock_range(sb, &super->s_wtime, NOVA_FAST_MOUNT_FIELD_SIZE);
bbuild.c:521:	pi->log_head = new_block;
bbuild.c:522:	nova_flush_buffer(&pi->log_head, CACHELINE_SIZE, 0);
bbuild.c:525:	for (i = 0; i < sbi->cpus; i++) {
bbuild.c:534:		pi->log_head, pi->log_tail);
bbuild.c:547:	num_blocks = high - low + 1;
bbuild.c:551:	tree = &(free_list->block_free_tree);
bbuild.c:555:		return -ENOMEM;
bbuild.c:556:	blknode->range_low = low;
bbuild.c:557:	blknode->range_high = high;
bbuild.c:564:	if (!free_list->first_node)
bbuild.c:565:		free_list->first_node = blknode;
bbuild.c:566:	free_list->num_blocknode++;
bbuild.c:567:	free_list->num_free_blocks += num_blocks;
bbuild.c:583:	start = free_list->block_start;
bbuild.c:584:	end = free_list->block_end + 1;
bbuild.c:590:			if (cpuid == sbi->cpus - 1)
bbuild.c:595:			start = free_list->block_start;
bbuild.c:596:			end = free_list->block_end + 1;
bbuild.c:603:				low << scale , (next << scale) - 1)) {
bbuild.c:604:			nova_dbg("Error: could not insert %lu - %lu\n",
bbuild.c:605:				low << scale, ((next << scale) - 1));
bbuild.c:611:			if (cpuid == sbi->cpus - 1)
bbuild.c:616:			start = free_list->block_start;
bbuild.c:617:			end = free_list->block_end + 1;
bbuild.c:660:		return -ENOMEM;
bbuild.c:662:	final_bm->scan_bm_4K.bitmap_size =
bbuild.c:666:	final_bm->scan_bm_4K.bitmap = kzalloc(final_bm->scan_bm_4K.bitmap_size,
bbuild.c:669:	if (!final_bm->scan_bm_4K.bitmap) {
bbuild.c:671:		return -ENOMEM;
bbuild.c:678:	for (i = 0; i < sbi->cpus; i++) {
bbuild.c:680:		nova_update_4K_map(sb, bm, bm->scan_bm_2M.bitmap,
bbuild.c:681:			bm->scan_bm_2M.bitmap_size * 8, PAGE_SHIFT_2M - 12);
bbuild.c:682:		nova_update_4K_map(sb, bm, bm->scan_bm_1G.bitmap,
bbuild.c:683:			bm->scan_bm_1G.bitmap_size * 8, PAGE_SHIFT_1G - 12);
bbuild.c:686:	/* Merge per-CPU bms to the final single bm */
bbuild.c:687:	num = final_bm->scan_bm_4K.bitmap_size / sizeof(unsigned long);
bbuild.c:688:	if (final_bm->scan_bm_4K.bitmap_size % sizeof(unsigned long))
bbuild.c:691:	for (i = 0; i < sbi->cpus; i++) {
bbuild.c:693:		src = (unsigned long *)bm->scan_bm_4K.bitmap;
bbuild.c:694:		dst = (unsigned long *)final_bm->scan_bm_4K.bitmap;
bbuild.c:701:	num_used_block = sbi->reserved_blocks;
bbuild.c:705:	ret = __nova_build_blocknode_map(sb, final_bm->scan_bm_4K.bitmap,
bbuild.c:706:			final_bm->scan_bm_4K.bitmap_size * 8, PAGE_SHIFT - 12);
bbuild.c:708:	kfree(final_bm->scan_bm_4K.bitmap);
bbuild.c:720:	for (i = 0; i < sbi->cpus; i++) {
bbuild.c:723:			kfree(bm->scan_bm_4K.bitmap);
bbuild.c:724:			kfree(bm->scan_bm_2M.bitmap);
bbuild.c:725:			kfree(bm->scan_bm_1G.bitmap);
bbuild.c:738:	for (i = 0; i < sbi->cpus; i++) {
bbuild.c:741:			return -ENOMEM;
bbuild.c:745:		bm->scan_bm_4K.bitmap_size =
bbuild.c:747:		bm->scan_bm_2M.bitmap_size =
bbuild.c:749:		bm->scan_bm_1G.bitmap_size =
bbuild.c:753:		bm->scan_bm_4K.bitmap = kzalloc(bm->scan_bm_4K.bitmap_size,
bbuild.c:755:		bm->scan_bm_2M.bitmap = kzalloc(bm->scan_bm_2M.bitmap_size,
bbuild.c:757:		bm->scan_bm_1G.bitmap = kzalloc(bm->scan_bm_1G.bitmap_size,
bbuild.c:760:		if (!bm->scan_bm_4K.bitmap || !bm->scan_bm_2M.bitmap ||
bbuild.c:761:				!bm->scan_bm_1G.bitmap)
bbuild.c:762:			return -ENOMEM;
bbuild.c:787:	sih->log_pages = 0;
bbuild.c:788:	sih->mmap_pages = 0;
bbuild.c:789:	sih->low_dirty = ULONG_MAX;
bbuild.c:790:	sih->high_dirty = 0;
bbuild.c:791:	sih->i_size = 0;
bbuild.c:792:	sih->pi_addr = 0;
bbuild.c:793:	INIT_RADIX_TREE(&sih->tree, GFP_ATOMIC);
bbuild.c:794:	INIT_RADIX_TREE(&sih->cache_tree, GFP_ATOMIC);
bbuild.c:795:	sih->i_mode = i_mode;
bbuild.c:801:	struct nova_inode_info_header *sih = &si->header;
bbuild.c:809:	if (pi->valid == 0)
bbuild.c:810:		return -EINVAL;
bbuild.c:812:	nova_ino = pi->nova_ino;
bbuild.c:816:			__func__, nova_ino, pi_addr, pi->valid,
bbuild.c:817:			pi->log_head, pi->log_tail);
bbuild.c:819:	nova_init_header(sb, sih, __le16_to_cpu(pi->i_mode));
bbuild.c:820:	sih->ino = nova_ino;
bbuild.c:822:	switch (__le16_to_cpu(pi->i_mode) & S_IFMT) {
bbuild.c:834:		if (pi->log_head)
bbuild.c:836:		sih->pi_addr = pi_addr;
bbuild.c:850:	curr_p = pi->log_head;
bbuild.c:852:		nova_err(sb, "Dir %llu log is NULL!\n", pi->nova_ino);
bbuild.c:857:				curr_p, pi->log_tail);
bbuild.c:858:	BUG_ON(curr_p & (PAGE_SIZE - 1));
bbuild.c:862:	while ((next = curr_page->page_tail.next_page) != 0) {
bbuild.c:864:		BUG_ON(curr_p & (PAGE_SIZE - 1));
bbuild.c:880:	start = entry->pgoff;
bbuild.c:884:	end = entry->pgoff + entry->num_pages;
bbuild.c:889:		ring->array[pgoff - base] = (u64)(entry->block >> PAGE_SHIFT)
bbuild.c:890:						+ pgoff - entry->pgoff;
bbuild.c:902:		last_blocknr = MAX_PGOFF - 1;
bbuild.c:904:		last_blocknr -= base;
bbuild.c:907:		nvmm = ring->array[pgoff];
bbuild.c:910:			ring->array[pgoff] = 0;
bbuild.c:926:	if (sih->i_size > entry->size) {
bbuild.c:927:		start = entry->size;
bbuild.c:928:		end = sih->i_size;
bbuild.c:930:		first_blocknr = (start + (1UL << data_bits) - 1) >> data_bits;
bbuild.c:933:			last_blocknr = (end - 1) >> data_bits;
bbuild.c:943:		if (last_blocknr > base + MAX_PGOFF - 1)
bbuild.c:944:			last_blocknr = base + MAX_PGOFF - 1;
bbuild.c:947:			ring->array[pgoff - base] = 0;
bbuild.c:950:	sih->i_size = entry->size;
bbuild.c:962:	u64 ino = pi->nova_ino;
bbuild.c:970:	btype = pi->i_blk_type;
bbuild.c:974:	sih->i_size = 0;
bbuild.c:975:	curr_p = pi->log_head;
bbuild.c:977:				curr_p, pi->log_tail);
bbuild.c:978:	if (curr_p == 0 && pi->log_tail == 0)
bbuild.c:982:		BUG_ON(curr_p & (PAGE_SIZE - 1));
bbuild.c:986:	while (curr_p != pi->log_tail) {
bbuild.c:990:				BUG_ON(curr_p & (PAGE_SIZE - 1));
bbuild.c:1022:		sih->i_size = entry->size;
bbuild.c:1024:		if (entry->num_pages != entry->invalid_pages) {
bbuild.c:1025:			if (entry->pgoff < base + MAX_PGOFF &&
bbuild.c:1026:					entry->pgoff + entry->num_pages > base)
bbuild.c:1037:		while ((next = curr_page->page_tail.next_page) != 0) {
bbuild.c:1039:			BUG_ON(curr_p & (PAGE_SIZE - 1));
bbuild.c:1046:	if (sih->i_size == 0)
bbuild.c:1049:	last_blocknr = (sih->i_size - 1) >> data_bits;
bbuild.c:1070:	if (pi->valid == 0)
bbuild.c:1073:	nova_ino = pi->nova_ino;
bbuild.c:1074:	ring->inodes_used_count++;
bbuild.c:1076:	sih->i_mode = __le16_to_cpu(pi->i_mode);
bbuild.c:1077:	sih->ino = nova_ino;
bbuild.c:1080:			__func__, nova_ino, pi_addr, pi->log_head,
bbuild.c:1081:			pi->log_tail);
bbuild.c:1083:	switch (__le16_to_cpu(pi->i_mode) & S_IFMT) {
bbuild.c:1108:		for (i = 0; i < sbi->cpus; i++) {
bbuild.c:1110:			vfree(ring->array);
bbuild.c:1111:			ring->array = NULL;
bbuild.c:1133:		ring->array = vzalloc(sizeof(u64) * MAX_PGOFF);
bbuild.c:1134:		if (!ring->array)
bbuild.c:1158:	return -ENOMEM;
bbuild.c:1181:		*ino_low = *ino_high = pi->nova_ino;
bbuild.c:1183:		if (pi->nova_ino == *ino_high + sbi->cpus) {
bbuild.c:1184:			*ino_high = pi->nova_ino;
bbuild.c:1188:			*ino_low = *ino_high = pi->nova_ino;
bbuild.c:1214:	data_bits = blk_type_to_shift[pi->i_blk_type];
bbuild.c:1215:	num_inodes_per_page = 1 << (data_bits - NOVA_INODE_BITS);
bbuild.c:1220:	for (count = 0; count < ring->num; count++) {
bbuild.c:1221:		curr = ring->addr[count];
bbuild.c:1235:			if (pi->valid) {
bbuild.c:1251:		last_blocknr = (max_size - 1) >> PAGE_SHIFT;
bbuild.c:1275:	for (cpuid = 0; cpuid < sbi->cpus; cpuid++) {
bbuild.c:1278:			return -EINVAL;
bbuild.c:1280:		curr = inode_table->log_head;
bbuild.c:1283:			if (ring->num >= 512) {
bbuild.c:1286:				return -EINVAL;
bbuild.c:1289:			ring->addr[ring->num] = curr;
bbuild.c:1290:			ring->num++;
bbuild.c:1292:			ring_id = (ring_id + 1) % sbi->cpus;
bbuild.c:1296:			curr_addr += 2097152 - 8;
bbuild.c:1301:	for (cpuid = 0; cpuid < sbi->cpus; cpuid++)
bbuild.c:1321:	sbi->s_inodes_used_count = 0;
bbuild.c:1325:		return -EINVAL;
bbuild.c:1329:	pi->log_head = pi->log_tail = 0;
bbuild.c:1330:	nova_flush_buffer(&pi->log_head, CACHELINE_SIZE, 0);
bbuild.c:1332:	for (i = 0; i < sbi->cpus; i++) {
bbuild.c:1335:			return -EINVAL;
bbuild.c:1337:		set_bm(pair->journal_head >> PAGE_SHIFT, global_bm[i], BM_4K);
bbuild.c:1341:	ret = allocate_resources(sb, sbi->cpus);
bbuild.c:1347:	wait_to_finish(sbi->cpus);
bbuild.c:1349:	for (i = 0; i < sbi->cpus; i++) {
bbuild.c:1351:		sbi->s_inodes_used_count += ring->inodes_used_count;
bbuild.c:1357:				sbi->s_inodes_used_count);
bbuild.c:1367:	unsigned long initsize = le64_to_cpu(super->s_size);
bbuild.c:1379:	sbi->num_blocks = ((unsigned long)(initsize) >> PAGE_SHIFT);
bbuild.c:1393:		sbi->s_inodes_used_count = 0;
bbuild.c:1406:			(end.tv_sec - start.tv_sec) * 1000000000 +
bbuild.c:1407:			(end.tv_nsec - start.tv_nsec);
journal.h:4: * Copyright 2015-2016 Regents of the University of California,
journal.h:5: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
journal.h:6: * Copyright 2012-2013 Intel Corporation
journal.h:7: * Copyright 2009-2011 Marco Stornelli <marco.stornelli@gmail.com>
journal.h:20: * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
balloc.c:4: * Copyright 2015-2016 Regents of the University of California,
balloc.c:5: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
balloc.c:6: * Copyright 2012-2013 Intel Corporation
balloc.c:7: * Copyright 2009-2011 Marco Stornelli <marco.stornelli@gmail.com>
balloc.c:10: * 2003-2004 (c) MontaVista Software, Inc. , Steve Longerbeam
balloc.c:23: * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
balloc.c:36:	sbi->free_lists = kzalloc(sbi->cpus * sizeof(struct free_list),
balloc.c:39:	if (!sbi->free_lists)
balloc.c:40:		return -ENOMEM;
balloc.c:42:	for (i = 0; i < sbi->cpus; i++) {
balloc.c:44:		free_list->block_free_tree = RB_ROOT;
balloc.c:45:		spin_lock_init(&free_list->s_lock);
balloc.c:56:	kfree(sbi->free_lists);
balloc.c:57:	sbi->free_lists = NULL;
balloc.c:71:	num_used_block = sbi->reserved_blocks;
balloc.c:73:	/* Divide the block range among per-CPU free lists */
balloc.c:74:	per_list_blocks = sbi->num_blocks / sbi->cpus;
balloc.c:75:	sbi->per_list_blocks = per_list_blocks;
balloc.c:76:	for (i = 0; i < sbi->cpus; i++) {
balloc.c:78:		tree = &(free_list->block_free_tree);
balloc.c:79:		free_list->block_start = per_list_blocks * i;
balloc.c:80:		free_list->block_end = free_list->block_start +
balloc.c:81:						per_list_blocks - 1;
balloc.c:85:			free_list->num_free_blocks = per_list_blocks;
balloc.c:87:				free_list->block_start += num_used_block;
balloc.c:88:				free_list->num_free_blocks -= num_used_block;
balloc.c:94:			blknode->range_low = free_list->block_start;
balloc.c:95:			blknode->range_high = free_list->block_end;
balloc.c:102:			free_list->first_node = blknode;
balloc.c:103:			free_list->num_blocknode = 1;
balloc.c:107:	free_list = nova_get_free_list(sb, (sbi->cpus - 1));
balloc.c:108:	if (free_list->block_end + 1 < sbi->num_blocks) {
balloc.c:110:		sbi->shared_free_list.block_start = free_list->block_end + 1;
balloc.c:111:		sbi->shared_free_list.block_end = sbi->num_blocks - 1;
balloc.c:118:	if (range_low < curr->range_low)
balloc.c:119:		return -1;
balloc.c:120:	if (range_low > curr->range_high)
balloc.c:135:	temp = tree->rb_node;
balloc.c:141:		if (compVal == -1) {
balloc.c:142:			temp = temp->rb_left;
balloc.c:144:			temp = temp->rb_right;
balloc.c:162:	cpu = ino % sbi->cpus;
balloc.c:163:	tree = &sbi->inode_maps[cpu].inode_inuse_tree;
balloc.c:164:	internal_ino = ino / sbi->cpus;
balloc.c:175:	temp = &(tree->rb_node);
balloc.c:181:					new_node->range_low);
balloc.c:184:		if (compVal == -1) {
balloc.c:185:			temp = &((*temp)->rb_left);
balloc.c:187:			temp = &((*temp)->rb_right);
balloc.c:189:			nova_dbg("%s: entry %lu - %lu already exists: "
balloc.c:190:				"%lu - %lu\n", __func__,
balloc.c:191:				new_node->range_low,
balloc.c:192:				new_node->range_high,
balloc.c:193:				curr->range_low,
balloc.c:194:				curr->range_high);
balloc.c:195:			return -EINVAL;
balloc.c:199:	rb_link_node(&new_node->node, parent, temp);
balloc.c:200:	rb_insert_color(&new_node->node, tree);
balloc.c:223:	tree = &sbi->inode_maps[cpu].inode_inuse_tree;
balloc.c:243:		nova_dbg("%s ERROR: %lu - %lu already in free list\n",
balloc.c:245:		return -EINVAL;
balloc.c:250:	} else if (ret_node->range_high < range_low) {
balloc.c:252:		temp = rb_next(&ret_node->node);
balloc.c:257:	} else if (ret_node->range_low > range_high) {
balloc.c:259:		temp = rb_prev(&ret_node->node);
balloc.c:265:		nova_dbg("%s ERROR: %lu - %lu overlaps with existing node "
balloc.c:266:			"%lu - %lu\n", __func__, range_low,
balloc.c:267:			range_high, ret_node->range_low,
balloc.c:268:			ret_node->range_high);
balloc.c:269:		return -EINVAL;
balloc.c:293:		return -EINVAL;
balloc.c:296:	cpuid = blocknr / sbi->per_list_blocks;
balloc.c:297:	if (cpuid >= sbi->cpus)
balloc.c:300:	/* Pre-allocate blocknode */
balloc.c:304:		return -ENOMEM;
balloc.c:308:	spin_lock(&free_list->s_lock);
balloc.c:310:	tree = &(free_list->block_free_tree);
balloc.c:314:	block_high = blocknr + num_blocks - 1;
balloc.c:316:	nova_dbgv("Free: %lu - %lu\n", block_low, block_high);
balloc.c:323:		spin_unlock(&free_list->s_lock);
balloc.c:328:	if (prev && next && (block_low == prev->range_high + 1) &&
balloc.c:329:			(block_high + 1 == next->range_low)) {
balloc.c:331:		rb_erase(&next->node, tree);
balloc.c:332:		free_list->num_blocknode--;
balloc.c:333:		prev->range_high = next->range_high;
balloc.c:337:	if (prev && (block_low == prev->range_high + 1)) {
balloc.c:339:		prev->range_high += num_blocks;
balloc.c:342:	if (next && (block_high + 1 == next->range_low)) {
balloc.c:344:		next->range_low -= num_blocks;
balloc.c:349:	curr_node->range_low = block_low;
balloc.c:350:	curr_node->range_high = block_high;
balloc.c:358:		free_list->first_node = curr_node;
balloc.c:359:	free_list->num_blocknode++;
balloc.c:362:	free_list->num_free_blocks += num_blocks;
balloc.c:365:		free_list->free_log_count++;
balloc.c:366:		free_list->freed_log_pages += num_blocks;
balloc.c:368:		free_list->free_data_count++;
balloc.c:369:		free_list->freed_data_pages += num_blocks;
balloc.c:371:        free_list->free_zone_count++;
balloc.c:372:        free_list->freed_zone_pages += num_blocks;
balloc.c:374:        free_list->free_htable_count++;
balloc.c:375:        free_list->freed_htable_pages += num_blocks;
balloc.c:379:	spin_unlock(&free_list->s_lock);
balloc.c:393:			pi->nova_ino, num, blocknr, blocknr + num - 1);
balloc.c:396:		return -EINVAL;
balloc.c:399:	ret = nova_free_blocks(sb, blocknr, num, pi->i_blk_type, 0);
balloc.c:402:				"failed!\n", pi->nova_ino, num, blocknr,
balloc.c:403:				blocknr + num - 1);
balloc.c:416:			pi->nova_ino, num, blocknr, blocknr + num - 1);
balloc.c:419:		return -EINVAL;
balloc.c:422:	ret = nova_free_blocks(sb, blocknr, num, pi->i_blk_type, 1);
balloc.c:425:				"failed!\n", pi->nova_ino, num, blocknr,
balloc.c:426:				blocknr + num - 1);
balloc.c:440:			dzt_ei->dzt_eno, num, blocknr, blocknr + num - 1);
balloc.c:444:		return -EINVAL;
balloc.c:448:    ret = nova_free_blocks(sb, blocknr, num, dzt_ei->zone_blk_type, 2);
balloc.c:452:				"failed!\n", dzt_ei->dzt_eno, num, blocknr,
balloc.c:453:				blocknr + num - 1);
balloc.c:466:			 num, blocknr, blocknr + num - 1);
balloc.c:470:		return -EINVAL;
balloc.c:479:				blocknr + num - 1);
balloc.c:496:	tree = &(free_list->block_free_tree);
balloc.c:497:	temp = &(free_list->first_node->node);
balloc.c:504:		curr_blocks = curr->range_high - curr->range_low + 1;
balloc.c:514:			if (curr == free_list->first_node) {
balloc.c:519:				free_list->first_node = next;
balloc.c:522:			rb_erase(&curr->node, tree);
balloc.c:523:			free_list->num_blocknode--;
balloc.c:525:			*new_blocknr = curr->range_low;
balloc.c:532:		*new_blocknr = curr->range_low;
balloc.c:533:		curr->range_low += num_blocks;
balloc.c:538:	free_list->num_free_blocks -= num_blocks;
balloc.c:543:		return -ENOSPC;
balloc.c:557:	for (i = 0; i < sbi->cpus; i++) {
balloc.c:559:		if (free_list->num_free_blocks > num_free_blocks) {
balloc.c:561:			num_free_blocks = free_list->num_free_blocks;
balloc.c:585:		return -EINVAL;
balloc.c:592:	spin_lock(&free_list->s_lock);
balloc.c:594:	if (free_list->num_free_blocks < num_blocks || !free_list->first_node) {
balloc.c:597:			free_list->num_free_blocks, num_blocks,
balloc.c:598:			free_list->num_blocknode);
balloc.c:599:		if (free_list->num_free_blocks >= num_blocks) {
balloc.c:602:			temp = rb_first(&free_list->block_free_tree);
balloc.c:604:			free_list->first_node = first;
balloc.c:606:			spin_unlock(&free_list->s_lock);
balloc.c:608:				return -ENOSPC;
balloc.c:619:		free_list->alloc_log_count++;
balloc.c:620:		free_list->alloc_log_pages += ret_blocks;
balloc.c:622:		free_list->alloc_data_count++;
balloc.c:623:		free_list->alloc_data_pages += ret_blocks;
balloc.c:625:        free_list->alloc_zone_count++;
balloc.c:626:        free_list->alloc_zone_pages += ret_blocks;
balloc.c:628:        free_list->alloc_htable_count++;
balloc.c:629:        free_list->alloc_htable_page += ret_blocks;
balloc.c:632:	spin_unlock(&free_list->s_lock);
balloc.c:635:		return -ENOSPC;
balloc.c:656:					pi->i_blk_type, zero, DATA);
balloc.c:660:			pi->nova_ino, start_blk, cow, allocated, *blocknr,
balloc.c:661:			*blocknr + allocated - 1);
balloc.c:672:					pi->i_blk_type, zero, LOG);
balloc.c:675:			pi->nova_ino, allocated, *blocknr,
balloc.c:676:			*blocknr + allocated - 1);
balloc.c:687:					dzt_e->zone_blk_type, zero, ZONE);
balloc.c:690:			dzt_e->dzt_no, allocated, *blocknr,
balloc.c:691:			*blocknr + allocated - 1);
balloc.c:703:	for (i = 0; i < sbi->cpus; i++) {
balloc.c:705:		num_free_blocks += free_list->num_free_blocks;
balloc.c:709:	num_free_blocks += free_list->num_free_blocks;
nova.h:6: * Copyright 2015-2016 Regents of the University of California,
nova.h:7: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
nova.h:8: * Copyright 2012-2013 Intel Corporation
nova.h:9: * Copyright 2009-2011 Marco Stornelli <marco.stornelli@gmail.com>
nova.h:12: * 2003-2004 (c) MontaVista Software, Inc. , Steve Longerbeam
nova.h:29:#include <linux/backing-dev.h>
nova.h:35:#include <linux/radix-tree.h>
nova.h:101:#define test_opt(sb, opt)       (NOVA_SB(sb)->s_mount_opt & NOVA_MOUNT_ ## opt)
nova.h:117:/* Flags that are appropriate for regular files (all but dir-specific ones). */
nova.h:119:/* Flags that are appropriate for non-directories/regular files. */
nova.h:133:#define	INVALID_CPU			(-1)
nova.h:219:#define NOVA_DIR_ROUND			(NOVA_DIR_PAD - 1)
nova.h:264:	pi->log_tail = new_tail;
nova.h:265:	nova_flush_buffer(&pi->log_tail, CACHELINE_SIZE, 1);
nova.h:293:	crc = crc16(~0, (__u8 *)data + sizeof(__le16), n - sizeof(__le16));
nova.h:411: * NOVA super-block data in memory
nova.h:447:	struct mutex 	s_lock;	/* protects the SB's buffer-head */
nova.h:455:	/* Per-CPU journal lock */
nova.h:458:	/* Per-CPU inode map */
nova.h:464:	/* Per-CPU free block list */
nova.h:482:	return sb->s_fs_info;
nova.h:490:/* If this is part of a read-modify-write of the super block,
nova.h:496:	return (struct nova_super_block *)sbi->virt_addr;
nova.h:503:	return (struct nova_super_block *)(sbi->virt_addr + NOVA_SB_SIZE);
nova.h:506:/* If this is part of a read-modify-write of the block,
nova.h:519:	NOVA_ASSERT((addr >= sbi->virt_addr) &&
nova.h:520:			(addr < (sbi->virt_addr + sbi->initsize)));
nova.h:521:	return (u64)(addr - sbi->virt_addr);
nova.h:537:	if (cpu < sbi->cpus)
nova.h:538:		return &sbi->free_lists[cpu];
nova.h:540:		return &sbi->shared_free_list;
nova.h:553:	if (cpu >= sbi->cpus)
nova.h:569:	if (cpu >= sbi->cpus)
nova.h:635:/* assumes the length to be 4-byte aligned */
nova.h:676:	struct nova_inode_info_header *sih = &si->header;
nova.h:679:	entry = radix_tree_lookup(&sih->tree, blocknr);
nova.h:696:	if (data->pgoff > pgoff || (unsigned long)data->pgoff +
nova.h:697:			(unsigned long)data->num_pages <= pgoff) {
nova.h:704:			"entry pgoff %llu, num %u\n", sih->ino,
nova.h:705:			curr, pgoff, data->pgoff, data->num_pages);
nova.h:706:		pi = nova_get_block(sb, sih->pi_addr);
nova.h:712:	return (unsigned long)(data->block >> PAGE_SHIFT) + pgoff
nova.h:713:		- data->pgoff;
nova.h:728:	nvmm = get_nvmm(sb, &si->header, entry, blocknr);
nova.h:735:	struct nova_inode_info_header *sih = &si->header;
nova.h:738:	addr = (unsigned long)radix_tree_lookup(&sih->cache_tree, blocknr);
nova.h:740:		__func__, sih->ino, blocknr, addr);
nova.h:746:	return blk_type_to_shift[pi->i_blk_type];
nova.h:751:	return blk_type_to_size[pi->i_blk_type];
nova.h:762:	return (struct nova_inode *)(sbi->virt_addr + NOVA_SB_SIZE * 2 +
nova.h:763:			 (inode_number - NOVA_ROOT_INO) * NOVA_INODE_SIZE);
nova.h:766:/* If this is part of a read-modify-write of the inode metadata,
nova.h:781:	struct nova_inode_info_header *sih = &si->header;
nova.h:783:	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
nova.h:813:	return (NOVA_SB(sb)->phys_addr + block) >> PAGE_SHIFT;
nova.h:818:	struct nova_sb_info *sbi = (struct nova_sb_info *)sb->s_fs_info;
nova.h:819:	return sbi->s_mount_opt & NOVA_MOUNT_MOUNTING;
nova.h:825:	if ((pi->i_flags & cpu_to_le32(NOVA_EOFBLOCKS_FL)) &&
nova.h:826:		(size + sb->s_blocksize) > (le64_to_cpu(pi->i_blocks)
nova.h:827:			<< sb->s_blocksize_bits))
nova.h:828:		pi->i_flags &= cpu_to_le32(~NOVA_EOFBLOCKS_FL);
nova.h:843:	return ((struct nova_inode_page_tail *)page_tail)->next_page;
nova.h:849:	curr_page->page_tail.next_page = next_page;
nova.h:850:	nova_flush_buffer(&curr_page->page_tail,
nova.h:856:#define	CACHE_ALIGN(p)	((p) & ~(CACHELINE_SIZE - 1))
nova.h:887:	if (entry->name_len == 1 && strncmp(entry->name, ".", 1) == 0)
nova.h:889:	if (entry->name_len == 2 && strncmp(entry->name, "..", 2) == 0)
nova.h:898:	if (entry->name_len == 1 && strncmp(entry->name, ".", 1) == 0)
nova.h:900:	if (entry->name_len == 2 && strncmp(entry->name, "..", 2) == 0)
super.c:6: * Copyright 2015-2016 Regents of the University of California,
super.c:7: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
super.c:8: * Copyright 2012-2013 Intel Corporation
super.c:9: * Copyright 2009-2011 Marco Stornelli <marco.stornelli@gmail.com>
super.c:12: * 2003-2004 (c) MontaVista Software, Inc. , Steve Longerbeam
super.c:68:		printk(KERN_CRIT "nova err: remounting filesystem read-only");
super.c:69:		sb->s_flags |= MS_RDONLY;
super.c:82:	bits = fls(size) - 1;
super.c:83:	sb->s_blocksize_bits = bits;
super.c:84:	sb->s_blocksize = (1 << bits);
super.c:98:	if (!sb->s_bdev->bd_disk->fops->direct_access) {
super.c:100:		return -EINVAL;
super.c:103:	sbi->s_bdev = sb->s_bdev;
super.c:106:	size = sb->s_bdev->bd_disk->fops->direct_access(sb->s_bdev,
super.c:109:	size = sb->s_bdev->bd_disk->fops->direct_access(sb->s_bdev,
super.c:115:		return -EINVAL;
super.c:118:	sbi->virt_addr = virt_addr;
super.c:120:	sbi->phys_addr = pfn_t_to_pfn(__pfn_t) << PAGE_SHIFT;
super.c:122:	sbi->phys_addr = pfn << PAGE_SHIFT;
super.c:124:	sbi->initsize = size;
super.c:127:		__func__, sbi->s_bdev->bd_disk->disk_name,
super.c:128:		sbi->phys_addr, sbi->virt_addr, sbi->initsize);
super.c:137:	res = (1ULL << 63) - 1;
super.c:162:	{ Opt_err_ro,	     "errors=remount-ro"  },
super.c:189:			sbi->bpi = option;
super.c:196:			sbi->uid = make_kuid(current_user_ns(), option);
super.c:201:			sbi->gid = make_kgid(current_user_ns(), option);
super.c:206:			sbi->mode = option & 01777U;
super.c:211:			set_opt(sbi->s_mount_opt, FORMAT);
super.c:214:			clear_opt(sbi->s_mount_opt, ERRORS_CONT);
super.c:215:			clear_opt(sbi->s_mount_opt, ERRORS_RO);
super.c:216:			set_opt(sbi->s_mount_opt, ERRORS_PANIC);
super.c:219:			clear_opt(sbi->s_mount_opt, ERRORS_CONT);
super.c:220:			clear_opt(sbi->s_mount_opt, ERRORS_PANIC);
super.c:221:			set_opt(sbi->s_mount_opt, ERRORS_RO);
super.c:224:			clear_opt(sbi->s_mount_opt, ERRORS_RO);
super.c:225:			clear_opt(sbi->s_mount_opt, ERRORS_PANIC);
super.c:226:			set_opt(sbi->s_mount_opt, ERRORS_CONT);
super.c:231:			set_opt(sbi->s_mount_opt, PROTECT);
super.c:251:	return -EINVAL;
super.c:254:	return -EINVAL;
super.c:265:	minimum_size = 2 << sb->s_blocksize_bits;
super.c:268:	if (sbi->num_inodes > 0)
super.c:269:		num_blocks = (sbi->num_inodes >>
super.c:270:			(sb->s_blocksize_bits - NOVA_INODE_BITS)) + 1;    //table 需要多少个blocks
super.c:273:	minimum_size += (num_blocks << sb->s_blocksize_bits);     //实际table需要的大小
super.c:294:	sbi->num_blocks = ((unsigned long)(size) >> PAGE_SHIFT);
super.c:296:	if (!sbi->virt_addr) {
super.c:298:		return ERR_PTR(-EINVAL);
super.c:302:	blocksize = sbi->blocksize = NOVA_DEF_BLOCK_SIZE_4K;
super.c:305:	blocksize = sb->s_blocksize;
super.c:307:	if (sbi->blocksize && sbi->blocksize != blocksize)
super.c:308:		sbi->blocksize = blocksize;
super.c:312:		return ERR_PTR(-EINVAL);
super.c:317:	reserved_blocks = (reserved_space + blocksize - 1) / blocksize;
super.c:318:	if (reserved_blocks > sbi->reserved_blocks) {
super.c:321:			sbi->reserved_blocks, reserved_blocks);
super.c:322:		return ERR_PTR(-EINVAL);
super.c:329:	/* clear out super-block and inode table */
super.c:330:	memset_nt(super, 0, sbi->reserved_blocks * sbi->blocksize);
super.c:331:	super->s_size = cpu_to_le64(size);
super.c:332:	super->s_blocksize = cpu_to_le32(blocksize);
super.c:333:	super->s_magic = cpu_to_le32(NOVA_SUPER_MAGIC);
super.c:339:		return ERR_PTR(-EINVAL);
super.c:343:		return ERR_PTR(-EINVAL);
super.c:346:		return ERR_PTR(-EINVAL);
super.c:349:	pi->nova_ino = NOVA_BLOCKNODE_INO;
super.c:353:	pi->nova_ino = NOVA_INODELIST_INO;
super.c:367:	root_i->i_mode = cpu_to_le16(sbi->mode | S_IFDIR);
super.c:368:	root_i->i_uid = cpu_to_le32(from_kuid(&init_user_ns, sbi->uid));
super.c:369:	root_i->i_gid = cpu_to_le32(from_kgid(&init_user_ns, sbi->gid));
super.c:370:	root_i->i_links_count = cpu_to_le16(2);
super.c:371:	root_i->i_blk_type = NOVA_BLOCK_TYPE_4K;
super.c:372:	root_i->i_flags = 0;
super.c:373:	root_i->i_blocks = cpu_to_le64(1);
super.c:374:	root_i->i_size = cpu_to_le64(sb->s_blocksize);
super.c:375:	root_i->i_atime = root_i->i_mtime = root_i->i_ctime =
super.c:377:	root_i->nova_ino = NOVA_ROOT_INO;
super.c:378:	root_i->valid = 1;
super.c:396:	set_opt(sbi->s_mount_opt, HUGEIOREMAP);
super.c:397:	set_opt(sbi->s_mount_opt, ERRORS_CONT);
super.c:398:	sbi->reserved_blocks = RESERVED_BLOCKS;
super.c:399:	sbi->cpus = num_online_cpus();
super.c:400:	sbi->map_id = 0;
super.c:405:	if (!S_ISDIR(le16_to_cpu(root_pi->i_mode)))
super.c:418:	if (le32_to_cpu(super->s_magic) != NOVA_SUPER_MAGIC) {
super.c:419:		if (le32_to_cpu(super_redund->s_magic) != NOVA_SUPER_MAGIC) {
super.c:426:			/* Try to auto-recover the super block */
super.c:450:			/* Try to auto-recover the super block */
super.c:477:	int retval = -EINVAL;
super.c:489:		return -ENOMEM;
super.c:490:	sb->s_fs_info = sbi;
super.c:491:	sbi->sb = sb;
super.c:496:	if (sbi->cpus > 64) {
super.c:506:	atomic_set(&sbi->next_generation, random);
super.c:509:	sbi->shared_free_list.block_free_tree = RB_ROOT;
super.c:510:	spin_lock_init(&sbi->shared_free_list.s_lock);
super.c:511:	sbi->mode = (S_IRUGO | S_IXUGO | S_IWUSR);
super.c:512:	sbi->uid = current_fsuid();
super.c:513:	sbi->gid = current_fsgid();
super.c:514:	set_opt(sbi->s_mount_opt, DAX);
super.c:515:	clear_opt(sbi->s_mount_opt, PROTECT);
super.c:516:	set_opt(sbi->s_mount_opt, HUGEIOREMAP);
super.c:518:	sbi->inode_maps = kzalloc(sbi->cpus * sizeof(struct inode_map),
super.c:520:	if (!sbi->inode_maps) {
super.c:521:		retval = -ENOMEM;
super.c:527:	for (i = 0; i < sbi->cpus; i++) {
super.c:528:		inode_map = &sbi->inode_maps[i];
super.c:529:		mutex_init(&inode_map->inode_table_mutex);
super.c:530:		inode_map->inode_inuse_tree = RB_ROOT;
super.c:533:	mutex_init(&sbi->s_lock);
super.c:535:	sbi->zeroed_page = kzalloc(PAGE_SIZE, GFP_KERNEL);
super.c:536:	if (!sbi->zeroed_page) {
super.c:537:		retval = -ENOMEM;
super.c:544:	set_opt(sbi->s_mount_opt, MOUNTING);
super.c:547:		retval = -ENOMEM;
super.c:552:    INIT_RADIX_TREE(&sbi->dzt_m_info, GFP_ATOMIC);
super.c:560:	if (sbi->s_mount_opt & NOVA_MOUNT_FORMAT) {
super.c:561:		root_pi = nova_init(sb, sbi->initsize);
super.c:569:		  (u64)sbi->phys_addr);
super.c:575:				le32_to_cpu(super->s_magic), NOVA_SUPER_MAGIC);
super.c:580:		retval = -EINVAL;
super.c:585:	blocksize = le32_to_cpu(super->s_blocksize);
super.c:598:	sb->s_magic = le32_to_cpu(super->s_magic);
super.c:599:	sb->s_op = &nova_sops;
super.c:600:	sb->s_maxbytes = nova_max_size(sb->s_blocksize_bits);
super.c:601:	sb->s_time_gran = 1;
super.c:602:	sb->s_export_op = &nova_export_ops;
super.c:603:	sb->s_xattr = NULL;
super.c:604:	sb->s_flags |= MS_NOSEC;
super.c:606:	/* If the FS was not formatted on this mount, scan the meta-data after
super.c:608:	if ((sbi->s_mount_opt & NOVA_MOUNT_FORMAT) == 0)
super.c:617:	sb->s_root = d_make_root(root_i);
super.c:618:	if (!sb->s_root) {
super.c:620:		retval = -ENOMEM;
super.c:624:	if (!(sb->s_flags & MS_RDONLY)) {
super.c:630:		nova_memunlock_range(sb, &super->s_mtime, 8);
super.c:631:		nova_memcpy_atomic(&super->s_mtime, &mnt_write_time, 8);
super.c:632:		nova_memlock_range(sb, &super->s_mtime, 8);
super.c:634:		nova_flush_buffer(&super->s_mtime, 8, false);
super.c:639:	clear_opt(sbi->s_mount_opt, MOUNTING);
super.c:645:	if (sbi->zeroed_page) {
super.c:646:		kfree(sbi->zeroed_page);
super.c:647:		sbi->zeroed_page = NULL;
super.c:650:	if (sbi->free_lists) {
super.c:651:		kfree(sbi->free_lists);
super.c:652:		sbi->free_lists = NULL;
super.c:655:	if (sbi->journal_locks) {
super.c:656:		kfree(sbi->journal_locks);
super.c:657:		sbi->journal_locks = NULL;
super.c:660:	if (sbi->inode_maps) {
super.c:661:		kfree(sbi->inode_maps);
super.c:662:		sbi->inode_maps = NULL;
super.c:671:	struct super_block *sb = d->d_sb;
super.c:672:	struct nova_sb_info *sbi = (struct nova_sb_info *)sb->s_fs_info;
super.c:674:	buf->f_type = NOVA_SUPER_MAGIC;
super.c:675:	buf->f_bsize = sb->s_blocksize;
super.c:677:	buf->f_blocks = sbi->num_blocks;
super.c:678:	buf->f_bfree = buf->f_bavail = nova_count_free_blocks(sb);
super.c:679:	buf->f_files = LONG_MAX;
super.c:680:	buf->f_ffree = LONG_MAX - sbi->s_inodes_used_count;
super.c:681:	buf->f_namelen = NOVA_NAME_LEN;
super.c:683:		buf->f_bfree);
super.c:689:	struct nova_sb_info *sbi = NOVA_SB(root->d_sb);
super.c:691:	seq_printf(seq, ",physaddr=0x%016llx", (u64)sbi->phys_addr);
super.c:692:	if (sbi->initsize)
super.c:693:		seq_printf(seq, ",init=%luk", sbi->initsize >> 10);
super.c:694:	if (sbi->blocksize)
super.c:695:		seq_printf(seq, ",bs=%lu", sbi->blocksize);
super.c:696:	if (sbi->bpi)
super.c:697:		seq_printf(seq, ",bpi=%lu", sbi->bpi);
super.c:698:	if (sbi->num_inodes)
super.c:699:		seq_printf(seq, ",N=%lu", sbi->num_inodes);
super.c:700:	if (sbi->mode != (S_IRWXUGO | S_ISVTX))
super.c:701:		seq_printf(seq, ",mode=%03o", sbi->mode);
super.c:702:	if (uid_valid(sbi->uid))
super.c:703:		seq_printf(seq, ",uid=%u", from_kuid(&init_user_ns, sbi->uid));
super.c:704:	if (gid_valid(sbi->gid))
super.c:705:		seq_printf(seq, ",gid=%u", from_kgid(&init_user_ns, sbi->gid));
super.c:706:	if (test_opt(root->d_sb, ERRORS_RO))
super.c:707:		seq_puts(seq, ",errors=remount-ro");
super.c:708:	if (test_opt(root->d_sb, ERRORS_PANIC))
super.c:711:	if (test_opt(root->d_sb, PROTECT))
super.c:713:	if (test_opt(root->d_sb, DAX))
super.c:725:	int ret = -EINVAL;
super.c:728:	mutex_lock(&sbi->s_lock);
super.c:729:	old_sb_flags = sb->s_flags;
super.c:730:	old_mount_opt = sbi->s_mount_opt;
super.c:735:	sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |
super.c:736:		      ((sbi->s_mount_opt & NOVA_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);
super.c:738:	if ((*mntflags & MS_RDONLY) != (sb->s_flags & MS_RDONLY)) {
super.c:745:		nova_memunlock_range(sb, &ps->s_mtime, 8);
super.c:746:		nova_memcpy_atomic(&ps->s_mtime, &mnt_write_time, 8);
super.c:747:		nova_memlock_range(sb, &ps->s_mtime, 8);
super.c:749:		nova_flush_buffer(&ps->s_mtime, 8, false);
super.c:754:	mutex_unlock(&sbi->s_lock);
super.c:759:	sb->s_flags = old_sb_flags;
super.c:760:	sbi->s_mount_opt = old_mount_opt;
super.c:761:	mutex_unlock(&sbi->s_lock);
super.c:773:	if (sbi->virt_addr) {
super.c:777:		sbi->virt_addr = NULL;
super.c:782:	kfree(sbi->zeroed_page);
super.c:784:	kfree(sbi->free_lists);
super.c:785:	kfree(sbi->journal_locks);
super.c:787:	for (i = 0; i < sbi->cpus; i++) {
super.c:788:		inode_map = &sbi->inode_maps[i];
super.c:790:			i, inode_map->allocated, inode_map->freed);
super.c:793:	kfree(sbi->inode_maps);
super.c:801:	sb->s_fs_info = NULL;
super.c:848:	vi->vfs_inode.i_version = 1;
super.c:850:	return &vi->vfs_inode;
super.c:858:	nova_dbg_verbose("%s: ino %lu\n", __func__, inode->i_ino);
super.c:864:	nova_dbgv("%s: %lu\n", __func__, inode->i_ino);
super.c:865:	call_rcu(&inode->i_rcu, nova_i_callback);
super.c:872:	inode_init_once(&vi->vfs_inode);
super.c:883:		return -ENOMEM;
super.c:895:		return -ENOMEM;
super.c:950:		return ERR_PTR(-ESTALE);
super.c:953:		return ERR_PTR(-ESTALE);
super.c:959:	if (generation && inode->i_generation != generation) {
super.c:962:		return ERR_PTR(-ESTALE);
dafs_namei.c:26:	entry.addrs[0] = (u64)nova_get_addr_off(sbi, &pidir->log_tail);
dafs_namei.c:28:	entry.values[0] = pidir->log_tail;
dafs_namei.c:30:	entry.addrs[1] = (u64)nova_get_addr_off(sbi, &pi->valid);
dafs_namei.c:32:	entry.values[1] = pi->valid;
dafs_namei.c:35:	spin_lock(&sbi->journal_locks[cpu]);
dafs_namei.c:38:	pidir->log_tail = pidir_tail;
dafs_namei.c:39:	nova_flush_buffer(&pidir->log_tail, CACHELINE_SIZE, 0);
dafs_namei.c:40:	pi->valid = 1;
dafs_namei.c:41:	nova_flush_buffer(&pi->valid, CACHELINE_SIZE, 0);
dafs_namei.c:45:	spin_unlock(&sbi->journal_locks[cpu]);
dafs_namei.c:53:    struct super_block *sb = dir->i_sb;
dafs_namei.c:75:	nova_dbgv("%s: %s\n", __func__, dentry->d_name.name);
dafs_namei.c:76:	nova_dbgv("%s: inode %llu, dir %lu\n", __func__, ino, dir->i_ino);
dafs_namei.c:78:					0, 0, &dentry->d_name);
dafs_namei.c:104:    struct super_block *sb = dir->i_sb;
dafs_namei.c:112:    return direntry->ino;
dafs_namei.c:124:	if (dentry->d_name.len > NOVA_NAME_LEN) {
dafs_namei.c:126:			__func__, dentry->d_name.len);
dafs_namei.c:127:		return ERR_PTR(-ENAMETOOLONG);
dafs_namei.c:130:	nova_dbg_verbose("%s: %s\n", __func__, dentry->d_name.name);
dafs_namei.c:135:		inode = nova_iget(dir->i_sb, ino);
dafs_namei.c:136:		if (inode == ERR_PTR(-ESTALE) || inode == ERR_PTR(-ENOMEM)
dafs_namei.c:137:				|| inode == ERR_PTR(-EACCES)) {
dafs_namei.c:138:			nova_err(dir->i_sb,
dafs_namei.c:141:			return ERR_PTR(-EIO);
dafs_namei.c:155:	struct nova_inode_info_header *sih = &si->header;
dafs_namei.c:164:				__func__, inode->i_ino);
dafs_namei.c:168:		return -ENOMEM;
dafs_namei.c:171:	entry->entry_type = LINK_CHANGE;
dafs_namei.c:172:	entry->links = cpu_to_le16(inode->i_nlink);
dafs_namei.c:173:	entry->ctime = cpu_to_le32(inode->i_ctime.tv_sec);
dafs_namei.c:174:	entry->flags = cpu_to_le32(inode->i_flags);
dafs_namei.c:175:	entry->generation = cpu_to_le32(inode->i_generation);
dafs_namei.c:178:	sih->last_link_change = curr_p;
dafs_namei.c:199:	entry.addrs[0] = (u64)nova_get_addr_off(sbi, &pi->log_tail);
dafs_namei.c:201:	entry.values[0] = pi->log_tail;
dafs_namei.c:203:	entry.addrs[1] = (u64)nova_get_addr_off(sbi, &pidir->log_tail);
dafs_namei.c:205:	entry.values[1] = pidir->log_tail;
dafs_namei.c:208:		entry.addrs[2] = (u64)nova_get_addr_off(sbi, &pi->valid);
dafs_namei.c:210:		entry.values[2] = pi->valid;
dafs_namei.c:214:	spin_lock(&sbi->journal_locks[cpu]);
dafs_namei.c:217:	pi->log_tail = pi_tail;
dafs_namei.c:218:	nova_flush_buffer(&pi->log_tail, CACHELINE_SIZE, 0);
dafs_namei.c:219:	pidir->log_tail = pidir_tail;
dafs_namei.c:220:	nova_flush_buffer(&pidir->log_tail, CACHELINE_SIZE, 0);
dafs_namei.c:222:		pi->valid = 0;
dafs_namei.c:223:		nova_flush_buffer(&pi->valid, CACHELINE_SIZE, 0);
dafs_namei.c:228:	spin_unlock(&sbi->journal_locks[cpu]);
dafs_namei.c:235:	if (entry->entry_type != LINK_CHANGE)
dafs_namei.c:238:	pi->i_links_count	= entry->links;
dafs_namei.c:239:	pi->i_ctime		= entry->ctime;
dafs_namei.c:240:	pi->i_flags		= entry->flags;
dafs_namei.c:241:	pi->i_generation	= entry->generation;
dafs_namei.c:247:    struct super_block *sb = dir->i_sb;
dafs_namei.c:248:    struct inode *inode = dest_dentry->d_inode;
dafs_namei.c:252:    int err = -ENOMEM;
dafs_namei.c:257:	if (inode->i_nlink >= NOVA_LINK_MAX) {
dafs_namei.c:258:		err = -EMLINK;
dafs_namei.c:264:		err = -EINVAL;
dafs_namei.c:270:			dentry->d_name.name, dest_dentry->d_name.name);
dafs_namei.c:272:			inode->i_ino, dir->i_ino);
dafs_namei.c:275:    err = dafs_add_dentry(dentry, inode->i_no, 0);
dafs_namei.c:281:	inode->i_ctime = CURRENT_TIME_SEC;
dafs_namei.c:304:    struct inode *inode = dentry->d_inode;
dafs_namei.c:305:    struct super_block *sb = dir->i_sb;
dafs_namei.c:306:    int retval = -ENOMEM;
dafs_namei.c:319:	nova_dbgv("%s: %s\n", __func__, dentry->d_name.name);
dafs_namei.c:321:				inode->i_ino, dir->i_ino);
dafs_namei.c:328:	inode->i_ctime = dir->i_ctime;
dafs_namei.c:330:	if (inode->i_nlink == 1)
dafs_namei.c:333:	if (inode->i_nlink) {
dafs_namei.c:356:    struct super_block *sb = dir->i_sb;
dafs_namei.c:357:    int err = -ENAMETOOLONG;
dafs_namei.c:370:	if (len + 1 > sb->s_blocksize)
dafs_namei.c:382:				dentry->d_name.name, symname);
dafs_namei.c:383:	nova_dbgv("%s: inode %llu, dir %lu\n", __func__, ino, dir->i_ino);
dafs_namei.c:391:					&dentry->d_name);
dafs_namei.c:412:	pi->i_blocks = 2;
dafs_namei.c:432:    struct super_block *sb = dir->i_sb;
dafs_namei.c:440:    int err = -EMLINK;
dafs_namei.c:444:    if(dir->i_nlink >= NOVA_LINK_MAX)
dafs_namei.c:451:	nova_dbgv("%s: name %s\n", __func__, dentry->d_name.name);
dafs_namei.c:453:				ino, dir->i_ino, dir->i_nlink);
dafs_namei.c:463:					S_IFDIR | mode, sb->s_blocksize,
dafs_namei.c:464:					0, &dentry->d_name);
dafs_namei.c:471:    dafs_append_dir_init_entries(sb, pi, inode->i, dir->i_ino);
dafs_namei.c:476:	dir->i_blocks = pidir->i_blocks;
dafs_namei.c:495:    struct inode *inode = dentry->d_inode;
dafs_namei.c:497:    struct super_block *sb = dir->i_sb;
dafs_namei.c:501:    struct nova_inode_info_header *sih = &si->header;
dafs_namei.c:503:    int err = -ENOTEMPTY;
dafs_namei.c:508:		return -ENOENT;
dafs_namei.c:510:	nova_dbgv("%s: name %s\n", __func__, dentry->d_name.name);
dafs_namei.c:513:		return -EINVAL;
dafs_namei.c:517:        return -ENOENT;
dafs_namei.c:523:				inode->i_ino, dir->i_ino, dir->i_nlink);
dafs_namei.c:525:	if (inode->i_nlink != 2)
dafs_namei.c:527:				inode->i_ino, inode->i_nlink, dir->i_ino);
dafs_namei.c:536:	/*inode->i_version++; */
dafs_namei.c:538:	inode->i_ctime = dir->i_ctime;
dafs_namei.c:540:	if (dir->i_nlink)
dafs_namei.c:568:    struct super_block *sb = dir->i_sb;
dafs_namei.c:585:	nova_dbgv("%s: %s\n", __func__, dentry->d_name.name);
dafs_namei.c:586:	nova_dbgv("%s: inode %llu, dir %lu\n", __func__, ino, dir->i_ino);
dafs_namei.c:591:					0, rdev, &dentry->d_name);
dafs_namei.c:611:    struct inode *old_inode = old_dentry->d_inode;
dafs_namei.c:612:    struct inode *new_inode = new_dentry->d_inode;
dafs_namei.c:613:    struct super_block *sb = old_inode->i_sb;
dafs_namei.c:621:    int err = -ENOMEM;
dafs_namei.c:630:			old_dentry->d_name.name, new_dentry->d_name.name);
dafs_namei.c:632:			__func__, S_ISDIR(old_inode->i_mode) ? "dir" : "normal",
dafs_namei.c:633:			old_inode->i_ino, old_dir->i_ino, new_dir->i_ino,
dafs_namei.c:634:			new_inode ? new_inode->i_ino : 0);
dafs_namei.c:639:        err = -ENOMEM;
dafs_namei.c:640:        if(S_ISDIR(old_inode->i_mode) && !dafs_empty_dir(new_inode))
dafs_namei.c:643:        if(S_ISDIR(old_inode->i_mode)){
dafs_namei.c:644:            err = -EMLINK;
dafs_namei.c:645:            if(new_dir->i_nlink >= NOVA_LINK_MAX)
dafs_namei.c:653:	if (S_ISDIR(old_inode->i_mode)) {
dafs_namei.c:654:		dec_link = -1;
dafs_namei.c:662:    if(S_ISDIR(old_inode->i_mode)){
dafs_namei.c:699:		new_inode->i_ctime = CURRENT_TIME;
dafs_namei.c:701:		if (S_ISDIR(old_inode->i_mode)) {
dafs_namei.c:702:			if (new_inode->i_nlink)
dafs_namei.c:705:		if (new_inode->i_nlink)
dafs_namei.c:725:    struct super_block *sb = child->d_inode->i_sb;
dafs_namei.c:731:        return ERR_PTR(-ENOENT);
dafs_namei.c:732:    ino = le64_to_cpu(de->ino);
dafs_namei.c:735:        inode = nova_iget(child->d_inode->i_sb, ino);
dafs_namei.c:737:        return ERR_PTR(-ENOENT);
zone.h:23:#define SIZE_DZT_BITMAP ((DAFS_DZT_ENTRIES_IN_BLOCK + 1 + BITS_PER_BYTE -1)/BITS_PER_BYTE)
zone.h:28:#define SIZE_OF_ZONE_BITMAP ((NR_DENTRY_IN_ZONE + BITS_PER_BYTE-1)/BITS_PER_BYTE)
zone.h:43:    const void *statemap; /*pointer to 2-bit map*/
zone.h:94:    struct dafs_dzt_entry dzt_entry[DAFS_DZT_ENTRIES_IN_BLOCK];      /*128-1 entries in BT block*/
zone.h:116:    struct hash_entry hash_entry[NR_HASH_ENTRIES]; /*dentry name-pos pairs*/
zone.h:144:* zone entries for copy-on-write Btree*/
ioctl.c:6: * Copyright 2015-2016 Regents of the University of California,
ioctl.c:7: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
ioctl.c:8: * Copyright 2012-2013 Intel Corporation
ioctl.c:9: * Copyright 2010-2011 Marco Stornelli <marco.stornelli@gmail.com>
ioctl.c:25:	struct address_space *mapping = filp->f_mapping;
ioctl.c:26:	struct inode    *inode = mapping->host;
ioctl.c:28:	struct super_block *sb = inode->i_sb;
ioctl.c:35:		return -EACCES;
ioctl.c:39:		flags = le32_to_cpu(pi->i_flags) & NOVA_FL_USER_VISIBLE;
ioctl.c:49:			ret = -EPERM;
ioctl.c:54:			ret = -EFAULT;
ioctl.c:58:		mutex_lock(&inode->i_mutex);
ioctl.c:59:		oldflags = le32_to_cpu(pi->i_flags);
ioctl.c:64:				mutex_unlock(&inode->i_mutex);
ioctl.c:65:				ret = -EPERM;
ioctl.c:70:		if (!S_ISDIR(inode->i_mode))
ioctl.c:75:		inode->i_ctime = CURRENT_TIME_SEC;
ioctl.c:86:		mutex_unlock(&inode->i_mutex);
ioctl.c:92:		return put_user(inode->i_generation, (int __user *)arg);
ioctl.c:96:			return -EPERM;
ioctl.c:101:			ret = -EFAULT;
ioctl.c:104:		mutex_lock(&inode->i_mutex);
ioctl.c:105:		inode->i_ctime = CURRENT_TIME_SEC;
ioctl.c:106:		inode->i_generation = generation;
ioctl.c:116:		mutex_unlock(&inode->i_mutex);
ioctl.c:142:		return -ENOTTY;
ioctl.c:163:		return -ENOIOCTLCMD;
remount-nova.sh:12:mount -t NOVA /dev/pmem0 /mnt/ramdisk
nova_def.h:8: * Copyright 2015-2016 Regents of the University of California,
nova_def.h:9: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
nova_def.h:10: * Copyright 2012-2013 Intel Corporation
nova_def.h:11: * Copyright 2009-2011 Marco Stornelli <marco.stornelli@gmail.com>
nova_def.h:14: * 2003-2004 (c) MontaVista Software, Inc. , Steve Longerbeam
nova_def.h:61:#define DAFS_BT_ENTRIES_IN_BLOCK 128-1
nova_def.h:94:	__le32	i_mtime;	/* Inode b-tree Modification time */
nova_def.h:100:	 * Blocks count. This field is updated in-place;
nova_def.h:164:#define NOVA_SB_STATIC_SIZE(ps) ((u64)&ps->s_start_dynamic - (u64)ps)
nova_def.h:185:#define CACHELINE_MASK  (~(CACHELINE_SIZE - 1))
nova_def.h:186:#define CACHELINE_ALIGN(addr) (((addr)+CACHELINE_SIZE-1) & CACHELINE_MASK)
nova_def.h:231:	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
wprotect.c:6: * Copyright 2015-2016 Regents of the University of California,
wprotect.c:7: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
wprotect.c:8: * Copyright 2012-2013 Intel Corporation
wprotect.c:9: * Copyright 2009-2011 Marco Stornelli <marco.stornelli@gmail.com>
wprotect.c:12: * 2003-2004 (c) MontaVista Software, Inc. , Steve Longerbeam
dafs_dir.c:27:    nr = radix_tree_gang_lookup(&ei->rf_root, (void **)entries, 0, NR_DENTRY_IN_ZONE);
dafs_dir.c:30:        key = rf_e->hash_name;
dafs_dir.c:31:        ret = radix_tree_delete(&ei->rf_root, key);
dafs_dir.c:44:    old_rf = radix_tree_delete(&ei->rf_root, hash_name);
dafs_dir.c:56:    new_rf->r_f = 0;
dafs_dir.c:57:    new_rf->sub_s = 0;
dafs_dir.c:58:    new_rf->f_s = 0;
dafs_dir.c:59:    new_rf->prio = LEVEL_0;
dafs_dir.c:60:    new_rf->hash_name = hash_name;
dafs_dir.c:61:    radix_tree_insert(&ei->rf_root, hash_name);
dafs_dir.c:69:    sub_rf = radix_tree_lookup(&dzt_ei->rf_root, sub_hash);
dafs_dir.c:71:        return -EINVAL;
dafs_dir.c:72:    sub_rf->r_f++;
dafs_dir.c:81:    sub_rf = radix_tree_lookup(&dzt_ei->rf_root, sub_hash);
dafs_dir.c:83:        return -EINVAL;
dafs_dir.c:84:    sub_rf->f_s = DENTRY_FREQUENCY_WRITE; 
dafs_dir.c:94:    old_rf = radix_tree_lookup(*src_ei->rf_root, old_hn);
dafs_dir.c:95:    new_rf->r_f = old_rf->r_f;
dafs_dir.c:106:    u64 num = ei->dzt_eno;
dafs_dir.c:108:    phlen = (u64)ei->root_len;
dafs_dir.c:112:        ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->pdz_addr);
dafs_dir.c:113:        de_pos = ei->rden_pos;
dafs_dir.c:114:        de = ze->dentry[de_pos];
dafs_dir.c:116:        memcpy(name, de->ful_name->f_name,de->ful_name->f_namelen+1);
dafs_dir.c:120:        num = le64_to_cpu(ze->dz_no);
dafs_dir.c:150:    //name = src_de->ful_name->f_name;
dafs_dir.c:152:    src_dz = src_ei->dzt_eno;
dafs_dir.c:164:        des_dz = dzt_ei->dzt_eno;
dafs_dir.c:166:        //des_name = des->ful_name->f_name;
dafs_dir.c:173:    test_and_set_bit_le(bitpos, dzt->bitmap);
dafs_dir.c:176:    dlog->type_d =  type;
dafs_dir.c:177:    dlog->src_dz_no = cpu_to_le64(src_dz);
dafs_dir.c:178:    dlog->src_hashname = cpu_to_le64(src_hn);
dafs_dir.c:179:    dlog->des_dz_no = cpu_to_le64(des_dz);
dafs_dir.c:180:    dlog->des_hashname = cpu_to_le64(des_hn);
dafs_dir.c:194:    test_and_clear_bit_le(bitpos, dzt_p->bitmap);
dafs_dir.c:202:    struct fs_struct *fs = current->fs;
dafs_dir.c:210:    read_lock(&fs->lock);
dafs_dir.c:211:    vfsmnt = mntget(fs->root.mnt);
dafs_dir.c:212:    read_unlock(&fs->lock);
dafs_dir.c:234:    struct dzt_manager dzt_m = sbi->dzt_m_info;
dafs_dir.c:244:        phlen = strlen(ph)-strlen(tem);
dafs_dir.c:251:        dzt_ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
dafs_dir.c:260:    dzt_ei = radix_tree_lookup(,&dzt_m->dzt_root,hashname);
dafs_dir.c:271:    struct inode *dir = dentry->d_parent->d_inode;
dafs_dir.c:272:    struct super_block *sb = dir->i_sb;
dafs_dir.c:274:    const char *name = dentry->d_name.name;
dafs_dir.c:275:    int namelen = dentry->d_name.len;
dafs_dir.c:292:				__func__, dir->i_ino, ino);
dafs_dir.c:297:		return -EINVAL;
dafs_dir.c:303:    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb,dzt_ei->dz_addr);
dafs_dir.c:305:    while(bitpos<zone_p->zone_max){
dafs_dir.c:306:        if(test_bit_le(bitpos, zone_p->statemap)||test_bit_le(bitpos+1, zone_p->statemap)){
dafs_dir.c:316:    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
dafs_dir.c:320:    dafs_de = dafs_ze->dentry[cur_pos];
dafs_dir.c:323:    dafs_de->entry_type = DAFS_DIR_ENTRY;
dafs_dir.c:324:    dafs_de->name_len = dentry->d_name.len;
dafs_dir.c:325:    dafs_de->file_type = 0;       //file_type是啥？ not decided
dafs_dir.c:327:    links_count = cpu_to_le16(dir->i_nlink);    
dafs_dir.c:328:	if (links_count == 0 && inc_link == -1)
dafs_dir.c:332:	dafs_de->links_count = cpu_to_le16(links_count);
dafs_dir.c:334:    //dafs_de->de_len = cpu_to_le16(delen);  
dafs_dir.c:335:    dafs_de->mtime = cpu_to_le32(dir->i_mtime.tv_sec);
dafs_dir.c:337:    dafs_de->vroot = 0;
dafs_dir.c:338:    //dafs_de->path_len =
dafs_dir.c:339:    dafs_de->ino = cpu_to_le64(ino);
dafs_dir.c:341:    dafs_de->par_ino = cpu_to_le64(dentry->d_parent->d_inode->ino);
dafs_dir.c:343:    nova_dbg_verbose("dir ino 0x%llu is subfile of parent ino 0x%llu ", dafs_de->ino, dafs_de->par_ino);
dafs_dir.c:345:    dafs_de->size = cpu_to_le64(dir->i_size);
dafs_dir.c:346:    dafs_de->zone_no = cpu_to_le64(dzt_ei->dzt_eno);
dafs_dir.c:347:    //dafs_de->prio = LEVEL_0;
dafs_dir.c:348:    //dafs_de->d_f = 0;
dafs_dir.c:349:    //dafs_de->sub_s = 0;
dafs_dir.c:350:    //dafs_de->f_s = 0;
dafs_dir.c:351:    dafs_de->sub_num = 0;
dafs_dir.c:352:    dafs_de->sub_pos[NR_DENTRY_IN_ZONE] = {0};
dafs_dir.c:354:    dafs_de->name[dentry->d_name.len] = '\0';
dafs_dir.c:355:    dafs_de->ful_name->f_namelen = cpu_to_le64(phlen);
dafs_dir.c:357:    memcpy(dafs->ful_name->f_name, phn, phlen+1);
dafs_dir.c:363:    test_and_set_bit_le(bitpos, zone_p->statemap);
dafs_dir.c:365:    dir->i_blocks = pidir->i_blocks;
dafs_dir.c:369:    ht_addr = dzt_ei->ht_head;
dafs_dir.c:402:    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
dafs_dir.c:404:    dzt_eno = dzt_ei->dzt_eno;
dafs_dir.c:409:    ht_addr = dzt_ei->ht_head;
dafs_dir.c:412:        return -EINVAL;
dafs_dir.c:413:    direntry = dafs_ze->dentry[de_pos];
dafs_dir.c:415:    if(update_flag &&(direntry->file_type!=ROOT_DIRECTORY))
dafs_dir.c:435:    struct dzt_manager *dzt_m = sbi->dzt_m_info;
dafs_dir.c:444:    //strcat(tem, dafs_ze->root_path);
dafs_dir.c:445:    if(dafs_de->file_type == ROOT_DIRECTORY){
dafs_dir.c:448:        d_hlen = le64_to_cpu(dafs_de->ful_name->f_namelen);
dafs_dir.c:449:        d_hn = BKDRHash(dafs_de->ful_name->f_name,d_hlen);
dafs_dir.c:453:        test_and_clear_bit_le(bitpos, zone_p->statemap);
dafs_dir.c:455:        test_and_clear_bit_le(bitpos, zone_p->statemap);
dafs_dir.c:456:        ret = make_invalid_htable(dzt_ei->ht_head, d_hn, d_hlen, 1);
dafs_dir.c:460:            return -EINVAL;
dafs_dir.c:462:        //dzt_rno = le64_to_cpu(dafs_de->dz_no);
dafs_dir.c:463:        //strcat(tem, dafs_de->ful_name->f_name);
dafs_dir.c:465:        //hashname = le64_to_cpu(dafs_de->hash_name);
dafs_dir.c:473:        hashname = le64_to_cpu(dafs_de->hash_name);
dafs_dir.c:474:        ei = radix_tree_delete(&dzt_m->dzt_root, hashname);
dafs_dir.c:475:        dzt_rno = ei->dzt_eno;
dafs_dir.c:476:        tail = le64_to_cpu(ei->ht_head);
dafs_dir.c:479:            tem = le64_to_cpu(ht->hash_tail);
dafs_dir.c:484:        test_and_clear_bit_le(dzt_rno, dzt_p->bitmap);
dafs_dir.c:486:        dafs_free_zone_blocks(sb, ei, ei->dz_addr >> PAGE_SHIFT, 1);
dafs_dir.c:492:            if(test_bit_le(par_pos, z_p->statemap)||test_bit_le(par_pos+1, z_p->statemap)){
dafs_dir.c:493:                pde = dafs_ze->dentry[par_id];
dafs_dir.c:494:                if(dafs_de->par_ino == pde->ino){
dafs_dir.c:496:                    for(j=0; j<pde->sub_num, j++){
dafs_dir.c:497:                        if(pde->sub_pos[j] = de_pos){
dafs_dir.c:500:                                pde->sub_pos[j] = pde->sub_pos[k];
dafs_dir.c:504:                            pde->sub_pos[j] = 0;
dafs_dir.c:507:                    pde->sub_num--;
dafs_dir.c:515:    }else if(dafs_de->file_type == NORMAL_DIRECTORY){
dafs_dir.c:517:        for(i=0;i<dafs_de->sub_num;i++){
dafs_dir.c:518:            sub_id = dafs_de->sub_pos[i];
dafs_dir.c:519:            sde = dafs_ze->dentry[sub_id];
dafs_dir.c:524:        d_hlen = le64_to_cpu(dafs_de->ful_name->f_namelen);
dafs_dir.c:525:        d_hn = BKDRHash(dafs_de->ful_name->f_name);
dafs_dir.c:529:        test_and_clear_bit_le(bitpos, z_p->statemap);
dafs_dir.c:531:        test_and_clear_bit_le(bitpos, z_p->statemap);
dafs_dir.c:532:        ret = make_invalid_htable(dzt_ei->ht_head, d_hn, d_hlen, 1);
dafs_dir.c:537:            return -EINVAL;
dafs_dir.c:542:            if(test_bit_le(par_pos, z_p->statemap)||test_bit_le(par_pos+1, z_p->statemap)){
dafs_dir.c:543:                pde = dafs_ze->dentry[par_id];
dafs_dir.c:544:                if(dafs_de->par_ino == pde->ino){
dafs_dir.c:546:                    for(j=0; j<pde->sub_num, j++){
dafs_dir.c:547:                        if(pde->sub_pos[j] = de_pos){
dafs_dir.c:550:                                pde->sub_pos[j] = pde->sub_pos[k];
dafs_dir.c:554:                            pde->sub_pos[j] = 0;
dafs_dir.c:557:                    pde->sub_num --;
dafs_dir.c:568:        d_hlen = le64_to_cpu(dafs_de->ful_name->f_namelen);
dafs_dir.c:569:        d_hn = BKDRHash(dafs_de->ful_name->f_name, d_hlen);
dafs_dir.c:573:        test_and_clear_bit_le(bitpos, z_p->statemap);
dafs_dir.c:575:        test_and_clear_bit_le(bitpos, z_p->statemap);
dafs_dir.c:576:        ret = make_invalid_htable(dzt_ei->ht_head, d_hn, d_hlen, 1);
dafs_dir.c:580:            return -EINVAL;
dafs_dir.c:585:            if(test_bit_le(par_pos, z_p->statemap)||test_bit_le(par_pos+1, z_p->statemap)){
dafs_dir.c:586:                pde = dafs_ze->dentry[par_id];
dafs_dir.c:587:                if(dafs_de->par_ino == pde->ino){
dafs_dir.c:589:                    for(j=0; j<pde->sub_num, j++){
dafs_dir.c:590:                        if(pde->sub_pos[j] = de_pos){
dafs_dir.c:593:                                pde->sub_pos[j] = pde->sub_pos[k];
dafs_dir.c:597:                            pde->sub_num[j] = 0;
dafs_dir.c:600:                    pde->sub_num--;
dafs_dir.c:621:    struct inode *dir = dentry->d_parent->d_inode;
dafs_dir.c:622:    struct super_block *sb = dir->i_sb;
dafs_dir.c:624:    //struct nova_inode_info_header *sih = &si->header;
dafs_dir.c:626:    //struct qstr *entry = &dentry->d_name;
dafs_dir.c:632:    struct dzt_manager *dzt_m = sbi->dzt_m_info;
dafs_dir.c:647:	if (!dentry->d_name.len)
dafs_dir.c:648:		return -EINVAL;
dafs_dir.c:652:	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
dafs_dir.c:661:    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
dafs_dir.c:663:    dzt_eno = dzt_ei->dzt_eno;
dafs_dir.c:667:    ret = lookup_in_hashtable(dzt_ei->ht_head, ph_hash, phlen, 1, &de_pos);
dafs_dir.c:669:        return -EINVAL;
dafs_dir.c:671:    dafs_de = dafs_ze->dentry[de_pos];
dafs_dir.c:673:    if(dafs_de->file_type == ROOT_DIRECTORY) {
dafs_dir.c:674:        ei_hash = le64_to_cpu(dafs_de->dzt_hn);
dafs_dir.c:675:        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
dafs_dir.c:681:    test_and_clear_bit_le(bitpos, z_p->statemap);
dafs_dir.c:683:    test_and_clear_bit_le(bitpos, z_p->statemap);
dafs_dir.c:684:    make_invalid_htable(dzt_ei->ht_head, ph_hash, phlen, 1);
dafs_dir.c:708:    struct inode *dir = dentry->d_parent->d_inode;
dafs_dir.c:709:    struct super_block *sb = dir->i_sb;
dafs_dir.c:711:    //struct nova_inode_info_header *sih = &si->header;
dafs_dir.c:713:    //struct qstr *entry = &dentry->d_name;
dafs_dir.c:719:    struct dzt_manager *dzt_m = sbi->dzt_m_info;
dafs_dir.c:734:	if (!dentry->d_name.len)
dafs_dir.c:735:		return -EINVAL;
dafs_dir.c:739:	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
dafs_dir.c:748:    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
dafs_dir.c:750:    dzt_eno = dzt_ei->dzt_eno;
dafs_dir.c:754:    ret = lookup_in_hashtable(dzt_ei->ht_head, ph_hash, phlen, 1, &de_pos);
dafs_dir.c:756:        return -EINVAL;
dafs_dir.c:758:    dafs_de = dafs_ze->dentry[de_pos];
dafs_dir.c:795:    if (pi->log_head) {
dafs_dir.c:797:				__func__, pi->log_head);
dafs_dir.c:798:		return - EINVAL;
dafs_dir.c:803:		return - ENOMEM;
dafs_dir.c:806:	pi->log_tail = pi->log_head = new_block;
dafs_dir.c:807:	pi->i_blocks = 1;
dafs_dir.c:808:	nova_flush_buffer(&pi->log_head, CACHELINE_SIZE, 0);
dafs_dir.c:818:    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
dafs_dir.c:821:    ret = lookup_in_hashtable(dzt_ei->ht_head, phhash, phlen, 1, &depos);
dafs_dir.c:823:        return -EINVAL;
dafs_dir.c:824:    dafs_rde = dafs_ze->dentry[depos];
dafs_dir.c:830:    while(bitpos<zone_p->zone_max){
dafs_dir.c:831:        if(test_bit_le(bitpos, zone_p->statemap)||test_bit_le(bitpos+1, zone_p->statemap)){
dafs_dir.c:839:    dafs_de = dafs_ze->dentry[cur_pos];
dafs_dir.c:840:    dafs_de->entry_type = DAFS_DIR_ENTRY;
dafs_dir.c:842:    dafs_de->file_type = FIXED_FILE;
dafs_dir.c:843:    dafs_de->name_len = 1;
dafs_dir.c:844:    dafs_de->links_count = 1;
dafs_dir.c:845:    //dafs_de->de_len = cpu_to_le16(delen);
dafs_dir.c:846:    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
dafs_dir.c:847:    //dafs_de->size = sb->s_blocksize;
dafs_dir.c:848:    dafs_de->vroot = 0;
dafs_dir.c:849:    dafs_de->ino = cpu_to_le64(self_ino);
dafs_dir.c:851:    dafs_de->parent_ino = cpu_to_le64(self_ino);
dafs_dir.c:852:    dafs_de->size = sb->s_blocksize;
dafs_dir.c:853:    dafs_de->zone_no = cpu_to_le64(dzt_ei->dzt_eno);
dafs_dir.c:854:    strncpy(dafs_de->name, ".\0", 2);
dafs_dir.c:855:    dafs_de->ful_name->f_namelen = cpu_to_le64(phlen + 2);
dafs_dir.c:857:    memcpy(dafs_de->ful_name->f_name, phn, phlen+3);
dafs_dir.c:858:    //dafs_de->ful_name->f_name = phn;
dafs_dir.c:863:    dafs_rde->sub_num +=1;
dafs_dir.c:864:    dafs_rde->sub_pos[0] = cpu_to_le64(cur_pos);
dafs_dir.c:868:    test_and_set_bit_le(bitpos, zone_p->statemap);
dafs_dir.c:872:    record_pos_htable(sb, dzt_ei->ht_head, hashname, h_len, cur_pos, 1);
dafs_dir.c:878:    while(bitpos<zone_p->zone_max){
dafs_dir.c:879:        if(test_bit_le(bitpos, zone_p->statemap)||test_bit_le(bitpos+1, zone_p->statemap)){
dafs_dir.c:887:    dafs_de = dafs_ze->dentry[cur_pos];
dafs_dir.c:888:    dafs_de->entry_type = DAFS_DIR_ENTRY;
dafs_dir.c:890:    dafs_de->file_type = FIXED_FILE;
dafs_dir.c:891:    dafs_de->name_len = 2;
dafs_dir.c:892:    dafs_de->links_count = 2;
dafs_dir.c:893:    //dafs_de->de_len = cpu_to_le16(delen);
dafs_dir.c:894:    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
dafs_dir.c:895:    //dafs_de->size = sb->s_blocksize;
dafs_dir.c:896:    dafs_de->vroot = 0;
dafs_dir.c:897:    dafs_de->ino = cpu_to_le64(parent_ino);
dafs_dir.c:899:    dafs_de->parent_ino = cpu_to_le64(self_ino);
dafs_dir.c:900:    dafs_de->size = sb->s_blocksize;
dafs_dir.c:901:    dafs_de->zone_no = cpu_to_le64(dzt_ei->dzt_eno);
dafs_dir.c:902:    strncpy(dafs_de->name, "..\0", 3);
dafs_dir.c:903:    dafs_de->ful_name->f_namelen = cpu_to_le64(phlen + 3);
dafs_dir.c:905:    memcpy(dafs_de->ful_name->f_name, phn, phlen+4)
dafs_dir.c:906:    //dafs_de->ful_name->f_name = phn;
dafs_dir.c:910:    dafs_rde->sub_num +=1;
dafs_dir.c:911:    dafs_rde->sub_pos[1] = cpu_to_le64(cur_pos);
dafs_dir.c:915:    test_and_set_bit_le(bitpos, zone_p->statemap);
dafs_dir.c:918:    record_pos_htable(sb, dzt_ei->ht_head, hashname, h_len, cur_pos, 1);
dafs_dir.c:932:    struct super_block *sb = inode->i_sb;
dafs_dir.c:949:    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
dafs_dir.c:951:    dzt_eno = dzt_ei->dzt_eno;
dafs_dir.c:957:    ret = lookup_in_hashtable(dzt_ei->ht_head, ph_hash, phlen, 1, &de_pos);
dafs_dir.c:959:        return -EINVAL;
dafs_dir.c:961:    direntry = dafs_ze->dentry[de_pos];
dafs_dir.c:963:    nr_de = direntry->sub_num;
dafs_dir.c:968:        de_pos = direntry->sub_pos[i];
dafs_dir.c:969:        denties[i] = dafs_ze->dentry[de_pos];
dafs_dir.c:982:    struct inode *dir = dentry->d_parent->d_inode;
dafs_dir.c:983:    struct super_block *sb = dir->i_sb;
dafs_dir.c:985:    const char *name = dentry->d_name.name;
dafs_dir.c:986:    int namelen = dentry->d_name.len;
dafs_dir.c:1002:				__func__, dir->i_ino, ino);
dafs_dir.c:1007:		return -EINVAL;
dafs_dir.c:1014:    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
dafs_dir.c:1017:    while(bitpos<zone_p->zone_max){
dafs_dir.c:1018:        if(test_bit_le(bitpos, zone_p->statemap)||test_bit_le(bitpos+1, zone_p->statemap)){
dafs_dir.c:1028:    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
dafs_dir.c:1032:    dafs_de = dafs_ze->dentry[cur_pos];
dafs_dir.c:1035:    dafs_de->entry_type = DAFS_DIR_ENTRY;
dafs_dir.c:1036:    dafs_de->name_len = dentry->d_name.len;
dafs_dir.c:1037:    dafs_de->file_type = ROOT_DIRECTORY;       //file_type是啥？ not decided
dafs_dir.c:1039:	dafs_de->links_count = old_de->links_count;
dafs_dir.c:1041:    //dafs_de->de_len = cpu_to_le16(delen);  
dafs_dir.c:1042:    dafs_de->mtime = cpu_to_le32(dir->i_mtime.tv_sec);
dafs_dir.c:1044:    dafs_de->vroot = 1;
dafs_dir.c:1045:    //dafs_de->path_len =
dafs_dir.c:1046:    dafs_de->ino = old_de->ino;
dafs_dir.c:1048:    dafs_de->par_ino = cpu_to_le64(dentry->d_parent->d_inode->ino);
dafs_dir.c:1050:    nova_dbg_verbose("dir ino 0x%llu is subfile of parent ino 0x%llu ", dafs_de->ino, dafs_de->par_ino);
dafs_dir.c:1052:    dafs_de->size = cpu_to_le64(dir->i_size);
dafs_dir.c:1053:    //dafs_de->zone_no = old_de->dz_no;
dafs_dir.c:1054:    //dafs_de->prio = old_de->prio;
dafs_dir.c:1055:    //dafs_de->d_f = old_de->d_f;
dafs_dir.c:1056:    //dafs_de->sub_s = old_de->sub_s;
dafs_dir.c:1057:    //dafs_de->f_s = old_de->f_s;
dafs_dir.c:1058:    dafs_de->sub_num = old->sub_num;
dafs_dir.c:1059:    dafs_de->sub_pos[NR_DENTRY_IN_ZONE] = {0};
dafs_dir.c:1061:    dafs_de->name[dentry->d_name.len] = '\0';
dafs_dir.c:1062:    dafs_de->ful_name->f_namelen = cpu_to_le64(phlen);
dafs_dir.c:1064:    memcpy(dafs_de->ful_name->f_name, phn, phlen);
dafs_dir.c:1065:    //dafs_de->ful_name->f_name = phn;
dafs_dir.c:1068:    if(dzt_ei->eno!=1){
dafs_dir.c:1069:        newp_len =(u64)dzt_ei->root_len + phlen;
dafs_dir.c:1084:    dafs_de->dzt_hn = cpu_to_le64(*new_hn);
dafs_dir.c:1091:    test_and_set_bit_le(bitpos, zone_p->statemap);
dafs_dir.c:1093:    dir->i_blocks = pidir->i_blocks;
dafs_dir.c:1097:    record_pos_htable(sb, dzt_ei->ht_head, hashname, phlen, cur_pos, 1);
dafs_dir.c:1120:    struct dzt_manager *dzt_m = sbi->dzt_m_info;
dafs_dir.c:1129:    ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
dafs_dir.c:1132:    sub_num = le64_to_cpu(src_de->sub_num);
dafs_dir.c:1134:    //src_ph = src_de->ful_name->f_name;
dafs_dir.c:1135:    //s_ph = src_de->name;
dafs_dir.c:1137:    //phlen = strlen(src_ph)-strlen(o_name);
dafs_dir.c:1145:    while(bitpos<z_p->zone_max){
dafs_dir.c:1146:        if(test_bit_le(bitpos, z_p->statemap)||test_bit_le(bitpos+1, z_p->statemap)){
dafs_dir.c:1153:    new_de = ze->dentry[dir_pos]; 
dafs_dir.c:1155:    new_de->entry_type = src_de->entry_type;
dafs_dir.c:1156:    new_de->name_len = strlen(name);
dafs_dir.c:1157:    new_de->file_type = src_de->file_type;       //file_type是啥？ not decided
dafs_dir.c:1158:	new_de->links_count = src_de->links_count;
dafs_dir.c:1159:    //new_de->de_len = cpu_to_le16(delen);  
dafs_dir.c:1160:    new_de->mtime = cpu_to_le32(CURRENT_TIME_SEC);
dafs_dir.c:1161:    new_de->vroot = src_de->vroot;
dafs_dir.c:1162:    new_de->ino = src_de->ino;
dafs_dir.c:1164:    new_de->par_ino = src_de->par_ino;
dafs_dir.c:1166:    nova_dbg_verbose("dir ino 0x%llu is subfile of parent ino 0x%llu ", new_de->ino, new_de->par_ino);
dafs_dir.c:1168:    new_de->size = src_de->size;
dafs_dir.c:1169:    //new_de->zone_no = ze->dz_no;
dafs_dir.c:1170:    //new_de->prio = src_de->prio;
dafs_dir.c:1171:    //new_de->d_f = src_de->d_f + 1;
dafs_dir.c:1172:    //new_de->sub_s = src_de->sub_s;
dafs_dir.c:1173:    //new_de->f_s = DENTRY_FREQUENCY_WRITE;
dafs_dir.c:1174:    new_de->sub_num = src_de->sub_num;
dafs_dir.c:1175:    new_de->sub_pos[NR_DENTRY_IN_ZONE] = {0};
dafs_dir.c:1177:    memcpy(new_de->name, name, strlen(name)+1);
dafs_dir.c:1178:    //new_de->name[str(name)] = name;
dafs_dir.c:1179:    new_de->ful_name->f_namelen = cpu_to_le64(strlen(new_ph));
dafs_dir.c:1181:    memcpy(new_de->ful_name->f_name, new_ph, strlen(new_ph)+1);
dafs_dir.c:1182:    //new_de->ful_name->f_name = new_ph;
dafs_dir.c:1188:    test_and_set_bit_le(bitpos, z_p->statemap);
dafs_dir.c:1191:    record_pos_htable(sb, dzt_ei->ht_head, hashname, strlen(new_ph), dir_pos, 1);
dafs_dir.c:1196:    new_rf->f_s = DENTRY_FREQUENCY_WRITE;
dafs_dir.c:1199:        return -EINVAL;
dafs_dir.c:1204:        sub_len = le64_to_cpu(sub_de->name_len);
dafs_dir.c:1206:        s_pos = src_de->sub_pos[i];
dafs_dir.c:1207:        sub_de = ze->dentry[s_pos];
dafs_dir.c:1208:        memcpy(s_name, sub_de->name, sub_len+1);
dafs_dir.c:1209:        //s_name = sub_de->name;
dafs_dir.c:1219:        if(sub_de->file_type == NORMAL_DIRECTORY){
dafs_dir.c:1225:            while(bitpos<z_p->zone_max){
dafs_dir.c:1226:                if(test_bit_le(bitpos, z_p->statemap)||test_bit_le(bitpos+1, z_p->statemap)){
dafs_dir.c:1233:            new_de = ze->dentry[dir_pos]; 
dafs_dir.c:1235:            new_de->entry_type = sub_de->entry_type;
dafs_dir.c:1236:            new_de->name_len = sub_de->name_len;
dafs_dir.c:1237:            new_de->file_type = sub_de->file_type;       //file_type是啥？ not decided
dafs_dir.c:1238:	        new_de->links_count = sub_de->links_count;
dafs_dir.c:1239:            //new_de->de_len = cpu_to_le16(delen);  
dafs_dir.c:1240:            new_de->mtime = cpu_to_le32(CURRENT_TIME_SEC);
dafs_dir.c:1241:            new_de->vroot = sub_de->vroot;
dafs_dir.c:1242:            new_de->ino = sub_de->ino;
dafs_dir.c:1244:            new_de->par_ino = sub_de->par_ino;
dafs_dir.c:1246:            nova_dbg_verbose("dir ino 0x%llu is subfile of parent ino 0x%llu ", new_de->ino, new_de->par_ino);
dafs_dir.c:1248:            new_de->size = sub_de->size;
dafs_dir.c:1249:            //new_de->zone_no = ze->dz_no;
dafs_dir.c:1250:            //new_de->prio = sub_de->prio;
dafs_dir.c:1251:            //new_de->d_f = sub_de->d_f + 1;
dafs_dir.c:1252:            //new_de->sub_s = sub_de->sub_s;
dafs_dir.c:1253:            //new_de->f_s = DENTRY_FREQUENCY_WRITE;
dafs_dir.c:1254:            new_de->sub_num = sub_de->sub_num;
dafs_dir.c:1255:            new_de->sub_pos[NR_DENTRY_IN_ZONE] = {0};
dafs_dir.c:1257:            memcpy(new_de->name, sub_de->name, sub_len+1);
dafs_dir.c:1258:            //new_de->name[strlen(s_name)] = sub_de->name;
dafs_dir.c:1259:            new_de->ful_name->f_namelen = cpu_to_le64(strlen(sub_ph));
dafs_dir.c:1261:            memcpy(new_de->ful_name->f_name, sub_ph, strlen(sub_ph)+1);
dafs_dir.c:1262:            //new_de->ful_name->f_name = sub_ph;
dafs_dir.c:1265:            if(new_de->file_type==ROOT_DIRECTORY) {
dafs_dir.c:1266:                dzt_hn = le64_to_cpu(sub_de->dzt_hn);
dafs_dir.c:1267:                ch_ei = radix_tree_delete(&dzt_m->dzt_root, dzt_hn);
dafs_dir.c:1268:                if(dzt_ei->dzt_eno!=1) {
dafs_dir.c:1269:                    ch_len =(u64)dzt_ei->root_len + strlen(sub_ph);
dafs_dir.c:1278:                ch_ei->root_len = (u32)ch_len;
dafs_dir.c:1279:                ch_ei->hash_name = dzt_hn;
dafs_dir.c:1280:                radix_tree_insert(&dzt_m->dzt_root, dzt_hn);
dafs_dir.c:1281:                radix_tree_tag_set(&dzt_m->dzt_root, dzt_hn, 1);
dafs_dir.c:1283:                new_de->dzt_hn = cpu_to_le64(dzt_hn);
dafs_dir.c:1285:                new_de->dzt_hn = sub_de->dzt_hn;
dafs_dir.c:1292:            test_and_set_bit_le(bitpos, z_p->statemap);
dafs_dir.c:1294:            record_pos_htable(sb, dzt_ei->ht_head, hashname, strlen(sub_ph), dir_pos, 1);
dafs_dir.c:1300:            new_rf->f_s = DENTRY_FREQUENCY_WRITE;
dafs_dir.c:1315:    struct super_block *sb = o_dentry->d_sb;
dafs_dir.c:1328:    o_ze = cpu_to_le64(o_ei->dz_addr);*/
dafs_dir.c:1335:    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
dafs_dir.c:1337:    n_name = n_dentry->d_name.name;
dafs_dir.c:1352:    struct super_block *sb = old_dentry->d_sb;
dafs_dir.c:1357:    struct inode *new_inode = new_dentry->d_inode;
dafs_dir.c:1358:    struct inode *old_inode = old_dentry->d_inode;
dafs_dir.c:1360:    struct dzt_manager *dzt_m = sbi->dzt_m_info;
dafs_dir.c:1363:    int err = -ENOENT;
dafs_dir.c:1366:    //dz_no = le64_to_cpu(old_de->zone_no);
dafs_dir.c:1367:    if(old_de->file_type == ROOT_DIRECTORY){
dafs_dir.c:1368:        old_hn = le64_to_cpu(old_de->hash_name);
dafs_dir.c:1369:        ch_ei = radix_tree_delete(&dzt_m->dzt_root, old_hn);
dafs_dir.c:1374:        ch_ei->root_len = (u32)root_len;
dafs_dir.c:1375:        ch_ei->hash_name = new_hn;
dafs_dir.c:1377:        radix_tree_insert(&dzt_m->dzt_root, new_hn);
dafs_dir.c:1378:        radix_tree_tag_set(&dzt_m->dzt_root, new_hn, 1);
dafs_dir.c:1380:        old_de->file_type = NORMAL_FILE;
dafs_dir.c:1395:    struct super_block *sb = old_dentry->d_sb;
dafs_dir.c:1401:    char *n_phname, *name=new_dentry->d_name.name, *phname, *ph, *phn;
dafs_dir.c:1403:    int namelen = new_dentry->d_name.len;
dafs_dir.c:1415:    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
dafs_dir.c:1418:    while(bitpos<z_p->zone_max){
dafs_dir.c:1419:        if(test_bit_le(bitpos, z_p->statemap)||test_bit_le(bitpos+1, z_p->statemap)){
dafs_dir.c:1429:    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
dafs_dir.c:1433:    dafs_de = n_ze->dentry[cur_pos];
dafs_dir.c:1436:    dafs_de->entry_type = DAFS_DIR_ENTRY;
dafs_dir.c:1437:    dafs_de->name_len = dentry->d_name.len;
dafs_dir.c:1438:    dafs_de->file_type = o_de->file_type;       //file_type是啥？ not decided
dafs_dir.c:1440:	dafs_de->links_count = o_de->links_count;
dafs_dir.c:1442:    //dafs_de->de_len = cpu_to_le16(de_len);  
dafs_dir.c:1443:    dafs_de->mtime = cpu_to_le32(CURRENT_TIME_SEC);
dafs_dir.c:1445:    dafs_de->vroot = 0;
dafs_dir.c:1446:    //dafs_de->path_len =
dafs_dir.c:1447:    dafs_de->ino = o_de->ino;
dafs_dir.c:1449:    dafs_de->par_ino = o_de->par_ino;
dafs_dir.c:1451:    nova_dbg_verbose("dir ino 0x%llu is subfile of parent ino 0x%llu ", dafs_de->ino, dafs_de->par_ino);
dafs_dir.c:1453:    dafs_de->size = o_de->size;
dafs_dir.c:1454:    dafs_de->zone_no = n_ze->dz_no;
dafs_dir.c:1455:    //dafs_de->prio = o_de->prio;
dafs_dir.c:1456:    //dafs_de->d_f = o_de->d_f;
dafs_dir.c:1457:    //dafs_de->sub_s = o_de->sub_s;
dafs_dir.c:1458:    //dafs_de->f_s = DENTRY_FREQUENCY_WRITE;
dafs_dir.c:1459:    dafs_de->sub_num = 0;
dafs_dir.c:1460:    dafs_de->sub_pos[NR_DENTRY_IN_ZONE] = {0};
dafs_dir.c:1462:    memcpy(dafs_de->name, name, (dentry->d_name.len) +1);
dafs_dir.c:1463:    //dafs_de->name[namelen] = name;
dafs_dir.c:1464:    dafs_de->ful_name->f_namelen = cpu_to_le64(phlen);
dafs_dir.c:1466:    memcpy(dafs_de->ful_name->f_name, phn, phlen+1);
dafs_dir.c:1467:    //dafs_de->ful_name->f_name = phn;
dafs_dir.c:1473:    test_and_set_bit_le(bitpos, z_p->statemap);
dafs_dir.c:1476:    dir->i_blocks = pidir->i_blocks;
dafs_dir.c:1480:    record_pos_htable(sb, n_ei->ht_addr, hashname, phlen, cur_pos, 1);
dafs_dir.c:1484:    new_rf->f_s = DENTRY_FREQUENCY_WRITE;
dafs_dir.c:1498:    struct super_block *sb = inode->i_sb;
dafs_dir.c:1501:    struct dentry *dentry = file->f_path.dentry; 
dafs_dir.c:1519:			__func__, (u64)inode->i_ino,
dafs_dir.c:1520:			pidir->i_size, ctx->pos);
dafs_dir.c:1531:        nova_err("ei with dentry %lu not exist!\n", dentry->d_inode->i_ino);
dafs_dir.c:1536:    ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
dafs_dir.c:1539:    sub_num = le64_to_cpu(f_de->sub_num);
dafs_dir.c:1541:    pos = ctx->pos;
dafs_dir.c:1548:        pos = f_de->sub_pos[n];
dafs_dir.c:1550:            ctx->pos = READDIR_END;
dafs_dir.c:1554:        de = ze->dentry[pos];
dafs_dir.c:1559:            return -EINVAL;
dafs_dir.c:1564:			de->entry_type, le64_to_cpu(de->ino),
dafs_dir.c:1565:			de->name, de->name_len,
dafs_dir.c:1568:        if(de->ino>0){
dafs_dir.c:1569:            ino = __le64_to_cpu(de->ino);
dafs_dir.c:1574:				ctx->pos = READDIR_END;
dafs_dir.c:1581:				(u64)ino, de->name, de->name_len,
dafs_dir.c:1583:			if (!dir_emit(ctx, de->name,
dafs_dir.c:1584:				de->name_len, ino,
dafs_dir.c:1585:				IF2DT(le16_to_cpu(_child_pi->i_mode)))) {
dafs_dir.c:1586:				nova_dbgv("Here: pos %llu\n", ctx->pos);
dafs_dir.c:1591:        ctx->pos = pos;
sysfs.c:6: * Copyright 2015-2016 Regents of the University of California,
sysfs.c:7: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
sysfs.c:8: * Copyright 2012-2013 Intel Corporation
sysfs.c:9: * Copyright 2009-2011 Marco Stornelli <marco.stornelli@gmail.com>
sysfs.c:12: * 2003-2004 (c) MontaVista Software, Inc. , Steve Longerbeam
sysfs.c:78:		sbi->s_proc = proc_mkdir(sbi->s_bdev->bd_disk->disk_name,
sysfs.c:81:	if (sbi->s_proc) {
sysfs.c:82:		proc_create_data("timing_stats", S_IRUGO, sbi->s_proc,
sysfs.c:91:	remove_proc_entry("timing_stats", sbi->s_proc);
sysfs.c:92:	remove_proc_entry(sbi->s_bdev->bd_disk->disk_name, nova_proc_root);
tags:1:!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
tags:295:dzt_entry	zone.h	/^    struct dafs_dzt_entry dzt_entry[DAFS_DZT_ENTRIES_IN_BLOCK];      \/*128-1 entries in BT block*\/$/;"	m	struct:dafs_dzt_block	typeref:struct:dafs_dzt_block::dafs_dzt_entry
tags:360:hash_entry	zone.h	/^    struct hash_entry hash_entry[NR_HASH_ENTRIES]; \/*dentry name-pos pairs*\/$/;"	m	struct:hash_table	typeref:struct:hash_table::hash_entry
tags:389:i_mtime	nova_def.h	/^	__le32	i_mtime;	\/* Inode b-tree Modification time *\/$/;"	m	struct:nova_inode
tags:477:nova-y	Makefile	/^nova-y := balloc.o bbuild.o dax.o dir.o file.o inode.o ioctl.o journal.o namei.o stats.o super.o symlink.o sysfs.o wprotect.o$/;"	m
tags:841:s_lock	nova.h	/^	struct mutex 	s_lock;	\/* protects the SB's buffer-head *\/$/;"	m	struct:nova_sb_info	typeref:struct:nova_sb_info::mutex
tags:874:statemap	zone.h	/^    const void *statemap; \/*pointer to 2-bit map*\/$/;"	m	struct:zone_ptr
journal.c:7: * Copyright 2015-2016 Regents of the University of California,
journal.c:8: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
journal.c:9: * Copyright 2012-2013 Intel Corporation
journal.c:10: * Copyright 2009-2011 Marco Stornelli <marco.stornelli@gmail.com>
journal.c:23: * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
journal.c:44:	if ((curr_p & (PAGE_SIZE - 1)) + size >= PAGE_SIZE)
journal.c:81:				i, entry->addrs[i], entry->values[i]);
journal.c:95:	if (!pair || pair->journal_head == 0 ||
journal.c:96:			pair->journal_head != pair->journal_tail)
journal.c:99:	temp = pair->journal_head;
journal.c:115:	pair->journal_tail = new_tail;
journal.c:116:	nova_flush_buffer(&pair->journal_head, CACHELINE_SIZE, 1);
journal.c:126:	if (!pair || pair->journal_tail != tail)
journal.c:129:	pair->journal_head = tail;
journal.c:130:	nova_flush_buffer(&pair->journal_head, CACHELINE_SIZE, 1);
journal.c:140:		type = entry->addrs[i] >> 56;
journal.c:141:		if (entry->addrs[i] && type) {
journal.c:143:			nova_recover_lite_journal_entry(sb, entry->addrs[i],
journal.c:144:					entry->values[i], type);
journal.c:156:							pair->journal_head);
journal.c:160:		temp = next_lite_journal(pair->journal_head);
journal.c:166:	pair->journal_tail = pair->journal_head;
journal.c:167:	nova_flush_buffer(&pair->journal_head, CACHELINE_SIZE, 1);
journal.c:179:	sbi->journal_locks = kzalloc(sbi->cpus * sizeof(spinlock_t),
journal.c:181:	if (!sbi->journal_locks)
journal.c:182:		return -ENOMEM;
journal.c:184:	for (i = 0; i < sbi->cpus; i++)
journal.c:185:		spin_lock_init(&sbi->journal_locks[i]);
journal.c:187:	for (i = 0; i < sbi->cpus; i++) {
journal.c:189:		if (pair->journal_head == pair->journal_tail)
journal.c:193:		temp = next_lite_journal(pair->journal_head);
journal.c:194:		if (pair->journal_tail == temp) {
journal.c:200:		if (pair->journal_tail == temp) {
journal.c:208:				pair->journal_head, pair->journal_tail);
journal.c:209:		return -EINVAL;
journal.c:228:	for (i = 0; i < sbi->cpus; i++) {
journal.c:231:			return -EINVAL;
journal.c:237:			return -ENOSPC;
journal.c:240:		pair->journal_head = pair->journal_tail = block;
stats.h:4: * Copyright 2015-2016 Regents of the University of California,
stats.h:5: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
stats.h:18: * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
stats.h:132:			(end.tv_sec - start.tv_sec) * 1000000000 + \
stats.h:133:			(end.tv_nsec - start.tv_nsec)); \
wprotect.h:6: * Copyright 2015-2016 Regents of the University of California,
wprotect.h:7: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
wprotect.h:8: * Copyright 2012-2013 Intel Corporation
wprotect.h:9: * Copyright 2009-2011 Marco Stornelli <marco.stornelli@gmail.com>
wprotect.h:12: * 2003-2004 (c) MontaVista Software, Inc. , Steve Longerbeam
wprotect.h:32:	ps->s_wtime = cpu_to_le32(get_seconds());
wprotect.h:33:	ps->s_sum = 0;
wprotect.h:35:			NOVA_SB_STATIC_SIZE(ps) - sizeof(__le16));
wprotect.h:36:	ps->s_sum = cpu_to_le16(crc);
wprotect.h:48:	pi->i_sum = 0;
wprotect.h:49:	crc = crc16(~0, (__u8 *)pi + sizeof(__le16), NOVA_INODE_SIZE -
wprotect.h:51:	pi->i_sum = cpu_to_le16(crc);
wprotect.h:61:	struct nova_sb_info *sbi = (struct nova_sb_info *)sb->s_fs_info;
wprotect.h:63:	return sbi->s_mount_opt & NOVA_MOUNT_PROTECT;
wprotect.h:137:		__nova_memunlock_range(bp, sb->s_blocksize);
wprotect.h:143:		__nova_memlock_range(bp, sb->s_blocksize);
.git/info/exclude:1:# git ls-files --others --exclude-from=.git/info/exclude
.git/hooks/applypatch-msg.sample:4:# applypatch from an e-mail message.
.git/hooks/applypatch-msg.sample:6:# The hook should exit with non-zero status after issuing an
.git/hooks/applypatch-msg.sample:10:# To enable this hook, rename this file to "applypatch-msg".
.git/hooks/applypatch-msg.sample:12:. git-sh-setup
.git/hooks/applypatch-msg.sample:13:commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
.git/hooks/applypatch-msg.sample:14:test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
.git/hooks/pre-commit.sample:5:# exit with non-zero status after issuing an appropriate message if
.git/hooks/pre-commit.sample:8:# To enable this hook, rename this file to "pre-commit".
.git/hooks/pre-commit.sample:10:if git rev-parse --verify HEAD >/dev/null 2>&1
.git/hooks/pre-commit.sample:18:# If you want to allow non-ASCII filenames set this variable to true.
.git/hooks/pre-commit.sample:19:allownonascii=$(git config --bool hooks.allownonascii)
.git/hooks/pre-commit.sample:24:# Cross platform projects tend to avoid non-ASCII filenames; prevent
.git/hooks/pre-commit.sample:31:	test $(git diff --cached --name-only --diff-filter=A -z $against |
.git/hooks/pre-commit.sample:32:	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
.git/hooks/pre-commit.sample:35:Error: Attempt to add a non-ASCII file name.
.git/hooks/pre-commit.sample:49:exec git diff-index --check --cached $against --
.git/hooks/pre-applypatch.sample:4:# by applypatch from an e-mail message.
.git/hooks/pre-applypatch.sample:6:# The hook should exit with non-zero status after issuing an
.git/hooks/pre-applypatch.sample:9:# To enable this hook, rename this file to "pre-applypatch".
.git/hooks/pre-applypatch.sample:11:. git-sh-setup
.git/hooks/pre-applypatch.sample:12:precommit="$(git rev-parse --git-path hooks/pre-commit)"
.git/hooks/pre-applypatch.sample:13:test -x "$precommit" && exec "$precommit" ${1+"$@"}
.git/hooks/update.sample:4:# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
.git/hooks/update.sample:9:# ------
.git/hooks/update.sample:27:# --- Command line
.git/hooks/update.sample:32:# --- Safety check
.git/hooks/update.sample:33:if [ -z "$GIT_DIR" ]; then
.git/hooks/update.sample:40:if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
.git/hooks/update.sample:45:# --- Config
.git/hooks/update.sample:46:allowunannotated=$(git config --bool hooks.allowunannotated)
.git/hooks/update.sample:47:allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
.git/hooks/update.sample:48:denycreatebranch=$(git config --bool hooks.denycreatebranch)
.git/hooks/update.sample:49:allowdeletetag=$(git config --bool hooks.allowdeletetag)
.git/hooks/update.sample:50:allowmodifytag=$(git config --bool hooks.allowmodifytag)
.git/hooks/update.sample:53:projectdesc=$(sed -e '1q' "$GIT_DIR/description")
.git/hooks/update.sample:61:# --- Check types
.git/hooks/update.sample:67:	newrev_type=$(git cat-file -t $newrev)
.git/hooks/update.sample:72:		# un-annotated tag
.git/hooks/update.sample:75:			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
.git/hooks/update.sample:76:			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
.git/hooks/update.sample:89:		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
.git/hooks/update.sample:98:		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
.git/hooks/update.sample:127:# --- Finished
.git/hooks/prepare-commit-msg.sample:7:# message file.  If the hook fails with a non-zero status,
.git/hooks/prepare-commit-msg.sample:10:# To enable this hook, rename this file to "prepare-commit-msg".
.git/hooks/prepare-commit-msg.sample:15:# The second includes the output of "git diff --name-status -r"
.git/hooks/prepare-commit-msg.sample:17:# commented because it doesn't cope with --amend or with squashed
.git/hooks/prepare-commit-msg.sample:20:# The third example adds a Signed-off-by line to the message, that can
.git/hooks/prepare-commit-msg.sample:25:    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
.git/hooks/prepare-commit-msg.sample:28:#   /usr/bin/perl -i.bak -pe '
.git/hooks/prepare-commit-msg.sample:29:#      print "\n" . `git diff --cached --name-status -r`
.git/hooks/prepare-commit-msg.sample:35:# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
.git/hooks/prepare-commit-msg.sample:36:# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
.git/hooks/pre-rebase.sample:5:# The "pre-rebase" hook is run just before "git rebase" starts doing
.git/hooks/pre-rebase.sample:7:# non-zero status.
.git/hooks/pre-rebase.sample:11:# $1 -- the upstream the series was forked from.
.git/hooks/pre-rebase.sample:12:# $2 -- the branch being rebased (or empty when rebasing the current branch).
.git/hooks/pre-rebase.sample:24:	topic=`git symbolic-ref HEAD` ||
.git/hooks/pre-rebase.sample:40:git show-ref -q "$topic" || {
.git/hooks/pre-rebase.sample:46:not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
.git/hooks/pre-rebase.sample:47:if test -z "$not_in_master"
.git/hooks/pre-rebase.sample:54:only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
.git/hooks/pre-rebase.sample:55:only_next_2=`git rev-list ^master           ${publish} | sort`
.git/hooks/pre-rebase.sample:58:	not_in_topic=`git rev-list "^$topic" master`
.git/hooks/pre-rebase.sample:59:	if test -z "$not_in_topic"
.git/hooks/pre-rebase.sample:61:		echo >&2 "$topic is already up-to-date with master"
.git/hooks/pre-rebase.sample:67:	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
.git/hooks/pre-rebase.sample:68:	/usr/bin/perl -e '
.git/hooks/pre-rebase.sample:72:			/^([0-9a-f]+) /;
.git/hooks/pre-rebase.sample:76:				/^([0-9a-f]+) (.*)$/;
.git/hooks/pre-rebase.sample:79:			if (!exists $not_in_next{$elem->[0]}) {
.git/hooks/pre-rebase.sample:84:				print STDERR " $elem->[1]\n";
.git/hooks/pre-rebase.sample:125:    build on top of it -- other people may already want to
.git/hooks/pre-rebase.sample:133:		   o---o---o---o---o---o---o---o---o---o "next"
.git/hooks/pre-rebase.sample:135:		 /   a---a---b A     /           /
.git/hooks/pre-rebase.sample:137:	       /   /   c---c---c---c B         /
.git/hooks/pre-rebase.sample:139:	     /   /   /   b---b C     \       /
.git/hooks/pre-rebase.sample:141:    ---o---o---o---o---o---o---o---o---o---o---o "master"
.git/hooks/pre-rebase.sample:158:	git rev-list ^master ^topic next
.git/hooks/pre-rebase.sample:159:	git rev-list ^master        next
.git/hooks/pre-rebase.sample:165:	git rev-list master..topic
.git/hooks/post-update.sample:6:# To enable this hook, rename this file to "post-update".
.git/hooks/post-update.sample:8:exec git update-server-info
.git/hooks/commit-msg.sample:5:# that has the commit message.  The hook should exit with non-zero
.git/hooks/commit-msg.sample:9:# To enable this hook, rename this file to "commit-msg".
.git/hooks/commit-msg.sample:11:# Uncomment the below to add a Signed-off-by line to the message.
.git/hooks/commit-msg.sample:12:# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
.git/hooks/commit-msg.sample:15:# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
.git/hooks/commit-msg.sample:16:# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
.git/hooks/commit-msg.sample:18:# This example catches duplicate Signed-off-by lines.
.git/hooks/commit-msg.sample:20:test "" = "$(grep '^Signed-off-by: ' "$1" |
.git/hooks/commit-msg.sample:21:	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
.git/hooks/commit-msg.sample:22:	echo >&2 Duplicate Signed-off-by lines.
.git/hooks/pre-push.sample:5:# pushed.  If this script exits with a non-zero status nothing will be pushed.
.git/hooks/pre-push.sample:9:# $1 -- Name of the remote to which the push is being done
.git/hooks/pre-push.sample:10:# $2 -- URL to which the push is being done
.git/hooks/pre-push.sample:44:		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
.git/hooks/pre-push.sample:45:		if [ -n "$commit" ]
.git/logs/HEAD:1:0000000000000000000000000000000000000000 0c6a6e67b0d8ac1f1f78214e50f76be572c3f131 CX-UI <tianfangmmr@126.com> 1505131758 +0800	clone: from git@github.com:CX-UI/ADFS.git
.git/logs/HEAD:2:0c6a6e67b0d8ac1f1f78214e50f76be572c3f131 0c6a6e67b0d8ac1f1f78214e50f76be572c3f131 CX-UI <tianfangmmr@126.com> 1505132142 +0800	checkout: moving from master to cx-dir
.git/logs/HEAD:3:0c6a6e67b0d8ac1f1f78214e50f76be572c3f131 fbfa98ea426fdc04dee61a415df73357f384bca0 CX-UI <tianfangmmr@126.com> 1505207639 +0800	commit: add zone
.git/logs/HEAD:4:fbfa98ea426fdc04dee61a415df73357f384bca0 8498ce29397ea536cb9948c818a1ba6d0c8123fe CX-UI <tianfangmmr@126.com> 1505222907 +0800	commit: define zones
.git/logs/HEAD:5:8498ce29397ea536cb9948c818a1ba6d0c8123fe 0c6a6e67b0d8ac1f1f78214e50f76be572c3f131 CX-UI <tianfangmmr@126.com> 1505267013 +0800	checkout: moving from cx-dir to master
.git/logs/HEAD:6:0c6a6e67b0d8ac1f1f78214e50f76be572c3f131 2802011faa927033dc249b1067a7fecb9298eff6 CX-UI <tianfangmmr@126.com> 1505267069 +0800	commit: test
.git/logs/HEAD:7:2802011faa927033dc249b1067a7fecb9298eff6 c1efceb3994bfdad4da57b028cce01dc77dbbc07 CX-UI <tianfangmmr@126.com> 1505267299 +0800	merge cx-dir: Merge made by the 'recursive' strategy.
.git/logs/HEAD:8:c1efceb3994bfdad4da57b028cce01dc77dbbc07 31612949cd859f3a622f3c7947ca6541a3c85d85 CX-UI <tianfangmmr@126.com> 1505361236 +0800	commit: modify struct
.git/logs/HEAD:9:31612949cd859f3a622f3c7947ca6541a3c85d85 df8760e954b5c27419f2ff010c5b6d09865bcc87 CX-UI <tianfangmmr@126.com> 1505372835 +0800	commit: build zone.c and related changes
.git/logs/HEAD:10:df8760e954b5c27419f2ff010c5b6d09865bcc87 e8fe6035487ed0968cace7dee092f9fb4d187eaf CX-UI <tianfangmmr@126.com> 1505401421 +0800	commit: init_zone
.git/logs/HEAD:11:e8fe6035487ed0968cace7dee092f9fb4d187eaf 5df2667a17127a78950033c531229ec9f242b51d CX-UI <tianfangmmr@126.com> 1505470191 +0800	commit: make radix tree in dram
.git/logs/HEAD:12:5df2667a17127a78950033c531229ec9f242b51d e0b6c32f65091b3ffc5f0e38c46a76a456969b91 CX-UI <tianfangmmr@126.com> 1505571779 +0800	commit: alloc zone
.git/logs/HEAD:13:e0b6c32f65091b3ffc5f0e38c46a76a456969b91 5fdd057a5a84ac20d4ae9c8fea0ed306a9d6a191 CX-UI <tianfangmmr@126.com> 1505619394 +0800	commit: init zone
.git/logs/HEAD:14:5fdd057a5a84ac20d4ae9c8fea0ed306a9d6a191 a0acde291437c445b496cf9d7c25f2c9815b1bb6 CX-UI <tianfangmmr@126.com> 1505635007 +0800	commit: prepare self-adaption behavior
.git/logs/HEAD:15:a0acde291437c445b496cf9d7c25f2c9815b1bb6 37cfa02c2168e6a2fcc67e3c0352451fe69d3597 CX-UI <tianfangmmr@126.com> 1505657006 +0800	commit: add mean frequency
.git/logs/HEAD:16:37cfa02c2168e6a2fcc67e3c0352451fe69d3597 2a5c5b01391d6e576986e273d09b1443b58e2eb7 CX-UI <tianfangmmr@126.com> 1505728909 +0800	commit: add check_zone
.git/logs/HEAD:17:2a5c5b01391d6e576986e273d09b1443b58e2eb7 3cc603fb022a137aabf27b832570959a61df51f8 CX-UI <tianfangmmr@126.com> 1505744445 +0800	commit: add dzt in dram
.git/logs/HEAD:18:3cc603fb022a137aabf27b832570959a61df51f8 71e780ef77604fa533d0f112a55927b85a3eb6f0 CX-UI <tianfangmmr@126.com> 1505835216 +0800	commit: finish split
.git/logs/HEAD:19:71e780ef77604fa533d0f112a55927b85a3eb6f0 b91a4a70bb92b9f34725870a7d684992ddc78faf CX-UI <tianfangmmr@126.com> 1505913041 +0800	commit: modify split
.git/logs/HEAD:20:b91a4a70bb92b9f34725870a7d684992ddc78faf 0546edaa76c411af840a188a168c1a436621df68 CX-UI <tianfangmmr@126.com> 1505915210 +0800	commit: modify split 2
.git/logs/HEAD:21:0546edaa76c411af840a188a168c1a436621df68 6fe926f57c5b961a5dffc92c8fe1fb3b4a0d52ae CX-UI <tianfangmmr@126.com> 1505915669 +0800	commit: modify split 3
.git/logs/HEAD:22:6fe926f57c5b961a5dffc92c8fe1fb3b4a0d52ae cda1e46992c9a5d9f279a70ea20ab05282455cf2 CX-UI <tianfangmmr@126.com> 1505998057 +0800	commit: finish inherit but problems in split
.git/logs/HEAD:23:cda1e46992c9a5d9f279a70ea20ab05282455cf2 d05192ba7b8cc1055510ac0bd20a48ffb6b0bbca CX-UI <tianfangmmr@126.com> 1506001600 +0800	commit: finish merge zone
.git/logs/HEAD:24:d05192ba7b8cc1055510ac0bd20a48ffb6b0bbca 5b7d4727dbc552576e1411b2a01bb5b9b615604d CX-UI <tianfangmmr@126.com> 1506079711 +0800	commit: shame of few changed
.git/logs/HEAD:25:5b7d4727dbc552576e1411b2a01bb5b9b615604d 903cce8d4a1bdbdba743e5f13d5b543d4a5d6e22 CX-UI <tianfangmmr@126.com> 1506154727 +0800	commit: fix reset but leaves some pro in ei and ze
.git/logs/HEAD:26:903cce8d4a1bdbdba743e5f13d5b543d4a5d6e22 d211c3b4e00e8237dcb8b8b60090a13e1bd35fc9 CX-UI <tianfangmmr@126.com> 1506326133 +0800	commit: change reset
.git/logs/HEAD:27:d211c3b4e00e8237dcb8b8b60090a13e1bd35fc9 dfd3c926fc1bae41a63a0569b8023032c85970ff CX-UI <tianfangmmr@126.com> 1506344653 +0800	commit: change sf
.git/logs/HEAD:28:dfd3c926fc1bae41a63a0569b8023032c85970ff 62ec2151451081e372e4037b5749575bf49da524 CX-UI <tianfangmmr@126.com> 1506414711 +0800	commit: build check large
.git/logs/HEAD:29:62ec2151451081e372e4037b5749575bf49da524 1445a372e8e180ae44b9e076813bd3282f12d75c CX-UI <tianfangmmr@126.com> 1506438977 +0800	commit: annoations
.git/logs/HEAD:30:1445a372e8e180ae44b9e076813bd3282f12d75c 5002fdfe0a16aaa3e8867238bc6b667cf6426a84 CX-UI <tianfangmmr@126.com> 1506520074 +0800	commit: annoations
.git/logs/HEAD:31:5002fdfe0a16aaa3e8867238bc6b667cf6426a84 972b451a9f82d3eaabab35594e3f397af3f7ab40 CX-UI <tianfangmmr@126.com> 1507527815 +0800	commit: fixed initialized zone
.git/logs/HEAD:32:972b451a9f82d3eaabab35594e3f397af3f7ab40 d8d5ec21542cc354d8e2852d0de83e303640da72 CX-UI <tianfangmmr@126.com> 1507554982 +0800	commit: get path
.git/logs/HEAD:33:d8d5ec21542cc354d8e2852d0de83e303640da72 cc1d7db97e6bbe8bdf959afafff7bca170011be7 CX-UI <tianfangmmr@126.com> 1507616358 +0800	commit: find zone
.git/logs/HEAD:34:cc1d7db97e6bbe8bdf959afafff7bca170011be7 d0d16a1613c2abe2bb78ac912e42c1ae05bce51b CX-UI <tianfangmmr@126.com> 1507621141 +0800	commit: find dentry on nvm
.git/logs/HEAD:35:d0d16a1613c2abe2bb78ac912e42c1ae05bce51b cfeb4b9bc22e19198418ee001671ed78a7fc6aa8 CX-UI <tianfangmmr@126.com> 1507706810 +0800	commit: finish create dentry
.git/logs/HEAD:36:cfeb4b9bc22e19198418ee001671ed78a7fc6aa8 0837320059f84757b57a71f0cc24a48b5e643a68 CX-UI <tianfangmmr@126.com> 1507724069 +0800	commit: finish unlink
.git/logs/HEAD:37:0837320059f84757b57a71f0cc24a48b5e643a68 9aa421848b69640ba698bfcfda8d488247944961 CX-UI <tianfangmmr@126.com> 1507727298 +0800	commit: finish symlink
.git/logs/HEAD:38:9aa421848b69640ba698bfcfda8d488247944961 6787b5a7ae67a2fd754ef4d726e0c8ea6aef0d49 CX-UI <tianfangmmr@126.com> 1507794204 +0800	commit: finish mkdir
.git/logs/HEAD:39:6787b5a7ae67a2fd754ef4d726e0c8ea6aef0d49 4aeeb89de1e559081570a455b8c790b18e6d37f6 CX-UI <tianfangmmr@126.com> 1507811466 +0800	commit: finish rmdir
.git/logs/HEAD:40:4aeeb89de1e559081570a455b8c790b18e6d37f6 8057fd813967b353701b539cf140fdf5891d91d4 CX-UI <tianfangmmr@126.com> 1507876852 +0800	commit: finish mknod
.git/logs/HEAD:41:8057fd813967b353701b539cf140fdf5891d91d4 f424571fd5e8c247f914339b4b7b5e77c48b8ab0 CX-UI <tianfangmmr@126.com> 1507896784 +0800	commit: start to rename
.git/logs/HEAD:42:f424571fd5e8c247f914339b4b7b5e77c48b8ab0 868ae91264e09d75e66766e074ed275f1d3a9196 CX-UI <tianfangmmr@126.com> 1507970253 +0800	commit: start to rename dir
.git/logs/HEAD:43:868ae91264e09d75e66766e074ed275f1d3a9196 7102fc4680a6beec6a759943725afbe3bef4cef8 CX-UI <tianfangmmr@126.com> 1508162943 +0800	commit: finish rename
.git/logs/HEAD:44:7102fc4680a6beec6a759943725afbe3bef4cef8 6015becb57053cc474503a4e875b1556d3751e9e CX-UI <tianfangmmr@126.com> 1508224337 +0800	commit: finish get_parent
.git/logs/HEAD:45:6015becb57053cc474503a4e875b1556d3751e9e 767acb20c15105d80c782aee91fc1ab177cd7535 CX-UI <tianfangmmr@126.com> 1508314134 +0800	commit: finish readdir
.git/logs/HEAD:46:767acb20c15105d80c782aee91fc1ab177cd7535 079d037e1992100029d8a38f0a30bc49ff611118 CX-UI <tianfangmmr@126.com> 1508416660 +0800	commit: finish hash table
.git/logs/HEAD:47:079d037e1992100029d8a38f0a30bc49ff611118 e7ab17130ea0c0086e1df72c599e1a43725d7f5a CX-UI <tianfangmmr@126.com> 1508554165 +0800	commit: finish change pos
.git/logs/HEAD:48:e7ab17130ea0c0086e1df72c599e1a43725d7f5a 0a76657e65707d63735490aeac713c89c9e2f51d CX-UI <tianfangmmr@126.com> 1508746624 +0800	commit: finish dir log
.git/logs/HEAD:49:0a76657e65707d63735490aeac713c89c9e2f51d 493f22aa44f859bc18c38226969b4f468ab31212 CX-UI <tianfangmmr@126.com> 1508765929 +0800	commit: finish half gc zone and htable
.git/logs/HEAD:50:493f22aa44f859bc18c38226969b4f468ab31212 479d009e5d47d1d7ab0368cf218fcaa32278482c CX-UI <tianfangmmr@126.com> 1508852856 +0800	commit: finish gc ht and zone
.git/logs/HEAD:51:479d009e5d47d1d7ab0368cf218fcaa32278482c a15f97112552f395a46e51bd8a3f70f0c30c3496 CX-UI <tianfangmmr@126.com> 1508900575 +0800	commit: correct ptr pointers
.git/logs/HEAD:52:a15f97112552f395a46e51bd8a3f70f0c30c3496 0b137d0a6b7dc9772005efbacf724ec6c4f4a9c8 CX-UI <tianfangmmr@126.com> 1508941780 +0800	commit: finish init rf_tree
.git/logs/HEAD:53:0b137d0a6b7dc9772005efbacf724ec6c4f4a9c8 33f4f1b77aba4dd99a117a221cb5fa2c5b43cebd CX-UI <tianfangmmr@126.com> 1508986350 +0800	commit: finish update read hot
.git/logs/HEAD:54:33f4f1b77aba4dd99a117a221cb5fa2c5b43cebd 362b7b7b5d881ee981ce7d576644da691a65672a CX-UI <tianfangmmr@126.com> 1509007903 +0800	commit: finish half rf_entry&tree free
.git/logs/HEAD:55:362b7b7b5d881ee981ce7d576644da691a65672a 09846e6caa655231293ff6b1b6a2906f489e713b CX-UI <tianfangmmr@126.com> 1509029412 +0800	commit: finish find ei path
.git/logs/HEAD:56:09846e6caa655231293ff6b1b6a2906f489e713b de66f18826480b5c529244019ce4928ea7e45d0a CX-UI <tianfangmmr@126.com> 1509076996 +0800	commit: change zone_no to hashname and correct remove
.git/logs/HEAD:57:de66f18826480b5c529244019ce4928ea7e45d0a 7ceba05b3b99b764d2ba8315726a82e4cfc1fda5 CX-UI <tianfangmmr@126.com> 1509095965 +0800	commit: add ei update when rename and debug rename
.git/logs/HEAD:58:7ceba05b3b99b764d2ba8315726a82e4cfc1fda5 8f048f9af8f72f1a75e5a9291bfcfcbe0fe85122 CX-UI <tianfangmmr@126.com> 1509252322 +0800	commit: modify get_dzt use back serching
.git/logs/HEAD:59:8f048f9af8f72f1a75e5a9291bfcfcbe0fe85122 62ae88219f9a1ff931ce03ae195eb90568edfa49 CX-UI <tianfangmmr@126.com> 1509336564 +0800	commit: modify changes ralated to get_dzt
.git/logs/HEAD:60:62ae88219f9a1ff931ce03ae195eb90568edfa49 8722afe971db2220232c4738aa3e5473ff5db9ac CX-UI <tianfangmmr@126.com> 1509363172 +0800	commit: finish modifying char
.git/logs/HEAD:61:8722afe971db2220232c4738aa3e5473ff5db9ac 691ed1839994911872176d9a42edf892e660c7e1 CX-UI <tianfangmmr@126.com> 1509366744 +0800	commit: modify get zone_entry from addr
.git/logs/HEAD:62:691ed1839994911872176d9a42edf892e660c7e1 53b1b9dd9173ab8081183225e6d28ed56f57a130 CX-UI <tianfangmmr@126.com> 1509463005 +0800	commit: unfinish split ralated
.git/logs/HEAD:63:53b1b9dd9173ab8081183225e6d28ed56f57a130 c572955fd847325162cb76f24d963c0774bcd41b CX-UI <tianfangmmr@126.com> 1509507542 +0800	commit: modify split function
.git/logs/HEAD:64:c572955fd847325162cb76f24d963c0774bcd41b 6063f89de03e5e4dde1f6a4a0791ad758156843c CX-UI <tianfangmmr@126.com> 1509540357 +0800	commit: modify rf_entry
.git/logs/HEAD:65:6063f89de03e5e4dde1f6a4a0791ad758156843c 5c18de3951d1380224f87923176e0e1bdef656d5 CX-UI <tianfangmmr@126.com> 1509548688 +0800	commit: finish modify split
.git/logs/HEAD:66:5c18de3951d1380224f87923176e0e1bdef656d5 46f64ba7a7b2aaa04e8854769c7eef0a8fe09a54 CX-UI <tianfangmmr@126.com> 1509549639 +0800	commit: final finish modify split
.git/logs/HEAD:67:46f64ba7a7b2aaa04e8854769c7eef0a8fe09a54 0a9468fd9826a54a23622a55ddf217e38dd19e8c CX-UI <tianfangmmr@126.com> 1509980205 +0800	commit: start to change merge
.git/logs/HEAD:68:0a9468fd9826a54a23622a55ddf217e38dd19e8c a09937f53699166e87de92dca9742b0ed26af2f6 CX-UI <tianfangmmr@126.com> 1510068195 +0800	commit: finish changing merge and start to chang inherit
.git/logs/HEAD:69:a09937f53699166e87de92dca9742b0ed26af2f6 c15dcc390a87df32d5c655a1c7dfee0a9d392562 CX-UI <tianfangmmr@126.com> 1510113027 +0800	commit: finish changing inherit and modify rf_tree with removing zone rf
.git/logs/HEAD:70:c15dcc390a87df32d5c655a1c7dfee0a9d392562 aa06560566eac212c6d6137fcdd5efb67ca094ab CX-UI <tianfangmmr@126.com> 1510128380 +0800	commit: finish changing rmdir
.git/logs/HEAD:71:aa06560566eac212c6d6137fcdd5efb67ca094ab 0066f59c1c87ac37bcdaf58fc4b8b230ecaf18d5 CX-UI <tianfangmmr@126.com> 1510542098 +0800	commit: change ckeck zones and delete check_zone_rlarge
.git/logs/HEAD:72:0066f59c1c87ac37bcdaf58fc4b8b230ecaf18d5 7ae65a742b228ae300719d771c3fef5bb9677c90 CX-UI <tianfangmmr@126.com> 1510629015 +0800	commit: add and change namei.c dir.c calls
.git/logs/HEAD:73:7ae65a742b228ae300719d771c3fef5bb9677c90 fffc9b5e07e4b0d5c1bc52b7ae7eff456f792553 CX-UI <tianfangmmr@126.com> 1510649934 +0800	commit: check and modify links, tail within inode in namei.c
.git/logs/HEAD:74:fffc9b5e07e4b0d5c1bc52b7ae7eff456f792553 914c0aff9e206fa99502ac0c1d20d827e982c99d CX-UI <tianfangmmr@126.com> 1510665147 +0800	commit: check nova_dentry then delete all fast gc for dentry
.git/logs/HEAD:75:914c0aff9e206fa99502ac0c1d20d827e982c99d 698b9109c34a546f6b855deb19b43c58fdf6ad83 CX-UI <tianfangmmr@126.com> 1510811516 +0800	commit: add check zone thread
.git/logs/refs/heads/cx-dir:1:0000000000000000000000000000000000000000 0c6a6e67b0d8ac1f1f78214e50f76be572c3f131 CX-UI <tianfangmmr@126.com> 1505132142 +0800	branch: Created from refs/remotes/origin/cx-dir
.git/logs/refs/heads/cx-dir:2:0c6a6e67b0d8ac1f1f78214e50f76be572c3f131 fbfa98ea426fdc04dee61a415df73357f384bca0 CX-UI <tianfangmmr@126.com> 1505207639 +0800	commit: add zone
.git/logs/refs/heads/cx-dir:3:fbfa98ea426fdc04dee61a415df73357f384bca0 8498ce29397ea536cb9948c818a1ba6d0c8123fe CX-UI <tianfangmmr@126.com> 1505222907 +0800	commit: define zones
.git/logs/refs/heads/master:1:0000000000000000000000000000000000000000 0c6a6e67b0d8ac1f1f78214e50f76be572c3f131 CX-UI <tianfangmmr@126.com> 1505131758 +0800	clone: from git@github.com:CX-UI/ADFS.git
.git/logs/refs/heads/master:2:0c6a6e67b0d8ac1f1f78214e50f76be572c3f131 2802011faa927033dc249b1067a7fecb9298eff6 CX-UI <tianfangmmr@126.com> 1505267069 +0800	commit: test
.git/logs/refs/heads/master:3:2802011faa927033dc249b1067a7fecb9298eff6 c1efceb3994bfdad4da57b028cce01dc77dbbc07 CX-UI <tianfangmmr@126.com> 1505267299 +0800	merge cx-dir: Merge made by the 'recursive' strategy.
.git/logs/refs/heads/master:4:c1efceb3994bfdad4da57b028cce01dc77dbbc07 31612949cd859f3a622f3c7947ca6541a3c85d85 CX-UI <tianfangmmr@126.com> 1505361236 +0800	commit: modify struct
.git/logs/refs/heads/master:5:31612949cd859f3a622f3c7947ca6541a3c85d85 df8760e954b5c27419f2ff010c5b6d09865bcc87 CX-UI <tianfangmmr@126.com> 1505372835 +0800	commit: build zone.c and related changes
.git/logs/refs/heads/master:6:df8760e954b5c27419f2ff010c5b6d09865bcc87 e8fe6035487ed0968cace7dee092f9fb4d187eaf CX-UI <tianfangmmr@126.com> 1505401421 +0800	commit: init_zone
.git/logs/refs/heads/master:7:e8fe6035487ed0968cace7dee092f9fb4d187eaf 5df2667a17127a78950033c531229ec9f242b51d CX-UI <tianfangmmr@126.com> 1505470191 +0800	commit: make radix tree in dram
.git/logs/refs/heads/master:8:5df2667a17127a78950033c531229ec9f242b51d e0b6c32f65091b3ffc5f0e38c46a76a456969b91 CX-UI <tianfangmmr@126.com> 1505571779 +0800	commit: alloc zone
.git/logs/refs/heads/master:9:e0b6c32f65091b3ffc5f0e38c46a76a456969b91 5fdd057a5a84ac20d4ae9c8fea0ed306a9d6a191 CX-UI <tianfangmmr@126.com> 1505619394 +0800	commit: init zone
.git/logs/refs/heads/master:10:5fdd057a5a84ac20d4ae9c8fea0ed306a9d6a191 a0acde291437c445b496cf9d7c25f2c9815b1bb6 CX-UI <tianfangmmr@126.com> 1505635007 +0800	commit: prepare self-adaption behavior
.git/logs/refs/heads/master:11:a0acde291437c445b496cf9d7c25f2c9815b1bb6 37cfa02c2168e6a2fcc67e3c0352451fe69d3597 CX-UI <tianfangmmr@126.com> 1505657006 +0800	commit: add mean frequency
.git/logs/refs/heads/master:12:37cfa02c2168e6a2fcc67e3c0352451fe69d3597 2a5c5b01391d6e576986e273d09b1443b58e2eb7 CX-UI <tianfangmmr@126.com> 1505728909 +0800	commit: add check_zone
.git/logs/refs/heads/master:13:2a5c5b01391d6e576986e273d09b1443b58e2eb7 3cc603fb022a137aabf27b832570959a61df51f8 CX-UI <tianfangmmr@126.com> 1505744445 +0800	commit: add dzt in dram
.git/logs/refs/heads/master:14:3cc603fb022a137aabf27b832570959a61df51f8 71e780ef77604fa533d0f112a55927b85a3eb6f0 CX-UI <tianfangmmr@126.com> 1505835216 +0800	commit: finish split
.git/logs/refs/heads/master:15:71e780ef77604fa533d0f112a55927b85a3eb6f0 b91a4a70bb92b9f34725870a7d684992ddc78faf CX-UI <tianfangmmr@126.com> 1505913041 +0800	commit: modify split
.git/logs/refs/heads/master:16:b91a4a70bb92b9f34725870a7d684992ddc78faf 0546edaa76c411af840a188a168c1a436621df68 CX-UI <tianfangmmr@126.com> 1505915210 +0800	commit: modify split 2
.git/logs/refs/heads/master:17:0546edaa76c411af840a188a168c1a436621df68 6fe926f57c5b961a5dffc92c8fe1fb3b4a0d52ae CX-UI <tianfangmmr@126.com> 1505915669 +0800	commit: modify split 3
.git/logs/refs/heads/master:18:6fe926f57c5b961a5dffc92c8fe1fb3b4a0d52ae cda1e46992c9a5d9f279a70ea20ab05282455cf2 CX-UI <tianfangmmr@126.com> 1505998057 +0800	commit: finish inherit but problems in split
.git/logs/refs/heads/master:19:cda1e46992c9a5d9f279a70ea20ab05282455cf2 d05192ba7b8cc1055510ac0bd20a48ffb6b0bbca CX-UI <tianfangmmr@126.com> 1506001600 +0800	commit: finish merge zone
.git/logs/refs/heads/master:20:d05192ba7b8cc1055510ac0bd20a48ffb6b0bbca 5b7d4727dbc552576e1411b2a01bb5b9b615604d CX-UI <tianfangmmr@126.com> 1506079711 +0800	commit: shame of few changed
.git/logs/refs/heads/master:21:5b7d4727dbc552576e1411b2a01bb5b9b615604d 903cce8d4a1bdbdba743e5f13d5b543d4a5d6e22 CX-UI <tianfangmmr@126.com> 1506154727 +0800	commit: fix reset but leaves some pro in ei and ze
.git/logs/refs/heads/master:22:903cce8d4a1bdbdba743e5f13d5b543d4a5d6e22 d211c3b4e00e8237dcb8b8b60090a13e1bd35fc9 CX-UI <tianfangmmr@126.com> 1506326133 +0800	commit: change reset
.git/logs/refs/heads/master:23:d211c3b4e00e8237dcb8b8b60090a13e1bd35fc9 dfd3c926fc1bae41a63a0569b8023032c85970ff CX-UI <tianfangmmr@126.com> 1506344653 +0800	commit: change sf
.git/logs/refs/heads/master:24:dfd3c926fc1bae41a63a0569b8023032c85970ff 62ec2151451081e372e4037b5749575bf49da524 CX-UI <tianfangmmr@126.com> 1506414711 +0800	commit: build check large
.git/logs/refs/heads/master:25:62ec2151451081e372e4037b5749575bf49da524 1445a372e8e180ae44b9e076813bd3282f12d75c CX-UI <tianfangmmr@126.com> 1506438977 +0800	commit: annoations
.git/logs/refs/heads/master:26:1445a372e8e180ae44b9e076813bd3282f12d75c 5002fdfe0a16aaa3e8867238bc6b667cf6426a84 CX-UI <tianfangmmr@126.com> 1506520074 +0800	commit: annoations
.git/logs/refs/heads/master:27:5002fdfe0a16aaa3e8867238bc6b667cf6426a84 972b451a9f82d3eaabab35594e3f397af3f7ab40 CX-UI <tianfangmmr@126.com> 1507527815 +0800	commit: fixed initialized zone
.git/logs/refs/heads/master:28:972b451a9f82d3eaabab35594e3f397af3f7ab40 d8d5ec21542cc354d8e2852d0de83e303640da72 CX-UI <tianfangmmr@126.com> 1507554982 +0800	commit: get path
.git/logs/refs/heads/master:29:d8d5ec21542cc354d8e2852d0de83e303640da72 cc1d7db97e6bbe8bdf959afafff7bca170011be7 CX-UI <tianfangmmr@126.com> 1507616358 +0800	commit: find zone
.git/logs/refs/heads/master:30:cc1d7db97e6bbe8bdf959afafff7bca170011be7 d0d16a1613c2abe2bb78ac912e42c1ae05bce51b CX-UI <tianfangmmr@126.com> 1507621141 +0800	commit: find dentry on nvm
.git/logs/refs/heads/master:31:d0d16a1613c2abe2bb78ac912e42c1ae05bce51b cfeb4b9bc22e19198418ee001671ed78a7fc6aa8 CX-UI <tianfangmmr@126.com> 1507706810 +0800	commit: finish create dentry
.git/logs/refs/heads/master:32:cfeb4b9bc22e19198418ee001671ed78a7fc6aa8 0837320059f84757b57a71f0cc24a48b5e643a68 CX-UI <tianfangmmr@126.com> 1507724069 +0800	commit: finish unlink
.git/logs/refs/heads/master:33:0837320059f84757b57a71f0cc24a48b5e643a68 9aa421848b69640ba698bfcfda8d488247944961 CX-UI <tianfangmmr@126.com> 1507727298 +0800	commit: finish symlink
.git/logs/refs/heads/master:34:9aa421848b69640ba698bfcfda8d488247944961 6787b5a7ae67a2fd754ef4d726e0c8ea6aef0d49 CX-UI <tianfangmmr@126.com> 1507794204 +0800	commit: finish mkdir
.git/logs/refs/heads/master:35:6787b5a7ae67a2fd754ef4d726e0c8ea6aef0d49 4aeeb89de1e559081570a455b8c790b18e6d37f6 CX-UI <tianfangmmr@126.com> 1507811466 +0800	commit: finish rmdir
.git/logs/refs/heads/master:36:4aeeb89de1e559081570a455b8c790b18e6d37f6 8057fd813967b353701b539cf140fdf5891d91d4 CX-UI <tianfangmmr@126.com> 1507876852 +0800	commit: finish mknod
.git/logs/refs/heads/master:37:8057fd813967b353701b539cf140fdf5891d91d4 f424571fd5e8c247f914339b4b7b5e77c48b8ab0 CX-UI <tianfangmmr@126.com> 1507896784 +0800	commit: start to rename
.git/logs/refs/heads/master:38:f424571fd5e8c247f914339b4b7b5e77c48b8ab0 868ae91264e09d75e66766e074ed275f1d3a9196 CX-UI <tianfangmmr@126.com> 1507970253 +0800	commit: start to rename dir
.git/logs/refs/heads/master:39:868ae91264e09d75e66766e074ed275f1d3a9196 7102fc4680a6beec6a759943725afbe3bef4cef8 CX-UI <tianfangmmr@126.com> 1508162943 +0800	commit: finish rename
.git/logs/refs/heads/master:40:7102fc4680a6beec6a759943725afbe3bef4cef8 6015becb57053cc474503a4e875b1556d3751e9e CX-UI <tianfangmmr@126.com> 1508224337 +0800	commit: finish get_parent
.git/logs/refs/heads/master:41:6015becb57053cc474503a4e875b1556d3751e9e 767acb20c15105d80c782aee91fc1ab177cd7535 CX-UI <tianfangmmr@126.com> 1508314134 +0800	commit: finish readdir
.git/logs/refs/heads/master:42:767acb20c15105d80c782aee91fc1ab177cd7535 079d037e1992100029d8a38f0a30bc49ff611118 CX-UI <tianfangmmr@126.com> 1508416660 +0800	commit: finish hash table
.git/logs/refs/heads/master:43:079d037e1992100029d8a38f0a30bc49ff611118 e7ab17130ea0c0086e1df72c599e1a43725d7f5a CX-UI <tianfangmmr@126.com> 1508554165 +0800	commit: finish change pos
.git/logs/refs/heads/master:44:e7ab17130ea0c0086e1df72c599e1a43725d7f5a 0a76657e65707d63735490aeac713c89c9e2f51d CX-UI <tianfangmmr@126.com> 1508746624 +0800	commit: finish dir log
.git/logs/refs/heads/master:45:0a76657e65707d63735490aeac713c89c9e2f51d 493f22aa44f859bc18c38226969b4f468ab31212 CX-UI <tianfangmmr@126.com> 1508765929 +0800	commit: finish half gc zone and htable
.git/logs/refs/heads/master:46:493f22aa44f859bc18c38226969b4f468ab31212 479d009e5d47d1d7ab0368cf218fcaa32278482c CX-UI <tianfangmmr@126.com> 1508852856 +0800	commit: finish gc ht and zone
.git/logs/refs/heads/master:47:479d009e5d47d1d7ab0368cf218fcaa32278482c a15f97112552f395a46e51bd8a3f70f0c30c3496 CX-UI <tianfangmmr@126.com> 1508900575 +0800	commit: correct ptr pointers
.git/logs/refs/heads/master:48:a15f97112552f395a46e51bd8a3f70f0c30c3496 0b137d0a6b7dc9772005efbacf724ec6c4f4a9c8 CX-UI <tianfangmmr@126.com> 1508941780 +0800	commit: finish init rf_tree
.git/logs/refs/heads/master:49:0b137d0a6b7dc9772005efbacf724ec6c4f4a9c8 33f4f1b77aba4dd99a117a221cb5fa2c5b43cebd CX-UI <tianfangmmr@126.com> 1508986350 +0800	commit: finish update read hot
.git/logs/refs/heads/master:50:33f4f1b77aba4dd99a117a221cb5fa2c5b43cebd 362b7b7b5d881ee981ce7d576644da691a65672a CX-UI <tianfangmmr@126.com> 1509007903 +0800	commit: finish half rf_entry&tree free
.git/logs/refs/heads/master:51:362b7b7b5d881ee981ce7d576644da691a65672a 09846e6caa655231293ff6b1b6a2906f489e713b CX-UI <tianfangmmr@126.com> 1509029412 +0800	commit: finish find ei path
.git/logs/refs/heads/master:52:09846e6caa655231293ff6b1b6a2906f489e713b de66f18826480b5c529244019ce4928ea7e45d0a CX-UI <tianfangmmr@126.com> 1509076996 +0800	commit: change zone_no to hashname and correct remove
.git/logs/refs/heads/master:53:de66f18826480b5c529244019ce4928ea7e45d0a 7ceba05b3b99b764d2ba8315726a82e4cfc1fda5 CX-UI <tianfangmmr@126.com> 1509095965 +0800	commit: add ei update when rename and debug rename
.git/logs/refs/heads/master:54:7ceba05b3b99b764d2ba8315726a82e4cfc1fda5 8f048f9af8f72f1a75e5a9291bfcfcbe0fe85122 CX-UI <tianfangmmr@126.com> 1509252322 +0800	commit: modify get_dzt use back serching
.git/logs/refs/heads/master:55:8f048f9af8f72f1a75e5a9291bfcfcbe0fe85122 62ae88219f9a1ff931ce03ae195eb90568edfa49 CX-UI <tianfangmmr@126.com> 1509336564 +0800	commit: modify changes ralated to get_dzt
.git/logs/refs/heads/master:56:62ae88219f9a1ff931ce03ae195eb90568edfa49 8722afe971db2220232c4738aa3e5473ff5db9ac CX-UI <tianfangmmr@126.com> 1509363172 +0800	commit: finish modifying char
.git/logs/refs/heads/master:57:8722afe971db2220232c4738aa3e5473ff5db9ac 691ed1839994911872176d9a42edf892e660c7e1 CX-UI <tianfangmmr@126.com> 1509366744 +0800	commit: modify get zone_entry from addr
.git/logs/refs/heads/master:58:691ed1839994911872176d9a42edf892e660c7e1 53b1b9dd9173ab8081183225e6d28ed56f57a130 CX-UI <tianfangmmr@126.com> 1509463005 +0800	commit: unfinish split ralated
.git/logs/refs/heads/master:59:53b1b9dd9173ab8081183225e6d28ed56f57a130 c572955fd847325162cb76f24d963c0774bcd41b CX-UI <tianfangmmr@126.com> 1509507542 +0800	commit: modify split function
.git/logs/refs/heads/master:60:c572955fd847325162cb76f24d963c0774bcd41b 6063f89de03e5e4dde1f6a4a0791ad758156843c CX-UI <tianfangmmr@126.com> 1509540357 +0800	commit: modify rf_entry
.git/logs/refs/heads/master:61:6063f89de03e5e4dde1f6a4a0791ad758156843c 5c18de3951d1380224f87923176e0e1bdef656d5 CX-UI <tianfangmmr@126.com> 1509548688 +0800	commit: finish modify split
.git/logs/refs/heads/master:62:5c18de3951d1380224f87923176e0e1bdef656d5 46f64ba7a7b2aaa04e8854769c7eef0a8fe09a54 CX-UI <tianfangmmr@126.com> 1509549639 +0800	commit: final finish modify split
.git/logs/refs/heads/master:63:46f64ba7a7b2aaa04e8854769c7eef0a8fe09a54 0a9468fd9826a54a23622a55ddf217e38dd19e8c CX-UI <tianfangmmr@126.com> 1509980205 +0800	commit: start to change merge
.git/logs/refs/heads/master:64:0a9468fd9826a54a23622a55ddf217e38dd19e8c a09937f53699166e87de92dca9742b0ed26af2f6 CX-UI <tianfangmmr@126.com> 1510068195 +0800	commit: finish changing merge and start to chang inherit
.git/logs/refs/heads/master:65:a09937f53699166e87de92dca9742b0ed26af2f6 c15dcc390a87df32d5c655a1c7dfee0a9d392562 CX-UI <tianfangmmr@126.com> 1510113027 +0800	commit: finish changing inherit and modify rf_tree with removing zone rf
.git/logs/refs/heads/master:66:c15dcc390a87df32d5c655a1c7dfee0a9d392562 aa06560566eac212c6d6137fcdd5efb67ca094ab CX-UI <tianfangmmr@126.com> 1510128380 +0800	commit: finish changing rmdir
.git/logs/refs/heads/master:67:aa06560566eac212c6d6137fcdd5efb67ca094ab 0066f59c1c87ac37bcdaf58fc4b8b230ecaf18d5 CX-UI <tianfangmmr@126.com> 1510542098 +0800	commit: change ckeck zones and delete check_zone_rlarge
.git/logs/refs/heads/master:68:0066f59c1c87ac37bcdaf58fc4b8b230ecaf18d5 7ae65a742b228ae300719d771c3fef5bb9677c90 CX-UI <tianfangmmr@126.com> 1510629015 +0800	commit: add and change namei.c dir.c calls
.git/logs/refs/heads/master:69:7ae65a742b228ae300719d771c3fef5bb9677c90 fffc9b5e07e4b0d5c1bc52b7ae7eff456f792553 CX-UI <tianfangmmr@126.com> 1510649934 +0800	commit: check and modify links, tail within inode in namei.c
.git/logs/refs/heads/master:70:fffc9b5e07e4b0d5c1bc52b7ae7eff456f792553 914c0aff9e206fa99502ac0c1d20d827e982c99d CX-UI <tianfangmmr@126.com> 1510665147 +0800	commit: check nova_dentry then delete all fast gc for dentry
.git/logs/refs/heads/master:71:914c0aff9e206fa99502ac0c1d20d827e982c99d 698b9109c34a546f6b855deb19b43c58fdf6ad83 CX-UI <tianfangmmr@126.com> 1510811516 +0800	commit: add check zone thread
.git/logs/refs/remotes/origin/HEAD:1:0000000000000000000000000000000000000000 0c6a6e67b0d8ac1f1f78214e50f76be572c3f131 CX-UI <tianfangmmr@126.com> 1505131758 +0800	clone: from git@github.com:CX-UI/ADFS.git
.git/logs/refs/remotes/origin/cx-dir:1:0c6a6e67b0d8ac1f1f78214e50f76be572c3f131 fbfa98ea426fdc04dee61a415df73357f384bca0 CX-UI <tianfangmmr@126.com> 1505207805 +0800	update by push
.git/logs/refs/remotes/origin/cx-dir:2:fbfa98ea426fdc04dee61a415df73357f384bca0 8498ce29397ea536cb9948c818a1ba6d0c8123fe CX-UI <tianfangmmr@126.com> 1505266780 +0800	update by push
.git/logs/refs/remotes/origin/master:1:0c6a6e67b0d8ac1f1f78214e50f76be572c3f131 2802011faa927033dc249b1067a7fecb9298eff6 CX-UI <tianfangmmr@126.com> 1505267142 +0800	update by push
.git/logs/refs/remotes/origin/master:2:2802011faa927033dc249b1067a7fecb9298eff6 31612949cd859f3a622f3c7947ca6541a3c85d85 CX-UI <tianfangmmr@126.com> 1505361333 +0800	update by push
.git/logs/refs/remotes/origin/master:3:31612949cd859f3a622f3c7947ca6541a3c85d85 5df2667a17127a78950033c531229ec9f242b51d CX-UI <tianfangmmr@126.com> 1505470215 +0800	update by push
.git/logs/refs/remotes/origin/master:4:5df2667a17127a78950033c531229ec9f242b51d e0b6c32f65091b3ffc5f0e38c46a76a456969b91 CX-UI <tianfangmmr@126.com> 1505571798 +0800	update by push
.git/logs/refs/remotes/origin/master:5:e0b6c32f65091b3ffc5f0e38c46a76a456969b91 5fdd057a5a84ac20d4ae9c8fea0ed306a9d6a191 CX-UI <tianfangmmr@126.com> 1505619428 +0800	update by push
.git/logs/refs/remotes/origin/master:6:5fdd057a5a84ac20d4ae9c8fea0ed306a9d6a191 a0acde291437c445b496cf9d7c25f2c9815b1bb6 CX-UI <tianfangmmr@126.com> 1505635028 +0800	update by push
.git/logs/refs/remotes/origin/master:7:a0acde291437c445b496cf9d7c25f2c9815b1bb6 2a5c5b01391d6e576986e273d09b1443b58e2eb7 CX-UI <tianfangmmr@126.com> 1505728964 +0800	update by push
.git/logs/refs/remotes/origin/master:8:2a5c5b01391d6e576986e273d09b1443b58e2eb7 3cc603fb022a137aabf27b832570959a61df51f8 CX-UI <tianfangmmr@126.com> 1505744490 +0800	update by push
.git/logs/refs/remotes/origin/master:9:3cc603fb022a137aabf27b832570959a61df51f8 71e780ef77604fa533d0f112a55927b85a3eb6f0 CX-UI <tianfangmmr@126.com> 1505835236 +0800	update by push
.git/logs/refs/remotes/origin/master:10:71e780ef77604fa533d0f112a55927b85a3eb6f0 b91a4a70bb92b9f34725870a7d684992ddc78faf CX-UI <tianfangmmr@126.com> 1505913068 +0800	update by push
.git/logs/refs/remotes/origin/master:11:b91a4a70bb92b9f34725870a7d684992ddc78faf 0546edaa76c411af840a188a168c1a436621df68 CX-UI <tianfangmmr@126.com> 1505915227 +0800	update by push
.git/logs/refs/remotes/origin/master:12:0546edaa76c411af840a188a168c1a436621df68 6fe926f57c5b961a5dffc92c8fe1fb3b4a0d52ae CX-UI <tianfangmmr@126.com> 1505915681 +0800	update by push
.git/logs/refs/remotes/origin/master:13:6fe926f57c5b961a5dffc92c8fe1fb3b4a0d52ae cda1e46992c9a5d9f279a70ea20ab05282455cf2 CX-UI <tianfangmmr@126.com> 1505998077 +0800	update by push
.git/logs/refs/remotes/origin/master:14:cda1e46992c9a5d9f279a70ea20ab05282455cf2 d05192ba7b8cc1055510ac0bd20a48ffb6b0bbca CX-UI <tianfangmmr@126.com> 1506001624 +0800	update by push
.git/logs/refs/remotes/origin/master:15:d05192ba7b8cc1055510ac0bd20a48ffb6b0bbca 5b7d4727dbc552576e1411b2a01bb5b9b615604d CX-UI <tianfangmmr@126.com> 1506079728 +0800	update by push
.git/logs/refs/remotes/origin/master:16:5b7d4727dbc552576e1411b2a01bb5b9b615604d 903cce8d4a1bdbdba743e5f13d5b543d4a5d6e22 CX-UI <tianfangmmr@126.com> 1506154747 +0800	update by push
.git/logs/refs/remotes/origin/master:17:903cce8d4a1bdbdba743e5f13d5b543d4a5d6e22 d211c3b4e00e8237dcb8b8b60090a13e1bd35fc9 CX-UI <tianfangmmr@126.com> 1506326157 +0800	update by push
.git/logs/refs/remotes/origin/master:18:d211c3b4e00e8237dcb8b8b60090a13e1bd35fc9 dfd3c926fc1bae41a63a0569b8023032c85970ff CX-UI <tianfangmmr@126.com> 1506344664 +0800	update by push
.git/logs/refs/remotes/origin/master:19:dfd3c926fc1bae41a63a0569b8023032c85970ff 62ec2151451081e372e4037b5749575bf49da524 CX-UI <tianfangmmr@126.com> 1506414741 +0800	update by push
.git/logs/refs/remotes/origin/master:20:62ec2151451081e372e4037b5749575bf49da524 5002fdfe0a16aaa3e8867238bc6b667cf6426a84 CX-UI <tianfangmmr@126.com> 1506520088 +0800	update by push
.git/logs/refs/remotes/origin/master:21:5002fdfe0a16aaa3e8867238bc6b667cf6426a84 972b451a9f82d3eaabab35594e3f397af3f7ab40 CX-UI <tianfangmmr@126.com> 1507527844 +0800	update by push
.git/logs/refs/remotes/origin/master:22:972b451a9f82d3eaabab35594e3f397af3f7ab40 d8d5ec21542cc354d8e2852d0de83e303640da72 CX-UI <tianfangmmr@126.com> 1507555004 +0800	update by push
.git/logs/refs/remotes/origin/master:23:d8d5ec21542cc354d8e2852d0de83e303640da72 cc1d7db97e6bbe8bdf959afafff7bca170011be7 CX-UI <tianfangmmr@126.com> 1507616381 +0800	update by push
.git/logs/refs/remotes/origin/master:24:cc1d7db97e6bbe8bdf959afafff7bca170011be7 d0d16a1613c2abe2bb78ac912e42c1ae05bce51b CX-UI <tianfangmmr@126.com> 1507621233 +0800	update by push
.git/logs/refs/remotes/origin/master:25:d0d16a1613c2abe2bb78ac912e42c1ae05bce51b cfeb4b9bc22e19198418ee001671ed78a7fc6aa8 CX-UI <tianfangmmr@126.com> 1507706836 +0800	update by push
.git/logs/refs/remotes/origin/master:26:cfeb4b9bc22e19198418ee001671ed78a7fc6aa8 0837320059f84757b57a71f0cc24a48b5e643a68 CX-UI <tianfangmmr@126.com> 1507724091 +0800	update by push
.git/logs/refs/remotes/origin/master:27:0837320059f84757b57a71f0cc24a48b5e643a68 9aa421848b69640ba698bfcfda8d488247944961 CX-UI <tianfangmmr@126.com> 1507727320 +0800	update by push
.git/logs/refs/remotes/origin/master:28:9aa421848b69640ba698bfcfda8d488247944961 6787b5a7ae67a2fd754ef4d726e0c8ea6aef0d49 CX-UI <tianfangmmr@126.com> 1507794221 +0800	update by push
.git/logs/refs/remotes/origin/master:29:6787b5a7ae67a2fd754ef4d726e0c8ea6aef0d49 4aeeb89de1e559081570a455b8c790b18e6d37f6 CX-UI <tianfangmmr@126.com> 1507811481 +0800	update by push
.git/logs/refs/remotes/origin/master:30:4aeeb89de1e559081570a455b8c790b18e6d37f6 8057fd813967b353701b539cf140fdf5891d91d4 CX-UI <tianfangmmr@126.com> 1507876864 +0800	update by push
.git/logs/refs/remotes/origin/master:31:8057fd813967b353701b539cf140fdf5891d91d4 868ae91264e09d75e66766e074ed275f1d3a9196 CX-UI <tianfangmmr@126.com> 1507970281 +0800	update by push
.git/logs/refs/remotes/origin/master:32:868ae91264e09d75e66766e074ed275f1d3a9196 7102fc4680a6beec6a759943725afbe3bef4cef8 CX-UI <tianfangmmr@126.com> 1508162963 +0800	update by push
.git/logs/refs/remotes/origin/master:33:7102fc4680a6beec6a759943725afbe3bef4cef8 6015becb57053cc474503a4e875b1556d3751e9e CX-UI <tianfangmmr@126.com> 1508224363 +0800	update by push
.git/logs/refs/remotes/origin/master:34:6015becb57053cc474503a4e875b1556d3751e9e 767acb20c15105d80c782aee91fc1ab177cd7535 CX-UI <tianfangmmr@126.com> 1508314151 +0800	update by push
.git/logs/refs/remotes/origin/master:35:767acb20c15105d80c782aee91fc1ab177cd7535 079d037e1992100029d8a38f0a30bc49ff611118 CX-UI <tianfangmmr@126.com> 1508416678 +0800	update by push
.git/logs/refs/remotes/origin/master:36:079d037e1992100029d8a38f0a30bc49ff611118 e7ab17130ea0c0086e1df72c599e1a43725d7f5a CX-UI <tianfangmmr@126.com> 1508554190 +0800	update by push
.git/logs/refs/remotes/origin/master:37:e7ab17130ea0c0086e1df72c599e1a43725d7f5a 0a76657e65707d63735490aeac713c89c9e2f51d CX-UI <tianfangmmr@126.com> 1508746636 +0800	update by push
.git/logs/refs/remotes/origin/master:38:0a76657e65707d63735490aeac713c89c9e2f51d 493f22aa44f859bc18c38226969b4f468ab31212 CX-UI <tianfangmmr@126.com> 1508765943 +0800	update by push
.git/logs/refs/remotes/origin/master:39:493f22aa44f859bc18c38226969b4f468ab31212 479d009e5d47d1d7ab0368cf218fcaa32278482c CX-UI <tianfangmmr@126.com> 1508853327 +0800	update by push
.git/logs/refs/remotes/origin/master:40:479d009e5d47d1d7ab0368cf218fcaa32278482c a15f97112552f395a46e51bd8a3f70f0c30c3496 CX-UI <tianfangmmr@126.com> 1508900595 +0800	update by push
.git/logs/refs/remotes/origin/master:41:a15f97112552f395a46e51bd8a3f70f0c30c3496 0b137d0a6b7dc9772005efbacf724ec6c4f4a9c8 CX-UI <tianfangmmr@126.com> 1508941797 +0800	update by push
.git/logs/refs/remotes/origin/master:42:0b137d0a6b7dc9772005efbacf724ec6c4f4a9c8 33f4f1b77aba4dd99a117a221cb5fa2c5b43cebd CX-UI <tianfangmmr@126.com> 1508986360 +0800	update by push
.git/logs/refs/remotes/origin/master:43:33f4f1b77aba4dd99a117a221cb5fa2c5b43cebd 362b7b7b5d881ee981ce7d576644da691a65672a CX-UI <tianfangmmr@126.com> 1509007924 +0800	update by push
.git/logs/refs/remotes/origin/master:44:362b7b7b5d881ee981ce7d576644da691a65672a 09846e6caa655231293ff6b1b6a2906f489e713b CX-UI <tianfangmmr@126.com> 1509029426 +0800	update by push
.git/logs/refs/remotes/origin/master:45:09846e6caa655231293ff6b1b6a2906f489e713b de66f18826480b5c529244019ce4928ea7e45d0a CX-UI <tianfangmmr@126.com> 1509077012 +0800	update by push
.git/logs/refs/remotes/origin/master:46:de66f18826480b5c529244019ce4928ea7e45d0a 7ceba05b3b99b764d2ba8315726a82e4cfc1fda5 CX-UI <tianfangmmr@126.com> 1509095986 +0800	update by push
.git/logs/refs/remotes/origin/master:47:7ceba05b3b99b764d2ba8315726a82e4cfc1fda5 8f048f9af8f72f1a75e5a9291bfcfcbe0fe85122 CX-UI <tianfangmmr@126.com> 1509252337 +0800	update by push
.git/logs/refs/remotes/origin/master:48:8f048f9af8f72f1a75e5a9291bfcfcbe0fe85122 62ae88219f9a1ff931ce03ae195eb90568edfa49 CX-UI <tianfangmmr@126.com> 1509336574 +0800	update by push
.git/logs/refs/remotes/origin/master:49:62ae88219f9a1ff931ce03ae195eb90568edfa49 8722afe971db2220232c4738aa3e5473ff5db9ac CX-UI <tianfangmmr@126.com> 1509363184 +0800	update by push
.git/logs/refs/remotes/origin/master:50:8722afe971db2220232c4738aa3e5473ff5db9ac 691ed1839994911872176d9a42edf892e660c7e1 CX-UI <tianfangmmr@126.com> 1509366755 +0800	update by push
.git/logs/refs/remotes/origin/master:51:691ed1839994911872176d9a42edf892e660c7e1 53b1b9dd9173ab8081183225e6d28ed56f57a130 CX-UI <tianfangmmr@126.com> 1509463026 +0800	update by push
.git/logs/refs/remotes/origin/master:52:53b1b9dd9173ab8081183225e6d28ed56f57a130 c572955fd847325162cb76f24d963c0774bcd41b CX-UI <tianfangmmr@126.com> 1509507552 +0800	update by push
.git/logs/refs/remotes/origin/master:53:c572955fd847325162cb76f24d963c0774bcd41b 6063f89de03e5e4dde1f6a4a0791ad758156843c CX-UI <tianfangmmr@126.com> 1509540368 +0800	update by push
.git/logs/refs/remotes/origin/master:54:6063f89de03e5e4dde1f6a4a0791ad758156843c 5c18de3951d1380224f87923176e0e1bdef656d5 CX-UI <tianfangmmr@126.com> 1509548698 +0800	update by push
.git/logs/refs/remotes/origin/master:55:5c18de3951d1380224f87923176e0e1bdef656d5 46f64ba7a7b2aaa04e8854769c7eef0a8fe09a54 CX-UI <tianfangmmr@126.com> 1509549649 +0800	update by push
.git/logs/refs/remotes/origin/master:56:46f64ba7a7b2aaa04e8854769c7eef0a8fe09a54 0a9468fd9826a54a23622a55ddf217e38dd19e8c CX-UI <tianfangmmr@126.com> 1509980222 +0800	update by push
.git/logs/refs/remotes/origin/master:57:0a9468fd9826a54a23622a55ddf217e38dd19e8c a09937f53699166e87de92dca9742b0ed26af2f6 CX-UI <tianfangmmr@126.com> 1510068212 +0800	update by push
.git/logs/refs/remotes/origin/master:58:a09937f53699166e87de92dca9742b0ed26af2f6 c15dcc390a87df32d5c655a1c7dfee0a9d392562 CX-UI <tianfangmmr@126.com> 1510113044 +0800	update by push
.git/logs/refs/remotes/origin/master:59:c15dcc390a87df32d5c655a1c7dfee0a9d392562 aa06560566eac212c6d6137fcdd5efb67ca094ab CX-UI <tianfangmmr@126.com> 1510128393 +0800	update by push
.git/logs/refs/remotes/origin/master:60:aa06560566eac212c6d6137fcdd5efb67ca094ab 0066f59c1c87ac37bcdaf58fc4b8b230ecaf18d5 CX-UI <tianfangmmr@126.com> 1510542131 +0800	update by push
.git/logs/refs/remotes/origin/master:61:0066f59c1c87ac37bcdaf58fc4b8b230ecaf18d5 7ae65a742b228ae300719d771c3fef5bb9677c90 CX-UI <tianfangmmr@126.com> 1510629035 +0800	update by push
.git/logs/refs/remotes/origin/master:62:7ae65a742b228ae300719d771c3fef5bb9677c90 fffc9b5e07e4b0d5c1bc52b7ae7eff456f792553 CX-UI <tianfangmmr@126.com> 1510649955 +0800	update by push
.git/logs/refs/remotes/origin/master:63:fffc9b5e07e4b0d5c1bc52b7ae7eff456f792553 914c0aff9e206fa99502ac0c1d20d827e982c99d CX-UI <tianfangmmr@126.com> 1510665169 +0800	update by push
.git/logs/refs/remotes/origin/master:64:914c0aff9e206fa99502ac0c1d20d827e982c99d 698b9109c34a546f6b855deb19b43c58fdf6ad83 CX-UI <tianfangmmr@126.com> 1510811537 +0800	update by push
Binary file .git/index matches
.git/packed-refs:1:# pack-refs with: peeled fully-peeled 
.git/packed-refs:2:0c6a6e67b0d8ac1f1f78214e50f76be572c3f131 refs/remotes/origin/cx-dir
.git/config:7:	url = git@github.com:CX-UI/ADFS.git
.git/config:12:[branch "cx-dir"]
.git/config:14:	merge = refs/heads/cx-dir
Binary file .git/objects/ff/fc9b5e07e4b0d5c1bc52b7ae7eff456f792553 matches
Binary file .git/objects/ff/a35a6b07e7ceb5061bfcb7fd4101fbcc3f1329 matches
Binary file .git/objects/ff/890d5061d8071b7b7d6746699ea3ca0286e1cd matches
Binary file .git/objects/5e/07502c9aa4a699ce87e579f87a8e03aab6fb9c matches
Binary file .git/objects/5e/cd164f7cf3eb5552a11f099aa3024caeff3a1a matches
Binary file .git/objects/5e/bfee540c30e57aaee17d8f4f38c86a1e547edc matches
Binary file .git/objects/46/d6731f987c0505b0cb094e5ba4b9934334bbd5 matches
Binary file .git/objects/5f/dd057a5a84ac20d4ae9c8fea0ed306a9d6a191 matches
Binary file .git/objects/5f/e27907fefaf013d03f39828825591cbff53e6c matches
Binary file .git/objects/5f/8c517713a51f8520be5113d6e136e4628e780e matches
Binary file .git/objects/cd/abd06a320a30b81987511d8ed49172a5fcd1e0 matches
Binary file .git/objects/cd/a1e46992c9a5d9f279a70ea20ab05282455cf2 matches
Binary file .git/objects/95/9570bbec00150729fbbb92d4085948f9b8cdb3 matches
Binary file .git/objects/62/ec2151451081e372e4037b5749575bf49da524 matches
Binary file .git/objects/ea/31a6c6898f0d5a789ceb5be51db0dc4cadeb09 matches
Binary file .git/objects/33/2a0944136a1c207860039d09910f05c599d995 matches
Binary file .git/objects/86/9c44e527c63cecdaa32984bc9cc1876d540e6a matches
Binary file .git/objects/86/24f9db915bcd0d86fd6f32b15290c9a7746902 matches
Binary file .git/objects/ad/e436012e3a8daa07f2b285a0e7e5df054c3438 matches
Binary file .git/objects/ad/bd8f5b67ba597d5c9e99374a5bd216a82e6d04 matches
Binary file .git/objects/13/71289853fdd8fb85317c3519df74d6bab3930a matches
Binary file .git/objects/d5/c0fc363ae6b5f7fc02ef327dcf1d77712bdf6a matches
Binary file .git/objects/58/58962208969d6969555d928f63854ad0f86a5d matches
Binary file .git/objects/10/6005a171c54ad7a625ce5871add13cf109f50d matches
Binary file .git/objects/90/73982a07aa1d32cdbe8fd2a0ae6406a5d7da75 matches
Binary file .git/objects/90/3cce8d4a1bdbdba743e5f13d5b543d4a5d6e22 matches
Binary file .git/objects/a0/b40c644799f021f1ae5730099683bc3fe92f98 matches
Binary file .git/objects/a0/9937f53699166e87de92dca9742b0ed26af2f6 matches
Binary file .git/objects/9f/6e05968d37747218af623deee6d29c6e8ecf79 matches
Binary file .git/objects/fe/8bb6a795783a4e5efcf750b5371931cc37ddf4 matches
Binary file .git/objects/27/c9fef93244709288e82882fe54de63b3d06105 matches
Binary file .git/objects/bf/3ef0e5548b710586061e07a6c8331439ff3715 matches
Binary file .git/objects/3a/94c2c36628641de74054f6a6d591ba3d3c9b04 matches
Binary file .git/objects/pack/pack-124decd22a802dd9aa33dfdc820513505f50483e.pack matches
Binary file .git/objects/pack/pack-124decd22a802dd9aa33dfdc820513505f50483e.idx matches
Binary file .git/objects/68/b42089049a05ad64b0b07c44a430c9aa1c1987 matches
Binary file .git/objects/99/c5c9418f466a059b441b67d2876350b8e403ca matches
Binary file .git/objects/99/f2ed8bc22121ce0b4821dd0f3f5988e9ef2851 matches
Binary file .git/objects/98/5025003c778493f98cccb388fb15f22a538185 matches
Binary file .git/objects/98/53c11abea67d938b342e828d9b79dd7d77b813 matches
Binary file .git/objects/3d/ad229536a5b32df014be6462d44f0c01ae3879 matches
Binary file .git/objects/3d/82dc346cc34fefac996cb022007cc33d6e6db7 matches
Binary file .git/objects/3d/a324d6e57cb67b657c0ff95c65bae0072835e8 matches
Binary file .git/objects/85/758f7ec0cb09ceef8e925f5f0f4b8e8379e3c3 matches
Binary file .git/objects/e7/7070d064bd9ec52265054699962e59818a8dab matches
Binary file .git/objects/e7/4efc0e1783801acaf0a6b6da112f4e2f6aad0a matches
Binary file .git/objects/e7/ab17130ea0c0086e1df72c599e1a43725d7f5a matches
Binary file .git/objects/71/e780ef77604fa533d0f112a55927b85a3eb6f0 matches
Binary file .git/objects/71/26b5f33e9c02e213d7920461b59b9400f4525a matches
Binary file .git/objects/71/9196d47a4f606fd239f9b96d44a6d0cd80f481 matches
Binary file .git/objects/71/205c3247d2d633ee540d7dbc30a0f4d52c185e matches
Binary file .git/objects/71/55c9a36cef8a0841a159c21417ee59c42c6117 matches
Binary file .git/objects/71/02fc4680a6beec6a759943725afbe3bef4cef8 matches
Binary file .git/objects/71/fbc396d801516afdf76610319fb0a6bfc2ac52 matches
Binary file .git/objects/59/48b8546065a61ce44130396b2416810d5f9a39 matches
Binary file .git/objects/bb/ef9dfb58f1351e7f214b8e1418bb4b8303a5fc matches
Binary file .git/objects/bb/9ba1cb5fd932766fd9ccdb06a40d4d998c1948 matches
Binary file .git/objects/49/839930e834a68849693992285b1d441f9c8faa matches
Binary file .git/objects/49/3f22aa44f859bc18c38226969b4f468ab31212 matches
Binary file .git/objects/e0/b6c32f65091b3ffc5f0e38c46a76a456969b91 matches
Binary file .git/objects/1a/e8ebeda981220e745a4cc9c12fea3bd330f567 matches
Binary file .git/objects/1a/7713457bf0f77619c73a43b4b098a8efcc884a matches
Binary file .git/objects/0d/3d3c92aae6daa2690a83f8f65812f25e1c174b matches
Binary file .git/objects/be/c15db0700e7fcfc1ea4fcc189e700d70b7ce8b matches
Binary file .git/objects/be/e97fbee97e0144b8e89995d3ea251969ba12d0 matches
Binary file .git/objects/f8/d48e8bacd8dd359c38b72a75613c5f23e9d09c matches
Binary file .git/objects/1c/0bcadf86513eb0c392793a236bba4609907e02 matches
Binary file .git/objects/a8/83a946e6e581f7ee10347cd62e7ab560ffda08 matches
Binary file .git/objects/9d/bb868f7ee35fc51e7616b88498fd42cb32a5d6 matches
Binary file .git/objects/db/73130bea183844309a0c76ab0177e97060cf68 matches
Binary file .git/objects/8e/f3d87752aa28a0e7e7774cc888bb96da6ce89a matches
Binary file .git/objects/8e/ed5cbd3950bc4612aabc6a46e9240d4aa029e5 matches
Binary file .git/objects/ed/20f9b92381adc667be92945fdb95258fb18480 matches
Binary file .git/objects/6c/f994baafcbf0ffc46e72e5d079b875bf6ab86d matches
Binary file .git/objects/6c/dfe3860dad011a1b25cf3d387f4ced4550081d matches
Binary file .git/objects/0b/e061ed0b258da64896253be594596ea8f325a8 matches
Binary file .git/objects/0b/64124d66ee1fae8395c52ff8d144e7eccbee48 matches
Binary file .git/objects/f1/29cf4fb6d1535f62042c5dae8d7635538418c8 matches
Binary file .git/objects/54/7e765613bd7b37411db12ef032cca2f1e51cab matches
Binary file .git/objects/54/98b43e61b92f22d0eb6f5853bc18e485c8ff32 matches
Binary file .git/objects/43/678af8b4d028028a7c43291a6404dc797416db matches
Binary file .git/objects/5b/7d4727dbc552576e1411b2a01bb5b9b615604d matches
Binary file .git/objects/7a/3c5e49e7c8e403227e0cb04df3194d68cbc774 matches
Binary file .git/objects/da/fdc07ae17a10d0e0610590f36fb90c3b630a8c matches
Binary file .git/objects/09/f5cf963ea393f7436af9036f9488dab727fc0f matches
Binary file .git/objects/09/c014c7d137603014b838820fbee4cfd3cdb105 matches
Binary file .git/objects/09/7486b8126fb6b477fb03435c8ed958aa5ead8e matches
Binary file .git/objects/09/b33d6117fcd02260ae282a6543bb2fcee3beb5 matches
Binary file .git/objects/09/846e6caa655231293ff6b1b6a2906f489e713b matches
Binary file .git/objects/a3/e6929361ae0464878df407c4eb7d8135bac993 matches
Binary file .git/objects/fb/0000a0dee3da5a5d215118cfd54748b0669cba matches
Binary file .git/objects/fb/fa98ea426fdc04dee61a415df73357f384bca0 matches
Binary file .git/objects/2a/3c804c9fa88a063d5964edbe7d04fe968d68b5 matches
Binary file .git/objects/f3/dec74164ae6c08a39996cd599b2555087c7a70 matches
Binary file .git/objects/3f/4c3d1c6135d8b2c669ed80d301ef77665f92e3 matches
Binary file .git/objects/c7/809d26e87ec34025cddea4ac5b55d98b6ef02b matches
Binary file .git/objects/4c/fc86da5a4a7d58a7747077da546300cae303c5 matches
Binary file .git/objects/4c/9a6d1489b8997e5dd053ea7aa8db6fdc5b92ba matches
Binary file .git/objects/1b/43eff3cf4049f03dbbc05d34e15f2e6e0f9a72 matches
Binary file .git/objects/1b/671ae5c476f0ebff9947b505a9e884e248f8e4 matches
Binary file .git/objects/1b/cf9eb4cee55a6257dd0a35ccb7d6f0ad8e34a8 matches
Binary file .git/objects/45/2f33bef2a31b196d85ceafdd9f92c7df2d348c matches
Binary file .git/objects/2f/15c24c5cfc66dc2a64723f0ab995b780e82584 matches
Binary file .git/objects/2f/0b465292180677b0d72857656579eeaed72429 matches
Binary file .git/objects/2f/83eccb83925ae018f7d1701852b671edefe4dc matches
Binary file .git/objects/2e/a0b034daf6caa839a3faf4c1e686783d646dac matches
Binary file .git/objects/91/818ff6a9fd1be7deff4bf38bdad9bb1a71b736 matches
Binary file .git/objects/02/5e768adfe32549a28092d2992c4f4cd40253c8 matches
Binary file .git/objects/2c/de5860acc81f1d9ef0ab83facde16c6122ab95 matches
Binary file .git/objects/2c/f0f793a4ec3d6b95c42057df93bace079ffe97 matches
Binary file .git/objects/aa/06560566eac212c6d6137fcdd5efb67ca094ab matches
Binary file .git/objects/aa/af6bb4bf2f1469275fac2ff21db681f0fc9bd9 matches
Binary file .git/objects/47/174eb396e11fe0fb204107b31d5120a638a0c2 matches
Binary file .git/objects/47/9d009e5d47d1d7ab0368cf218fcaa32278482c matches
Binary file .git/objects/c5/d9b13ac1e27d66a33e0ff9dbfb19942aa47fff matches
Binary file .git/objects/c5/e533c99e5ed8eef7ef83252c31f827a85604e2 matches
Binary file .git/objects/e9/766e3ff4269ed3360b3cf17f98804ac93b3014 matches
Binary file .git/objects/c0/bfb548601efe3658306b721e86d2ce19e245a0 matches
Binary file .git/objects/17/050182dd465d027e9d63f39e3440cce4719be4 matches
Binary file .git/objects/17/fbd93d98499ab1e95bade5ca48dd6ab34f5c43 matches
Binary file .git/objects/19/d3ec8a4958664eac095b3653245483e9261a2b matches
Binary file .git/objects/19/c812faaa8a1d68c53d6ac8f42c0c59cee0a495 matches
Binary file .git/objects/19/37bd2860b9edc6c91921231f20c4d54511329c matches
Binary file .git/objects/52/e7b583e948246a8586a505dfc3919801601b9d matches
Binary file .git/objects/05/e6e8a9935e0851ef8080679106c937be69f609 matches
Binary file .git/objects/05/46edaa76c411af840a188a168c1a436621df68 matches
Binary file .git/objects/08/37320059f84757b57a71f0cc24a48b5e643a68 matches
Binary file .git/objects/08/f153122fdf76cb1685f098d4d3ee07291d351a matches
Binary file .git/objects/8d/f100b2adb9d89996d27a7869f59e7e80db5717 matches
Binary file .git/objects/21/83ae27832af7cd0d4b072d565f06fa18cd1e08 matches
Binary file .git/objects/21/9d75ff61ef0cafcebb9f3ea62eb647fcd7bac6 matches
Binary file .git/objects/81/47e9f418cede1512c19a68a9278c94aa7d51a1 matches
Binary file .git/objects/4b/aa1e86f2a6fae21719971a85b90b222a9d2776 matches
Binary file .git/objects/75/13a15bf70d256429ded30430082ab93b8a4fe1 matches
Binary file .git/objects/de/593550e7c4156668feaabdd03336c0dc5d2e59 matches
Binary file .git/objects/de/57f46d8db761cd19ddc7829efdadb86dbdc67e matches
Binary file .git/objects/de/f2ec75315d661ff99dce0dd0fad732082af2aa matches
Binary file .git/objects/e5/47503d0562180334a8fbda2a13b7ddbdea8300 matches
Binary file .git/objects/f5/e2120b3663d4ea82a02963cde6f369e78abc69 matches
Binary file .git/objects/06/c2f06f02388ee67e83b2d3369ca04dd82c986c matches
Binary file .git/objects/96/b04d61c0953cc6714d93bbf4da0f1770a36818 matches
Binary file .git/objects/96/f9a064dd305f9858e756555f1e994a76336eeb matches
Binary file .git/objects/c8/d6e0bbb78fd3aeb1c68944a50187dadfb36055 matches
Binary file .git/objects/c8/15e78bf24225d0c7d7ba4e4abc7b24a43882a6 matches
Binary file .git/objects/a2/b25bda15f50ab2ee629db38d5cde9dd444cc0a matches
Binary file .git/objects/a6/acad41cc1297ec9dab14857dc8d9b3fc2ce46c matches
Binary file .git/objects/15/26b383189caa58aad2ee419b2abe79acdcf072 matches
Binary file .git/objects/15/21cf5ef45c0b62a2c416222d25cc64a6cfed27 matches
Binary file .git/objects/15/6fc7b446105e6160a8a10b0870021759eec8b3 matches
Binary file .git/objects/6b/ac146d3585a753f4a96307bf65d6f43338aeba matches
Binary file .git/objects/6b/0efca911afc59366d24aed8d20a467d4c45626 matches
Binary file .git/objects/82/5662f05a50baa93a577ae05c0698b88a5fce49 matches
Binary file .git/objects/9b/f47057b4ad445c72fdcccb2b80b8a81a9c9fc2 matches
Binary file .git/objects/9b/97f60521c8b00fee64c24164ec279d08b194d1 matches
Binary file .git/objects/ab/2775a9ca332002eb75d0685ef2c61d464df8c4 matches
Binary file .git/objects/ab/3f52fca25ec41860b31facd5dbf3bea8c3add1 matches
Binary file .git/objects/d9/3dbe8342b1aa73f7fe0d9cc0b24dc153e9d74b matches
Binary file .git/objects/d9/4b30d36415fd363fac2eb838768d384ef29efb matches
Binary file .git/objects/7c/eba05b3b99b764d2ba8315726a82e4cfc1fda5 matches
Binary file .git/objects/7c/f693b0c313e16744a96bf50027b54b4fef0a5e matches
Binary file .git/objects/9a/8f5d7477d978f07559ad25595da87d5847f9b8 matches
Binary file .git/objects/36/b91bd430d41a2bebc1ba5ed4ab02283e443790 matches
Binary file .git/objects/d1/833e1b89aabcffc344ebeffb82c54b5ab232cb matches
Binary file .git/objects/d1/a143503f2da2884631e8f848ff70a657484dab matches
Binary file .git/objects/f4/24571fd5e8c247f914339b4b7b5e77c48b8ab0 matches
Binary file .git/objects/c9/38018b448c95d01342c0a53b9f4a44241ba4d4 matches
Binary file .git/objects/29/c14398ad5263da048f8e64bf732362b7c2d4b6 matches
Binary file .git/objects/cf/1ea0fd351272fb1dde8b3f756461f0a78b3c5d matches
Binary file .git/objects/cf/db92db3646af88eaf4e6ae82647cc6f0bc88bc matches
Binary file .git/objects/cf/6d68a1d84aa9e82ee587bd3a7308a891461301 matches
Binary file .git/objects/cf/eb4b9bc22e19198418ee001671ed78a7fc6aa8 matches
Binary file .git/objects/a1/2bbc54e2a9520e2b48c50f3de034d2f8c99f3f matches
Binary file .git/objects/a1/685a686e013e0d08223ab9c3ad68dad9ea2516 matches
Binary file .git/objects/a1/b05fee3b51f6132c1e8228bce2410dcad8ab50 matches
Binary file .git/objects/37/cfa02c2168e6a2fcc67e3c0352451fe69d3597 matches
Binary file .git/objects/37/f3f1e5673ae29e47573ae4de24c172c2762601 matches
Binary file .git/objects/37/b4ef65ec6f64fecef1cb0f9cc8fc0aff6f50f2 matches
Binary file .git/objects/04/9cf317faebe9d1202d02be8d6a28885376ce7c matches
Binary file .git/objects/53/7ab7f9f843c695c8f9fed9fe7545248cfee2fe matches
Binary file .git/objects/53/b1b9dd9173ab8081183225e6d28ed56f57a130 matches
Binary file .git/objects/c1/206ec920a0afcb3db73cbe06d1ea4a124704ea matches
Binary file .git/objects/c1/27321f5cb78648932306d6d34eb28c186326ae matches
Binary file .git/objects/c1/1136f45019a78555817e76232c037604b20389 matches
Binary file .git/objects/c1/efceb3994bfdad4da57b028cce01dc77dbbc07 matches
Binary file .git/objects/89/2d42238ee1bf76338abc8237a82de2f4c7b210 matches
Binary file .git/objects/89/a73456774cf0e766317061e6d18f9cc65e4e82 matches
Binary file .git/objects/fa/17e449f73a62c51c180110359776dce8e7a33a matches
Binary file .git/objects/fa/87fe605f4acb643a97ab1366ae58ad3802794f matches
Binary file .git/objects/cc/c306937843777db7e0a9ca978713ee66eeab72 matches
Binary file .git/objects/cc/2d9d1bdaa5aa12a7ad857780d18055e64746e3 matches
Binary file .git/objects/1f/2d009d8bea9ba4942746cb9b78a40ac86acb4f matches
Binary file .git/objects/38/df67d52dab81c6e291cce10e33f2c3a927d4c2 matches
Binary file .git/objects/83/65522a7c2b8e868a8043832565bee25154fb14 matches
Binary file .git/objects/df/d3c926fc1bae41a63a0569b8023032c85970ff matches
Binary file .git/objects/df/98e390b061ac2964332e5aa9229910f0f4ffea matches
Binary file .git/objects/79/eacf6950d7a9b858fb191110d3006cf0b62a8d matches
Binary file .git/objects/64/910761defaf306fdd740799a5a25a702c1897a matches
Binary file .git/objects/6d/0dc0258948492e05e1c1de26b03ce4c720bcee matches
Binary file .git/objects/6d/73726a3cb0d94f00aa7e5031734a25834aafab matches
Binary file .git/objects/4a/ef580b58554d8816c698b857603d8768515c5e matches
Binary file .git/objects/4a/d5ed08d13ecc8c614a76fdb8ceac14c0e298fb matches
Binary file .git/objects/3b/ce3a870c80a5ed34b9ef245037b313b809af33 matches
Binary file .git/objects/3b/5b66675a5ae6a168af7ce5447bc0a8046e4291 matches
Binary file .git/objects/3b/e399808ad60d002d0630693c05de8bb5bccf7c matches
Binary file .git/objects/3b/2c28e1d2800f9ca7193cd82325ee83bb77ad77 matches
Binary file .git/objects/3b/21ae1f00b4fed47528cc9824197093d31e5d3f matches
Binary file .git/objects/66/30159f26767541e2685c96d2496cf6562c7d2c matches
Binary file .git/objects/3c/c603fb022a137aabf27b832570959a61df51f8 matches
Binary file .git/objects/3c/24ae065aa36aa65524d241eb610f97c54eb15e matches
Binary file .git/objects/97/2b451a9f82d3eaabab35594e3f397af3f7ab40 matches
Binary file .git/objects/d8/f787e7341e6ebe00fd27ce33c5cddc6d88f055 matches
Binary file .git/objects/bc/c189747eeb63a1ea695d2a70188308f3f22f9f matches
Binary file .git/objects/bc/8f218bfc6aaa9b5066b6c1b1e50b86803c1e05 matches
Binary file .git/objects/0e/fc7b5b7052a7daf5187307ac9813820f233eb3 matches
Binary file .git/objects/0e/0474b400d3a14ee6a36ebff6d5dacd8b943791 matches
Binary file .git/objects/51/d26d39f2d1590e69245255c7055e579d4c9a41 matches
Binary file .git/objects/0c/bb7d2f6c047386570d7ee6712614f0e75a72a1 matches
Binary file .git/objects/73/aaa304aabef461ab43c95f8039e60a6aa9ad51 matches
Binary file .git/objects/73/f9542fabb6214f49151927d151ca772b30f29f matches
Binary file .git/objects/84/b0b351d3403678e5d24d370d33c8d4a3396d64 matches
Binary file .git/objects/84/d39a7febe5c8c6034549934981fd4f939a9434 matches
Binary file .git/objects/00/66f59c1c87ac37bcdaf58fc4b8b230ecaf18d5 matches
Binary file .git/objects/00/78df61125b482dc9ce52b8a113303455f907c0 matches
Binary file .git/objects/74/de46a6a8f27c4528da5d84f552762fecee7ed7 matches
Binary file .git/objects/8c/da702fe30225def87abc19e53a9b93024e60d4 matches
Binary file .git/objects/8c/fcc2840c3539e6bf60642812e2efd1428a7c95 matches
Binary file .git/objects/56/eaa8f270c465c5fd5f540816d30fde089a17dd matches
Binary file .git/objects/56/ecce3f1dcbb56b8aff82c170542c5002a8c66e matches
Binary file .git/objects/8f/e46b58dc19952869f406dac3f20b440c81e44d matches
Binary file .git/objects/07/9d037e1992100029d8a38f0a30bc49ff611118 matches
Binary file .git/objects/07/c1fae57aa6415ea15e4e0766cf2a5dc5e8110f matches
Binary file .git/objects/07/b5f33e64695063bd1a4e8a5f6c4eb601887863 matches
Binary file .git/objects/39/b0d11485d29643aa96f3c7ac75da708c43fc74 matches
Binary file .git/objects/3e/8adba351f555c52e0db1ae9b22d80a4da59437 matches
Binary file .git/objects/3e/9f64f97491c0727c785396360e8492b09b2f54 matches
Binary file .git/objects/fd/18e772a360bd6c7f101ea9cad26ca5880b7b3c matches
Binary file .git/objects/fd/9a15d358a9390c9d3d7ebf3e06c7021e723003 matches
Binary file .git/objects/5d/2e114aa94943d22ccc5a40ba4e54fe878b64bd matches
Binary file .git/objects/5d/84132d7115f214a45319c6df802ef463351868 matches
Binary file .git/objects/18/3be63d37c38b2a62f900ef42bc01567c658feb matches
Binary file .git/objects/e2/8bdbfa78bf66ede47bbbe15c726125f78f0cfa matches
Binary file .git/objects/69/8b9109c34a546f6b855deb19b43c58fdf6ad83 matches
Binary file .git/objects/69/20ddd8fc264f12999c148d37e02328f0f373e3 matches
Binary file .git/objects/69/721f9827d1d9c520faa4ace09ca98ecaaa83ec matches
Binary file .git/objects/7f/e71e02893217f66e6c5289a2a72084e5f53032 matches
Binary file .git/objects/7f/d23888e8b104eeecec5e5d5a22874e1f28b399 matches
Binary file .git/objects/7f/1a773e51ae8464972e38688abe54de1f41a597 matches
Binary file .git/objects/22/3f638c0e892c031dff6b581a49abfd6871e171 matches
Binary file .git/objects/22/785036f47165753850b5d5792d664c7bc2a653 matches
Binary file .git/objects/22/258cc3debff76bab09445134ee5dfdc5f52beb matches
Binary file .git/objects/7d/0e2ddcd9af558e95f21a1b1729ac976d0c760a matches
Binary file .git/objects/7d/0cda6cd25e52cacc249591ae6de5ea34cca73d matches
Binary file .git/objects/9c/33a2040a62e3d524bc033daf712c9f4b355cba matches
Binary file .git/objects/44/5dafa51064e860898817b653517a8ad175fd47 matches
Binary file .git/objects/ac/45b09c74ce4dae029ae361ff5ea9ea3a990ba3 matches
Binary file .git/objects/b9/73cbaf69acd8e55fa17bdca7ec95c0674a561a matches
Binary file .git/objects/b9/1a4a70bb92b9f34725870a7d684992ddc78faf matches
Binary file .git/objects/6a/03746401818e277345f69c3394f2746a4020a7 matches
Binary file .git/objects/6a/580b07d89af791f8d2c9777ad501fd435ef11b matches
Binary file .git/objects/6a/d461785c94f1e9573badbad2e42273e3ab620c matches
Binary file .git/objects/0f/2ff88f6caec6fa3695d442c0767be013bb47a6 matches
Binary file .git/objects/32/282ea4a203efa3be69c71e044ec9701643a639 matches
Binary file .git/objects/32/389a9bf3b3d2d755f27e13ce59790692882973 matches
Binary file .git/objects/0a/76657e65707d63735490aeac713c89c9e2f51d matches
Binary file .git/objects/0a/06586b1c312544cbb2576cc38a1a10fe675121 matches
Binary file .git/objects/0a/9468fd9826a54a23622a55ddf217e38dd19e8c matches
Binary file .git/objects/c4/a83546de3c48c60c7cf3a23a3bc34573d5c40c matches
Binary file .git/objects/c4/d4dcc6a14861392bf871b798fe70ba15118fcf matches
Binary file .git/objects/c4/7e2a489eed73d85fbe9702c2d817fd5be2539c matches
Binary file .git/objects/fc/bc1a18e266d56f4631276eb7ff39a72573a8de matches
Binary file .git/objects/fc/0f910261748abda3db69c129f9c3b66cac3997 matches
Binary file .git/objects/d6/d625d4fceba1831444cb5eed869810adae62a7 matches
Binary file .git/objects/d6/57ded57b6715dfa572322af3eceba0a609c2a1 matches
Binary file .git/objects/d6/141c07a60994694b16a25d9654843a9149c13f matches
Binary file .git/objects/67/87b5a7ae67a2fd754ef4d726e0c8ea6aef0d49 matches
Binary file .git/objects/a7/8b2fd3348dbfbfe263f7e8fd2db19697dc8d93 matches
Binary file .git/objects/a7/13c87140606a76a19e66048fcdf2377771c24e matches
Binary file .git/objects/f7/26498ad387ca7a83de84da150b3f1a086177e2 matches
Binary file .git/objects/25/0f88e01b225d1b2fa4196978109fdba33e76b1 matches
Binary file .git/objects/92/a178f85c548c102863a538d4257d2d24229ee3 matches
Binary file .git/objects/92/3e83e2ec9dfd8d9f1090a6617dfadc02a88361 matches
Binary file .git/objects/1d/aa0ed9c030dc46fe1dccfb5700c64976d51e1c matches
Binary file .git/objects/1d/9ab59df8d5a541dbf0cca8138f24d93e737ed9 matches
Binary file .git/objects/a9/d3aef0f569e46ce510462133d8a9edbcd0b6c3 matches
Binary file .git/objects/b3/f3a4fc8cfb4f06965c0908005e78c92eea8175 matches
Binary file .git/objects/72/511b891ad7ead859c497ca09a139154e9db4ea matches
Binary file .git/objects/7b/55d86072b6fa6510bf85d9c3c63b9d5445d07e matches
Binary file .git/objects/e4/620a83c57ca48f71976ce3ce7f0bcd37a935b8 matches
Binary file .git/objects/8a/52bae929b57dc86af677ed7bfed65d9c903603 matches
Binary file .git/objects/63/fac9de38da83bc5499138bdbd348f283194a0c matches
Binary file .git/objects/78/d22911711b35a857386c7be2a5e58f192f085f matches
Binary file .git/objects/78/7c05cc9236d32737dd449f5e82c5cc06ff09a6 matches
Binary file .git/objects/78/459d10f737557112a70b31ce15d2fba9990c53 matches
Binary file .git/objects/34/8ad4a313db019a39545947010af5ba2734d62d matches
Binary file .git/objects/34/cbdd018b570fc4b4eba80eac181ed2b8fe6011 matches
Binary file .git/objects/34/8c72a209a44706183e07678fce76c16222bf0c matches
Binary file .git/objects/34/a53912c35dfe40b26341e097cd8e7ab0b12ded matches
Binary file .git/objects/d0/73d6a89aa17e50fcfba0cc91f38c5170b30d94 matches
Binary file .git/objects/d0/0f4ff2befb64ca04ed94e2e4dfabbdd0e01e84 matches
Binary file .git/objects/d0/3cc5cdae3ec31c6a41eb8e56a8daea970c6cbc matches
Binary file .git/objects/11/dc32cfdd496e4e76f7cb36161aa0b669dada74 matches
Binary file .git/objects/11/7eecaaa9c5138f0c298c485d2eac52671940de matches
Binary file .git/objects/11/d338850b9490f32c6e0b5c7bd7e3896808fa98 matches
Binary file .git/objects/94/f4c05d06ad8b3bad0faa1da423f62ef698b530 matches
Binary file .git/objects/03/8d09b9a33c904f8ca3417af85834cf92fbcdd4 matches
Binary file .git/objects/03/f1a8fe061469c498d9d6a60279d2b230abefac matches
Binary file .git/objects/5c/e183cafc66ea0078d75b9b085e3003726b9578 matches
Binary file .git/objects/5c/9566f465d68f37ea757ecc7408d187d92fb7a8 matches
Binary file .git/objects/5c/2a352f7ff00619683d1b537702f2dc44cac135 matches
Binary file .git/objects/5c/6374c075aefa59e3b4ed318f42311f89b9c985 matches
Binary file .git/objects/5c/5b67efa86e69cbf793c2204527d2b60c9943e3 matches
Binary file .git/objects/5c/3482d888ee1abd33a7ce7b461c9a15335367c9 matches
Binary file .git/objects/af/33121fc34f5566ee8d55b3a65058ca0b55c13e matches
hash.c:26:        return -ENOMEM;
hash.c:41:    p->hash_map = ht->hash_map;
hash.c:43:    p->hash_max = NR_HASH_ENTRIES;
hash.c:44:    p->he = ht->hash_entry;
hash.c:48:/* record dentry-pos pairs in hash table
hash.c:66:    //ht_addr = dzt_ei->ht_head;
hash.c:69:        return -EINVAL;
hash.c:93:        if(!test_bit_le(h_pos, ht_p->hash_map))
hash.c:98:    tail = le64_to_cpu(ht->hash_tail);
hash.c:101:        ht->hash_tail = cpu_to_le64(tail);
hash.c:112:    he = ht->hash_entry[h_pos];
hash.c:113:    he->hd_name = cpu_to_le64(hashname);
hash.c:114:    he->name_len = cpu_to_le64(namelen);
hash.c:115:    he->hd_pos = cpu_to_le64(pos);
hash.c:116:    test_and_set_bit_le(h_pos, ht_p->hash_map);
hash.c:160:        if(!test_bit_le(h_pos, ht_p->hash_map)){
hash.c:165:        he = ht->hash_entry[h_pos];
hash.c:166:        h_name = le64_to_cpu(he->hd_name);
hash.c:167:        h_len = le64_to_cpu(he->name_len);
hash.c:169:            *pos = le64_to_cpu(he->hd_pos);
hash.c:177:    tail = le64_to_cpu(ht->hash_tail);
hash.c:223:        if(!test_bit_le(h_pos, ht_p->hash_map)){
hash.c:228:        he = ht->hash_entry[h_pos];
hash.c:229:        h_name = le64_to_cpu(he->hd_name);
hash.c:230:        h_len = le64_to_cpu(he->name_len);
hash.c:232:            clear_bit_le(h_pos, ht_p->hash_map);
hash.c:240:    tail = le64_to_cpu(ht->hash_tail);
dax.c:6: * Copyright 2015-2016 Regents of the University of California,
dax.c:7: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
dax.c:8: * Copyright 2012-2013 Intel Corporation
dax.c:9: * Copyright 2009-2011 Marco Stornelli <marco.stornelli@gmail.com>
dax.c:26:	struct inode *inode = filp->f_mapping->host;
dax.c:27:	struct super_block *sb = inode->i_sb;
dax.c:29:	struct nova_inode_info_header *sih = &si->header;
dax.c:42:		error = -EFAULT;
dax.c:51:		__func__, inode->i_ino,	pos, len, isize);
dax.c:53:	if (len > isize - pos)
dax.c:54:		len = isize - pos;
dax.c:59:	end_index = (isize - 1) >> PAGE_SHIFT;
dax.c:70:			nr = ((isize - 1) & ~PAGE_MASK) + 1;
dax.c:86:		if (index < entry->pgoff ||
dax.c:87:			index - entry->pgoff >= entry->num_pages) {
dax.c:89:				"blocknr %llu\n", __func__, index, entry->pgoff,
dax.c:90:				entry->num_pages, entry->block >> PAGE_SHIFT);
dax.c:91:			return -EINVAL;
dax.c:93:		if (entry->invalid_pages == 0) {
dax.c:94:			nr = (entry->num_pages - (index - entry->pgoff))
dax.c:104:		nr = nr - offset;
dax.c:105:		if (nr > len - copied)
dax.c:106:			nr = len - copied;
dax.c:121:			error = -EFAULT;
dax.c:125:		copied += (nr - left);
dax.c:126:		offset += (nr - left);
dax.c:174:				sb->s_blocksize - offset);
dax.c:192:	struct nova_inode_info_header *sih = &si->header;
dax.c:199:	offset = pos & (sb->s_blocksize - 1);
dax.c:200:	num_blocks = ((count + offset - 1) >> sb->s_blocksize_bits) + 1;
dax.c:202:	offset = pos & (nova_inode_blk_size(pi) - 1);
dax.c:203:	start_blk = pos >> sb->s_blocksize_bits;
dax.c:204:	end_blk = start_blk + num_blocks - 1;
dax.c:225:			((num_blocks - 1) << sb->s_blocksize_bits));
dax.c:226:	eblk_offset = (pos + count) & (nova_inode_blk_size(pi) - 1);
dax.c:234:					sb->s_blocksize - eblk_offset);
dax.c:241:					sb->s_blocksize - eblk_offset, 0);
dax.c:255:	while (curr_p != pi->log_tail) {
dax.c:261:				__func__, pi->nova_ino);
dax.c:262:			return -EINVAL;
dax.c:302:				__func__, pi->nova_ino);
dax.c:303:			return -EINVAL;
dax.c:316:		blocknr = entry->block >> PAGE_SHIFT;
dax.c:317:		nova_free_data_blocks(sb, pi, blocknr, entry->num_pages);
dax.c:327:	struct address_space *mapping = filp->f_mapping;
dax.c:328:	struct inode    *inode = mapping->host;
dax.c:330:	struct nova_inode_info_header *sih = &si->header;
dax.c:331:	struct super_block *sb = inode->i_sb;
dax.c:356:	 * since write is copy-on-write while mmap is DAX (in-place).
dax.c:359:		return -EACCES;
dax.c:363:	sb_start_write(inode->i_sb);
dax.c:365:		mutex_lock(&inode->i_mutex);
dax.c:368:		ret = -EFAULT;
dax.c:373:	if (filp->f_flags & O_APPEND)
dax.c:380:	offset = pos & (sb->s_blocksize - 1);
dax.c:381:	num_blocks = ((count + offset - 1) >> sb->s_blocksize_bits) + 1;
dax.c:389:	inode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;
dax.c:393:			__func__, inode->i_ino,	pos, count);
dax.c:395:	temp_tail = pi->log_tail;
dax.c:397:		offset = pos & (nova_inode_blk_size(pi) - 1);
dax.c:398:		start_blk = pos >> sb->s_blocksize_bits;
dax.c:400:		/* don't zero-out the allocated blocks */
dax.c:414:		bytes = sb->s_blocksize * allocated - offset;
dax.c:418:		kmem = nova_get_block(inode->i_sb,
dax.c:419:			nova_get_block_off(sb, blocknr,	pi->i_blk_type));
dax.c:421:		if (offset || ((offset + bytes) & (PAGE_SIZE - 1)) != 0)
dax.c:428:		copied = bytes - memcpy_to_pmem_nocache(kmem + offset,
dax.c:436:							pi->i_blk_type));
dax.c:441:		if (pos + copied > inode->i_size)
dax.c:444:			entry_data.size = cpu_to_le64(inode->i_size);
dax.c:450:			ret = -ENOSPC;
dax.c:460:			count -= copied;
dax.c:461:			num_blocks -= allocated;
dax.c:467:				status = -EFAULT;
dax.c:478:	data_bits = blk_type_to_shift[pi->i_blk_type];
dax.c:479:	le64_add_cpu(&pi->i_blocks,
dax.c:480:			(total_blocks << (data_bits - sb->s_blocksize_bits)));
dax.c:490:	inode->i_blocks = le64_to_cpu(pi->i_blocks);
dax.c:494:	nova_dbgv("blocks: %lu, %llu\n", inode->i_blocks, pi->i_blocks);
dax.c:497:	if (pos > inode->i_size) {
dax.c:499:		sih->i_size = pos;
dax.c:508:		mutex_unlock(&inode->i_mutex);
dax.c:509:	sb_end_write(inode->i_sb);
dax.c:529:	struct super_block *sb = inode->i_sb;
dax.c:532:	struct nova_inode_info_header *sih = &si->header;
dax.c:555:		if (entry->invalid_pages == 0)
dax.c:556:			num_blocks = entry->num_pages - (iblock - entry->pgoff);
dax.c:574:	inode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;
dax.c:580:		next_pgoff = entry->pgoff;
dax.c:583:			ret = -EINVAL;
dax.c:587:		num_blocks = next_pgoff - iblock;
dax.c:607:							pi->i_blk_type));
dax.c:613:	entry_data.size = cpu_to_le64(inode->i_size);
dax.c:616:						&entry_data, pi->log_tail);
dax.c:619:		ret = -ENOSPC;
dax.c:624:	data_bits = blk_type_to_shift[pi->i_blk_type];
dax.c:625:	le64_add_cpu(&pi->i_blocks,
dax.c:626:			(num_blocks << (data_bits - sb->s_blocksize_bits)));
dax.c:635:	inode->i_blocks = le64_to_cpu(pi->i_blocks);
dax.c:646:	map_bh(bh, inode->i_sb, nvmm);
dax.c:648:		bh->b_size = sb->s_blocksize * num_blocks;
dax.c:656:	unsigned long max_blocks = bh->b_size >> inode->i_blkbits;
dax.c:664:		bh->b_size = ret << inode->i_blkbits;
dax.c:677:	struct nova_inode_info_header *sih = &si->header;
dax.c:689:		start_blk = pos >> sb->s_blocksize_bits;
dax.c:690:		offset = pos & (sb->s_blocksize - 1);
dax.c:691:		bytes = sb->s_blocksize - offset;
dax.c:698:					__func__, inode->i_ino, sih->ino, start_blk);
dax.c:699:			nova_dbg("mmap pages %lu\n", sih->mmap_pages);
dax.c:700:			ret = -EINVAL;
dax.c:706:		copied = bytes - memcpy_to_pmem_nocache(kmem + offset,
dax.c:713:			count -= copied;
dax.c:720:				status = -EFAULT;
dax.c:754:	sb_start_write(inode->i_sb);
dax.c:756:	offset = pos & (sb->s_blocksize - 1);
dax.c:757:	num_blocks = ((count + offset - 1) >> sb->s_blocksize_bits) + 1;
dax.c:759:	inode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;
dax.c:763:		__func__, inode->i_ino, pos >> sb->s_blocksize_bits,
dax.c:768:		offset = pos & (nova_inode_blk_size(pi) - 1);
dax.c:769:		start_blk = pos >> sb->s_blocksize_bits;
dax.c:779:		bytes = sb->s_blocksize * allocated - offset;
dax.c:783:		kmem = nova_get_block(inode->i_sb,
dax.c:784:			nova_get_block_off(sb, blocknr,	pi->i_blk_type));
dax.c:786:		if (offset || ((offset + bytes) & (PAGE_SIZE - 1)))
dax.c:799:							pi->i_blk_type));
dax.c:805:		entry_data.size = cpu_to_le64(inode->i_size);
dax.c:811:			ret = -ENOSPC;
dax.c:820:			count -= copied;
dax.c:821:			num_blocks -= allocated;
dax.c:827:				status = -EFAULT;
dax.c:840:	data_bits = blk_type_to_shift[pi->i_blk_type];
dax.c:841:	le64_add_cpu(&pi->i_blocks,
dax.c:842:			(total_blocks << (data_bits - sb->s_blocksize_bits)));
dax.c:844:	inode->i_blocks = le64_to_cpu(pi->i_blocks);
dax.c:855:	sb_end_write(inode->i_sb);
dax.c:864:	struct nova_inode_info_header *sih = &si->header;
dax.c:894:			__func__, sih->ino, pgoff, mmap_block);
dax.c:896:		ret = radix_tree_insert(&sih->cache_tree, pgoff,
dax.c:903:		sih->mmap_pages++;
dax.c:922:	struct super_block *sb = inode->i_sb;
dax.c:924:	struct nova_inode_info_header *sih = &si->header;
dax.c:927:	vm_flags_t vm_flags = vma->vm_flags;
dax.c:938:		if (pgoff < sih->low_dirty)
dax.c:939:			sih->low_dirty = pgoff;
dax.c:940:		if (pgoff > sih->high_dirty)
dax.c:941:			sih->high_dirty = pgoff;
dax.c:953:	struct address_space *mapping = vma->vm_file->f_mapping;
dax.c:954:	struct inode *inode = mapping->host;
dax.c:961:	mutex_lock(&inode->i_mutex);
dax.c:962:	size = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;
dax.c:963:	if (vmf->pgoff >= size) {
dax.c:966:			__func__, __LINE__, vma->vm_start, vma->vm_end,
dax.c:967:			vmf->pgoff, (unsigned long)vmf->virtual_address, size);
dax.c:971:	err = nova_get_mmap_addr(inode, vma, vmf->pgoff, 1,
dax.c:976:			__func__, __LINE__, vma->vm_start, vma->vm_end,
dax.c:977:			vmf->pgoff, (unsigned long)vmf->virtual_address);
dax.c:982:			__func__, vma->vm_flags, vmf->flags);
dax.c:986:			"VA(0x%lx)->PA(0x%lx)\n",
dax.c:987:			inode->i_ino, vma->vm_start, vma->vm_end, vmf->pgoff,
dax.c:988:			vma->vm_pgoff, (unsigned long)vmf->virtual_address,
dax.c:995:	err = vm_insert_mixed(vma, (unsigned long)vmf->virtual_address,
dax.c:998:	err = vm_insert_mixed(vma, (unsigned long)vmf->virtual_address, dax_pfn);
dax.c:1001:	if (err == -ENOMEM)
dax.c:1004:	 * err == -EBUSY is fine, we've raced against another thread
dax.c:1005:	 * that faulted-in the same page
dax.c:1007:	if (err != -EBUSY)
dax.c:1013:	mutex_unlock(&inode->i_mutex);
dax.c:1031:	struct inode *inode = file_inode(vma->vm_file);
dax.c:1037:	mutex_lock(&inode->i_mutex);
dax.c:1039:	mutex_unlock(&inode->i_mutex);
dax.c:1048:	struct inode *inode = file_inode(vma->vm_file);
dax.c:1054:	mutex_lock(&inode->i_mutex);
dax.c:1056:	mutex_unlock(&inode->i_mutex);
dax.c:1065:	struct inode *inode = file_inode(vma->vm_file);
dax.c:1072:	mutex_lock(&inode->i_mutex);
dax.c:1073:	size = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;
dax.c:1074:	if (vmf->pgoff >= size)
dax.c:1078:	mutex_unlock(&inode->i_mutex);
dax.c:1095:	vma->vm_flags |= VM_MIXEDMAP | VM_HUGEPAGE;
dax.c:1097:	vma->vm_ops = &nova_dax_vm_ops;
dax.c:1101:			__LINE__, vma->vm_start, vma->vm_end,
dax.c:1102:			vma->vm_flags, pgprot_val(vma->vm_page_prot));
setup-nova.sh:10:mount -t NOVA -o init /dev/pmem0m /mnt/ramdisk
setup-nova.sh:11:mount -t NOVA -o init /dev/pmem1m /mnt/scratch
namei.c:6: * Copyright 2015-2016 Regents of the University of California,
namei.c:7: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
namei.c:8: * Copyright 2012-2013 Intel Corporation
namei.c:9: * Copyright 2009-2011 Marco Stornelli <marco.stornelli@gmail.com>
namei.c:12: * 2003-2004 (c) MontaVista Software, Inc. , Steve Longerbeam
namei.c:24:	struct super_block *sb = dir->i_sb;
namei.c:28:					entry->name, entry->len);
namei.c:33:	return direntry->ino;
namei.c:45:	if (dentry->d_name.len > NOVA_NAME_LEN) {
namei.c:47:			__func__, dentry->d_name.len);
namei.c:48:		return ERR_PTR(-ENAMETOOLONG);
namei.c:51:	nova_dbg_verbose("%s: %s\n", __func__, dentry->d_name.name);
namei.c:52:	ino = nova_inode_by_name(dir, &dentry->d_name, &de);
namei.c:56:		inode = nova_iget(dir->i_sb, ino);
namei.c:57:		if (inode == ERR_PTR(-ESTALE) || inode == ERR_PTR(-ENOMEM)
namei.c:58:				|| inode == ERR_PTR(-EACCES)) {
namei.c:59:			nova_err(dir->i_sb,
namei.c:62:			return ERR_PTR(-EIO);
namei.c:83:	entry.addrs[0] = (u64)nova_get_addr_off(sbi, &pidir->log_tail);
namei.c:85:	entry.values[0] = pidir->log_tail;
namei.c:87:	entry.addrs[1] = (u64)nova_get_addr_off(sbi, &pi->valid);
namei.c:89:	entry.values[1] = pi->valid;
namei.c:92:	spin_lock(&sbi->journal_locks[cpu]);
namei.c:95:	pidir->log_tail = pidir_tail;
namei.c:96:	nova_flush_buffer(&pidir->log_tail, CACHELINE_SIZE, 0);
namei.c:97:	pi->valid = 1;
namei.c:98:	nova_flush_buffer(&pi->valid, CACHELINE_SIZE, 0);
namei.c:102:	spin_unlock(&sbi->journal_locks[cpu]);
namei.c:110: * is so far negative - it has no inode.
namei.c:120:	struct super_block *sb = dir->i_sb;
namei.c:141:	nova_dbgv("%s: %s\n", __func__, dentry->d_name.name);
namei.c:142:	nova_dbgv("%s: inode %llu, dir %lu\n", __func__, ino, dir->i_ino);
namei.c:144:					0, 0, &dentry->d_name);
namei.c:167:	struct super_block *sb = dir->i_sb;
namei.c:184:	nova_dbgv("%s: %s\n", __func__, dentry->d_name.name);
namei.c:185:	nova_dbgv("%s: inode %llu, dir %lu\n", __func__, ino, dir->i_ino);
namei.c:191:					0, rdev, &dentry->d_name);
namei.c:211:	struct super_block *sb = dir->i_sb;
namei.c:212:	int err = -ENAMETOOLONG;
namei.c:225:	if (len + 1 > sb->s_blocksize)
namei.c:237:				dentry->d_name.name, symname);
namei.c:238:	nova_dbgv("%s: inode %llu, dir %lu\n", __func__, ino, dir->i_ino);
namei.c:245:					&dentry->d_name);
namei.c:266:	pi->i_blocks = 2;
namei.c:298:	entry.addrs[0] = (u64)nova_get_addr_off(sbi, &pi->log_tail);
namei.c:300:	entry.values[0] = pi->log_tail;
namei.c:302:	entry.addrs[1] = (u64)nova_get_addr_off(sbi, &pidir->log_tail);
namei.c:304:	entry.values[1] = pidir->log_tail;
namei.c:307:		entry.addrs[2] = (u64)nova_get_addr_off(sbi, &pi->valid);
namei.c:309:		entry.values[2] = pi->valid;
namei.c:313:	spin_lock(&sbi->journal_locks[cpu]);
namei.c:316:	pi->log_tail = pi_tail;
namei.c:317:	nova_flush_buffer(&pi->log_tail, CACHELINE_SIZE, 0);
namei.c:318:	pidir->log_tail = pidir_tail;
namei.c:319:	nova_flush_buffer(&pidir->log_tail, CACHELINE_SIZE, 0);
namei.c:321:		pi->valid = 0;
namei.c:322:		nova_flush_buffer(&pi->valid, CACHELINE_SIZE, 0);
namei.c:327:	spin_unlock(&sbi->journal_locks[cpu]);
namei.c:336:	struct nova_inode_info_header *sih = &si->header;
namei.c:345:				__func__, inode->i_ino);
namei.c:349:		return -ENOMEM;
namei.c:352:	entry->entry_type = LINK_CHANGE;
namei.c:353:	entry->links = cpu_to_le16(inode->i_nlink);
namei.c:354:	entry->ctime = cpu_to_le32(inode->i_ctime.tv_sec);
namei.c:355:	entry->flags = cpu_to_le32(inode->i_flags);
namei.c:356:	entry->generation = cpu_to_le32(inode->i_generation);
namei.c:359:	sih->last_link_change = curr_p;
namei.c:368:	if (entry->entry_type != LINK_CHANGE)
namei.c:371:	pi->i_links_count	= entry->links;
namei.c:372:	pi->i_ctime		= entry->ctime;
namei.c:373:	pi->i_flags		= entry->flags;
namei.c:374:	pi->i_generation	= entry->generation;
namei.c:382:	struct super_block *sb = dir->i_sb;
namei.c:383:	struct inode *inode = dest_dentry->d_inode;
namei.c:387:	int err = -ENOMEM;
namei.c:391:	if (inode->i_nlink >= NOVA_LINK_MAX) {
namei.c:392:		err = -EMLINK;
namei.c:398:		err = -EINVAL;
namei.c:405:			dentry->d_name.name, dest_dentry->d_name.name);
namei.c:407:			inode->i_ino, dir->i_ino);
namei.c:408:	err = nova_add_dentry(dentry, inode->i_ino, 0, 0, &pidir_tail);
namei.c:414:	inode->i_ctime = CURRENT_TIME_SEC;
namei.c:434:	struct inode *inode = dentry->d_inode;
namei.c:435:	struct super_block *sb = dir->i_sb;
namei.c:436:	int retval = -ENOMEM;
namei.c:449:	nova_dbgv("%s: %s\n", __func__, dentry->d_name.name);
namei.c:451:				inode->i_ino, dir->i_ino);
namei.c:456:	inode->i_ctime = dir->i_ctime;
namei.c:458:	if (inode->i_nlink == 1)
namei.c:461:	if (inode->i_nlink) {
namei.c:482:	struct super_block *sb = dir->i_sb;
namei.c:490:	int err = -EMLINK;
namei.c:494:	if (dir->i_nlink >= NOVA_LINK_MAX)
namei.c:501:	nova_dbgv("%s: name %s\n", __func__, dentry->d_name.name);
namei.c:503:				ino, dir->i_ino, dir->i_nlink);
namei.c:511:					S_IFDIR | mode, sb->s_blocksize,
namei.c:512:					0, &dentry->d_name);
namei.c:519:	nova_append_dir_init_entries(sb, pi, inode->i_ino, dir->i_ino);
namei.c:523:	sih = &si->header;
namei.c:527:	dir->i_blocks = pidir->i_blocks;
namei.c:550:	struct nova_inode_info_header *sih = &si->header;
namei.c:557:	sb = inode->i_sb;
namei.c:558:	nr_entries = radix_tree_gang_lookup(&sih->tree,
namei.c:574:	struct inode *inode = dentry->d_inode;
namei.c:576:	struct super_block *sb = inode->i_sb;
namei.c:580:	struct nova_inode_info_header *sih = &si->header;
namei.c:581:	int err = -ENOTEMPTY;
namei.c:586:		return -ENOENT;
namei.c:588:	nova_dbgv("%s: name %s\n", __func__, dentry->d_name.name);
namei.c:591:		return -EINVAL;
namei.c:593:	if (nova_inode_by_name(dir, &dentry->d_name, &de) == 0)
namei.c:594:		return -ENOENT;
namei.c:600:				inode->i_ino, dir->i_ino, dir->i_nlink);
namei.c:602:	if (inode->i_nlink != 2)
namei.c:604:				inode->i_ino, inode->i_nlink, dir->i_ino);
namei.c:606:	err = nova_remove_dentry(dentry, -1, 0, &pidir_tail);
namei.c:610:	/*inode->i_version++; */
namei.c:612:	inode->i_ctime = dir->i_ctime;
namei.c:614:	if (dir->i_nlink)
namei.c:640:	struct inode *old_inode = old_dentry->d_inode;
namei.c:641:	struct inode *new_inode = new_dentry->d_inode;
namei.c:642:	struct super_block *sb = old_inode->i_sb;
namei.c:650:	int err = -ENOENT;
namei.c:659:			old_dentry->d_name.name, new_dentry->d_name.name);
namei.c:661:			__func__, S_ISDIR(old_inode->i_mode) ? "dir" : "normal",
namei.c:662:			old_inode->i_ino, old_dir->i_ino, new_dir->i_ino,
namei.c:663:			new_inode ? new_inode->i_ino : 0);
namei.c:668:		err = -ENOTEMPTY;
namei.c:670:		if (S_ISDIR(old_inode->i_mode) && !nova_empty_dir(new_inode))
namei.c:675:		if (S_ISDIR(old_inode->i_mode)) {
namei.c:676:			err = -EMLINK;
namei.c:677:			if (new_dir->i_nlink >= NOVA_LINK_MAX)
namei.c:683:	if (S_ISDIR(old_inode->i_mode)) {
namei.c:684:		dec_link = -1;
namei.c:694:	old_inode->i_ctime = CURRENT_TIME;
namei.c:701:	if (S_ISDIR(old_inode->i_mode) && old_dir != new_dir) {
namei.c:703:		/* For simplicity, we use in-place update and journal it */
namei.c:705:		head_addr = (char *)nova_get_block(sb, old_pi->log_head);
namei.c:708:		if (le64_to_cpu(father_entry->ino) != old_dir->i_ino)
namei.c:711:				old_inode->i_ino, old_dir->i_ino,
namei.c:712:				le64_to_cpu(father_entry->ino));
namei.c:723:	err = nova_add_dentry(new_dentry, old_inode->i_ino,
namei.c:743:		new_inode->i_ctime = CURRENT_TIME;
namei.c:745:		if (S_ISDIR(old_inode->i_mode)) {
namei.c:746:			if (new_inode->i_nlink)
namei.c:749:		if (new_inode->i_nlink)
namei.c:761:	entry.addrs[0] = (u64)nova_get_addr_off(sbi, &old_pi->log_tail);
namei.c:763:	entry.values[0] = old_pi->log_tail;
namei.c:765:	entry.addrs[1] = (u64)nova_get_addr_off(sbi, &old_pidir->log_tail);
namei.c:767:	entry.values[1] = old_pidir->log_tail;
namei.c:771:						&new_pidir->log_tail);
namei.c:773:		entry.values[2] = new_pidir->log_tail;
namei.c:777:						&father_entry->ino);
namei.c:779:			entry.values[3] = father_entry->ino;
namei.c:788:						&new_pi->log_tail);
namei.c:790:		entry1.values[0] = new_pi->log_tail;
namei.c:792:		if (!new_inode->i_nlink) {
namei.c:794:							&new_pi->valid);
namei.c:796:			entry1.values[1] = new_pi->valid;
namei.c:802:	spin_lock(&sbi->journal_locks[cpu]);
namei.c:806:	old_pi->log_tail = old_pi_tail;
namei.c:807:	nova_flush_buffer(&old_pi->log_tail, CACHELINE_SIZE, 0);
namei.c:808:	old_pidir->log_tail = old_tail;
namei.c:809:	nova_flush_buffer(&old_pidir->log_tail, CACHELINE_SIZE, 0);
namei.c:812:		new_pidir->log_tail = new_tail;
namei.c:813:		nova_flush_buffer(&new_pidir->log_tail, CACHELINE_SIZE, 0);
namei.c:817:		father_entry->ino = cpu_to_le64(new_dir->i_ino);
namei.c:822:		new_pi->log_tail = new_pi_tail;
namei.c:823:		nova_flush_buffer(&new_pi->log_tail, CACHELINE_SIZE, 0);
namei.c:824:		if (!new_inode->i_nlink) {
namei.c:825:			new_pi->valid = 0;
namei.c:826:			nova_flush_buffer(&new_pi->valid, CACHELINE_SIZE, 0);
namei.c:833:	spin_unlock(&sbi->journal_locks[cpu]);
namei.c:850:	nova_inode_by_name(child->d_inode, &dotdot, &de);
namei.c:852:		return ERR_PTR(-ENOENT);
namei.c:853:	ino = le64_to_cpu(de->ino);
namei.c:856:		inode = nova_iget(child->d_inode->i_sb, ino);
namei.c:858:		return ERR_PTR(-ENOENT);
README.md:3:Current development and releases of NOVA will be through https://github.com/NVSL/linux-nova.
README.md:5:# NOVA: NOn-Volatile memory Accelerated log-structured file system
README.md:8:NOVA is a log-structured file system designed for byte-addressable non-volatile memories, developed by
README.md:9:the [Non-Volatile Systems Laboratory][NVSL], University of California, San Diego.
README.md:11:NOVA extends ideas of LFS to leverage NVMM, yielding a simpler, high-performance file system that supports fast and efficient garbage collection and quick recovery from system failures.
README.md:18:* DAX-mmap: NOVA supports DAX-mmap which maps NVMM pages directly to the user space.
README.md:24:**NOVA: A Log-structured File system for Hybrid Volatile/Non-volatile Main Memories**<br>
README.md:30:NOVA works on the 4.3 version of x86-64 Linux kernel.
README.md:53:#mount -t NOVA -o init /dev/pmem0 /mnt/ramdisk 
README.md:61:#mount -t NOVA /dev/pmem0 /mnt/ramdisk 
README.md:64:There are two scripts provided in the source code, `setup-nova.sh` and `remount-nova.sh` to help setup NOVA.
README.md:68:* NOVA only works on x86-64 kernels.
README.md:71:* Applications can write to a file, or mmap a file and load/store the file directly, but not at the same time, i.e. writing to a mmaped file is disallowed, because write is copy-on-write (out-of-place) while mmap is DAX (in-place).
README.md:74:[POSIXtest]: http://www.tuxera.com/community/posix-test-suite/ 
zone.c:44:    dzt_block-> dzt_entry[0].zone_blk_type = DAFS_BLOCK_TYPE_512K;
zone.c:45:    dzt_block-> dzt_entry[0].root_len = 1;
zone.c:46:    dzt_block-> dzt_entry[0].dzt_eno = 0;
zone.c:47:    //dzt_block-> dzt_entry[0].dz_no = 0;
zone.c:48:    //dzt_block-> dzt_entry[0].dz_addr = ROOT_ZONE_ADDR;            //not decided yet
zone.c:49:    dzt_block-> dzt_entry[0].pdz_addr = NULL;
zone.c:50:    dzt_block-> dzt_entry[0].rden_pos = NULL;
zone.c:51:    dzt_block-> dzt_entry[0].hash_name = cpu_to_le64(BKDRHash(name, 1));        
zone.c:52:    dzt_block-> dzt_entry[0].child_dzt_eno = NULL;            // init NULL not decided yet
zone.c:56:    dzt_block->dzt_entry[0].ht_head = cpu_to_le64(ht_addr);
zone.c:60:    dafs_alloc_dir_zone(sbi, dzt_block->dzt_entry[0]);
zone.c:64:    test_and_set_bit_le(0, dzt_p->bitmap);
zone.c:68:    ei = dafs_build_dzt(sbi, dzt_block->dzt_entry[0]);
zone.c:98:    zone_entry = (struct dafs_zone_entry *)nova_get_block(sb, ei->dz_addr);
zone.c:103:    dafs_rde = zone_entry->dentry[0];
zone.c:104:    dafs_rde->entry_type = DAFS_DIR_ENTRY;             /*not decided yet*/
zone.c:105:    dafs_rde->name_len = 1;
zone.c:106:    dafs_rde->file_type = ROOT_DIRECTORY;
zone.c:107:    dafs_rde->links_count = 0;
zone.c:108:    dafs_rde->mtime = CURRENT_TIME_SEC.tv_sec;
zone.c:109:    dafs_rde->vroot = 1;
zone.c:110:    dafs_rde->path_len = 1;
zone.c:111:    dafs_rde->ino = 0;      /*not decided*/
zone.c:112:    dafs_rde->par_ino = 0;   /*not decided*/
zone.c:113:    dafs_rde->size = DAFS_DEF_DENTRY_SIZE; /*not decided*/
zone.c:114:    dafs_rde->dzt_hn = cpu_to_le64(hn); 
zone.c:115:    dafs_rde->prio = LEVEL_0;
zone.c:116:    dafs_rde->sub_num = 0;
zone.c:117:    dafs_rde->sub_pos[NR_DENTRY_IN_ZONE]={0};
zone.c:118:    dafs_rde->name = "/";
zone.c:119:    dafs_rde->ful_name->f_namelen = 1;
zone.c:120:    dafs_rde->ful_name->f_name = "/";
zone.c:122:    record_pos_htable(sb, ei->ht_head, hn, 1, 0, 1);
zone.c:123:    zone_entry->dz_no = cpu_to_le64(ei->dzt_eno);
zone.c:126:    zone_entry->dentry[1].entry_type = DAFS_DIR_ENTRY;      /*not decided */
zone.c:127:    zone_entry->dentry[1].name_len = 1;
zone.c:128:    zone_entry->dentry[1].links_count = 1;
zone.c:129:    zone_entry->dentry[1].mtime = CURRENT_TIME_SEC.tv_sec;
zone.c:130:    zone_entry->dentry[1].vroot = 0;
zone.c:131:    zone_entry->dentry[1].size = DAFS_DEF_DENTRY_SIZE;      //not decided
zone.c:132:    zone_entry->dentry[1].dzt_hn = 0;
zone.c:133:    zone_entry->dentry[1].sub_pos[NR_DENTRY_IN_ZONE] = 0;
zone.c:134:    zone_entry->dentry[1].name = ".";
zone.c:135:    zone_entry->dentry[1].ful_name->f_namelen = 2;
zone.c:136:    zone_entry->dentry[1].ful_name->f_name = "/.";
zone.c:138:    record_pos_htable(sb, ei->ht_head, hn, 2, 1,1);
zone.c:141:    zone_entry->dentry[2].entry_type = DAFS_DIR_ENTRY;      /*default file type*/
zone.c:142:    zone_entry->dentry[2].name_len = 2;
zone.c:143:    zone_entry->dentry[2].links_count = 2;
zone.c:144:    zone_entry->dentry[2].mtime = CURRENT_TIME_SEC.tv_sec;
zone.c:145:    zone_entry->dentry[2].vroot = 0;
zone.c:146:    zone_entry->dentry[2].ino = dafs_de->par_ino;
zone.c:147:    zone_entry->dentry[2].size = DAFS_DEF_DENTRY_SIZE;
zone.c:148:    zone_entry->dentry[2].dzt_hn = 0;          //not decided
zone.c:149:    zone_entry->dentry[2].sub_pos[NR_DENTRY_IN_ZONE] = {0};
zone.c:150:    zone_entry->dentry[2].name = "..";
zone.c:151:    zone_entry->dentry[2].ful_name->f_namelen = 3;
zone.c:152:    zone_entry->dentry[2].ful_name->f_name = "/..";
zone.c:154:    record_pos_htable(sb, ei->ht_head, hn, 3, 2, 1);
zone.c:156:    /*change 2-bitmap*/
zone.c:159:        test_and_set_bit_le(bitpos, z_p->statemap);
zone.c:168:    p->statemap = z_e->zone_statemap;
zone.c:169:    p->zone_max = NR_DENTRY_IN_ZONE * 2;
zone.c:170:    p->z_entry = z_e->dentry;
zone.c:184:    //struct dzt_manager *dzt_m = sbi->dzt_manager;
zone.c:186:    unsigned long zone_type = dzt_e->zone_blk_type;
zone.c:199:        return -ENOMEM;
zone.c:204:    dzt_e->dz_addr = cpu_to_le64(block);
zone.c:221:    p->bitmap = dzt_blk->dzt_bitmap;
zone.c:222:    p->max = DAFS_DZT_ENTRIES_IN_BLOCK;
zone.c:223:    p->dzt_entry = dzt_blk->dzt_entry;
zone.c:237:    test_and_set_bit(bitpos, dzt_p->bitmap);
zone.c:242:* build dzt radix-tree
zone.c:252:    entry_info = kzalloc(sizeof(struct dzt_entry_info), GFP_KERNEL);  //move dzt entry into DRAM B-tree
zone.c:255:        return -ENOMEM;
zone.c:257:    entry_info->zone_blk_type = DAFS_BLOCK_TYPE_512K; 
zone.c:258:    entry_info->root_len = le32_to_cpu(dafs_dzt_entry->root_len);
zone.c:259:    entry_info->dzt_eno = le64_to_cpu(dafs_dzt_entry->dzt_eno);
zone.c:260:    //entry_info->dz_no = le64_to_cpu(dafs_dzt_entry->dz_no);
zone.c:261:    entry_info->dz_addr = le64_to_cpu(dafs_dzt_entry->dz_addr);
zone.c:262:    entry_info->hash_name = le64_to_cpu(dafs_dzt_entry->hash_name);
zone.c:263:    entry_info->ht_head = le64_to_cpu(dafs_dzt_entry->ht_head);
zone.c:265:    //INIT_LIST_HEAD(&entry_info->child_list);
zone.c:270:        return -ENOMEM;
zone.c:272:    INIT_RADIX_TREE(&dzt_m->dzt_root, GFP_ATOMIC);
zone.c:276:    INIT_RADIX_TREE(&entry_info->rf_root, GFP_ATOMIC);
zone.c:279:    radix_tree_insert(&dzt_m->dzt_root, entry_info->hash_name, entry_info);
zone.c:291:    struct dzt_manager *dzt_m = sbi->dzt_m_info;
zone.c:302:    dzt_p->bitmap = dzt_blk->dzt_bitmap;
zone.c:303:    dzt_p->max = DAFS_DZT_ENTRIES_IN_BLOCK;
zone.c:304:    dzt_p->dzt_entry = dzt_blk->dzt_entry;
zone.c:306:    while(bit_pos < dzt_p->max){
zone.c:307:        if(!test_bit_le(bit_pos, dzt_p->bitmap)){
zone.c:312:        dzt_entry = dzt_p->dzt_entry[bit_pos];
zone.c:314:        dzt_ei->root_len = le32_to_cpu(dzt_entry->root_len);
zone.c:315:        dzt_ei->dzt_eno = le64_to_cpu(dzt_entry->dzt_eno);
zone.c:316:        dzt_ei->dz_no = le64_to_cpu(dzt_entry->dz_no);
zone.c:317:        dzt_ei->dz_addr = le64_to_cpu(dzt_entry->dz_addr);
zone.c:318:        dzt_ei->hash_name = le64_to_cpu(dzt_entry->hash_name);
zone.c:338:    //rfe->r_f = 0;
zone.c:339:    //rfe->hash_name = dzt_ei->hash_name;
zone.c:340:    //radix_tree_insert(&dzt_ei->rf_root, rfe->hash_name, rfe);
zone.c:342:    ht_addr = dzt_ei->ht_head;
zone.c:349:    while(bit_pos < ht_p->hash_max) {
zone.c:350:        if(test_bit_le(bit_pos, ht_p->bitmap) {
zone.c:351:            he = ht->hash_entry[bit_pos];
zone.c:352:            rfe->r_f = 0;
zone.c:353:            rfe->hash_name = le64_to_cpu(ht->hd_name);
zone.c:354:            radix_tree_insert(&dzt_ei->rf_root, rfe->hash_name, rfe);
zone.c:359:    tail =le64_to_cpu(ht->hash_tail);
zone.c:373:    struct dzt_manager *dzt_m = sbi->dzt_manager;
zone.c:377:    dzt_entry_info->zone_blk_type = dzt_ei->zone_blk_type;
zone.c:378:    dzt_entry_info->root_len = dzt_ei->root_len;
zone.c:379:    dzt_entry_info->dzt_eno = dzt_ei->dzt_eno;
zone.c:380:    //dzt_entry_info->dz_no = dzt_ei->dz_no;
zone.c:381:    dzt_entry_info->dz_addr = dzt_ei->dz_addr;
zone.c:382:    dzt_entry_info->hash_name = dzt_ei->hash_name;
zone.c:383:    INIT_RADIX_TREE(&dzt_entry_info->rf_root, GFP_ATOMIC);
zone.c:384:    init_rf_entry(sbi->sb, dzt_entry_info);
zone.c:386:    radix_tree_insert(&dzt_m->dzt_root, dzt_entry_info->hash_name, dzt_entry_info);
zone.c:394:    struct dzt_manager *dzt_m = sbi->dzt_manager;
zone.c:416:    struct dzt_manager *dzt_m = sbi->dzt_manager;
zone.c:428:    par_ze = (struct dafs_zone_entry *)nova_get_block(sb, par_dei->dz_addr); 
zone.c:437:    dafs_rde = par_ze->dentry[sp_id];
zone.c:438:    de_nlen = le64_to_cpu(dafs_rde->ful_name->f_namelen);
zone.c:441:    new_dzt_ei->zone_blk_type = DAFS_BLOCK_TYPE_512K;
zone.c:442:    new_dzt_ei->dzt_eno = eno_pos;
zone.c:443:    new_dzt_ei->pdz_addr = par_dei->dz_addr;
zone.c:444:    new_dzt_ei->rden_pos = sp_id;
zone.c:446:    if(par_dei->eno!=1){
zone.c:448:        name_len = (u64)(par_dei->root_len) + de_nlen;
zone.c:450:        get_zone_path(sb, par_dei, pname, dafs_rde->ful_name->f_name);
zone.c:456:        new_dzt_ei->root_len =(u32) name_len;
zone.c:457:        new_dzt_ei->hash_name = phash;
zone.c:461:        phash = BKDRHash(dafs_rde->ful_name->f_name, name_len);
zone.c:462:        new_dzt_ei->root_len = (u32)name_len;
zone.c:463:        new_dzt_ei->hash_name = phash;
zone.c:469:    ret = get_hash_table(sb, &new_dzt_ei->ht_head);
zone.c:471:        return -ENOMEM;
zone.c:474:    INIT_RADIX_TREE(&new_dzt_ei->rf_root, GFP_ATOMIC);
zone.c:477:        return -EINVAL;
zone.c:498:    tail_pos = le64_to_cpu(dzt_blk->dzt_tail_pos);
zone.c:502:    if(!test_bit_le(tail_pos, dzt_p->bitmap)){
zone.c:506:        dzt_blk->dzt_tail_pos = cpu_to_le64(i);      //not decided 原子性
zone.c:509:    while(bitpos < dzt_p->max){
zone.c:510:        if(!test_bit_le(bitpos, dzt_p->bitmap))
zone.c:533:    en_pos = dzt_ei->dzt_eno;
zone.c:536:    dzt_e = dzt_blk->dzt_entry[en_pos];
zone.c:538:    dzt_e->zoon_blk_type = cpu_to_le64(dzt_ei->zoon_blk_type);
zone.c:539:    dzt_e->root_len = cpu_to_le64(dzt_ei->root_len);
zone.c:540:    dzt_e->dzt_eno = cpu_to_le64(dzt_ei->dzt_eno);
zone.c:541:    dzt_e->pdz_addr = cpu_to_le64(dzt_ei->pdz_addr);
zone.c:542:    dzt_e->rden_pos = cpu_to_le64(dzt_ei->rden_pos);
zone.c:543:    //dzt_e->dz_sf = cpu_to_le64(dzt_ei->dz_sf);
zone.c:544:    dzt_e->hash_name = cpu_to_le64(dzt_ei->hash_name);
zone.c:557:    struct dzt_manager *dzt_m = sbi->dzt_m_info;
zone.c:563:    ch_pos = old_rdei->dzt_eno;
zone.c:564:    hash_name = old_rdei->hash_name;
zone.c:565:    radix_tree_delete(&dzt_m->dzt_root, hash_name);
zone.c:566:    test_and_clear_bit(ch_pos, dzt_p->bitmap);
zone.c:581:    struct dzt_manager *dzt_m = sbi->dzt_manager;
zone.c:594:        return -ENOMEM;
zone.c:602:    n_dzt_e->dz_addr = cpu_to_le64(block);
zone.c:603:    n_dzt_ei->dz_addr = block;
zone.c:606:    new_ze =(struct dafs_zone_entry *)nova_get_block(sb, n_dzt_ei->dz_addr);
zone.c:609:    memset(new_ze->statemap, 0, SIZE_OF_ZONE_BITMAP);
zone.c:611:    new_ze->dz_no = cpu_to_le64(n_dzt_ei->dzt_eno);
zone.c:612:    //new_ze->dz_sf = 0;
zone.c:615:    dafs_rde = par_ze->dentry[sp_id];
zone.c:616:    par_root_len = par_dzt_ei->root_len;
zone.c:617:    memcpy(root_path[0], par_ze->root_path, par_root_len);
zone.c:618:    memcpy(root_path[par_root_len], dafs_rde->name, cpu_to_le64(dafs_rde->name_len));
zone.c:619:    name_len = par_root_len + cpu_to_le64(dafs_rde->name_len);
zone.c:620:    memcpy(new_ze->root_path[0], root, name_len);*/
zone.c:624:    par_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_dzt_ei->pdz_addr);
zone.c:631:    make_dzt_entry_valid(sbi, n_dzt_e->dzt_eno);
zone.c:632:    radix_tree_insert(&dzt_m->dzt_root, n_dzt_ei->hash_name, n_dzt_ei);
zone.c:643:    struct dzt_manager *dzt_m = sbi->dzt_m_info;
zone.c:648:    if(!test_bit_le(eno, dzt_p->bitmap)){
zone.c:650:        return -EINVAL;
zone.c:652:    dzt_e = dzt_blk->dzt_entry[eno];
zone.c:653:    hashname = le64_to_cpu(dzt_e->hash_name);
zone.c:654:    ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
zone.c:657:        return -EINVAL;
zone.c:685:    old_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_nei->pdz_addr);
zone.c:686:    new_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_nei->dz_addr);
zone.c:688:    dafs_rde = old_ze->dentry[ch_pos];
zone.c:691:    //new_z_e->dz_no = dzt_ne->dzt_eno;
zone.c:692:    old_namelen = le64_to_cpu(dafs_rde->ful_name->f_namelen);
zone.c:694:    ch_len = le64_to_cpu(dafs_rde->sub_num);
zone.c:697:        ch_no[i] = le64_to_cpu(dafs_rde->sub_pos[i]);
zone.c:702:    dafs_rde->file_type = ROOT_DIRECTORY;
zone.c:703:    dafs_rde->mtime = CURRENT_TIME_SEC.tv_sec;
zone.c:704:    dafs_rde->vroot = 1;
zone.c:705:    //dafs_rde->zoon_no = dzt_nei->dzt_eno;
zone.c:706:    dafs_rde->dzt_hn = cpu_to_le64(dzt_nei->hash_name);
zone.c:707:    dafs_rde->sub_num = 0;
zone.c:708:    dafs_rde->sub_pos[NR_DENTRY_IN_ZONE] = {0};
zone.c:710:    name_len = le64_to_cpu(dafs_rde->ful_name->f_namelen);
zone.c:711:    hashname = BKDRHash(dafs_rde->ful_name->f_name, name_len);
zone.c:713:    eno = le64_to_cpu(old_ze->dz_no);
zone.c:717:    rf_e = radix_tree_lookup(&old_ei->rf_root, hashname);
zone.c:718:    rf_e->sub_s = 0;
zone.c:719:    rf_e->f_s = 0;
zone.c:720:    rf_e->prio = 0;
zone.c:744:    //unsigned long old_len = r_ze->name_len;
zone.c:754:    old_ze = (struct dafs_zone_entry *)nova_get_block(sb, new_ei->pdz_addr);
zone.c:755:    new_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
zone.c:758:    ch_len = par_de->sub_num;
zone.c:761:        old_de = old_ze->dentry[old_id];
zone.c:762:        new_de = new_ze->dentry[new_id];
zone.c:763:        if(old_de->file_type == NORMAL_FILE){
zone.c:764:            new_de->entry_type = old_de->entry_type;
zone.c:765:            new_de->name_len = old_de->name_len;
zone.c:766:            //new_de->name_len = old_de->name_len-old_len;
zone.c:767:            new_de->file_type = old_de->file_type;
zone.c:768:            new_de->links_count = old_de ->links_count;
zone.c:769:            new_de->mtime = CURRENT_TIME_SEC.tv_sec;
zone.c:770:            new_de->vroot = old_de->vroot;
zone.c:771:            //new_de->path_len = old_de->path_len-old_len;
zone.c:772:            new_de->ino = old_de->ino;
zone.c:773:            new_de->par_ino = old_de->par_ino;
zone.c:774:            new_de->size = old_de->size;
zone.c:775:            new_de->dzt_hn = old_de->dzt_hn;
zone.c:776:            //new_de->prio = LEVEL_0;
zone.c:777:            //new_de->d_f = 0;            //not decided
zone.c:778:            //new_de->sub_s = old_de->sub_s;
zone.c:779:            new_de->f_s = DENTRY_FREQUENCY_COLD;
zone.c:780:            memcpy(new_de->name, old_de->name, le64_to_cpu(old_de->name_len)+1);
zone.c:781:            name_len = le64_to_cpu(old_de->ful_name->f_namelen) - old_len;
zone.c:782:            new_de->ful_name->f_namelen = cpu_to_le64(name_len);
zone.c:783:            memcpy(new_de->ful_name->f_name, old_de->ful_name->f_name+old_len, name_len+1);
zone.c:786:            /*for(k = 0;k<new_de->name_len;k++){
zone.c:787:                new_de->name[k] = old_de->name[old_len];
zone.c:792:            //old_ze->dz_sf -= old_de->d_f;
zone.c:795:            par_de->sub_pos[i] = new_id;
zone.c:798:            set_bit_le(bitpos, new_p->statemap);
zone.c:801:            hashname = BKDRHash(new_de->ful_name->f_name, name_len);
zone.c:802:            record_pos_htable(sb, new_ei->ht_head, hashname, name_len, new_id, 1);
zone.c:808:            test_and_clear_bit_le(bitpos, old_p->statemap);
zone.c:810:            test_and_clear_bit_le(bitpos, old_p->statemap);
zone.c:813:            name_len = le64_to_cpu(old_de->ful_name->f_namelen);
zone.c:814:            hashname = BKDRHash(old_de->ful_name->f_name, name_len);
zone.c:815:            make_invalid_htable(old_ei->ht_head, hashname, name_len, 1);
zone.c:823:        }else if(old_de->file_type == ROOT_DIRECTORY){
zone.c:824:            new_de->entry_type = old_de->entry_type;
zone.c:825:            new_de->name_len = old_de->name_len;
zone.c:826:            //new_de->name_len = old_de->name_len-old_len;
zone.c:827:            new_de->file_type = old_de->file_type;
zone.c:828:            new_de->links_count = old_de ->links_count;
zone.c:829:            new_de->mtime = CURRENT_TIME_SEC.tv_sec;
zone.c:830:            new_de->vroot = old_de->vroot;
zone.c:831:            //new_de->path_len = old_de->path_len-old_len;
zone.c:832:            new_de->ino = old_de->ino;
zone.c:833:            new_de->par_ino = old_de->par_ino;
zone.c:834:            new_de->size = old_de->size;
zone.c:835:            new_de->dzt_hn = old_de->dzt_hn;
zone.c:836:            //new_de->zone_no = old_de->zone_no;
zone.c:837:            //new_de->prio = LEVEL_0;
zone.c:838:            //new_de->d_f = 0;
zone.c:839:            //new_de->sub_s = old_de->sub_s;
zone.c:840:            //new_de->f_s = DENTRY_FREQUENCY_COLD;
zone.c:841:            new_de->sub_num = old_de->sub_num;
zone.c:842:            memcpy(new_de->name, old_de->name, le64_to_cpu(old_de->name_len)+1);
zone.c:843:            name_len = le64_to_cpu(old_de->ful_name->f_namelen) - old_len;
zone.c:844:            new_de->ful_name->f_namelen = cpu_to_le64(name_len);
zone.c:845:            memcpy(new_de->ful_name->f_name, old_de->ful_name->f_name+old_len, name_len+1);
zone.c:848:            for(k = 0;k<new_de->name_len;k++){
zone.c:849:                new_de->name[k] = old_de->name[old_len];
zone.c:854:            //old_ze->dz_sf -= old_de->d_f;
zone.c:856:            par_de->sub_pos[i] = new_id;
zone.c:858:            set_bit_le(bitpos, new_p->statemap);
zone.c:861:            hashname = BKDRHash(new_de->ful_name->f_name, name_len);
zone.c:862:            record_pos_htable(sb, new_ei->ht_head, hashname, name_len, new_id, 1);
zone.c:868:            test_and_clear_bit_le(bitpos, old_p->statemap);
zone.c:870:            test_and_clear_bit_le(bitpos, old_p->statemap);
zone.c:873:            name_len = le64_to_cpu(old_de->ful_name->f_namelen);
zone.c:874:            hashname = BKDRHash(old_de->ful_name->f_name, name_len);
zone.c:875:            make_invalid_htable(old_ei->ht_head, hashname, name_len, 1);
zone.c:882:        }else if(old_de->file_type == NORMAL_DIRECTORY){
zone.c:884:            new_de->entry_type = old_de->entry_type;
zone.c:885:            new_de->name_len = old_de->name_len;
zone.c:886:            //new_de->name_len = old_de->name_len-old_len;
zone.c:887:            new_de->file_type = old_de->file_type;
zone.c:888:            new_de->links_count = old_de ->links_count;
zone.c:889:            new_de->mtime = CURRENT_TIME_SEC.tv_sec;
zone.c:890:            new_de->vroot = old_de->vroot;
zone.c:891:            //new_de->path_len = old_de->path_len-old_len;
zone.c:892:            new_de->ino = old_de->ino;
zone.c:893:            new_de->par_ino = old_de->par_ino;
zone.c:894:            new_de->size = old_de->size;
zone.c:895:            //new_de->prio = LEVEL_0;
zone.c:896:            //new_de->d_f = 0;
zone.c:897:            //new_de->sub_s = old_de->sub_s;
zone.c:898:            //new_de->f_s = DENTRY_FREQUENCY_COLD;
zone.c:899:            new_de->sub_num = old_de->sub_num;
zone.c:900:            memcpy(new_de->name, old_de->name, le64_to_cpu(old_de->name_len)+1);
zone.c:901:            name_len = le64_to_cpu(old_de->ful_name->f_namelen) - old_len;
zone.c:902:            new_de->ful_name->f_namelen = cpu_to_le64(name_len);
zone.c:903:            memcpy(new_de->ful_name->f_name, old_de->ful_name->f_name+old_len, name_len+1);
zone.c:905:            for(k = 0;k<new_de->name_len;k++){
zone.c:906:                new_de->name[k] = old_de->name[old_len];
zone.c:911:            //old_ze->dz_sf -= old_de->d_f;
zone.c:913:            par_de->sub_pos[i] = new_id;
zone.c:915:            set_bit_le(bitpos, z_p->statemap);
zone.c:918:            hashname = BKDRHash(new_de->ful_name->f_name, name_len);
zone.c:919:            record_pos_htable(sb, new_ei->ht_head, hashname, name_len, new_id, 1);
zone.c:925:            test_and_clear_bit_le(bitpos, old_p->statemap);
zone.c:927:            test_and_clear_bit_le(bitpos, old_p->statemap);
zone.c:930:            name_len = le64_to_cpu(old_de->ful_name->f_namelen);
zone.c:931:            hashname = BKDRHash(old_de->ful_name->f_name, name_len);
zone.c:932:            make_invalid_htable(old_ei->ht_head, hashname, name_len, 1);
zone.c:939:            sub_len = le64_to_cpu(old_de->sub_num);
zone.c:942:                sub_no[j] = le64_to_cpu(old_de->sub_pos[j]);
zone.c:944:            //memcpy(sub_no[0],old_de->sub_pos,old_de->sub_num);
zone.c:966:    des_ze = (struct dafs_zone_entry *)nova_get_block(sb, cur_ei->pdz_addr);
zone.c:967:    cur_ze = (struct dafs_zone_entry *)nova_get_block(sb, cur_ei->dz_addr);
zone.c:969:    cur_de = cur_ze->dentry[cur_pos];
zone.c:970:    memcpy(name, rde->ful_name->f_name, le64_to_cpu(rde->ful_name->f_namelen)+1);
zone.c:973:    if(cur_de->file_type != NORMAL_DIRECTORY){
zone.c:975:        des_de = des_ze->dentry[fpos];
zone.c:976:        des_de->entry_type = cur_de->entry_type;
zone.c:977:        des_de->name_len = cur_de->name_len;
zone.c:978:        des_de->file_type = cur_de->file_type;
zone.c:979:        des_de->links_count = cur_de->links_count;
zone.c:980:        des_de->mtime = CURRENT_TIME_SEC.tv_sec;
zone.c:981:        des_de->vroot = cur_de->vroot;
zone.c:982:        des_de->ino = cur_de->ino;
zone.c:983:        des_de->par_ino = cur_de->par_ino;
zone.c:984:        des_de->size = cur_de->size;
zone.c:985:        des_de->dzt_hn = cur_de->dzt_hn;
zone.c:986:        des_de->sub_num = 0;
zone.c:987:        des_de->sub_pos[NR_DENTRY_IN_ZONE]={0};
zone.c:988:        memcpy(des_de->name, cur_de->name, le64_to_cpu(cur_de->name_len));
zone.c:989:        plen = le64_to_cpu(cur_de->ful_name->f_namelen)+le64_to_cpu(rde->ful_name->f_namelen);
zone.c:990:        des_de->ful_name->f_namelen = cpu_to_le64(plen);
zone.c:992:        strcat(name, cur_de->name);
zone.c:993:        memcpy(des_de->ful_name->f_name, name, plen);
zone.c:996:        eno = le64_to_cpu(par_ze->dz_no);
zone.c:999:        record_pos_htable(sb, par_ei->ht_head, hn, plen, f_pos, 1);
zone.c:1002:        old_hn = BKDRHash(cur_de->ful_name->f_name, le64_to_cpu(cur_de->ful_name->f_namelen));
zone.c:1003:        old_rf = radix_tree_lookup(&cur_ei->rf_root, old_hn);
zone.c:1005:        new_rf->r_f = old_rf->r_f;
zone.c:1006:        new_rf->sub_s = old_rf->sub_s;
zone.c:1007:        new_rf->f_s = old_rf->f_s;
zone.c:1008:        new_rf->prio = LEVEL_0;
zone.c:1009:        new_rf->hash_name = hn;
zone.c:1010:        radix_tree_insert(&par_ei->rf_root, hn); 
zone.c:1014:        test_and_set_bit_le(bitpos+1,par_p->statemap);
zone.c:1017:        test_and_clear_bit_le(bitpos, cur_p->statemap);
zone.c:1019:        test_and_clear_bit_le(bitpos, cur_p->statemap);
zone.c:1022:        subnum = le64_to_cpu(rde->sub_num);
zone.c:1024:        rde->sub_num = cpu_to_le64(sub_num);
zone.c:1025:        rde->sub_pos[sub_num] = cpu_to_le64(cur_pos);
zone.c:1030:        des_de = des_ze->dentry[fpos];
zone.c:1031:        des_de->entry_type = cur_de->entry_type;
zone.c:1032:        des_de->name_len = cur_de->name_len;
zone.c:1033:        des_de->file_type = cur_de->file_type;
zone.c:1034:        des_de->links_count = cur_de->links_count;
zone.c:1035:        des_de->mtime = CURRENT_TIME_SEC.tv_sec;
zone.c:1036:        des_de->vroot = cur_de->vroot;
zone.c:1037:        des_de->ino = cur_de->ino;
zone.c:1038:        des_de->par_ino = cur_de->par_ino;
zone.c:1039:        des_de->size = cur_de->size;
zone.c:1040:        des_de->dzt_hn = cur_de->dzt_hn;
zone.c:1041:        des_de->sub_num = 0;
zone.c:1042:        des_de->sub_pos[NR_DENTRY_IN_ZONE]={0};
zone.c:1043:        memcpy(des_de->name, cur_de->name, le64_to_cpu(cur_de->name_len));
zone.c:1044:        plen = le64_to_cpu(cur_de->ful_name->f_namelen)+le64_to_cpu(rde->ful_name->f_namelen);
zone.c:1045:        des_de->ful_name->f_namelen = cpu_to_le64(plen);
zone.c:1047:        strcat(name, cur_de->name);
zone.c:1048:        memcpy(des_de->ful_name->f_name, name, plen);
zone.c:1051:        eno = le64_to_cpu(par_ze->dz_no);
zone.c:1054:        record_pos_htable(sb, par_ei->ht_head, hn, plen, f_pos, 1);
zone.c:1057:        old_hn = BKDRHash(cur_de->ful_name->f_name, le64_to_cpu(cur_de->ful_name->f_namelen));
zone.c:1058:        old_rf = radix_tree_lookup(&cur_ei->rf_root, old_hn);
zone.c:1060:        new_rf->r_f = old_rf->r_f;
zone.c:1061:        new_rf->sub_s = old_rf->sub_s;
zone.c:1062:        new_rf->f_s = old_rf->f_s;
zone.c:1063:        new_rf->prio = LEVEL_0;
zone.c:1064:        new_rf->hash_name = hn;
zone.c:1065:        radix_tree_insert(&par_ei->rf_root, hn); 
zone.c:1069:        test_and_set_bit_le(bitpos+1,par_p->statemap);
zone.c:1072:        test_and_clear_bit_le(bitpos, cur_p->statemap);
zone.c:1074:        test_and_clear_bit_le(bitpos, cur_p->statemap);
zone.c:1077:        subnum = le64_to_cpu(rde->sub_num);
zone.c:1079:        rde->sub_num = cpu_to_le64(sub_num);
zone.c:1080:        rde->sub_pos[sub_num] = cpu_to_le64(cur_pos);
zone.c:1083:        f_num = le64_to_cpu(cur_de->sub_num);
zone.c:1085:            pos = le64_to_cpu(cur_de->sub_pos[i]);
zone.c:1104:    templen = namelen - strlen(tem);
zone.c:1121:        temlen = namelen - strlen(tem);
zone.c:1128:        return -EINVAL;
zone.c:1151:    cur_ze = (struct dafs_zone_entry *)nova_get_block(sb, cur_ei->dz_addr);
zone.c:1152:    par_ze = (struct dafs_zone_entry *)nova_get_block(sb, cur_ei->pdz_addr);
zone.c:1154:    rde_pos = cur_ei->rde_pos;
zone.c:1155:    rde = par_ze->dentry[rde_pos];
zone.c:1160:    while(bitpos<z_p->zone_max){
zone.c:1162:        if(test_bit_le(bitpos, cur_p->statemap)){
zone.c:1163:            de = cur_ze->dentry[filepos];
zone.c:1164:            plen = de->ful_name->f_namelen;
zone.c:1165:            nlen = plen - le64_to_cpu(de->name_len); 
zone.c:1166:            memcpy(name, de->ful_name->f_name, nlen);
zone.c:1169:            if(hn == cur_ei->hash_name){
zone.c:1173:                hn = get_par_hn(name, cur_ei->hash_name, &len);
zone.c:1176:                ret = lookup_in_hashtable(cur_ei->ht_head, hn, len, 1, &pos);
zone.c:1207:    des_ze = (struct dafs_zone_entry *)nova_get_block(sb, cur_ei->pdz_addr);
zone.c:1208:    cur_ze = (struct dafs_zone_entry *)nova_get_block(sb, cur_ei->dz_addr);
zone.c:1210:    cur_de = cur_ze->dentry[cur_pos];
zone.c:1212:    memcpy(tem, cur_de->ful_name->f_name, inamelen);
zone.c:1213:    len = le64_to_cpu(cur_de->ful_name->f_namelen);
zone.c:1221:    memcpy(name, rde->ful_name->f_name, le64_to_cpu(rde->ful_name->f_namelen)+1);
zone.c:1225:    if(cur_de->file_type == ROOT_DIRECTORY || cur_de->file_type == NORMAL_FILE){
zone.c:1227:        des_de = des_ze->dentry[fpos];
zone.c:1228:        des_de->entry_type = cur_de->entry_type;
zone.c:1229:        des_de->name_len = cur_de->name_len;
zone.c:1230:        des_de->file_type = cur_de->file_type;
zone.c:1231:        des_de->links_count = cur_de->links_count;
zone.c:1232:        des_de->mtime = CURRENT_TIME_SEC.tv_sec;
zone.c:1233:        des_de->vroot = cur_de->vroot;
zone.c:1234:        des_de->ino = cur_de->ino;
zone.c:1235:        des_de->par_ino = cur_de->par_ino;
zone.c:1236:        des_de->size = cur_de->size;
zone.c:1237:        des_de->dzt_hn = cur_de->dzt_hn;
zone.c:1238:        des_de->sub_num = 0;
zone.c:1239:        des_de->sub_pos[NR_DENTRY_IN_ZONE]={0};
zone.c:1240:        memcpy(des_de->name, cur_de->name, le64_to_cpu(cur_de->name_len));
zone.c:1241:        plen = le64_to_cpu(cur_de->ful_name->f_namelen)+le64_to_cpu(rde->ful_name->f_namelen);
zone.c:1242:        des_de->ful_name->f_namelen = cpu_to_le64(plen);
zone.c:1244:        strcat(name, cur_de->name);
zone.c:1245:        memcpy(des_de->ful_name->f_name, name, plen);
zone.c:1248:        eno = le64_to_cpu(par_ze->dz_no);
zone.c:1251:        record_pos_htable(sb, par_ei->ht_head, hn, plen, f_pos, 1);
zone.c:1256:        old_hn = BKDRHash(cur_de->ful_name->f_name, le64_to_cpu(cur_de->ful_name->f_namelen));
zone.c:1257:        old_rf = radix_tree_delete(&cur_ei->rf_root, old_hn);
zone.c:1259:        new_rf->r_f = old_rf->r_f;
zone.c:1260:        new_rf->sub_s = old_rf->sub_s;
zone.c:1261:        new_rf->f_s = old_rf->f_s;
zone.c:1262:        new_rf->prio = LEVEL_0;
zone.c:1263:        new_rf->hash_name = hn;
zone.c:1264:        radix_tree_insert(&par_ei->rf_root, hn); 
zone.c:1270:        test_and_set_bit_le(bitpos+1,par_p->statemap);
zone.c:1273:        test_and_clear_bit_le(bitpos, cur_p->statemap);
zone.c:1275:        test_and_clear_bit_le(bitpos, cur_p->statemap);
zone.c:1278:        make_invalid_htable(cur_ei->ht_head, old_hn, len, 1);
zone.c:1281:        subnum = le64_to_cpu(rde->sub_num);
zone.c:1283:        rde->sub_num = cpu_to_le64(sub_num);
zone.c:1284:        rde->sub_pos[sub_num] = cpu_to_le64(cur_pos);
zone.c:1286:    } else if(cur_de->file_type == NORMAL_DIRECTORY){
zone.c:1289:        des_de = des_ze->dentry[fpos];
zone.c:1290:        des_de->entry_type = cur_de->entry_type;
zone.c:1291:        des_de->name_len = cur_de->name_len;
zone.c:1292:        des_de->file_type = cur_de->file_type;
zone.c:1293:        des_de->links_count = cur_de->links_count;
zone.c:1294:        des_de->mtime = CURRENT_TIME_SEC.tv_sec;
zone.c:1295:        des_de->vroot = cur_de->vroot;
zone.c:1296:        des_de->ino = cur_de->ino;
zone.c:1297:        des_de->par_ino = cur_de->par_ino;
zone.c:1298:        des_de->size = cur_de->size;
zone.c:1299:        des_de->dzt_hn = cur_de->dzt_hn;
zone.c:1300:        des_de->sub_num = 0;
zone.c:1301:        des_de->sub_pos[NR_DENTRY_IN_ZONE]={0};
zone.c:1302:        memcpy(des_de->name, cur_de->name, le64_to_cpu(cur_de->name_len));
zone.c:1303:        plen = le64_to_cpu(cur_de->ful_name->f_namelen)+le64_to_cpu(rde->ful_name->f_namelen);
zone.c:1304:        des_de->ful_name->f_namelen = cpu_to_le64(plen);
zone.c:1306:        strcat(name, cur_de->name);
zone.c:1307:        memcpy(des_de->ful_name->f_name, name, plen);
zone.c:1310:        eno = le64_to_cpu(par_ze->dz_no);
zone.c:1313:        record_pos_htable(sb, par_ei->ht_head, hn, plen, f_pos, 1);
zone.c:1316:        old_hn = BKDRHash(cur_de->ful_name->f_name, len);
zone.c:1317:        old_rf = radix_tree_delete(&cur_ei->rf_root, old_hn);
zone.c:1319:        new_rf->r_f = old_rf->r_f;
zone.c:1320:        new_rf->sub_s = old_rf->sub_s;
zone.c:1321:        new_rf->f_s = old_rf->f_s;
zone.c:1322:        new_rf->prio = LEVEL_0;
zone.c:1323:        new_rf->hash_name = hn;
zone.c:1324:        radix_tree_insert(&par_ei->rf_root, hn); 
zone.c:1329:        test_and_set_bit_le(bitpos+1,par_p->statemap);
zone.c:1332:        test_and_clear_bit_le(bitpos, cur_p->statemap);
zone.c:1334:        test_and_clear_bit_le(bitpos, cur_p->statemap);
zone.c:1337:        make_invalid_htable(cur_ei->ht_head, old_hn, len, 1);
zone.c:1340:        subnum = le64_to_cpu(rde->sub_num);
zone.c:1342:        rde->sub_num = cpu_to_le64(sub_num);
zone.c:1343:        rde->sub_pos[sub_num] = cpu_to_le64(cur_pos);
zone.c:1346:        f_num = le64_to_cpu(cur_de->sub_num);
zone.c:1348:            pos = le64_to_cpu(cur_de->sub_pos[i]);
zone.c:1353:        des_de = des_ze->dentry[fpos];
zone.c:1354:        des_de->entry_type = cur_de->entry_type;
zone.c:1355:        des_de->name_len = cur_de->name_len;
zone.c:1356:        des_de->file_type = ROOT_DIRECTORY;
zone.c:1357:        des_de->links_count = cur_de->links_count;
zone.c:1358:        des_de->mtime = CURRENT_TIME_SEC.tv_sec;
zone.c:1359:        des_de->vroot = 1;
zone.c:1360:        des_de->ino = cur_de->ino;
zone.c:1361:        des_de->par_ino = cur_de->par_ino;
zone.c:1362:        des_de->size = cur_de->size;
zone.c:1364:        des_de->dzt_hn = cur_ei->hash_name;
zone.c:1365:        des_de->sub_num = 0;
zone.c:1366:        des_de->sub_pos[NR_DENTRY_IN_ZONE]={0};
zone.c:1367:        memcpy(des_de->name, cur_de->name, le64_to_cpu(cur_de->name_len));
zone.c:1368:        plen = le64_to_cpu(cur_de->ful_name->f_namelen)+le64_to_cpu(rde->ful_name->f_namelen);
zone.c:1369:        des_de->ful_name->f_namelen = cpu_to_le64(plen);
zone.c:1371:        strcat(name, cur_de->name);
zone.c:1372:        memcpy(des_de->ful_name->f_name, name, plen);
zone.c:1375:        eno = le64_to_cpu(par_ze->dz_no);
zone.c:1378:        record_pos_htable(sb, par_ei->ht_head, hn, plen, f_pos, 1);
zone.c:1383:        old_hn = BKDRHash(cur_de->ful_name->f_name, len);
zone.c:1384:        old_rf = radix_tree_delete(&cur_ei->rf_root, old_hn);
zone.c:1391:        test_and_set_bit_le(bitpos+1,par_p->statemap);
zone.c:1394:        test_and_clear_bit_le(bitpos, cur_p->statemap);
zone.c:1396:        test_and_clear_bit_le(bitpos, cur_p->statemap);
zone.c:1399:        make_invalid_htable(cur_ei->ht_head, old_hn, len, 1);
zone.c:1402:        subnum = le64_to_cpu(rde->sub_num);
zone.c:1404:        rde->sub_num = cpu_to_le64(sub_num);
zone.c:1405:        rde->sub_pos[sub_num] = cpu_to_le64(cur_pos);
zone.c:1408:        cur_ei->rden_pos = fpos;
zone.c:1410:        if(par_ei->eno!=1){
zone.c:1412:            len = (u64)(par_ei->root_len) + plen;
zone.c:1414:            get_zone_path(sb, par_dei, pname, des_de->ful_name->f_name);
zone.c:1420:            new_dzt_ei->root_len =(u32) len;
zone.c:1421:            new_dzt_ei->hash_name = phash;
zone.c:1424:            new_dzt_ei->root_len = (u32)plen;
zone.c:1425:            new_dzt_ei->hash_name = hn;
zone.c:1447:    cur_ze = (struct dafs_zone_entry *)nova_get_block(sb, cur_ei->dz_addr);
zone.c:1448:    inhe_de = cur_ze->dentry[inhe_pos];
zone.c:1449:    namelen = le64_to_cpu(inhe_de->ful_name->f_namelen);
zone.c:1451:    memcpy(iname, inhe_de->ful_name->f_name, namelen);
zone.c:1453:    par_ze = (struct dafs_zone_entry *)nova_get_block(sb, cur_ei->pdz_addr);
zone.c:1454:    rde_pos = cur_ei->rde_pos;
zone.c:1455:    rde = par_ze->dentry[rde_pos];
zone.c:1461:    while(bitpos<z_p->zone_max){
zone.c:1463:        if(test_bit_le(bitpos, z_p->statemap)){
zone.c:1464:            de = cur_ze->dentry[filepos];
zone.c:1465:            plen = de->ful_name->f_namelen;
zone.c:1466:            nlen = plen - le64_to_cpu(de->name_len); 
zone.c:1467:            memcpy(name, de->ful_name->f_name, nlen);
zone.c:1476:                    if(hn == cur_ei->hash_name){
zone.c:1480:                        hn = get_par_hn(name, cur_ei->hash_name, &len);
zone.c:1483:                        ret = lookup_in_hashtable(cur_ei->ht_head, hn, len, 1, &pos);
zone.c:1504:    while(bitpos<z_p->zone_max){
zone.c:1505:        if(test_bit_le(bitpos, z_p->statemap)){
zone.c:1511:            if(test_bit_le(bitpos, z_p->statemap)){
zone.c:1537:    nr = radix_tree_gang_lookup(&ei->rf_root, (void **)entries, 0, NR_DENTRY_IN_ZONE);
zone.c:1540:        rcount+=rf_e->r_f;
zone.c:1551:* conditions for self-adaption within zones*/
zone.c:1574:    par_eno = le64_to_cpu(ze->dz_no);
zone.c:1581:    while(bitpos < z_p->zone_max){
zone.c:1582:        if((!test_bit_le(bitpos, z_p->statemap)) && (!test_bit_le(bitpos+1, z_p->statemap))){
zone.c:1587:            dafs_de = ze->dentry[id];
zone.c:1591:                test_and_clear_bit_le(bitpos, z_p->statemap);
zone.c:1593:                test_and_set_bit_le(bitpos, z_p->statemap);
zone.c:1597:                test_and_set_bit_le(bitpos, z_p->statemap);
zone.c:1599:                test_and_clear_bit_le(bitpos, z_p->statemap);
zone.c:1603:                test_and_set_bit_le(bitpos, z_p->statemap);
zone.c:1605:                test_and_set_bit_le(bitpos, z_p->statemap);
zone.c:1634:    if(dafs_de->file_type==ROOT_DIRECTORY){
zone.c:1640:    name_len = le64_to_cpu(dafs_de->ful_name->f_namelen);
zone.c:1641:    hashname = BKDRHash(dafs_de->ful_name->f_name, name_len);
zone.c:1642:    rf_e = radix_tree_lookup(&ei->rf_root, hashname);
zone.c:1643:    rcount = rf_e->r_f;
zone.c:1644:    //rcount = le64_to_cpu(dafs_de->rcount);
zone.c:1647:    if(dafs_de->file_type == NORMAL_DIRECTORY ){            
zone.c:1648:        sub_num = le64_to_cpu(dafs_de->sub_num);
zone.c:1653:        rf_e->sub_s = sub_s;
zone.c:1656:    //rf_e->sub_s = sub_s;
zone.c:1658:    //sub_s = le64_to_cpu(dafs_de->sub_s);
zone.c:1659:    //f_s = le64_to_cpu(dafs_de->f_s);
zone.c:1661:    if(rf_e->f_s!=DENTRY_FREQUENCY_WRITE)
zone.c:1665:            //dafs_de->f_s = cpu_to_le64(f_s);
zone.c:1668:            //dafs_de->f_s = cpu_to_le64(f_s);
zone.c:1670:        rf_e->f_s = f_s;
zone.c:1679:            rf_e->prio = LEVEL_1;
zone.c:1680:            //dafs_de->prio = LEVEL_1;
zone.c:1685:            rf_e->prio = LEVEL_2;
zone.c:1686:            //dafs_de->prio = LEVEL_2;
zone.c:1691:            rf_e->prio = LEVEL_2;
zone.c:1692:            //dafs_de->prio = LEVEL_2;
zone.c:1697:            rf_e->prio = LEVEL_3;
zone.c:1698:            //dafs_de->prio = LEVEL_3;
zone.c:1702:            rf_e->prio = LEVEL_4;
zone.c:1703:            //dafs_DE->prio = LEVEL_4;
zone.c:1747:    z_e = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
zone.c:1750:    while(bitpos < z_p->zone_max){
zone.c:1751:        if((!test_bit_le(bitpos, z_p->statemap))){
zone.c:1753:            if(!test_bit_le(bitpos, z_p->statemap)){
zone.c:1765:            if(!test_bit_le(bitpos, z_p->statemap)){
zone.c:1797:            dafs_de = z_e->dentry[sp_id];
zone.c:1798:            prio = le_to_cpu(dafs_de->prio);
zone.c:1836:        //dafs_rde = par_ze->dentry[sp_id];
zone.c:1845:        while(bitpos<z_p->zone_max){
zone.c:1846:            if(test_bit_le(bitpos, z_p->statemap)){
zone.c:1848:                if(test_bit_le(bitpos, z_p->statemap)){
zone.c:1849:                    dafs_de = par_ze->dentry[ne_id];
zone.c:1850:                    name_len = le64_to_cpu(dafs_de->ful_name->f_namelen);
zone.c:1851:                    hashname = BKDRHash(dafs_de->ful_name->f_name, name_len);
zone.c:1852:                    rf_e = radix_tree_lookup(&par_dzt_ei->rf_root, hashname);
zone.c:1853:                    if(rf_e->prio==LEVEL_3 || rf_e->prio==LEVEL_4){
zone.c:1891:    struct dzt_manager *dzt_m = sbi->dzt_m_info;
zone.c:1902:    hash_name = cur_rdei->hash_name;
zone.c:1903:    radix_tree_delete(&dzt_m->dzt_root, hash_name);
zone.c:1905:    ch_pos = cur_rdei->dzt_eno;
zone.c:1906:    test_and_clear_bit_le(ch_pos, dzt_p->bitmap);
zone.c:1909:    par_ze = (struct dafs_zone_entry *)nova_get_block(sb, cur_rdei->pdz_addr);
zone.c:1910:    or_pos = cur_rdei->rden_pos;
zone.c:1911:    dafs_orde = par_ze->dentry[or_pos];
zone.c:1912:    dafs_orde->file_type = NORMAL_DIRECTORY;
zone.c:1913:    dafs_orde->mtime = CURRENT_TIME_SEC.tv_sec;
zone.c:1914:    dafs_orde->vroot = 0;
zone.c:1915:    dafs_orde->dzt_hn = 0;
zone.c:1928:    tail = le64_to_cpu(cur_rdei->ht_head);
zone.c:1931:        tem = le64_to_cpu(ht->hash_tail);
zone.c:1935:    dafs_free_zone_blocks(sb, cur_rdei, cur_rdei->dz_addr >> PAGE_SHIFT, 1);
zone.c:1951:    struct dzt_manager *dzt_m = sbi->dzt_m_info;
zone.c:1961:    ch_pos = cur_rdei->dzt_eno;
zone.c:1962:    hash_name = cur_rdei->hash_name;
zone.c:1963:    radix_tree_delete(&dzt_m->dzt_root, hash_name);
zone.c:1964:    test_and_clear_bit(ch_pos, dzt_p->bitmap);
zone.c:1967:    par_ze = (struct dafs_zone_entry *)nova_get_block(sb, cur_rdei->pdz_addr);
zone.c:1968:    or_pos = cur_rdei->rden_pos;
zone.c:1969:    dafs_orde = par_ze->dentry[or_pos];
zone.c:1970:    dafs_orde->file_type = NORMAL_DIRECTORY;
zone.c:1971:    dafs_orde->mtime = CURRENT_TIME_SEC.tv_sec;
zone.c:1972:    dafs_orde->vroot = 0;
zone.c:1973:    dafs_orde->dzt_hn = 0;
zone.c:1977:    dafs_nrde = cur_ze->dentry[nr_pos];
zone.c:1978:    dafs_nrde->file_type = INHE_ROOT_DIRECTORY;
zone.c:1984:    radix_tree_insert(&dzt_m->dzt_root, cur_rdei->hash_name, cur_rdei);
zone.c:1985:    radix_tree_tag_set(&dzt_m->dzt_root, cur_rdei->hash_name, 1);
zone.c:1988:    test_and_set_bit_le(ch_pos, dzt_p->bitmap);
zone.c:2000:    eno = dzt_ei->dzt_eno;
zone.c:2002:    test_and_clear_bit_le(eno, dzt_p->bitmap);
zone.c:2012:    tail = le64_to_cpu(dzt_ei->ht_head);
zone.c:2015:        tem = le64_to_cpu(ht->hash_tail);
zone.c:2019:    dafs_free_zone_blocks(sb, dzt_ei, dzt_ei->dz_addr >> PAGE_SHIFT, 1);
zone.c:2037:        dzt_m = sbi->dzt_m_info;
zone.c:2038:        nr = radix_tree_gang_lookup(&dzt_m->dzt_root, (void **)dzt_eis, 0, DAFS_DZT_ENTRIES_IN_BLOCK);
zone.c:2041:            ret = dafs_check_zones(sbi->sb, ei);
zone.c:2043:                return -EINVAL;
zone.c:2055:    sbi->check_thread = NULL;
zone.c:2059:        return -ENOMEM;
zone.c:2061:    init_waitqueue_head(&(check_thread->wait_queue_head));
zone.c:2062:    check_thread->zone_task = kthread_run(check_thread_func, sbi, "DAFS_CHECK_ZONE");
zone.c:2063:    sbi->check_thread = check_thread;
zone.c:2064:    if(IS_ERR(check_thread->zone_task)){
zone.c:2065:        err = PTR_ERR(check_thread->zone_task);
zone.c:2077:    if(sbi->check_thread) {
zone.c:2078:        kthread_stop(sbi->check_thread->zone_task);
zone.c:2079:        kfree(sbi->check_thread);
zone.c:2080:        sbi->check_thread = NULL;
Makefile:5:obj-m += nova.o
Makefile:7:nova-y := balloc.o bbuild.o dax.o dir.o file.o inode.o ioctl.o journal.o namei.o stats.o super.o symlink.o sysfs.o wprotect.o
Makefile:10:	make -C /lib/modules/$(shell uname -r)/build M=`pwd`
Makefile:13:	make -C /lib/modules/$(shell uname -r)/build M=`pwd` clean
file.c:6: * Copyright 2015-2016 Regents of the University of California,
file.c:7: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
file.c:8: * Copyright 2012-2013 Intel Corporation
file.c:9: * Copyright 2009-2011 Marco Stornelli <marco.stornelli@gmail.com>
file.c:12: * 2003-2004 (c) MontaVista Software, Inc. , Steve Longerbeam
file.c:29:	struct nova_inode_info_header *sih = &si->header;
file.c:33:	if (sih->i_size > 0)
file.c:62:		new_size, pi->i_size);
file.c:65:	pi->i_blk_type = block_type;
file.c:72:	struct inode *inode = file->f_path.dentry->d_inode;
file.c:78:	mutex_lock(&inode->i_mutex);
file.c:83:			mutex_unlock(&inode->i_mutex);
file.c:90:			mutex_unlock(&inode->i_mutex);
file.c:96:	if ((offset < 0 && !(file->f_mode & FMODE_UNSIGNED_OFFSET)) ||
file.c:97:	    offset > inode->i_sb->s_maxbytes) {
file.c:98:		mutex_unlock(&inode->i_mutex);
file.c:99:		return -EINVAL;
file.c:102:	if (offset != file->f_pos) {
file.c:103:		file->f_pos = offset;
file.c:104:		file->f_version = 0;
file.c:107:	mutex_unlock(&inode->i_mutex);
file.c:131:			__func__, pi->nova_ino, *start, end);
file.c:137:		bytes = sb->s_blocksize - offset;
file.c:138:		if (bytes > (end - temp))
file.c:139:			bytes = end - temp;
file.c:170:	low_blk = sih->low_dirty;
file.c:171:	high_blk = sih->high_dirty;
file.c:186:	struct address_space *mapping = file->f_mapping;
file.c:187:	struct inode *inode = mapping->host;
file.c:189:	struct nova_inode_info_header *sih = &si->header;
file.c:190:	struct super_block *sb = inode->i_sb;
file.c:204:	mutex_lock(&inode->i_mutex);
file.c:220:		mutex_unlock(&inode->i_mutex);
file.c:235:	end_temp = pi->log_tail;
file.c:255:	if (begin_tail && end_tail && end_tail != pi->log_tail) {
file.c:261:		inode->i_blocks = le64_to_cpu(pi->i_blocks);
file.c:264:	mutex_unlock(&inode->i_mutex);
file.c:280:	struct address_space *mapping = file->f_mapping;
file.c:281:	struct inode *inode = mapping->host;
file.c:282:	struct super_block *sb = inode->i_sb;
file.c:284:	struct nova_inode_info_header *sih = &si->header;
file.c:307:		return -ENODATA;
file.c:334:			pgoff = entry->pgoff;
file.c:342:		nr_flush_bytes = end - start;
file.c:344:		if (pgoff < entry->pgoff ||
file.c:345:				pgoff - entry->pgoff >= entry->num_pages) {
file.c:347:				"blocknr %llu\n", __func__, pgoff, entry->pgoff,
file.c:348:				entry->num_pages, entry->block >> PAGE_SHIFT);
file.c:350:			return -EINVAL;
file.c:354:		if (entry->invalid_pages == 0)
file.c:355:			avail_bytes = (entry->num_pages - (pgoff - entry->pgoff))
file.c:356:				* PAGE_SIZE - offset;
file.c:358:			avail_bytes = PAGE_SIZE - offset;
stats.c:4: * Copyright 2015-2016 Regents of the University of California,
stats.c:5: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
stats.c:18: * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
stats.c:126:	for (i = 0; i < sbi->cpus; i++) {
stats.c:129:		alloc_log_count += free_list->alloc_log_count;
stats.c:130:		alloc_log_pages += free_list->alloc_log_pages;
stats.c:131:		alloc_data_count += free_list->alloc_data_count;
stats.c:132:		alloc_data_pages += free_list->alloc_data_pages;
stats.c:133:		free_log_count += free_list->free_log_count;
stats.c:134:		freed_log_pages += free_list->freed_log_pages;
stats.c:135:		free_data_count += free_list->free_data_count;
stats.c:136:		freed_data_pages += free_list->freed_data_pages;
stats.c:257:			curr, entry->pgoff, entry->num_pages,
stats.c:258:			entry->block >> PAGE_SHIFT,
stats.c:259:			entry->invalid_pages, entry->size);
stats.c:266:			curr, entry->mode, entry->size);
stats.c:273:			curr, entry->links, entry->flags);
stats.c:281:			le64_to_cpu(entry->ino),
stats.c:282:			entry->name_len, le16_to_cpu(DAFS_DEF_ZONE_ENTRY_SIZE);//entry->de_len));
stats.c:284:	return le16_to_cpu(DAFS_DEF_ZONE_ENTRY_SIZE);//entry->de_len);
stats.c:348:			start, tail->next_page);
stats.c:356:	if (pi->log_tail == 0)
stats.c:359:	curr = pi->log_head;
stats.c:361:			sih->ino, curr, pi->log_tail);
stats.c:362:	while (curr != pi->log_tail) {
stats.c:363:		if ((curr & (PAGE_SIZE - 1)) == LAST_ENTRY) {
stats.c:367:					curr, tail->next_page);
stats.c:368:			curr = tail->next_page;
stats.c:378:	struct nova_inode_info_header *sih = &si->header;
stats.c:392:	if (pi->log_head == 0 || pi->log_tail == 0) {
stats.c:393:		nova_dbg("Pi %lu has no log\n", sih->ino);
stats.c:397:	curr = pi->log_head;
stats.c:399:	while ((next = curr_page->page_tail.next_page) != 0) {
stats.c:417:	if (pi->log_head == 0 || pi->log_tail == 0) {
stats.c:418:		nova_dbg("Pi %lu has no log\n", sih->ino);
stats.c:422:	curr = pi->log_head;
stats.c:424:			sih->ino, curr, pi->log_tail);
stats.c:426:	while ((next = curr_page->page_tail.next_page) != 0) {
stats.c:429:		if (pi->log_tail >> PAGE_SHIFT == curr >> PAGE_SHIFT)
stats.c:436:	if (pi->log_tail >> PAGE_SHIFT == curr >> PAGE_SHIFT)
stats.c:439:		"si reports %lu pages\n", sih->ino, used, count,
stats.c:440:		sih->log_pages);
stats.c:447:	struct nova_inode_info_header *sih = &si->header;
stats.c:459:	nova_dbg("======== NOVA per-CPU free list allocation stats ========\n");
stats.c:460:	for (i = 0; i < sbi->cpus; i++) {
stats.c:464:			i, free_list->block_start, free_list->block_end,
stats.c:465:			free_list->block_end - free_list->block_start + 1,
stats.c:466:			free_list->num_free_blocks, free_list->num_blocknode);
stats.c:473:			free_list->alloc_log_count,
stats.c:474:			free_list->alloc_log_pages,
stats.c:475:			free_list->alloc_data_count,
stats.c:476:			free_list->alloc_data_pages,
stats.c:477:			free_list->free_log_count,
stats.c:478:			free_list->freed_log_pages,
stats.c:479:			free_list->free_data_count,
stats.c:480:			free_list->freed_data_pages);
stats.c:487:		i, free_list->block_start, free_list->block_end,
stats.c:488:		free_list->block_end - free_list->block_start + 1,
stats.c:489:		free_list->num_free_blocks, free_list->num_blocknode);
stats.c:496:		free_list->alloc_log_count, free_list->alloc_log_pages,
stats.c:497:		free_list->alloc_data_count, free_list->alloc_data_pages,
stats.c:498:		free_list->free_log_count, free_list->freed_log_pages,
stats.c:499:		free_list->free_data_count, free_list->freed_data_pages);
dir.c:6: * Copyright 2015-2016 Regents of the University of California,
dir.c:7: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
dir.c:8: * Copyright 2012-2013 Intel Corporation
dir.c:9: * Copyright 2009-2011 Marco Stornelli <marco.stornelli@gmail.com>
dir.c:12: * 2003-2004 (c) MontaVista Software, Inc. , Steve Longerbeam
dir.c:32:	struct nova_inode_info_header *sih = &si->header;
dir.c:38:	direntry = radix_tree_lookup(&sih->tree, hash);
dir.c:54:	ret = radix_tree_insert(&sih->tree, hash, direntry);
dir.c:64:	if (dentry->name_len != namelen)
dir.c:65:		return -EINVAL;
dir.c:67:	return strncmp(dentry->name, name, namelen);
dir.c:78:	entry = radix_tree_delete(&sih->tree, hash);
dir.c:84:			return -EINVAL;
dir.c:87:		if (entry->ino == 0 || entry->invalid ||
dir.c:94:					entry->entry_type,
dir.c:95:					le64_to_cpu(entry->ino),
dir.c:96:					entry->name, entry->name_len,
dir.c:97:					le16_to_cpu(entry->de_len));
dir.c:98:			return -EINVAL;
dir.c:102:		entry->invalid = 1;
dir.c:122:		nr_entries = radix_tree_gang_lookup(&sih->tree,
dir.c:127:			pos = BKDRHash(direntry->name, direntry->name_len);
dir.c:128:			ret = radix_tree_delete(&sih->tree, pos);
dir.c:132:					direntry->entry_type,
dir.c:133:					le64_to_cpu(direntry->ino),
dir.c:134:					direntry->name, direntry->name_len,
dir.c:135:					le16_to_cpu(direntry->de_len));
dir.c:161:	struct nova_inode_info_header *sih = &si->header;
dir.c:178:	entry->entry_type = DIR_LOG;
dir.c:179:	entry->ino = cpu_to_le64(ino);
dir.c:180:	entry->name_len = dentry->d_name.len;
dir.c:181:	memcpy_to_pmem_nocache(entry->name, dentry->d_name.name,
dir.c:182:				dentry->d_name.len);
dir.c:183:	entry->name[dentry->d_name.len] = '\0';
dir.c:184:	entry->file_type = 0;
dir.c:185:	entry->invalid = 0;
dir.c:186:	entry->mtime = cpu_to_le32(dir->i_mtime.tv_sec);
dir.c:187:	entry->size = cpu_to_le64(dir->i_size);
dir.c:189:	links_count = cpu_to_le16(dir->i_nlink);
dir.c:190:	if (links_count == 0 && link_change == -1)
dir.c:194:	entry->links_count = cpu_to_le16(links_count);
dir.c:197:	entry->de_len = cpu_to_le16(de_len);
dir.c:200:			curr_p, entry->ino, entry->de_len,
dir.c:201:			entry->name_len, entry->file_type);
dir.c:208:	dir->i_blocks = pidir->i_blocks;
dir.c:222:	if (pi->log_head) {
dir.c:224:				__func__, pi->log_head);
dir.c:225:		return - EINVAL;
dir.c:231:		return - ENOMEM;
dir.c:233:	pi->log_tail = pi->log_head = new_block;
dir.c:234:	pi->i_blocks = 1;
dir.c:235:	nova_flush_buffer(&pi->log_head, CACHELINE_SIZE, 0);
dir.c:238:	de_entry->entry_type = DIR_LOG;
dir.c:239:	de_entry->ino = cpu_to_le64(self_ino);
dir.c:240:	de_entry->name_len = 1;
dir.c:241:	de_entry->de_len = cpu_to_le16(NOVA_DIR_LOG_REC_LEN(1));
dir.c:242:	de_entry->mtime = CURRENT_TIME_SEC.tv_sec;
dir.c:243:	de_entry->size = sb->s_blocksize;
dir.c:244:	de_entry->links_count = 1;
dir.c:246:	strncpy(de_entry->name, ".\0", 2);
dir.c:252:					le16_to_cpu(de_entry->de_len));
dir.c:253:	de_entry->entry_type = DIR_LOG;
dir.c:254:	de_entry->ino = cpu_to_le64(parent_ino);
dir.c:255:	de_entry->name_len = 2;
dir.c:256:	de_entry->de_len = cpu_to_le16(NOVA_DIR_LOG_REC_LEN(2));
dir.c:257:	de_entry->mtime = CURRENT_TIME_SEC.tv_sec;
dir.c:258:	de_entry->size = sb->s_blocksize;
dir.c:259:	de_entry->links_count = 2;
dir.c:260:	strncpy(de_entry->name, "..\0", 3);
dir.c:275:	struct inode *dir = dentry->d_parent->d_inode;
dir.c:276:	struct super_block *sb = dir->i_sb;
dir.c:278:	struct nova_inode_info_header *sih = &si->header;
dir.c:280:	const char *name = dentry->d_name.name;
dir.c:281:	int namelen = dentry->d_name.len;
dir.c:289:				__func__, dir->i_ino, ino);
dir.c:293:		return -EINVAL;
dir.c:302:	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
dir.c:322:	struct inode *dir = dentry->d_parent->d_inode;
dir.c:323:	struct super_block *sb = dir->i_sb;
dir.c:325:	struct nova_inode_info_header *sih = &si->header;
dir.c:327:	struct qstr *entry = &dentry->d_name;
dir.c:334:	if (!dentry->d_name.len)
dir.c:335:		return -EINVAL;
dir.c:339:	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
dir.c:341:	loglen = NOVA_DIR_LOG_REC_LEN(entry->len);
dir.c:346:	nova_remove_dir_radix_tree(sb, sih, entry->name, entry->len, 0);
dir.c:354:	if (!entry->name_len)
dir.c:355:		return -EINVAL;
dir.c:357:	nova_dbg_verbose("%s: add %s\n", __func__, entry->name);
dir.c:359:			entry->name, entry->name_len, entry);
dir.c:366:	nova_dbg_verbose("%s: remove %s\n", __func__, entry->name);
dir.c:367:	nova_remove_dir_radix_tree(sb, sih, entry->name,
dir.c:368:					entry->name_len, 1);
dir.c:378:	pi->i_ctime = entry->mtime;
dir.c:379:	pi->i_mtime = entry->mtime;
dir.c:380:	pi->i_size = entry->size;
dir.c:381:	pi->i_links_count = entry->links_count;
dir.c:392:	u64 ino = pi->nova_ino;
dir.c:404:	sih->pi_addr = pi_addr;
dir.c:406:	curr_p = pi->log_head;
dir.c:413:				curr_p, pi->log_tail);
dir.c:415:	sih->log_pages = 1;
dir.c:416:	while (curr_p != pi->log_tail) {
dir.c:418:			sih->log_pages++;
dir.c:435:				sih->last_setattr = curr_p;
dir.c:443:				sih->last_link_change = curr_p;
dir.c:457:			entry->entry_type, le64_to_cpu(entry->ino),
dir.c:458:			entry->name, entry->name_len,
dir.c:459:			le16_to_cpu(entry->de_len));
dir.c:461:		if (entry->ino > 0) {
dir.c:462:			if (entry->invalid == 0) {
dir.c:478:		de_len = le16_to_cpu(entry->de_len);
dir.c:482:	sih->i_size = le64_to_cpu(pi->i_size);
dir.c:483:	sih->i_mode = le64_to_cpu(pi->i_mode);
dir.c:489:	while ((next = curr_page->page_tail.next_page) != 0) {
dir.c:490:		sih->log_pages++;
dir.c:496:	pi->i_blocks = sih->log_pages;
dir.c:507:	struct super_block *sb = inode->i_sb;
dir.c:510:	struct nova_inode_info_header *sih = &si->header;
dir.c:525:			__func__, (u64)inode->i_ino,
dir.c:526:			pidir->i_size, ctx->pos);
dir.c:530:				__func__, inode->i_ino);
dir.c:531:		ctx->pos = READDIR_END;
dir.c:535:	pos = ctx->pos;
dir.c:540:		nr_entries = radix_tree_gang_lookup(&sih->tree,
dir.c:544:			pos = BKDRHash(entry->name, entry->name_len);
dir.c:545:			ino = __le64_to_cpu(entry->ino);
dir.c:553:				ctx->pos = READDIR_END;
dir.c:560:				(u64)ino, entry->name, entry->name_len,
dir.c:561:				entry->de_len);
dir.c:562:			if (!dir_emit(ctx, entry->name, entry->name_len,
dir.c:563:				ino, IF2DT(le16_to_cpu(child_pi->i_mode)))) {
dir.c:564:				nova_dbgv("Here: pos %llu\n", ctx->pos);
dir.c:567:			ctx->pos = pos + 1;
dir.c:587:	nr_entries = radix_tree_gang_lookup(&sih->tree,
dir.c:600:	struct super_block *sb = inode->i_sb;
dir.c:603:	struct nova_inode_info_header *sih = &si->header;
dir.c:621:			__func__, (u64)inode->i_ino,
dir.c:622:			pidir->i_size, ctx->pos);
dir.c:624:	if (pidir->log_head == 0) {
dir.c:625:		nova_err(sb, "Dir %lu log is NULL!\n", inode->i_ino);
dir.c:627:		return -EINVAL;
dir.c:631:	pos = ctx->pos;
dir.c:634:		curr_p = pidir->log_head;
dir.c:644:	while (curr_p != pidir->log_tail) {
dir.c:650:			nova_err(sb, "Dir %lu log is NULL!\n", inode->i_ino);
dir.c:652:			return -EINVAL;
dir.c:670:			return -EINVAL;
dir.c:676:			entry->entry_type, le64_to_cpu(entry->ino),
dir.c:677:			entry->name, entry->name_len,
dir.c:678:			le16_to_cpu(entry->de_len));
dir.c:680:		de_len = le16_to_cpu(entry->de_len);
dir.c:681:		if (entry->ino > 0 && entry->invalid == 0) {
dir.c:682:			ino = __le64_to_cpu(entry->ino);
dir.c:683:			pos = BKDRHash(entry->name, entry->name_len);
dir.c:689:				ctx->pos = READDIR_END;
dir.c:696:				(u64)ino, entry->name, entry->name_len,
dir.c:697:				entry->de_len);
dir.c:698:			if (prev_entry && !dir_emit(ctx, prev_entry->name,
dir.c:699:				prev_entry->name_len, ino,
dir.c:700:				IF2DT(le16_to_cpu(prev_child_pi->i_mode)))) {
dir.c:701:				nova_dbgv("Here: pos %llu\n", ctx->pos);
dir.c:707:		ctx->pos = pos;
dir.c:711:	if (prev_entry && !dir_emit(ctx, prev_entry->name,
dir.c:712:			prev_entry->name_len, ino,
dir.c:713:			IF2DT(le16_to_cpu(prev_child_pi->i_mode))))
dir.c:716:	ctx->pos = READDIR_END;
inode.c:6: * Copyright 2015-2016 Regents of the University of California,
inode.c:7: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
inode.c:8: * Copyright 2012-2013 Intel Corporation
inode.c:9: * Copyright 2009-2011 Marco Stornelli <marco.stornelli@gmail.com>
inode.c:12: * 2003-2004 (c) MontaVista Software, Inc. , Steve Longerbeam
inode.c:23:#include <linux/backing-dev.h>
inode.c:40:	sbi->s_inodes_used_count = NOVA_NORMAL_INODE_START;
inode.c:42:	range_high = (NOVA_NORMAL_INODE_START - 1) / sbi->cpus;
inode.c:43:	if (NOVA_NORMAL_INODE_START % sbi->cpus)
inode.c:46:	for (i = 0; i < sbi->cpus; i++) {
inode.c:47:		inode_map = &sbi->inode_maps[i];
inode.c:51:			return -ENOMEM;
inode.c:53:		range_node->range_low = 0;
inode.c:54:		range_node->range_high = range_high;
inode.c:61:		inode_map->num_range_node_inode = 1;
inode.c:62:		inode_map->first_inode_range = range_node;
inode.c:78:	pi->i_mode = 0;
inode.c:79:	pi->i_uid = 0;
inode.c:80:	pi->i_gid = 0;
inode.c:81:	pi->i_links_count = cpu_to_le16(1);
inode.c:82:	pi->i_flags = 0;
inode.c:83:	pi->nova_ino = NOVA_INODETABLE_INO;
inode.c:85:	pi->i_blk_type = NOVA_BLOCK_TYPE_2M;
inode.c:87:	for (i = 0; i < sbi->cpus; i++) {
inode.c:91:			return -EINVAL;
inode.c:98:			return -ENOSPC;  
inode.c:103:		inode_table->log_head = block;
inode.c:130:	data_bits = blk_type_to_shift[pi->i_blk_type];
inode.c:131:	num_inodes_bits = data_bits - NOVA_INODE_BITS;
inode.c:134:	cpuid = ino % sbi->cpus;
inode.c:135:	internal_ino = ino / sbi->cpus;
inode.c:140:	index = internal_ino & ((1 << num_inodes_bits) - 1);
inode.c:142:	curr = inode_table->log_head;
inode.c:144:		return -EINVAL;
inode.c:148:			return -EINVAL;
inode.c:152:		curr_addr += 2097152 - 8;
inode.c:157:				return -EINVAL;
inode.c:187:	if (entry->num_pages < entry->invalid_pages + num_pages) {
inode.c:190:				__func__, sih->ino, entry->pgoff,
inode.c:191:				entry->num_pages, entry->invalid_pages,
inode.c:196:	entry->invalid_pages += num_pages;
inode.c:224:	u32 btype = pi->i_blk_type;
inode.c:240:		curr_block = curr_page->page_tail.next_page;
inode.c:276:			__func__, sih->ino, sih->mmap_pages,
inode.c:280:		addr = (unsigned long)radix_tree_lookup(&sih->cache_tree, i);
inode.c:282:			ret = radix_tree_delete(&sih->cache_tree, i);
inode.c:284:			sih->mmap_pages--;
inode.c:290:			__func__, sih->ino, deleted);
inode.c:292:	if (sih->mmap_pages == 0) {
inode.c:293:		sih->low_dirty = ULONG_MAX;
inode.c:294:		sih->high_dirty = 0;
inode.c:309:			"size %lu", __func__, sih->ino, sih->mmap_pages,
inode.c:310:			start_blocknr, sih->high_dirty, sih->i_size);
inode.c:312:	for (i = start_blocknr; i <= sih->high_dirty; i++) {
inode.c:313:		block = (unsigned long)radix_tree_lookup(&sih->cache_tree, i);
inode.c:336:	pi = (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
inode.c:340:	if (delete_mmap && sih->mmap_pages)
inode.c:344:	if (sih->mmap_pages && start_blocknr <= sih->high_dirty)
inode.c:349:		entry = radix_tree_lookup(&sih->tree, pgoff);
inode.c:351:			ret = radix_tree_delete(&sih->tree, pgoff);
inode.c:364:			pgoff = pgoff > entry->pgoff ? pgoff : entry->pgoff;
inode.c:376:			pi->nova_ino, start_blocknr, last_blocknr, freed);
inode.c:387:	if (!(S_ISREG(sih->i_mode)) && !(S_ISDIR(sih->i_mode)))
inode.c:390:	if (S_ISREG(sih->i_mode)) {
inode.c:408:	struct super_block *sb = inode->i_sb;
inode.c:411:	struct nova_inode_info_header *sih = &si->header;
inode.c:412:	unsigned int data_bits = blk_type_to_shift[pi->i_blk_type];
inode.c:416:	inode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;
inode.c:419:			 pi->i_blocks, start, end, pi->i_size);
inode.c:421:	first_blocknr = (start + (1UL << data_bits) - 1) >> data_bits;
inode.c:425:	last_blocknr = (end - 1) >> data_bits;
inode.c:433:	inode->i_blocks -= (freed * (1 << (data_bits -
inode.c:434:				sb->s_blocksize_bits)));
inode.c:436:	pi->i_blocks = cpu_to_le64(inode->i_blocks);
inode.c:438:	check_eof_blocks(sb, pi, inode->i_size);
inode.c:450:	nr_entries = radix_tree_gang_lookup(&sih->tree,
inode.c:479:		entry = radix_tree_lookup(&sih->tree, pgoff);
inode.c:490:				pgoff = pgoff > entry->pgoff ?
inode.c:491:					pgoff : entry->pgoff;
inode.c:498:			blocks += pgoff - old_pgoff;
inode.c:513:	unsigned long start_pgoff = entry->pgoff;
inode.c:514:	unsigned int num = entry->num_pages;
inode.c:524:		pentry = radix_tree_lookup_slot(&sih->tree, curr_pgoff);
inode.c:529:				old_entry->invalid_pages++;
inode.c:531:				pi->i_blocks--;
inode.c:535:			ret = radix_tree_insert(&sih->tree, curr_pgoff, entry);
inode.c:554:	struct nova_inode_info_header *sih = &si->header;
inode.c:555:	int ret = -EIO;
inode.c:559:	inode->i_mode = sih->i_mode;
inode.c:560:	i_uid_write(inode, le32_to_cpu(pi->i_uid));
inode.c:561:	i_gid_write(inode, le32_to_cpu(pi->i_gid));
inode.c:562://	set_nlink(inode, le16_to_cpu(pi->i_links_count));
inode.c:563:	inode->i_generation = le32_to_cpu(pi->i_generation);
inode.c:564:	nova_set_inode_flags(inode, pi, le32_to_cpu(pi->i_flags));
inode.c:565:	ino = inode->i_ino;
inode.c:568:	if (inode->i_mode == 0 || pi->valid == 0) {
inode.c:570:		ret = -ESTALE;
inode.c:574:	inode->i_blocks = le64_to_cpu(pi->i_blocks);
inode.c:575:	inode->i_mapping->a_ops = &nova_aops_dax;
inode.c:577:	switch (inode->i_mode & S_IFMT) {
inode.c:579:		inode->i_op = &nova_file_inode_operations;
inode.c:580:		inode->i_fop = &nova_dax_file_operations;
inode.c:583:		inode->i_op = &nova_dir_inode_operations;
inode.c:584:		inode->i_fop = &nova_dir_operations;
inode.c:587:		inode->i_op = &nova_symlink_inode_operations;
inode.c:590:		inode->i_op = &nova_special_inode_operations;
inode.c:591:		init_special_inode(inode, inode->i_mode,
inode.c:592:				   le32_to_cpu(pi->dev.rdev));
inode.c:597:	inode->i_size = le64_to_cpu(sih->i_size);
inode.c:598:	inode->i_atime.tv_sec = le32_to_cpu(pi->i_atime);
inode.c:599:	inode->i_ctime.tv_sec = le32_to_cpu(pi->i_ctime);
inode.c:600:	inode->i_mtime.tv_sec = le32_to_cpu(pi->i_mtime);
inode.c:601:	inode->i_atime.tv_nsec = inode->i_mtime.tv_nsec =
inode.c:602:					 inode->i_ctime.tv_nsec = 0;
inode.c:603:	set_nlink(inode, le16_to_cpu(pi->i_links_count));
inode.c:613:	unsigned int flags = inode->i_flags;
inode.c:614:	unsigned int nova_flags = le32_to_cpu(pi->i_flags);
inode.c:629:	pi->i_flags = cpu_to_le32(nova_flags);
inode.c:634:	nova_memunlock_inode(inode->i_sb, pi);
inode.c:635:	pi->i_mode = cpu_to_le16(inode->i_mode);
inode.c:636:	pi->i_uid = cpu_to_le32(i_uid_read(inode));
inode.c:637:	pi->i_gid = cpu_to_le32(i_gid_read(inode));
inode.c:638:	pi->i_links_count = cpu_to_le16(inode->i_nlink);
inode.c:639:	pi->i_size = cpu_to_le64(inode->i_size);
inode.c:640:	pi->i_blocks = cpu_to_le64(inode->i_blocks);
inode.c:641:	pi->i_atime = cpu_to_le32(inode->i_atime.tv_sec);
inode.c:642:	pi->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);
inode.c:643:	pi->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);
inode.c:644:	pi->i_generation = cpu_to_le32(inode->i_generation);
inode.c:647:	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
inode.c:648:		pi->dev.rdev = cpu_to_le32(inode->i_rdev);
inode.c:650:	nova_memlock_inode(inode->i_sb, pi);
inode.c:667:	inode_map = &sbi->inode_maps[cpuid];
inode.c:668:	i = inode_map->first_inode_range;
inode.c:670:	temp = &i->node;
inode.c:678:		next_range_low = next_i->range_low;
inode.c:681:	new_ino = i->range_high + 1;
inode.c:683:	if (next_i && new_ino == (next_range_low - 1)) {
inode.c:685:		i->range_high = next_i->range_high;
inode.c:686:		rb_erase(&next_i->node, &inode_map->inode_inuse_tree);
inode.c:688:		inode_map->num_range_node_inode--;
inode.c:689:	} else if (new_ino < (next_range_low - 1)) {
inode.c:691:		i->range_high = new_ino;
inode.c:695:		return -ENOSPC;
inode.c:698:	*ino = new_ino * sbi->cpus + cpuid;
inode.c:699:	sbi->s_inodes_used_count++;
inode.c:700:	inode_map->allocated++;
inode.c:713:	int cpuid = ino % sbi->cpus;
inode.c:714:	unsigned long internal_ino = ino / sbi->cpus;
inode.c:718:	inode_map = &sbi->inode_maps[cpuid];
inode.c:720:	mutex_lock(&inode_map->inode_table_mutex);
inode.c:724:		mutex_unlock(&inode_map->inode_table_mutex);
inode.c:725:		return -EINVAL;
inode.c:728:	if ((internal_ino == i->range_low) && (internal_ino == i->range_high)) {
inode.c:730:		rb_erase(&i->node, &inode_map->inode_inuse_tree);
inode.c:732:		inode_map->num_range_node_inode--;
inode.c:735:	if ((internal_ino == i->range_low) && (internal_ino < i->range_high)) {
inode.c:737:		i->range_low = internal_ino + 1;
inode.c:740:	if ((internal_ino > i->range_low) && (internal_ino == i->range_high)) {
inode.c:742:		i->range_high = internal_ino - 1;
inode.c:745:	if ((internal_ino > i->range_low) && (internal_ino < i->range_high)) {
inode.c:753:		curr_node->range_low = internal_ino + 1;
inode.c:754:		curr_node->range_high = i->range_high;
inode.c:755:		i->range_high = internal_ino - 1;
inode.c:761:		inode_map->num_range_node_inode++;
inode.c:767:	nova_error_mng(sb, "Found inuse block %lu - %lu\n",
inode.c:768:				 i->range_low, i->range_high);
inode.c:769:	mutex_unlock(&inode_map->inode_table_mutex);
inode.c:773:	sbi->s_inodes_used_count--;
inode.c:774:	inode_map->freed++;
inode.c:775:	mutex_unlock(&inode_map->inode_table_mutex);
inode.c:783: * is not on the hash-lists, and it cannot be reached
inode.c:790:	struct super_block *sb = inode->i_sb;
inode.c:799:	if (pi->valid) {
inode.c:801:				__func__, inode->i_ino);
inode.c:802:		pi->valid = 0;
inode.c:805:	if (pi->nova_ino != inode->i_ino) {
inode.c:807:				__func__, inode->i_ino, pi->nova_ino);
inode.c:810:				inode->i_size, sih->pi_addr, pi->log_head,
inode.c:811:				pi->log_tail, pi->i_mode);
inode.c:813:				"inode mode %u\n", sih->ino, sih->i_size,
inode.c:814:				sih->i_mode, inode->i_mode);
inode.c:819:	pi->i_blocks = 0;
inode.c:821:	sih->log_pages = 0;
inode.c:822:	sih->i_mode = 0;
inode.c:823:	sih->pi_addr = 0;
inode.c:824:	sih->i_size = 0;
inode.c:826:	err = nova_free_inuse_inode(sb, pi->nova_ino);
inode.c:841:		return ERR_PTR(-ENOMEM);
inode.c:842:	if (!(inode->i_state & I_NEW))
inode.c:861:		err = -EACCES;
inode.c:872:	inode->i_ino = ino;
inode.c:889:	pi = nova_get_block(sb, sih->pi_addr);
inode.c:890:	btype = pi->i_blk_type;
inode.c:893:	if (sih->i_size == 0)
inode.c:896:		last_blocknr = (sih->i_size - 1) >> data_bits;
inode.c:903:	struct super_block *sb = inode->i_sb;
inode.c:906:	struct nova_inode_info_header *sih = &si->header;
inode.c:916:				__func__, inode->i_ino);
inode.c:922:	nova_dbg_verbose("%s: %lu\n", __func__, inode->i_ino);
inode.c:923:	if (!inode->i_nlink && !is_bad_inode(inode)) {
inode.c:928:		/* We need the log to free the blocks from the b-tree */
inode.c:929:		switch (inode->i_mode & S_IFMT) {
inode.c:932:			nova_dbgv("%s: file ino %lu\n", __func__, inode->i_ino);
inode.c:937:			nova_dbgv("%s: dir ino %lu\n", __func__, inode->i_ino);
inode.c:945:					__func__, inode->i_ino);
inode.c:951:					__func__, inode->i_ino);
inode.c:960:					__func__, inode->i_ino);
inode.c:965:		inode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;
inode.c:966:		inode->i_size = 0;
inode.c:972:	/* TODO: Since we don't use page-cache, do we really need the following
inode.c:974:	truncate_inode_pages(&inode->i_data, 0);
inode.c:993:	map_id = sbi->map_id;
inode.c:994:	sbi->map_id = (sbi->map_id + 1) % sbi->cpus;
inode.c:996:	inode_map = &sbi->inode_maps[map_id];
inode.c:998:	mutex_lock(&inode_map->inode_table_mutex);
inode.c:1002:		mutex_unlock(&inode_map->inode_table_mutex);
inode.c:1009:		mutex_unlock(&inode_map->inode_table_mutex);
inode.c:1013:	mutex_unlock(&inode_map->inode_table_mutex);
inode.c:1036:	sb = dir->i_sb;
inode.c:1037:	sbi = (struct nova_sb_info *)sb->s_fs_info;
inode.c:1040:		errval = -ENOMEM;
inode.c:1045:	inode->i_blocks = inode->i_size = 0;
inode.c:1046:	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
inode.c:1048:	inode->i_generation = atomic_add_return(1, &sbi->next_generation);
inode.c:1049:	inode->i_size = size;
inode.c:1053:		errval = -EACCES;
inode.c:1062:	inode->i_ino = ino;
inode.c:1066:			inode->i_op = &nova_file_inode_operations;
inode.c:1067:			inode->i_mapping->a_ops = &nova_aops_dax;
inode.c:1068:			inode->i_fop = &nova_dax_file_operations;
inode.c:1072:			inode->i_op = &nova_special_inode_operations;
inode.c:1075:			inode->i_op = &nova_symlink_inode_operations;
inode.c:1076:			inode->i_mapping->a_ops = &nova_aops_dax;
inode.c:1079:			inode->i_op = &nova_dir_inode_operations;
inode.c:1080:			inode->i_fop = &nova_dir_operations;
inode.c:1081:			inode->i_mapping->a_ops = &nova_aops_dax;
inode.c:1094:	pi->i_blk_type = NOVA_DEFAULT_BLOCK_TYPE;
inode.c:1095:	pi->i_flags = nova_mask_flags(mode, diri->i_flags);
inode.c:1096:	pi->log_head = 0;
inode.c:1097:	pi->log_tail = 0;
inode.c:1098:	pi->nova_ino = ino;
inode.c:1102:	sih = &si->header;
inode.c:1103:	nova_init_header(sb, sih, inode->i_mode);
inode.c:1104:	sih->pi_addr = pi_addr;
inode.c:1105:	sih->ino = ino;
inode.c:1109:	nova_set_inode_flags(inode, pi, le32_to_cpu(pi->i_flags));
inode.c:1112:		nova_err(sb, "nova_new_inode failed ino %lx\n", inode->i_ino);
inode.c:1113:		errval = -EINVAL;
inode.c:1144:	struct super_block *sb = inode->i_sb;
inode.c:1148:	 * we can do in-place atomic update */
inode.c:1150:	pi->i_atime = cpu_to_le32(inode->i_atime.tv_sec);
inode.c:1153:	nova_flush_buffer(&pi->i_atime, sizeof(pi->i_atime), 0);
inode.c:1164:	struct nova_inode_info_header *sih = &si->header;
inode.c:1165:	unsigned long offset = newsize & (sb->s_blocksize - 1);
inode.c:1170:	if (offset == 0 || newsize > inode->i_size)
inode.c:1173:	length = sb->s_blocksize - offset;
inode.c:1174:	pgoff = newsize >> sb->s_blocksize_bits;
inode.c:1185:	if (sih->mmap_pages && pgoff <= sih->high_dirty &&
inode.c:1186:			pgoff >= sih->low_dirty) {
inode.c:1187:		nvmm = (unsigned long)radix_tree_lookup(&sih->cache_tree,
inode.c:1198:	struct super_block *sb = inode->i_sb;
inode.c:1200:	struct nova_inode_info_header *sih = &si->header;
inode.c:1203:	if (!(S_ISREG(inode->i_mode))) {
inode.c:1204:		nova_err(inode->i_sb, "%s:wrong file mode %x\n", inode->i_mode);
inode.c:1211:		__func__, inode->i_ino, oldsize, newsize);
inode.c:1216:		sih->i_size = newsize;
inode.c:1236:	inode = dentry->d_inode;
inode.c:1238:	/* stat->blocks should be the number of 512B blocks */
inode.c:1239:	stat->blocks = (inode->i_blocks << inode->i_sb->s_blocksize_bits) >> 9;
inode.c:1246:	unsigned int ia_valid = attr->ia_valid, attr_mask;
inode.c:1252:	entry->entry_type	= SET_ATTR;
inode.c:1253:	entry->attr	= ia_valid & attr_mask;
inode.c:1254:	entry->mode	= cpu_to_le16(inode->i_mode);
inode.c:1255:	entry->uid	= cpu_to_le32(i_uid_read(inode));
inode.c:1256:	entry->gid	= cpu_to_le32(i_gid_read(inode));
inode.c:1257:	entry->atime	= cpu_to_le32(inode->i_atime.tv_sec);
inode.c:1258:	entry->ctime	= cpu_to_le32(inode->i_ctime.tv_sec);
inode.c:1259:	entry->mtime	= cpu_to_le32(inode->i_mtime.tv_sec);
inode.c:1262:		entry->size = cpu_to_le64(attr->ia_size);
inode.c:1264:		entry->size = cpu_to_le64(inode->i_size);
inode.c:1273:	unsigned int data_bits = blk_type_to_shift[pi->i_blk_type];
inode.c:1278:	if (entry->entry_type != SET_ATTR)
inode.c:1281:	pi->i_mode	= entry->mode;
inode.c:1282:	pi->i_uid	= entry->uid;
inode.c:1283:	pi->i_gid	= entry->gid;
inode.c:1284:	pi->i_atime	= entry->atime;
inode.c:1285:	pi->i_ctime	= entry->ctime;
inode.c:1286:	pi->i_mtime	= entry->mtime;
inode.c:1288:	if (pi->i_size > entry->size && S_ISREG(pi->i_mode)) {
inode.c:1289:		start = entry->size;
inode.c:1290:		end = pi->i_size;
inode.c:1292:		first_blocknr = (start + (1UL << data_bits) - 1) >> data_bits;
inode.c:1295:			last_blocknr = (end - 1) >> data_bits;
inode.c:1306:	pi->i_size	= entry->size;
inode.c:1307:	sih->i_size = le64_to_cpu(pi->i_size);
inode.c:1317:	struct nova_inode_info_header *sih = &si->header;
inode.c:1326:				__func__, inode->i_ino);
inode.c:1336:	sih->last_setattr = curr_p;
inode.c:1344:	struct inode *inode = dentry->d_inode;
inode.c:1345:	struct super_block *sb = inode->i_sb;
inode.c:1348:	struct nova_inode_info_header *sih = &si->header;
inode.c:1350:	unsigned int ia_valid = attr->ia_valid, attr_mask;
inode.c:1351:	loff_t oldsize = inode->i_size;
inode.c:1357:		return -EACCES;
inode.c:1367:		sih->i_mode = inode->i_mode;
inode.c:1383:	if ((ia_valid & ATTR_SIZE) && (attr->ia_size != oldsize ||
inode.c:1384:			pi->i_flags & cpu_to_le32(NOVA_EOFBLOCKS_FL))) {
inode.c:1385://		nova_set_blocksize_hint(sb, inode, pi, attr->ia_size);
inode.c:1388:		nova_setsize(inode, oldsize, attr->ia_size);
inode.c:1398:	inode->i_flags &=
inode.c:1401:		inode->i_flags |= S_SYNC;
inode.c:1403:		inode->i_flags |= S_APPEND;
inode.c:1405:		inode->i_flags |= S_IMMUTABLE;
inode.c:1407:		inode->i_flags |= S_NOATIME;
inode.c:1409:		inode->i_flags |= S_DIRSYNC;
inode.c:1410:	if (!pi->i_xattr)
inode.c:1412:	inode->i_flags |= S_DAX;
inode.c:1419:	struct file *filp = iocb->ki_filp;
inode.c:1422:	ssize_t ret = -EINVAL;
inode.c:1425:	unsigned long nr_segs = iter->nr_segs;
inode.c:1426:	const struct iovec *iv = iter->iov;
inode.c:1433:	iv = iter->iov;
inode.c:1436:			ret = nova_dax_file_read(filp, iv->iov_base,
inode.c:1437:					iv->iov_len, &offset);
inode.c:1439:			ret = nova_cow_file_write(filp, iv->iov_base,
inode.c:1440:					iv->iov_len, &offset, false);
inode.c:1445:		if (iter->count > iv->iov_len)
inode.c:1446:			iter->count -= iv->iov_len;
inode.c:1448:			iter->count = 0;
inode.c:1451:		iter->nr_segs--;
inode.c:1467:	struct file *filp = iocb->ki_filp;
inode.c:1468:	struct address_space *mapping = filp->f_mapping;
inode.c:1469:	struct inode *inode = mapping->host;
inode.c:1506:	for (i = 0; i < num_pages - 1; i++) {
inode.c:1540:	num_pages -= allocated;
inode.c:1542:			pi->nova_ino, allocated, new_inode_blocknr);
inode.c:1547:	prev_blocknr = new_inode_blocknr + allocated - 1;
inode.c:1563:		num_pages -= allocated;
inode.c:1566:		prev_blocknr = new_inode_blocknr + allocated - 1;
inode.c:1590:			if (sih->last_setattr == curr_p)
inode.c:1594:			if (setattr_entry->attr & ATTR_SIZE)
inode.c:1599:			if (sih->last_link_change == curr_p)
inode.c:1605:			if (entry->num_pages != entry->invalid_pages)
inode.c:1612:			if (dentry->ino && dentry->invalid == 0)
inode.c:1614:			*length = le16_to_cpu(dentry->de_len);
inode.c:1619:			*length = PAGE_SIZE - ENTRY_LOC(curr_p);;
inode.c:1625:			*length = PAGE_SIZE - ENTRY_LOC(curr_p);;
inode.c:1645:					sih->ino);
inode.c:1651:			sih->valid_bytes += length;
inode.c:1678:	unsigned short btype = pi->i_blk_type;
inode.c:1681:			curr_page->page_tail.next_page, 1);
inode.c:1693:	unsigned long start_pgoff = old_entry->pgoff;
inode.c:1694:	unsigned int num = old_entry->num_pages;
inode.c:1702:		pentry = radix_tree_lookup_slot(&sih->tree, curr_pgoff);
inode.c:1722:	hash = BKDRHash(old_dentry->name, old_dentry->name_len);
inode.c:1724:			old_dentry->name, hash);
inode.c:1727:	pentry = radix_tree_lookup_slot(&sih->tree, hash);
inode.c:1751:			sih->last_setattr = new_curr;
inode.c:1754:			sih->last_link_change = new_curr;
inode.c:1789:	u64 ino = pi->nova_ino;
inode.c:1803:	curr_p = pi->log_head;
inode.c:1805:	old_head = pi->log_head;
inode.c:1807:				curr_p, pi->log_tail);
inode.c:1808:	if (curr_p == 0 && pi->log_tail == 0)
inode.c:1811:	if (curr_p >> PAGE_SHIFT == pi->log_tail >> PAGE_SHIFT)
inode.c:1823:	while (curr_p != pi->log_tail) {
inode.c:1828:		if (curr_p >> PAGE_SHIFT == pi->log_tail >> PAGE_SHIFT) {
inode.c:1857:	tail_block = BLOCK_OFF(pi->log_tail);
inode.c:1860:	next = curr_page->page_tail.next_page;
inode.c:1868:	pi->log_head = new_head;
inode.c:1874:	next = curr_page->page_tail.next_page;
inode.c:1886:	sih->log_pages = sih->log_pages + blocks - checked_pages;
inode.c:1887:	NOVA_STATS_ADD(thorough_gc_pages, checked_pages - blocks);
inode.c:1913:	unsigned short btype = pi->i_blk_type;
inode.c:1920:	curr = pi->log_head;
inode.c:1921:	sih->valid_bytes = 0;
inode.c:1926:		if (curr >> PAGE_SHIFT == pi->log_tail >> PAGE_SHIFT) {
inode.c:1935:		next = curr_page->page_tail.next_page;
inode.c:1939:			if (curr == pi->log_head) {
inode.c:1966:	checked_pages -= freed_pages;
inode.c:1972:	curr = pi->log_head;
inode.c:1974:	pi->log_head = possible_head;
inode.c:1978:	sih->log_pages += num_pages - freed_pages;
inode.c:1979:	pi->i_blocks += num_pages - freed_pages;
inode.c:1981:	nova_flush_buffer(&pi->log_head, CACHELINE_SIZE, 1);
inode.c:1990:	blocks = sih->valid_bytes / LAST_ENTRY;
inode.c:1991:	if (sih->valid_bytes % LAST_ENTRY)
inode.c:1998:				"valid pages %lu\n", sih->ino,
inode.c:2021:		pi->log_tail = new_block;
inode.c:2022:		nova_flush_buffer(&pi->log_tail, CACHELINE_SIZE, 0);
inode.c:2023:		pi->log_head = new_block;
inode.c:2024:		sih->log_pages = 1;
inode.c:2025:		pi->i_blocks++;
inode.c:2026:		nova_flush_buffer(&pi->log_head, CACHELINE_SIZE, 1);
inode.c:2028:		num_pages = sih->log_pages >= EXTEND_THRESHOLD ?
inode.c:2029:				EXTEND_THRESHOLD : sih->log_pages;
inode.c:2041:					sih->log_pages);
inode.c:2093:		curr_p = pi->log_tail;
inode.c:2123: * We cannot update pi->log_tail here because a transaction may contain
inode.c:2130:	struct nova_inode_info_header *sih = &si->header;
inode.c:2147:			"block %llu, size %llu\n", inode->i_ino,
inode.c:2148:			curr_p, entry->pgoff, entry->num_pages,
inode.c:2149:			entry->block >> PAGE_SHIFT, entry->size);
inode.c:2150:	/* entry->invalid is set to 0 */
inode.c:2162:	if (pi->log_head == 0 || pi->log_tail == 0)
inode.c:2167:	curr_block = pi->log_head;
inode.c:2170:	pi->log_head = pi->log_tail = 0;
inode.c:2171:	nova_flush_buffer(&pi->log_head, CACHELINE_SIZE, 0);
inode.c:2184:	pi->i_ctime = cpu_to_le32(entry->mtime);
inode.c:2185:	pi->i_mtime = cpu_to_le32(entry->mtime);
inode.c:2186:	pi->i_size = cpu_to_le64(entry->size);
inode.c:2197:	unsigned int data_bits = blk_type_to_shift[pi->i_blk_type];
inode.c:2198:	u64 ino = pi->nova_ino;
inode.c:2208:	sih->pi_addr = pi_addr;
inode.c:2210:	curr_p = pi->log_head;
inode.c:2212:				curr_p, pi->log_tail);
inode.c:2213:	if (curr_p == 0 && pi->log_tail == 0)
inode.c:2216:	sih->log_pages = 1;
inode.c:2218:	while (curr_p != pi->log_tail) {
inode.c:2220:			sih->log_pages++;
inode.c:2237:				sih->last_setattr = curr_p;
inode.c:2245:				sih->last_link_change = curr_p;
inode.c:2259:		if (entry->num_pages != entry->invalid_pages) {
inode.c:2262:			 * Don't double free them, just re-assign the pointers.
inode.c:2268:		/* Update sih->i_size for setattr apply operations */
inode.c:2269:		sih->i_size = le64_to_cpu(pi->i_size);
inode.c:2273:	sih->i_size = le64_to_cpu(pi->i_size);
inode.c:2274:	sih->i_mode = le16_to_cpu(pi->i_mode);
inode.c:2280:	while ((next = curr_page->page_tail.next_page) != 0) {
inode.c:2281:		sih->log_pages++;
inode.c:2287:	pi->i_blocks = sih->log_pages + (sih->i_size >> data_bits);
inode.c:2299:	struct super_block *sb = inode->i_sb;
inode.c:2302:	struct nova_inode_info_header *sih = &si->header;
inode.c:2303:	unsigned int data_bits = blk_type_to_shift[pi->i_blk_type];
inode.c:2308:	if (*offset >= inode->i_size)
inode.c:2309:		return -ENXIO;
inode.c:2311:	if (!inode->i_blocks || !sih->i_size) {
inode.c:2313:			return inode->i_size;
inode.c:2315:			return -ENXIO;
inode.c:2318:	offset_in_block = *offset & ((1UL << data_bits) - 1);
inode.c:2321:	last_blocknr = inode->i_size >> data_bits;
inode.c:2327:	blocks = nova_lookup_hole_in_range(inode->i_sb, sih,
inode.c:2332:		return -ENXIO;
inode.c:2338:			*offset = inode->i_size;
inode.c:2347:			*offset = inode->i_size;
inode.c:2352:		blocks--;
inode.c:2354:			   ((1 << data_bits) - offset_in_block);
symlink.c:6: * Copyright 2015-2016 Regents of the University of California,
symlink.c:7: * UCSD Non-Volatile Systems Lab, Andiry Xu <jix024@cs.ucsd.edu>
symlink.c:8: * Copyright 2012-2013 Intel Corporation
symlink.c:9: * Copyright 2009-2011 Marco Stornelli <marco.stornelli@gmail.com>
symlink.c:12: * 2003-2004 (c) MontaVista Software, Inc. , Steve Longerbeam
symlink.c:32:	struct nova_inode_info_header *sih = &si->header;
symlink.c:50:	entry->pgoff = 0;
symlink.c:51:	entry->num_pages = cpu_to_le32(1);
symlink.c:52:	entry->invalid_pages = 0;
symlink.c:53:	entry->block = cpu_to_le64(nova_get_block_off(sb, name_blocknr,
symlink.c:56:	entry->mtime = cpu_to_le32(time);
symlink.c:59:	entry->size = cpu_to_le64(len + 1);
symlink.c:62:	sih->log_pages = 1;
symlink.c:63:	pi->log_head = block;
symlink.c:72:	struct inode *inode = dentry->d_inode;
symlink.c:73:	struct super_block *sb = inode->i_sb;
symlink.c:78:							pi->log_head);
symlink.c:79:	blockp = (char *)nova_get_block(sb, BLOCK_OFF(entry->block));
symlink.c:87:	struct super_block *sb = inode->i_sb;
symlink.c:92:							pi->log_head);
symlink.c:93:	blockp = (char *)nova_get_block(sb, BLOCK_OFF(entry->block));
symlink.c:101:	struct inode *inode = dentry->d_inode;
