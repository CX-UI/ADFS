
dafs_namei.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <dafs_symlink>:
    //nova_dbg("%s end",__func__);
	return retval;
}

static int dafs_symlink(struct inode *dir, struct dentry *dentry, const char *symname)
{
       0:	e8 00 00 00 00       	callq  5 <dafs_symlink+0x5>
       5:	55                   	push   %rbp
       6:	48 89 e5             	mov    %rsp,%rbp
    int allocated;
    u64 tail = 0;
    u64 ino;
    timing_t symlink_time;
  
    BUG();
       9:	0f 0b                	ud2    
       b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000000010 <dafs_create>:
	NOVA_END_TIMING(create_trans_t, trans_time);
    //nova_dbg("%s end", __func__);
}

static int dafs_create(struct inode *dir, struct dentry *dentry, umode_t mode, bool excl)
{
      10:	e8 00 00 00 00       	callq  15 <dafs_create+0x5>
      15:	55                   	push   %rbp
      16:	48 89 e5             	mov    %rsp,%rbp
      19:	41 57                	push   %r15
      1b:	41 56                	push   %r14
      1d:	41 55                	push   %r13
      1f:	41 54                	push   %r12
      21:	49 89 fc             	mov    %rdi,%r12
      24:	53                   	push   %rbx
      25:	49 89 f6             	mov    %rsi,%r14
      28:	41 89 d7             	mov    %edx,%r15d
      2b:	48 83 ec 48          	sub    $0x48,%rsp
    u64 tail = 0;
    u64 ino;
    timing_t create_time;

    //nova_dbg("%s:dafs start to create",__func__);
    NOVA_START_TIMING(create_t, create_time);
      2f:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # 35 <dafs_create+0x25>

static int dafs_create(struct inode *dir, struct dentry *dentry, umode_t mode, bool excl)
{
    struct inode *inode = NULL;
    int err = PTR_ERR(inode);
    struct super_block *sb = dir->i_sb;
      35:	4c 8b 6f 28          	mov    0x28(%rdi),%r13
	NOVA_END_TIMING(create_trans_t, trans_time);
    //nova_dbg("%s end", __func__);
}

static int dafs_create(struct inode *dir, struct dentry *dentry, umode_t mode, bool excl)
{
      39:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
      40:	00 00 
      42:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
      46:	31 c0                	xor    %eax,%eax
    struct inode *inode = NULL;
    int err = PTR_ERR(inode);
    struct super_block *sb = dir->i_sb;
    struct nova_inode *pidir, *pi;
    int file_type;
    u64 pi_addr = 0;
      48:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
      4f:	00 
    u64 tail = 0;
    u64 ino;
    timing_t create_time;

    //nova_dbg("%s:dafs start to create",__func__);
    NOVA_START_TIMING(create_t, create_time);
      50:	85 c9                	test   %ecx,%ecx
      52:	0f 85 3c 01 00 00    	jne    194 <dafs_create+0x184>
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
      58:	49 8b 44 24 c8       	mov    -0x38(%r12),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
      5d:	48 85 c0             	test   %rax,%rax
      60:	74 21                	je     83 <dafs_create+0x73>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
      62:	49 8b 95 b0 03 00 00 	mov    0x3b0(%r13),%rdx

    /*文件所在的目录的inode*/
    pidir = nova_get_inode(sb ,dir);
    if(!pidir)
      69:	48 03 42 18          	add    0x18(%rdx),%rax
      6d:	74 14                	je     83 <dafs_create+0x73>
        goto out_err;
    /*在used list上面分配节点号*/
    ino = nova_new_nova_inode(sb, &pi_addr);
      6f:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
      73:	4c 89 ef             	mov    %r13,%rdi
      76:	e8 00 00 00 00       	callq  7b <dafs_create+0x6b>
    if(ino == 0)
      7b:	48 85 c0             	test   %rax,%rax
    /*文件所在的目录的inode*/
    pidir = nova_get_inode(sb ,dir);
    if(!pidir)
        goto out_err;
    /*在used list上面分配节点号*/
    ino = nova_new_nova_inode(sb, &pi_addr);
      7e:	49 89 c2             	mov    %rax,%r10
    if(ino == 0)
      81:	75 54                	jne    d7 <dafs_create+0xc7>
}

static int dafs_create(struct inode *dir, struct dentry *dentry, umode_t mode, bool excl)
{
    struct inode *inode = NULL;
    int err = PTR_ERR(inode);
      83:	31 db                	xor    %ebx,%ebx
	//dafs_lite_transaction_for_new_inode(sb, pi, pidir, tail);
	NOVA_END_TIMING(create_t, create_time);
	return err;

out_err:
    nova_err(sb, "%s return %d\n", __func__, err);
      85:	89 d9                	mov    %ebx,%ecx
      87:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
      8e:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
      95:	4c 89 ef             	mov    %r13,%rdi
      98:	e8 00 00 00 00       	callq  9d <dafs_create+0x8d>
	NOVA_END_TIMING(create_t, create_time);
      9d:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # a3 <dafs_create+0x93>
      a3:	85 c0                	test   %eax,%eax
      a5:	0f 85 bc 00 00 00    	jne    167 <dafs_create+0x157>
      ab:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # b3 <dafs_create+0xa3>
      b2:	00 
    //nova_dbg("%s:dafs finish create",__func__);
	return err;

}
      b3:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
      b7:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
      be:	00 00 
      c0:	89 d8                	mov    %ebx,%eax
      c2:	0f 85 da 00 00 00    	jne    1a2 <dafs_create+0x192>
      c8:	48 83 c4 48          	add    $0x48,%rsp
      cc:	5b                   	pop    %rbx
      cd:	41 5c                	pop    %r12
      cf:	41 5d                	pop    %r13
      d1:	41 5e                	pop    %r14
      d3:	41 5f                	pop    %r15
      d5:	5d                   	pop    %rbp
      d6:	c3                   	retq   
    if(S_ISDIR(mode))
        file_type = 1;
    else 
        file_type = 0;

    err = dafs_add_dentry(dentry, ino, 0, file_type);
      d7:	44 89 f8             	mov    %r15d,%eax
      da:	31 c9                	xor    %ecx,%ecx
      dc:	4c 89 d6             	mov    %r10,%rsi
      df:	66 25 00 f0          	and    $0xf000,%ax
      e3:	4c 89 f7             	mov    %r14,%rdi
      e6:	4c 89 55 a0          	mov    %r10,-0x60(%rbp)
      ea:	66 3d 00 40          	cmp    $0x4000,%ax
      ee:	0f 94 c1             	sete   %cl
      f1:	31 d2                	xor    %edx,%edx
      f3:	e8 00 00 00 00       	callq  f8 <dafs_create+0xe8>
    
    if(err)
      f8:	85 c0                	test   %eax,%eax
    if(S_ISDIR(mode))
        file_type = 1;
    else 
        file_type = 0;

    err = dafs_add_dentry(dentry, ino, 0, file_type);
      fa:	89 c3                	mov    %eax,%ebx
    
    if(err)
      fc:	75 87                	jne    85 <dafs_create+0x75>
        goto out_err;
    
	nova_dbgv("%s: %s\n", __func__, dentry->d_name.name);
      fe:	f6 05 00 00 00 00 10 	testb  $0x10,0x0(%rip)        # 105 <dafs_create+0xf5>
     105:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
     109:	0f 85 98 00 00 00    	jne    1a7 <dafs_create+0x197>
	nova_dbgv("%s: inode %llu, dir %lu\n", __func__, ino, dir->i_ino);
	inode = nova_new_vfs_inode(TYPE_CREATE, dir, pi_addr, ino, mode,
					0, 0, &dentry->d_name);
     10f:	49 8d 46 20          	lea    0x20(%r14),%rax
    if(err)
        goto out_err;
    
	nova_dbgv("%s: %s\n", __func__, dentry->d_name.name);
	nova_dbgv("%s: inode %llu, dir %lu\n", __func__, ino, dir->i_ino);
	inode = nova_new_vfs_inode(TYPE_CREATE, dir, pi_addr, ino, mode,
     113:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
     117:	45 31 c9             	xor    %r9d,%r9d
     11a:	4c 89 e6             	mov    %r12,%rsi
     11d:	31 ff                	xor    %edi,%edi
     11f:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
					0, 0, &dentry->d_name);
     126:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    if(err)
        goto out_err;
    
	nova_dbgv("%s: %s\n", __func__, dentry->d_name.name);
	nova_dbgv("%s: inode %llu, dir %lu\n", __func__, ino, dir->i_ino);
	inode = nova_new_vfs_inode(TYPE_CREATE, dir, pi_addr, ino, mode,
     12b:	45 0f b7 c7          	movzwl %r15w,%r8d
     12f:	4c 89 d1             	mov    %r10,%rcx
     132:	e8 00 00 00 00       	callq  137 <dafs_create+0x127>
					0, 0, &dentry->d_name);

	if (IS_ERR(inode))
     137:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
    if(err)
        goto out_err;
    
	nova_dbgv("%s: %s\n", __func__, dentry->d_name.name);
	nova_dbgv("%s: inode %llu, dir %lu\n", __func__, ino, dir->i_ino);
	inode = nova_new_vfs_inode(TYPE_CREATE, dir, pi_addr, ino, mode,
     13d:	49 89 c4             	mov    %rax,%r12
					0, 0, &dentry->d_name);

	if (IS_ERR(inode))
     140:	0f 87 3d ff ff ff    	ja     83 <dafs_create+0x73>
		goto out_err;

	d_instantiate(dentry, inode);
     146:	48 89 c6             	mov    %rax,%rsi
     149:	4c 89 f7             	mov    %r14,%rdi
     14c:	e8 00 00 00 00       	callq  151 <dafs_create+0x141>
	unlock_new_inode(inode);
     151:	4c 89 e7             	mov    %r12,%rdi
     154:	e8 00 00 00 00       	callq  159 <dafs_create+0x149>

    pi = nova_get_block(sb ,pi_addr);
    
    /* record tail in journal entry*/
	//dafs_lite_transaction_for_new_inode(sb, pi, pidir, tail);
	NOVA_END_TIMING(create_t, create_time);
     159:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 15f <dafs_create+0x14f>
     15f:	85 d2                	test   %edx,%edx
     161:	0f 84 44 ff ff ff    	je     ab <dafs_create+0x9b>
	getnstimeofday64(ts);
}

static inline void getrawmonotonic(struct timespec *ts)
{
	getrawmonotonic64(ts);
     167:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
     16b:	e8 00 00 00 00       	callq  170 <dafs_create+0x160>
	return err;

out_err:
    nova_err(sb, "%s return %d\n", __func__, err);
	NOVA_END_TIMING(create_t, create_time);
     170:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
     174:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
     178:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
     17f:	48 2b 45 b8          	sub    -0x48(%rbp),%rax
     183:	48 03 45 c8          	add    -0x38(%rbp),%rax
     187:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 18f <dafs_create+0x17f>
     18e:	00 
     18f:	e9 17 ff ff ff       	jmpq   ab <dafs_create+0x9b>
     194:	48 8d 7d b0          	lea    -0x50(%rbp),%rdi
     198:	e8 00 00 00 00       	callq  19d <dafs_create+0x18d>
     19d:	e9 b6 fe ff ff       	jmpq   58 <dafs_create+0x48>
    //nova_dbg("%s:dafs finish create",__func__);
	return err;

}
     1a2:	e8 00 00 00 00       	callq  1a7 <dafs_create+0x197>
    err = dafs_add_dentry(dentry, ino, 0, file_type);
    
    if(err)
        goto out_err;
    
	nova_dbgv("%s: %s\n", __func__, dentry->d_name.name);
     1a7:	49 8b 56 28          	mov    0x28(%r14),%rdx
     1ab:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     1b2:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     1b9:	e8 00 00 00 00       	callq  1be <dafs_create+0x1ae>
	nova_dbgv("%s: inode %llu, dir %lu\n", __func__, ino, dir->i_ino);
     1be:	f6 05 00 00 00 00 10 	testb  $0x10,0x0(%rip)        # 1c5 <dafs_create+0x1b5>
     1c5:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
     1c9:	0f 84 40 ff ff ff    	je     10f <dafs_create+0xff>
     1cf:	49 8b 4c 24 40       	mov    0x40(%r12),%rcx
     1d4:	4c 89 d2             	mov    %r10,%rdx
     1d7:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     1de:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     1e5:	e8 00 00 00 00       	callq  1ea <dafs_create+0x1da>
     1ea:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
     1ee:	e9 1c ff ff ff       	jmpq   10f <dafs_create+0xff>
     1f3:	0f 1f 00             	nopl   (%rax)
     1f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     1fd:	00 00 00 

0000000000000200 <dafs_lookup>:
    return ino;
}

static struct dentry *dafs_lookup(struct inode *dir, struct dentry *dentry,\
        unsigned int flags)
{
     200:	e8 00 00 00 00       	callq  205 <dafs_lookup+0x5>
     205:	55                   	push   %rbp
     206:	48 89 e5             	mov    %rsp,%rbp
     209:	41 56                	push   %r14
     20b:	41 55                	push   %r13
     20d:	41 54                	push   %r12
     20f:	53                   	push   %rbx
     210:	49 89 fc             	mov    %rdi,%r12
     213:	48 89 f3             	mov    %rsi,%rbx
     216:	48 83 ec 28          	sub    $0x28,%rsp
    struct dafs_dentry *de;
    ino_t ino;
    timing_t lookup_time;
    
    //nova_dbg("%s:dafs start lookup %s ",__func__, dentry->d_name.name);
	NOVA_START_TIMING(lookup_t, lookup_time);
     21a:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 220 <dafs_lookup+0x20>
    return ino;
}

static struct dentry *dafs_lookup(struct inode *dir, struct dentry *dentry,\
        unsigned int flags)
{
     220:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     227:	00 00 
     229:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
     22d:	31 c0                	xor    %eax,%eax
    struct dafs_dentry *de;
    ino_t ino;
    timing_t lookup_time;
    
    //nova_dbg("%s:dafs start lookup %s ",__func__, dentry->d_name.name);
	NOVA_START_TIMING(lookup_t, lookup_time);
     22f:	85 d2                	test   %edx,%edx
     231:	75 78                	jne    2ab <dafs_lookup+0xab>
	if (dentry->d_name.len > NOVA_NAME_LEN) {
     233:	81 7b 24 ff 00 00 00 	cmpl   $0xff,0x24(%rbx)
		/*nova_dbg("%s: namelen %u exceeds limit\n",
			__func__, dentry->d_name.len);*/
		return ERR_PTR(-ENAMETOOLONG);
     23a:	48 c7 c0 dc ff ff ff 	mov    $0xffffffffffffffdc,%rax
    ino_t ino;
    timing_t lookup_time;
    
    //nova_dbg("%s:dafs start lookup %s ",__func__, dentry->d_name.name);
	NOVA_START_TIMING(lookup_t, lookup_time);
	if (dentry->d_name.len > NOVA_NAME_LEN) {
     241:	76 20                	jbe    263 <dafs_lookup+0x63>
        nova_dbg("%s:dafs finish lookup inode exist %llu",__func__, inode->i_ino);
    else
        nova_dbg("%s:dafs finish lookup %llu",__func__, ino);
	*/
    return d_splice_alias(inode, dentry);
}
     243:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
     247:	65 48 33 14 25 28 00 	xor    %gs:0x28,%rdx
     24e:	00 00 
     250:	0f 85 df 00 00 00    	jne    335 <dafs_lookup+0x135>
     256:	48 83 c4 28          	add    $0x28,%rsp
     25a:	5b                   	pop    %rbx
     25b:	41 5c                	pop    %r12
     25d:	41 5d                	pop    %r13
     25f:	41 5e                	pop    %r14
     261:	5d                   	pop    %rbp
     262:	c3                   	retq   
    struct super_block *sb = dir->i_sb;
    struct dafs_dentry *direntry;
    u64 ino;
   
    //nova_dbg("%s: start-- dentry is %s ",__func__, dentry->d_name.name);
    direntry = dafs_find_direntry(sb, dentry,1,0);
     263:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
     268:	31 c9                	xor    %ecx,%ecx
     26a:	ba 01 00 00 00       	mov    $0x1,%edx
     26f:	48 89 de             	mov    %rbx,%rsi
     272:	e8 00 00 00 00       	callq  277 <dafs_lookup+0x77>
    if(direntry == NULL) { 
     277:	48 85 c0             	test   %rax,%rax
     27a:	0f 84 ad 00 00 00    	je     32d <dafs_lookup+0x12d>
        return 0;
    }
    
    *res_entry = direntry;
    ino = le64_to_cpu(direntry->ino);
     280:	4c 8b 70 18          	mov    0x18(%rax),%r14
}

static struct dentry *dafs_lookup(struct inode *dir, struct dentry *dentry,\
        unsigned int flags)
{
    struct inode *inode = NULL;
     284:	45 31 ed             	xor    %r13d,%r13d
	}

	//nova_dbg("%s: %s\n", __func__, dentry->d_name.name);
    ino = dafs_inode_by_name(dir, dentry, &de);
	//nova_dbg("%s: look up get ino %llu", __func__, ino);
	if (ino) {
     287:	4d 85 f6             	test   %r14,%r14
     28a:	75 2d                	jne    2b9 <dafs_lookup+0xb9>
				  __func__, (unsigned long)ino);
			return ERR_PTR(-EIO);
		}
	}

	NOVA_END_TIMING(lookup_t, lookup_time);
     28c:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 292 <dafs_lookup+0x92>
     292:	85 c0                	test   %eax,%eax
     294:	75 6a                	jne    300 <dafs_lookup+0x100>
    /*if(inode)
        nova_dbg("%s:dafs finish lookup inode exist %llu",__func__, inode->i_ino);
    else
        nova_dbg("%s:dafs finish lookup %llu",__func__, ino);
	*/
    return d_splice_alias(inode, dentry);
     296:	48 89 de             	mov    %rbx,%rsi
     299:	4c 89 ef             	mov    %r13,%rdi
				  __func__, (unsigned long)ino);
			return ERR_PTR(-EIO);
		}
	}

	NOVA_END_TIMING(lookup_t, lookup_time);
     29c:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 2a4 <dafs_lookup+0xa4>
     2a3:	00 
    /*if(inode)
        nova_dbg("%s:dafs finish lookup inode exist %llu",__func__, inode->i_ino);
    else
        nova_dbg("%s:dafs finish lookup %llu",__func__, ino);
	*/
    return d_splice_alias(inode, dentry);
     2a4:	e8 00 00 00 00       	callq  2a9 <dafs_lookup+0xa9>
     2a9:	eb 98                	jmp    243 <dafs_lookup+0x43>
     2ab:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
     2af:	e8 00 00 00 00       	callq  2b4 <dafs_lookup+0xb4>
     2b4:	e9 7a ff ff ff       	jmpq   233 <dafs_lookup+0x33>
	//nova_dbg("%s: %s\n", __func__, dentry->d_name.name);
    ino = dafs_inode_by_name(dir, dentry, &de);
	//nova_dbg("%s: look up get ino %llu", __func__, ino);
	if (ino) {
        //根据ino得到整个inode的数据结构
		inode = nova_iget(dir->i_sb, ino);
     2b9:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
     2be:	4c 89 f6             	mov    %r14,%rsi
     2c1:	e8 00 00 00 00       	callq  2c6 <dafs_lookup+0xc6>
     2c6:	49 89 c5             	mov    %rax,%r13
		if (inode == ERR_PTR(-ESTALE) || inode == ERR_PTR(-ENOMEM)
				|| inode == ERR_PTR(-EACCES)) {
     2c9:	48 8d 40 0d          	lea    0xd(%rax),%rax
     2cd:	48 83 f8 01          	cmp    $0x1,%rax
     2d1:	76 06                	jbe    2d9 <dafs_lookup+0xd9>
     2d3:	49 83 fd 8c          	cmp    $0xffffffffffffff8c,%r13
     2d7:	75 b3                	jne    28c <dafs_lookup+0x8c>
			nova_err(dir->i_sb,
     2d9:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
     2de:	4c 89 f1             	mov    %r14,%rcx
     2e1:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
     2e8:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     2ef:	e8 00 00 00 00       	callq  2f4 <dafs_lookup+0xf4>
				  "%s: get inode failed: %lu\n",
				  __func__, (unsigned long)ino);
			return ERR_PTR(-EIO);
     2f4:	48 c7 c0 fb ff ff ff 	mov    $0xfffffffffffffffb,%rax
     2fb:	e9 43 ff ff ff       	jmpq   243 <dafs_lookup+0x43>
     300:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
     304:	e8 00 00 00 00       	callq  309 <dafs_lookup+0x109>
		}
	}

	NOVA_END_TIMING(lookup_t, lookup_time);
     309:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
     30d:	48 2b 45 b8          	sub    -0x48(%rbp),%rax
     311:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
     318:	48 2b 45 c0          	sub    -0x40(%rbp),%rax
     31c:	48 03 45 d0          	add    -0x30(%rbp),%rax
     320:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 328 <dafs_lookup+0x128>
     327:	00 
     328:	e9 69 ff ff ff       	jmpq   296 <dafs_lookup+0x96>
}

static struct dentry *dafs_lookup(struct inode *dir, struct dentry *dentry,\
        unsigned int flags)
{
    struct inode *inode = NULL;
     32d:	45 31 ed             	xor    %r13d,%r13d
     330:	e9 57 ff ff ff       	jmpq   28c <dafs_lookup+0x8c>
        nova_dbg("%s:dafs finish lookup inode exist %llu",__func__, inode->i_ino);
    else
        nova_dbg("%s:dafs finish lookup %llu",__func__, ino);
	*/
    return d_splice_alias(inode, dentry);
}
     335:	e8 00 00 00 00       	callq  33a <dafs_lookup+0x13a>
     33a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000000340 <dafs_lite_transaction_for_new_inode.constprop.5>:
#include <linux/fs.h>
#include <linux/pagemap.h>
#include "nova.h"
//#include "zone.h"

static void dafs_lite_transaction_for_new_inode(struct super_block *sb,
     340:	e8 00 00 00 00       	callq  345 <dafs_lite_transaction_for_new_inode.constprop.5+0x5>
     345:	55                   	push   %rbp
     346:	49 89 f2             	mov    %rsi,%r10
     349:	49 89 d3             	mov    %rdx,%r11
     34c:	48 89 e5             	mov    %rsp,%rbp
     34f:	41 57                	push   %r15
     351:	41 56                	push   %r14
     353:	41 55                	push   %r13
     355:	41 54                	push   %r12
     357:	49 89 fe             	mov    %rdi,%r14
     35a:	53                   	push   %rbx
     35b:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
	int cpu;
	u64 journal_tail;
	timing_t trans_time;

    //nova_dbg("%s: start",__func__);
	NOVA_START_TIMING(create_trans_t, trans_time);
     362:	44 8b 05 00 00 00 00 	mov    0x0(%rip),%r8d        # 369 <dafs_lite_transaction_for_new_inode.constprop.5+0x29>
     369:	4c 8b bf b0 03 00 00 	mov    0x3b0(%rdi),%r15
#include <linux/fs.h>
#include <linux/pagemap.h>
#include "nova.h"
//#include "zone.h"

static void dafs_lite_transaction_for_new_inode(struct super_block *sb,
     370:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     377:	00 00 
     379:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     37d:	31 c0                	xor    %eax,%eax
	int cpu;
	u64 journal_tail;
	timing_t trans_time;

    //nova_dbg("%s: start",__func__);
	NOVA_START_TIMING(create_trans_t, trans_time);
     37f:	45 85 c0             	test   %r8d,%r8d
     382:	0f 85 08 02 00 00    	jne    590 <dafs_lite_transaction_for_new_inode.constprop.5+0x250>

	/* Commit a lite transaction */
	memset(&entry, 0, sizeof(struct nova_lite_journal_entry));
     388:	4c 8d 4d 90          	lea    -0x70(%rbp),%r9
     38c:	31 c0                	xor    %eax,%eax
     38e:	b9 08 00 00 00       	mov    $0x8,%ecx
	entry.addrs[0] = (u64)nova_get_addr_off(sbi, &pidir->log_tail);
     393:	4d 8d 63 50          	lea    0x50(%r11),%r12

    //nova_dbg("%s: start",__func__);
	NOVA_START_TIMING(create_trans_t, trans_time);

	/* Commit a lite transaction */
	memset(&entry, 0, sizeof(struct nova_lite_journal_entry));
     397:	4c 89 cf             	mov    %r9,%rdi
     39a:	f3 48 ab             	rep stos %rax,%es:(%rdi)
}

static inline u64
nova_get_addr_off(struct nova_sb_info *sbi, void *addr)
{
	NOVA_ASSERT((addr >= sbi->virt_addr) &&
     39d:	49 8b 47 18          	mov    0x18(%r15),%rax
     3a1:	49 39 c4             	cmp    %rax,%r12
     3a4:	0f 82 65 02 00 00    	jb     60f <dafs_lite_transaction_for_new_inode.constprop.5+0x2cf>
     3aa:	48 89 c2             	mov    %rax,%rdx
     3ad:	49 03 57 48          	add    0x48(%r15),%rdx
     3b1:	49 39 d4             	cmp    %rdx,%r12
     3b4:	0f 83 55 02 00 00    	jae    60f <dafs_lite_transaction_for_new_inode.constprop.5+0x2cf>
	entry.addrs[0] = (u64)nova_get_addr_off(sbi, &pidir->log_tail);
	entry.addrs[0] |= (u64)8 << 56;
     3ba:	4c 89 e2             	mov    %r12,%rdx
	entry.values[0] = pidir->log_tail;

	entry.addrs[1] = (u64)nova_get_addr_off(sbi, &pi->valid);
     3bd:	49 8d 5a 02          	lea    0x2(%r10),%rbx
	NOVA_START_TIMING(create_trans_t, trans_time);

	/* Commit a lite transaction */
	memset(&entry, 0, sizeof(struct nova_lite_journal_entry));
	entry.addrs[0] = (u64)nova_get_addr_off(sbi, &pidir->log_tail);
	entry.addrs[0] |= (u64)8 << 56;
     3c1:	48 29 c2             	sub    %rax,%rdx
     3c4:	48 b8 00 00 00 00 00 	movabs $0x800000000000000,%rax
     3cb:	00 00 08 
     3ce:	48 09 d0             	or     %rdx,%rax
     3d1:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	entry.values[0] = pidir->log_tail;
     3d5:	49 8b 43 50          	mov    0x50(%r11),%rax
     3d9:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
     3dd:	49 8b 47 18          	mov    0x18(%r15),%rax
     3e1:	48 39 c3             	cmp    %rax,%rbx
     3e4:	0f 82 d3 01 00 00    	jb     5bd <dafs_lite_transaction_for_new_inode.constprop.5+0x27d>
     3ea:	48 89 c2             	mov    %rax,%rdx
     3ed:	49 03 57 48          	add    0x48(%r15),%rdx
     3f1:	48 39 d3             	cmp    %rdx,%rbx
     3f4:	0f 83 c3 01 00 00    	jae    5bd <dafs_lite_transaction_for_new_inode.constprop.5+0x27d>

	entry.addrs[1] = (u64)nova_get_addr_off(sbi, &pi->valid);
	entry.addrs[1] |= (u64)1 << 56;
     3fa:	48 89 da             	mov    %rbx,%rdx
     3fd:	4c 89 9d 58 ff ff ff 	mov    %r11,-0xa8(%rbp)
	entry.values[1] = pi->valid;
     404:	4c 89 95 60 ff ff ff 	mov    %r10,-0xa0(%rbp)
	entry.addrs[0] = (u64)nova_get_addr_off(sbi, &pidir->log_tail);
	entry.addrs[0] |= (u64)8 << 56;
	entry.values[0] = pidir->log_tail;

	entry.addrs[1] = (u64)nova_get_addr_off(sbi, &pi->valid);
	entry.addrs[1] |= (u64)1 << 56;
     40b:	48 29 c2             	sub    %rax,%rdx
     40e:	48 b8 00 00 00 00 00 	movabs $0x100000000000000,%rax
     415:	00 00 01 
     418:	4c 89 8d 50 ff ff ff 	mov    %r9,-0xb0(%rbp)
     41f:	48 09 d0             	or     %rdx,%rax
     422:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	entry.values[1] = pi->valid;
     426:	41 0f b6 42 02       	movzbl 0x2(%r10),%eax
     42b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

	cpu = smp_processor_id();
     42f:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 436 <dafs_lite_transaction_for_new_inode.constprop.5+0xf6>
	spin_lock(&sbi->journal_locks[cpu]);
     436:	4c 63 e8             	movslq %eax,%r13
     439:	89 85 68 ff ff ff    	mov    %eax,-0x98(%rbp)
     43f:	49 c1 e5 02          	shl    $0x2,%r13
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static __always_inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
     443:	4c 89 ef             	mov    %r13,%rdi
     446:	49 03 bf b8 00 00 00 	add    0xb8(%r15),%rdi
     44d:	e8 00 00 00 00       	callq  452 <dafs_lite_transaction_for_new_inode.constprop.5+0x112>
	journal_tail = nova_create_lite_transaction(sb, &entry, NULL, 1, cpu);
     452:	4c 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%r9
     459:	44 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%r8d
     460:	b9 01 00 00 00       	mov    $0x1,%ecx
     465:	31 d2                	xor    %edx,%edx
     467:	4c 89 f7             	mov    %r14,%rdi
     46a:	4c 89 ce             	mov    %r9,%rsi
     46d:	e8 00 00 00 00       	callq  472 <dafs_lite_transaction_for_new_inode.constprop.5+0x132>

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
     472:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # 478 <dafs_lite_transaction_for_new_inode.constprop.5+0x138>

	pidir->log_tail = pidir_tail;
     478:	4c 8b 9d 58 ff ff ff 	mov    -0xa8(%rbp),%r11
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
     47f:	44 89 e6             	mov    %r12d,%esi
     482:	83 e6 3f             	and    $0x3f,%esi
	if (support_clwb) {
     485:	31 c9                	xor    %ecx,%ecx
     487:	4c 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%r10
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
     48e:	83 c6 40             	add    $0x40,%esi
	if (support_clwb) {
     491:	85 ff                	test   %edi,%edi
     493:	49 c7 43 50 00 00 00 	movq   $0x0,0x50(%r11)
     49a:	00 
     49b:	0f 84 c7 00 00 00    	je     568 <dafs_lite_transaction_for_new_inode.constprop.5+0x228>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
     4a1:	89 ca                	mov    %ecx,%edx
     4a3:	4c 01 e2             	add    %r12,%rdx
     4a6:	66 0f ae 32          	clwb   (%rdx)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     4aa:	83 c1 40             	add    $0x40,%ecx
     4ad:	39 ce                	cmp    %ecx,%esi
     4af:	77 f0                	ja     4a1 <dafs_lite_transaction_for_new_inode.constprop.5+0x161>
	nova_flush_buffer(&pidir->log_tail, CACHELINE_SIZE, 0);
	pi->valid = 1;
     4b1:	41 c6 42 02 01       	movb   $0x1,0x2(%r10)

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
     4b6:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 4bc <dafs_lite_transaction_for_new_inode.constprop.5+0x17c>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
     4bc:	89 de                	mov    %ebx,%esi
     4be:	83 e6 3f             	and    $0x3f,%esi
	if (support_clwb) {
     4c1:	31 c9                	xor    %ecx,%ecx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
     4c3:	83 c6 40             	add    $0x40,%esi
	if (support_clwb) {
     4c6:	85 d2                	test   %edx,%edx
     4c8:	0f 84 ae 00 00 00    	je     57c <dafs_lite_transaction_for_new_inode.constprop.5+0x23c>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
     4ce:	89 ca                	mov    %ecx,%edx
     4d0:	48 01 da             	add    %rbx,%rdx
     4d3:	66 0f ae 32          	clwb   (%rdx)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     4d7:	83 c1 40             	add    $0x40,%ecx
     4da:	39 ce                	cmp    %ecx,%esi
     4dc:	77 f0                	ja     4ce <dafs_lite_transaction_for_new_inode.constprop.5+0x18e>
	/* TODO: Fix me. */
}

static inline void PERSISTENT_BARRIER(void)
{
	asm volatile ("sfence\n" : : );
     4de:	0f ae f8             	sfence 
	nova_flush_buffer(&pi->valid, CACHELINE_SIZE, 0);
	PERSISTENT_BARRIER();

	nova_commit_lite_transaction(sb, journal_tail, cpu);
     4e1:	8b 95 68 ff ff ff    	mov    -0x98(%rbp),%edx
     4e7:	4c 89 f7             	mov    %r14,%rdi
     4ea:	48 89 c6             	mov    %rax,%rsi
     4ed:	e8 00 00 00 00       	callq  4f2 <dafs_lite_transaction_for_new_inode.constprop.5+0x1b2>
	return arch_spin_trylock(&(lock)->raw_lock);
}

static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
{
	arch_spin_unlock(&lock->raw_lock);
     4f2:	4c 89 ef             	mov    %r13,%rdi
     4f5:	49 03 bf b8 00 00 00 	add    0xb8(%r15),%rdi
	PVOP_VCALL2(pv_lock_ops.queued_spin_lock_slowpath, lock, val);
}

static __always_inline void pv_queued_spin_unlock(struct qspinlock *lock)
{
	PVOP_VCALLEE1(pv_lock_ops.queued_spin_unlock, lock);
     4fc:	ff 14 25 00 00 00 00 	callq  *0x0
	spin_unlock(&sbi->journal_locks[cpu]);
	NOVA_END_TIMING(create_trans_t, trans_time);
     503:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 509 <dafs_lite_transaction_for_new_inode.constprop.5+0x1c9>
     509:	85 c0                	test   %eax,%eax
     50b:	74 2e                	je     53b <dafs_lite_transaction_for_new_inode.constprop.5+0x1fb>
     50d:	48 8d 7d 80          	lea    -0x80(%rbp),%rdi
     511:	e8 00 00 00 00       	callq  516 <dafs_lite_transaction_for_new_inode.constprop.5+0x1d6>
     516:	48 8b 45 80          	mov    -0x80(%rbp),%rax
     51a:	48 2b 85 70 ff ff ff 	sub    -0x90(%rbp),%rax
     521:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
     528:	48 2b 85 78 ff ff ff 	sub    -0x88(%rbp),%rax
     52f:	48 03 45 88          	add    -0x78(%rbp),%rax
     533:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 53b <dafs_lite_transaction_for_new_inode.constprop.5+0x1fb>
     53a:	00 
     53b:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 543 <dafs_lite_transaction_for_new_inode.constprop.5+0x203>
     542:	00 
    //nova_dbg("%s end", __func__);
}
     543:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
     547:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
     54e:	00 00 
     550:	0f 85 0b 01 00 00    	jne    661 <dafs_lite_transaction_for_new_inode.constprop.5+0x321>
     556:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
     55d:	5b                   	pop    %rbx
     55e:	41 5c                	pop    %r12
     560:	41 5d                	pop    %r13
     562:	41 5e                	pop    %r14
     564:	41 5f                	pop    %r15
     566:	5d                   	pop    %rbp
     567:	c3                   	retq   
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
     568:	89 ca                	mov    %ecx,%edx
     56a:	4c 01 e2             	add    %r12,%rdx
     56d:	0f ae 3a             	clflush (%rdx)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     570:	83 c1 40             	add    $0x40,%ecx
     573:	39 ce                	cmp    %ecx,%esi
     575:	77 f1                	ja     568 <dafs_lite_transaction_for_new_inode.constprop.5+0x228>
     577:	e9 35 ff ff ff       	jmpq   4b1 <dafs_lite_transaction_for_new_inode.constprop.5+0x171>
			_mm_clflush(buf + i);
     57c:	89 ca                	mov    %ecx,%edx
     57e:	48 01 da             	add    %rbx,%rdx
     581:	0f ae 3a             	clflush (%rdx)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     584:	83 c1 40             	add    $0x40,%ecx
     587:	39 ce                	cmp    %ecx,%esi
     589:	77 f1                	ja     57c <dafs_lite_transaction_for_new_inode.constprop.5+0x23c>
     58b:	e9 4e ff ff ff       	jmpq   4de <dafs_lite_transaction_for_new_inode.constprop.5+0x19e>
     590:	48 8d bd 70 ff ff ff 	lea    -0x90(%rbp),%rdi
     597:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
     59e:	48 89 b5 68 ff ff ff 	mov    %rsi,-0x98(%rbp)
     5a5:	e8 00 00 00 00       	callq  5aa <dafs_lite_transaction_for_new_inode.constprop.5+0x26a>
     5aa:	4c 8b 9d 60 ff ff ff 	mov    -0xa0(%rbp),%r11
     5b1:	4c 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%r10
     5b8:	e9 cb fd ff ff       	jmpq   388 <dafs_lite_transaction_for_new_inode.constprop.5+0x48>
     5bd:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
     5c4:	ba 1a 02 00 00       	mov    $0x21a,%edx
     5c9:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     5d0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     5d7:	4c 89 8d 58 ff ff ff 	mov    %r9,-0xa8(%rbp)
     5de:	4c 89 9d 60 ff ff ff 	mov    %r11,-0xa0(%rbp)
     5e5:	4c 89 95 68 ff ff ff 	mov    %r10,-0x98(%rbp)
     5ec:	e8 00 00 00 00       	callq  5f1 <dafs_lite_transaction_for_new_inode.constprop.5+0x2b1>
     5f1:	49 8b 47 18          	mov    0x18(%r15),%rax
     5f5:	4c 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%r9
     5fc:	4c 8b 9d 60 ff ff ff 	mov    -0xa0(%rbp),%r11
     603:	4c 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%r10
     60a:	e9 eb fd ff ff       	jmpq   3fa <dafs_lite_transaction_for_new_inode.constprop.5+0xba>
     60f:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
     616:	ba 1a 02 00 00       	mov    $0x21a,%edx
     61b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     622:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     629:	4c 89 8d 58 ff ff ff 	mov    %r9,-0xa8(%rbp)
     630:	4c 89 9d 60 ff ff ff 	mov    %r11,-0xa0(%rbp)
     637:	4c 89 95 68 ff ff ff 	mov    %r10,-0x98(%rbp)
     63e:	e8 00 00 00 00       	callq  643 <dafs_lite_transaction_for_new_inode.constprop.5+0x303>
     643:	49 8b 47 18          	mov    0x18(%r15),%rax
     647:	4c 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%r9
     64e:	4c 8b 9d 60 ff ff ff 	mov    -0xa0(%rbp),%r11
     655:	4c 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%r10
     65c:	e9 59 fd ff ff       	jmpq   3ba <dafs_lite_transaction_for_new_inode.constprop.5+0x7a>
     661:	e8 00 00 00 00       	callq  666 <dafs_lite_transaction_for_new_inode.constprop.5+0x326>
     666:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     66d:	00 00 00 

0000000000000670 <dafs_mkdir>:
	nova_err(sb, "%s return %d\n", __func__, err);
	goto out;
}

static int dafs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
{
     670:	e8 00 00 00 00       	callq  675 <dafs_mkdir+0x5>
     675:	55                   	push   %rbp
     676:	48 89 e5             	mov    %rsp,%rbp
     679:	41 57                	push   %r15
     67b:	41 56                	push   %r14
     67d:	41 55                	push   %r13
     67f:	41 54                	push   %r12
     681:	41 89 d7             	mov    %edx,%r15d
     684:	53                   	push   %rbx
     685:	49 89 fc             	mov    %rdi,%r12
     688:	49 89 f6             	mov    %rsi,%r14
     68b:	48 83 ec 50          	sub    $0x50,%rsp
    u64 ino;
    int err = -EMLINK;
    timing_t mkdir_time;
   
    //nova_dbg("%s:dafs start to mkdir",__func__);
    NOVA_START_TIMING(mkdir_t, mkdir_time);
     68f:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 695 <dafs_mkdir+0x25>
	goto out;
}

static int dafs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
{
    struct super_block *sb = dir->i_sb;
     695:	4c 8b 6f 28          	mov    0x28(%rdi),%r13
	nova_err(sb, "%s return %d\n", __func__, err);
	goto out;
}

static int dafs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
{
     699:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     6a0:	00 00 
     6a2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     6a6:	31 c0                	xor    %eax,%eax
    struct super_block *sb = dir->i_sb;
    struct inode *inode;
    struct nova_inode *pidir, *pi;
    struct nova_inode_info *si;
    struct nova_inode_info_header *sih = NULL;
    u64 pi_addr = 0;
     6a8:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
     6af:	00 
    u64 ino;
    int err = -EMLINK;
    timing_t mkdir_time;
   
    //nova_dbg("%s:dafs start to mkdir",__func__);
    NOVA_START_TIMING(mkdir_t, mkdir_time);
     6b0:	85 d2                	test   %edx,%edx
     6b2:	0f 85 cb 00 00 00    	jne    783 <dafs_mkdir+0x113>
    if(dir->i_nlink >= NOVA_LINK_MAX)
     6b8:	81 7f 48 ff 7c 00 00 	cmpl   $0x7cff,0x48(%rdi)
    struct nova_inode_info *si;
    struct nova_inode_info_header *sih = NULL;
    u64 pi_addr = 0;
    u64 tail = 0;
    u64 ino;
    int err = -EMLINK;
     6bf:	bb e1 ff ff ff       	mov    $0xffffffe1,%ebx
    timing_t mkdir_time;
   
    //nova_dbg("%s:dafs start to mkdir",__func__);
    NOVA_START_TIMING(mkdir_t, mkdir_time);
    if(dir->i_nlink >= NOVA_LINK_MAX)
     6c4:	0f 87 86 00 00 00    	ja     750 <dafs_mkdir+0xe0>
        goto out;
    
    ino = nova_new_nova_inode(sb, &pi_addr);
     6ca:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
     6ce:	4c 89 ef             	mov    %r13,%rdi
     6d1:	e8 00 00 00 00       	callq  6d6 <dafs_mkdir+0x66>
	if (ino == 0)
     6d6:	48 85 c0             	test   %rax,%rax
     6d9:	0f 84 9d 00 00 00    	je     77c <dafs_mkdir+0x10c>
		goto out_err;

	//nova_dbg("%s: name %s\n", __func__, dentry->d_name.name);

    /*.文件指向目录项*/
    err = dafs_add_dentry(dentry, ino, 1, 1);
     6df:	b9 01 00 00 00       	mov    $0x1,%ecx
     6e4:	ba 01 00 00 00       	mov    $0x1,%edx
     6e9:	48 89 c6             	mov    %rax,%rsi
     6ec:	4c 89 f7             	mov    %r14,%rdi
     6ef:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
     6f3:	e8 00 00 00 00       	callq  6f8 <dafs_mkdir+0x88>
	if (err) {
     6f8:	85 c0                	test   %eax,%eax
		goto out_err;

	//nova_dbg("%s: name %s\n", __func__, dentry->d_name.name);

    /*.文件指向目录项*/
    err = dafs_add_dentry(dentry, ino, 1, 1);
     6fa:	89 c3                	mov    %eax,%ebx
	if (err) {
     6fc:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
     700:	0f 84 9f 00 00 00    	je     7a5 <dafs_mkdir+0x135>
    //nova_dbg("%s: dafs end mkdir",__func__);
	return err;

out_err:
//	clear_nlink(inode);
	nova_err(sb, "%s return %d\n", __func__, err);
     706:	89 d9                	mov    %ebx,%ecx
     708:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
     70f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     716:	4c 89 ef             	mov    %r13,%rdi
     719:	e8 00 00 00 00       	callq  71e <dafs_mkdir+0xae>
	d_instantiate(dentry, inode);
	unlock_new_inode(inode);
    //nova_dbg("test bug");
	dafs_lite_transaction_for_new_inode(sb, pi, pidir, tail);
out:
	NOVA_END_TIMING(mkdir_t, mkdir_time);
     71e:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 724 <dafs_mkdir+0xb4>
     724:	85 c0                	test   %eax,%eax
     726:	74 28                	je     750 <dafs_mkdir+0xe0>
     728:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
     72c:	e8 00 00 00 00       	callq  731 <dafs_mkdir+0xc1>
     731:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
     735:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
     739:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
     740:	48 2b 45 b8          	sub    -0x48(%rbp),%rax
     744:	48 03 45 c8          	add    -0x38(%rbp),%rax
     748:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 750 <dafs_mkdir+0xe0>
     74f:	00 
     750:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 758 <dafs_mkdir+0xe8>
     757:	00 

out_err:
//	clear_nlink(inode);
	nova_err(sb, "%s return %d\n", __func__, err);
	goto out;
}
     758:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
     75c:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
     763:	00 00 
     765:	89 d8                	mov    %ebx,%eax
     767:	0f 85 49 01 00 00    	jne    8b6 <dafs_mkdir+0x246>
     76d:	48 83 c4 50          	add    $0x50,%rsp
     771:	5b                   	pop    %rbx
     772:	41 5c                	pop    %r12
     774:	41 5d                	pop    %r13
     776:	41 5e                	pop    %r14
     778:	41 5f                	pop    %r15
     77a:	5d                   	pop    %rbp
     77b:	c3                   	retq   
    struct nova_inode_info *si;
    struct nova_inode_info_header *sih = NULL;
    u64 pi_addr = 0;
    u64 tail = 0;
    u64 ino;
    int err = -EMLINK;
     77c:	bb e1 ff ff ff       	mov    $0xffffffe1,%ebx
     781:	eb 83                	jmp    706 <dafs_mkdir+0x96>
     783:	48 8d 7d b0          	lea    -0x50(%rbp),%rdi
     787:	bb e1 ff ff ff       	mov    $0xffffffe1,%ebx
     78c:	e8 00 00 00 00       	callq  791 <dafs_mkdir+0x121>
    timing_t mkdir_time;
   
    //nova_dbg("%s:dafs start to mkdir",__func__);
    NOVA_START_TIMING(mkdir_t, mkdir_time);
    if(dir->i_nlink >= NOVA_LINK_MAX)
     791:	41 81 7c 24 48 ff 7c 	cmpl   $0x7cff,0x48(%r12)
     798:	00 00 
     79a:	0f 86 2a ff ff ff    	jbe    6ca <dafs_mkdir+0x5a>
     7a0:	e9 79 ff ff ff       	jmpq   71e <dafs_mkdir+0xae>
		goto out_err;
	}

    //nova_dbg("dbgdbg dir %llu, par ino %llu", dir->i_ino, dentry->d_parent->d_inode->i_ino);

	inode = nova_new_vfs_inode(TYPE_MKDIR, dir, pi_addr, ino,
     7a5:	4d 8b 4d 18          	mov    0x18(%r13),%r9
					S_IFDIR | mode, sb->s_blocksize,
					0, &dentry->d_name);
     7a9:	49 8d 46 20          	lea    0x20(%r14),%rax
		goto out_err;
	}

    //nova_dbg("dbgdbg dir %llu, par ino %llu", dir->i_ino, dentry->d_parent->d_inode->i_ino);

	inode = nova_new_vfs_inode(TYPE_MKDIR, dir, pi_addr, ino,
     7ad:	45 89 f8             	mov    %r15d,%r8d
     7b0:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
     7b4:	66 41 81 c8 00 40    	or     $0x4000,%r8w
     7ba:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
     7c1:	45 0f b7 c0          	movzwl %r8w,%r8d
					S_IFDIR | mode, sb->s_blocksize,
					0, &dentry->d_name);
     7c5:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
		goto out_err;
	}

    //nova_dbg("dbgdbg dir %llu, par ino %llu", dir->i_ino, dentry->d_parent->d_inode->i_ino);

	inode = nova_new_vfs_inode(TYPE_MKDIR, dir, pi_addr, ino,
     7ca:	4c 89 d1             	mov    %r10,%rcx
     7cd:	4c 89 e6             	mov    %r12,%rsi
     7d0:	bf 03 00 00 00       	mov    $0x3,%edi
     7d5:	e8 00 00 00 00       	callq  7da <dafs_mkdir+0x16a>
					S_IFDIR | mode, sb->s_blocksize,
					0, &dentry->d_name);
	if (IS_ERR(inode)) {
     7da:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
		goto out_err;
	}

    //nova_dbg("dbgdbg dir %llu, par ino %llu", dir->i_ino, dentry->d_parent->d_inode->i_ino);

	inode = nova_new_vfs_inode(TYPE_MKDIR, dir, pi_addr, ino,
     7e0:	49 89 c0             	mov    %rax,%r8
					S_IFDIR | mode, sb->s_blocksize,
					0, &dentry->d_name);
	if (IS_ERR(inode)) {
     7e3:	0f 87 c6 00 00 00    	ja     8af <dafs_mkdir+0x23f>
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
     7e9:	48 8b 40 c8          	mov    -0x38(%rax),%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     7ed:	49 8b 95 b0 03 00 00 	mov    0x3b0(%r13),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     7f4:	45 31 c9             	xor    %r9d,%r9d
    pi->log_tail = pi->log_head = 0;
   
    //dafs不需要rebuild dir tree
    si = NOVA_I(inode);
    sih = &si->header;
    dafs_rebuild_dir_time_and_size(sb, pi, 1, dir);
     7f7:	4c 89 e1             	mov    %r12,%rcx
     7fa:	4c 89 ef             	mov    %r13,%rdi
     7fd:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
     801:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     805:	49 89 c7             	mov    %rax,%r15
     808:	4c 03 7a 18          	add    0x18(%rdx),%r15
     80c:	48 85 c0             	test   %rax,%rax
     80f:	ba 01 00 00 00       	mov    $0x1,%edx
     814:	4d 0f 44 f9          	cmove  %r9,%r15
     818:	4c 89 fe             	mov    %r15,%rsi
		goto out_err;
	}

	pi = nova_get_inode(sb, inode);
    //dafs_append_dir_init_entries(sb, pi, inode->i_ino, dir->i_ino);
    pi->log_tail = pi->log_head = 0;
     81b:	49 c7 47 48 00 00 00 	movq   $0x0,0x48(%r15)
     822:	00 
     823:	49 c7 47 50 00 00 00 	movq   $0x0,0x50(%r15)
     82a:	00 
   
    //dafs不需要rebuild dir tree
    si = NOVA_I(inode);
    sih = &si->header;
    dafs_rebuild_dir_time_and_size(sb, pi, 1, dir);
     82b:	e8 00 00 00 00       	callq  830 <dafs_mkdir+0x1c0>
    //dafs_append_dir_init_entries(sb, pi, inode->i_ino, dir->i_ino);
    pi->log_tail = pi->log_head = 0;
   
    //dafs不需要rebuild dir tree
    si = NOVA_I(inode);
    sih = &si->header;
     830:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
    dafs_rebuild_dir_time_and_size(sb, pi, 1, dir);
    dafs_rebuild_dir_inode_tree(sb, pi, pi_addr, sih);
     834:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
     838:	4c 89 fe             	mov    %r15,%rsi
     83b:	4c 89 ef             	mov    %r13,%rdi
    //dafs_append_dir_init_entries(sb, pi, inode->i_ino, dir->i_ino);
    pi->log_tail = pi->log_head = 0;
   
    //dafs不需要rebuild dir tree
    si = NOVA_I(inode);
    sih = &si->header;
     83e:	49 8d 48 88          	lea    -0x78(%r8),%rcx
    dafs_rebuild_dir_time_and_size(sb, pi, 1, dir);
    dafs_rebuild_dir_inode_tree(sb, pi, pi_addr, sih);
     842:	e8 00 00 00 00       	callq  847 <dafs_mkdir+0x1d7>
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
     847:	49 8b 44 24 c8       	mov    -0x38(%r12),%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     84c:	49 8b 95 b0 03 00 00 	mov    0x3b0(%r13),%rdx

	pidir = nova_get_inode(sb, dir);
	dir->i_blocks = pidir->i_blocks;
	inc_nlink(dir);
     853:	4c 89 e7             	mov    %r12,%rdi
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     856:	4c 8b 4d 98          	mov    -0x68(%rbp),%r9
     85a:	48 89 c1             	mov    %rax,%rcx
     85d:	48 03 4a 18          	add    0x18(%rdx),%rcx
     861:	48 85 c0             	test   %rax,%rax
     864:	48 89 ca             	mov    %rcx,%rdx
     867:	49 0f 44 d1          	cmove  %r9,%rdx
    sih = &si->header;
    dafs_rebuild_dir_time_and_size(sb, pi, 1, dir);
    dafs_rebuild_dir_inode_tree(sb, pi, pi_addr, sih);

	pidir = nova_get_inode(sb, dir);
	dir->i_blocks = pidir->i_blocks;
     86b:	48 8b 42 20          	mov    0x20(%rdx),%rax
     86f:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
     873:	49 89 84 24 98 00 00 	mov    %rax,0x98(%r12)
     87a:	00 
	inc_nlink(dir);
     87b:	e8 00 00 00 00       	callq  880 <dafs_mkdir+0x210>
	d_instantiate(dentry, inode);
     880:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
     884:	4c 89 f7             	mov    %r14,%rdi
     887:	4c 89 c6             	mov    %r8,%rsi
     88a:	e8 00 00 00 00       	callq  88f <dafs_mkdir+0x21f>
	unlock_new_inode(inode);
     88f:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
     893:	4c 89 c7             	mov    %r8,%rdi
     896:	e8 00 00 00 00       	callq  89b <dafs_mkdir+0x22b>
    //nova_dbg("test bug");
	dafs_lite_transaction_for_new_inode(sb, pi, pidir, tail);
     89b:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
     89f:	4c 89 fe             	mov    %r15,%rsi
     8a2:	4c 89 ef             	mov    %r13,%rdi
     8a5:	e8 96 fa ff ff       	callq  340 <dafs_lite_transaction_for_new_inode.constprop.5>
     8aa:	e9 6f fe ff ff       	jmpq   71e <dafs_mkdir+0xae>
	inode = nova_new_vfs_inode(TYPE_MKDIR, dir, pi_addr, ino,
					S_IFDIR | mode, sb->s_blocksize,
					0, &dentry->d_name);
	if (IS_ERR(inode)) {
        //nova_dbg("dafs fail to make inode");
		err = PTR_ERR(inode);
     8af:	89 c3                	mov    %eax,%ebx
		goto out_err;
     8b1:	e9 50 fe ff ff       	jmpq   706 <dafs_mkdir+0x96>

out_err:
//	clear_nlink(inode);
	nova_err(sb, "%s return %d\n", __func__, err);
	goto out;
}
     8b6:	e8 00 00 00 00       	callq  8bb <dafs_mkdir+0x24b>
     8bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000008c0 <dafs_mknod>:
	NOVA_END_TIMING(rmdir_t, rmdir_time);
	return err;
}

static int dafs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t rdev)
{
     8c0:	e8 00 00 00 00       	callq  8c5 <dafs_mknod+0x5>
     8c5:	55                   	push   %rbp
     8c6:	48 89 e5             	mov    %rsp,%rbp
     8c9:	41 57                	push   %r15
     8cb:	41 56                	push   %r14
     8cd:	41 55                	push   %r13
     8cf:	41 54                	push   %r12
     8d1:	49 89 ff             	mov    %rdi,%r15
     8d4:	53                   	push   %rbx
     8d5:	49 89 f5             	mov    %rsi,%r13
     8d8:	41 89 d6             	mov    %edx,%r14d
     8db:	48 83 ec 58          	sub    $0x58,%rsp
     8df:	89 4d a4             	mov    %ecx,-0x5c(%rbp)
    u64 tail = 0;
    u64 ino;
    int file_type;
    timing_t mknod_time;
    
	NOVA_START_TIMING(mknod_t, mknod_time);
     8e2:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # 8e8 <dafs_mknod+0x28>
	NOVA_END_TIMING(rmdir_t, rmdir_time);
	return err;
}

static int dafs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t rdev)
{
     8e8:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     8ef:	00 00 
     8f1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     8f5:	31 c0                	xor    %eax,%eax
    struct inode *inode = NULL;
    int err = PTR_ERR(inode);
    struct super_block *sb = dir->i_sb;
     8f7:	48 8b 5f 28          	mov    0x28(%rdi),%rbx
    u64 pi_addr = 0;
     8fb:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
     902:	00 
    u64 tail = 0;
    u64 ino;
    int file_type;
    timing_t mknod_time;
    
	NOVA_START_TIMING(mknod_t, mknod_time);
     903:	85 c9                	test   %ecx,%ecx
     905:	0f 85 64 01 00 00    	jne    a6f <dafs_mknod+0x1af>
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
     90b:	49 8b 47 c8          	mov    -0x38(%r15),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     90f:	48 85 c0             	test   %rax,%rax
     912:	0f 84 07 01 00 00    	je     a1f <dafs_mknod+0x15f>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     918:	48 8b 93 b0 03 00 00 	mov    0x3b0(%rbx),%rdx

    //nova_dbg("%s start",__func__);
	pidir = nova_get_inode(sb, dir);
	if (!pidir)
     91f:	48 03 42 18          	add    0x18(%rdx),%rax
     923:	48 89 45 98          	mov    %rax,-0x68(%rbp)
     927:	0f 84 f2 00 00 00    	je     a1f <dafs_mknod+0x15f>
		goto out_err;

	ino = nova_new_nova_inode(sb, &pi_addr);
     92d:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
     931:	48 89 df             	mov    %rbx,%rdi
     934:	e8 00 00 00 00       	callq  939 <dafs_mknod+0x79>
	if (ino == 0)
     939:	48 85 c0             	test   %rax,%rax
    //nova_dbg("%s start",__func__);
	pidir = nova_get_inode(sb, dir);
	if (!pidir)
		goto out_err;

	ino = nova_new_nova_inode(sb, &pi_addr);
     93c:	49 89 c3             	mov    %rax,%r11
	if (ino == 0)
     93f:	0f 84 da 00 00 00    	je     a1f <dafs_mknod+0x15f>
		goto out_err;

	nova_dbgv("%s: %s\n", __func__, dentry->d_name.name);
     945:	f6 05 00 00 00 00 10 	testb  $0x10,0x0(%rip)        # 94c <dafs_mknod+0x8c>
     94c:	0f 85 30 01 00 00    	jne    a82 <dafs_mknod+0x1c2>

    if(S_ISDIR(mode))
        file_type = 1;
    else
        file_type = 0;
    err = dafs_add_dentry(dentry, ino, 0, file_type);
     952:	44 89 f0             	mov    %r14d,%eax
     955:	31 c9                	xor    %ecx,%ecx
     957:	4c 89 de             	mov    %r11,%rsi
     95a:	66 25 00 f0          	and    $0xf000,%ax
     95e:	4c 89 ef             	mov    %r13,%rdi
     961:	4c 89 5d 90          	mov    %r11,-0x70(%rbp)
     965:	66 3d 00 40          	cmp    $0x4000,%ax
     969:	0f 94 c1             	sete   %cl
     96c:	31 d2                	xor    %edx,%edx
     96e:	e8 00 00 00 00       	callq  973 <dafs_mknod+0xb3>
     973:	41 89 c4             	mov    %eax,%r12d

	inode = nova_new_vfs_inode(TYPE_MKNOD, dir, pi_addr, ino, mode,
					0, rdev, &dentry->d_name);
     976:	49 8d 45 20          	lea    0x20(%r13),%rax
        file_type = 1;
    else
        file_type = 0;
    err = dafs_add_dentry(dentry, ino, 0, file_type);

	inode = nova_new_vfs_inode(TYPE_MKNOD, dir, pi_addr, ino, mode,
     97a:	4c 8b 5d 90          	mov    -0x70(%rbp),%r11
     97e:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
     982:	45 31 c9             	xor    %r9d,%r9d
     985:	45 0f b7 c6          	movzwl %r14w,%r8d
					0, rdev, &dentry->d_name);
     989:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
        file_type = 1;
    else
        file_type = 0;
    err = dafs_add_dentry(dentry, ino, 0, file_type);

	inode = nova_new_vfs_inode(TYPE_MKNOD, dir, pi_addr, ino, mode,
     98e:	8b 45 a4             	mov    -0x5c(%rbp),%eax
     991:	4c 89 fe             	mov    %r15,%rsi
     994:	4c 89 d9             	mov    %r11,%rcx
     997:	bf 01 00 00 00       	mov    $0x1,%edi
     99c:	89 04 24             	mov    %eax,(%rsp)
     99f:	e8 00 00 00 00       	callq  9a4 <dafs_mknod+0xe4>
					0, rdev, &dentry->d_name);
	if (IS_ERR(inode))
     9a4:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
        file_type = 1;
    else
        file_type = 0;
    err = dafs_add_dentry(dentry, ino, 0, file_type);

	inode = nova_new_vfs_inode(TYPE_MKNOD, dir, pi_addr, ino, mode,
     9aa:	49 89 c6             	mov    %rax,%r14
					0, rdev, &dentry->d_name);
	if (IS_ERR(inode))
     9ad:	77 73                	ja     a22 <dafs_mknod+0x162>
		goto out_err;

	d_instantiate(dentry, inode);
     9af:	48 89 c6             	mov    %rax,%rsi
     9b2:	4c 89 ef             	mov    %r13,%rdi
     9b5:	e8 00 00 00 00       	callq  9ba <dafs_mknod+0xfa>
	unlock_new_inode(inode);
     9ba:	4c 89 f7             	mov    %r14,%rdi
     9bd:	e8 00 00 00 00       	callq  9c2 <dafs_mknod+0x102>

	pi = nova_get_block(sb, pi_addr);
     9c2:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
     9c6:	48 8b 83 b0 03 00 00 	mov    0x3b0(%rbx),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     9cd:	be 00 00 00 00       	mov    $0x0,%esi
	dafs_lite_transaction_for_new_inode(sb, pi, pidir, tail);
     9d2:	48 89 df             	mov    %rbx,%rdi
     9d5:	48 89 d1             	mov    %rdx,%rcx
     9d8:	48 03 48 18          	add    0x18(%rax),%rcx
     9dc:	48 85 d2             	test   %rdx,%rdx
     9df:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
     9e3:	48 0f 45 f1          	cmovne %rcx,%rsi
     9e7:	e8 54 f9 ff ff       	callq  340 <dafs_lite_transaction_for_new_inode.constprop.5>
	NOVA_END_TIMING(mknod_t, mknod_time);
     9ec:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 9f2 <dafs_mknod+0x132>
     9f2:	85 d2                	test   %edx,%edx
     9f4:	75 4f                	jne    a45 <dafs_mknod+0x185>
	return err;
out_err:
	nova_err(sb, "%s return %d\n", __func__, err);
	NOVA_END_TIMING(mknod_t, mknod_time);
     9f6:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 9fe <dafs_mknod+0x13e>
     9fd:	00 
	return err;
}
     9fe:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
     a02:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
     a09:	00 00 
     a0b:	44 89 e0             	mov    %r12d,%eax
     a0e:	75 6d                	jne    a7d <dafs_mknod+0x1bd>
     a10:	48 83 c4 58          	add    $0x58,%rsp
     a14:	5b                   	pop    %rbx
     a15:	41 5c                	pop    %r12
     a17:	41 5d                	pop    %r13
     a19:	41 5e                	pop    %r14
     a1b:	41 5f                	pop    %r15
     a1d:	5d                   	pop    %rbp
     a1e:	c3                   	retq   
}

static int dafs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t rdev)
{
    struct inode *inode = NULL;
    int err = PTR_ERR(inode);
     a1f:	45 31 e4             	xor    %r12d,%r12d
	pi = nova_get_block(sb, pi_addr);
	dafs_lite_transaction_for_new_inode(sb, pi, pidir, tail);
	NOVA_END_TIMING(mknod_t, mknod_time);
	return err;
out_err:
	nova_err(sb, "%s return %d\n", __func__, err);
     a22:	44 89 e1             	mov    %r12d,%ecx
     a25:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
     a2c:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     a33:	48 89 df             	mov    %rbx,%rdi
     a36:	e8 00 00 00 00       	callq  a3b <dafs_mknod+0x17b>
	NOVA_END_TIMING(mknod_t, mknod_time);
     a3b:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # a41 <dafs_mknod+0x181>
     a41:	85 c0                	test   %eax,%eax
     a43:	74 b1                	je     9f6 <dafs_mknod+0x136>
     a45:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
     a49:	e8 00 00 00 00       	callq  a4e <dafs_mknod+0x18e>
     a4e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
     a52:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
     a56:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
     a5d:	48 2b 45 b8          	sub    -0x48(%rbp),%rax
     a61:	48 03 45 c8          	add    -0x38(%rbp),%rax
     a65:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # a6d <dafs_mknod+0x1ad>
     a6c:	00 
     a6d:	eb 87                	jmp    9f6 <dafs_mknod+0x136>
     a6f:	48 8d 7d b0          	lea    -0x50(%rbp),%rdi
     a73:	e8 00 00 00 00       	callq  a78 <dafs_mknod+0x1b8>
     a78:	e9 8e fe ff ff       	jmpq   90b <dafs_mknod+0x4b>
	return err;
}
     a7d:	e8 00 00 00 00       	callq  a82 <dafs_mknod+0x1c2>

	ino = nova_new_nova_inode(sb, &pi_addr);
	if (ino == 0)
		goto out_err;

	nova_dbgv("%s: %s\n", __func__, dentry->d_name.name);
     a82:	49 8b 55 28          	mov    0x28(%r13),%rdx
     a86:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     a8d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     a94:	48 89 45 90          	mov    %rax,-0x70(%rbp)
     a98:	e8 00 00 00 00       	callq  a9d <dafs_mknod+0x1dd>
	nova_dbgv("%s: inode %llu, dir %lu\n", __func__, ino, dir->i_ino);
     a9d:	f6 05 00 00 00 00 10 	testb  $0x10,0x0(%rip)        # aa4 <dafs_mknod+0x1e4>
     aa4:	4c 8b 5d 90          	mov    -0x70(%rbp),%r11
     aa8:	0f 84 a4 fe ff ff    	je     952 <dafs_mknod+0x92>
     aae:	49 8b 4f 40          	mov    0x40(%r15),%rcx
     ab2:	4c 89 da             	mov    %r11,%rdx
     ab5:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     abc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     ac3:	e8 00 00 00 00       	callq  ac8 <dafs_mknod+0x208>
     ac8:	4c 8b 5d 90          	mov    -0x70(%rbp),%r11
     acc:	e9 81 fe ff ff       	jmpq   952 <dafs_mknod+0x92>
     ad1:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
     ad6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     add:	00 00 00 

0000000000000ae0 <dafs_lite_transaction_for_time_and_link.constprop.4>:
    //nova_dbg("%s end",__func__);
	return 0;
}

/*没改*/
static void dafs_lite_transaction_for_time_and_link(struct super_block *sb,
     ae0:	e8 00 00 00 00       	callq  ae5 <dafs_lite_transaction_for_time_and_link.constprop.4+0x5>
     ae5:	55                   	push   %rbp
     ae6:	49 89 d1             	mov    %rdx,%r9
     ae9:	45 89 c3             	mov    %r8d,%r11d
     aec:	48 89 e5             	mov    %rsp,%rbp
     aef:	41 57                	push   %r15
     af1:	41 56                	push   %r14
     af3:	41 55                	push   %r13
     af5:	41 54                	push   %r12
     af7:	49 89 ff             	mov    %rdi,%r15
     afa:	53                   	push   %rbx
     afb:	49 89 f5             	mov    %rsi,%r13
     afe:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
	int cpu;
    struct ptr_pair *pair; 
	timing_t trans_time;

    //nova_dbg("%s start",__func__);
	NOVA_START_TIMING(link_trans_t, trans_time);
     b05:	44 8b 15 00 00 00 00 	mov    0x0(%rip),%r10d        # b0c <dafs_lite_transaction_for_time_and_link.constprop.4+0x2c>
    //nova_dbg("%s end",__func__);
	return 0;
}

/*没改*/
static void dafs_lite_transaction_for_time_and_link(struct super_block *sb,
     b0c:	48 89 8d 58 ff ff ff 	mov    %rcx,-0xa8(%rbp)
     b13:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     b1a:	00 00 
     b1c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     b20:	31 c0                	xor    %eax,%eax
     b22:	4c 8b b7 b0 03 00 00 	mov    0x3b0(%rdi),%r14
	int cpu;
    struct ptr_pair *pair; 
	timing_t trans_time;

    //nova_dbg("%s start",__func__);
	NOVA_START_TIMING(link_trans_t, trans_time);
     b29:	45 85 d2             	test   %r10d,%r10d
     b2c:	0f 85 ae 02 00 00    	jne    de0 <dafs_lite_transaction_for_time_and_link.constprop.4+0x300>
	cpu = smp_processor_id();
    // for debug
	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
	/* Commit a lite transaction */
	memset(&entry, 0, sizeof(struct nova_lite_journal_entry));
     b32:	4c 8d 55 90          	lea    -0x70(%rbp),%r10
     b36:	31 c0                	xor    %eax,%eax
     b38:	b9 08 00 00 00       	mov    $0x8,%ecx
	entry.addrs[0] = (u64)nova_get_addr_off(sbi, &pi->log_tail);
     b3d:	4d 8d 65 50          	lea    0x50(%r13),%r12
	cpu = smp_processor_id();
    // for debug
	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
	/* Commit a lite transaction */
	memset(&entry, 0, sizeof(struct nova_lite_journal_entry));
     b41:	4c 89 d7             	mov    %r10,%rdi
     b44:	f3 48 ab             	rep stos %rax,%es:(%rdi)
}

static inline u64
nova_get_addr_off(struct nova_sb_info *sbi, void *addr)
{
	NOVA_ASSERT((addr >= sbi->virt_addr) &&
     b47:	49 8b 46 18          	mov    0x18(%r14),%rax
     b4b:	49 39 c4             	cmp    %rax,%r12
     b4e:	0f 82 b9 02 00 00    	jb     e0d <dafs_lite_transaction_for_time_and_link.constprop.4+0x32d>
     b54:	48 89 c2             	mov    %rax,%rdx
     b57:	49 03 56 48          	add    0x48(%r14),%rdx
     b5b:	49 39 d4             	cmp    %rdx,%r12
     b5e:	0f 83 a9 02 00 00    	jae    e0d <dafs_lite_transaction_for_time_and_link.constprop.4+0x32d>
	entry.addrs[0] = (u64)nova_get_addr_off(sbi, &pi->log_tail);
	entry.addrs[0] |= (u64)8 << 56;
     b64:	4c 89 e2             	mov    %r12,%rdx
	entry.values[0] = pi->log_tail;

	entry.addrs[1] = (u64)nova_get_addr_off(sbi, &pidir->log_tail);
     b67:	49 8d 59 50          	lea    0x50(%r9),%rbx
	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
	/* Commit a lite transaction */
	memset(&entry, 0, sizeof(struct nova_lite_journal_entry));
	entry.addrs[0] = (u64)nova_get_addr_off(sbi, &pi->log_tail);
	entry.addrs[0] |= (u64)8 << 56;
     b6b:	48 29 c2             	sub    %rax,%rdx
     b6e:	48 b8 00 00 00 00 00 	movabs $0x800000000000000,%rax
     b75:	00 00 08 
     b78:	48 09 d0             	or     %rdx,%rax
     b7b:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	entry.values[0] = pi->log_tail;
     b7f:	49 8b 45 50          	mov    0x50(%r13),%rax
     b83:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
     b87:	49 8b 46 18          	mov    0x18(%r14),%rax
     b8b:	48 39 c3             	cmp    %rax,%rbx
     b8e:	0f 82 cb 02 00 00    	jb     e5f <dafs_lite_transaction_for_time_and_link.constprop.4+0x37f>
     b94:	48 89 c2             	mov    %rax,%rdx
     b97:	49 03 56 48          	add    0x48(%r14),%rdx
     b9b:	48 39 d3             	cmp    %rdx,%rbx
     b9e:	0f 83 bb 02 00 00    	jae    e5f <dafs_lite_transaction_for_time_and_link.constprop.4+0x37f>

	entry.addrs[1] = (u64)nova_get_addr_off(sbi, &pidir->log_tail);
	entry.addrs[1] |= (u64)8 << 56;
     ba4:	48 89 da             	mov    %rbx,%rdx
     ba7:	48 29 c2             	sub    %rax,%rdx
     baa:	48 b8 00 00 00 00 00 	movabs $0x800000000000000,%rax
     bb1:	00 00 08 
     bb4:	48 09 d0             	or     %rdx,%rax
	entry.values[1] = pidir->log_tail;

	if (invalidate) {
     bb7:	45 85 db             	test   %r11d,%r11d
	entry.addrs[0] = (u64)nova_get_addr_off(sbi, &pi->log_tail);
	entry.addrs[0] |= (u64)8 << 56;
	entry.values[0] = pi->log_tail;

	entry.addrs[1] = (u64)nova_get_addr_off(sbi, &pidir->log_tail);
	entry.addrs[1] |= (u64)8 << 56;
     bba:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	entry.values[1] = pidir->log_tail;
     bbe:	49 8b 41 50          	mov    0x50(%r9),%rax
     bc2:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

	if (invalidate) {
     bc6:	0f 85 d1 01 00 00    	jne    d9d <dafs_lite_transaction_for_time_and_link.constprop.4+0x2bd>
		entry.values[2] = pi->valid;
	}

    //nova_dbg("%s finish commit transaction",__func__);

	cpu = smp_processor_id();
     bcc:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # bd3 <dafs_lite_transaction_for_time_and_link.constprop.4+0xf3>
	spin_lock(&sbi->journal_locks[cpu]);
     bd3:	48 63 f8             	movslq %eax,%rdi
     bd6:	44 89 9d 48 ff ff ff 	mov    %r11d,-0xb8(%rbp)
     bdd:	4c 89 8d 50 ff ff ff 	mov    %r9,-0xb0(%rbp)
     be4:	48 c1 e7 02          	shl    $0x2,%rdi
     be8:	4c 89 95 40 ff ff ff 	mov    %r10,-0xc0(%rbp)
     bef:	89 85 68 ff ff ff    	mov    %eax,-0x98(%rbp)
     bf5:	48 89 bd 60 ff ff ff 	mov    %rdi,-0xa0(%rbp)
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static __always_inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
     bfc:	49 03 be b8 00 00 00 	add    0xb8(%r14),%rdi
     c03:	e8 00 00 00 00       	callq  c08 <dafs_lite_transaction_for_time_and_link.constprop.4+0x128>
	journal_tail = nova_create_lite_transaction(sb, &entry, NULL, 1, cpu);
     c08:	4c 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%r10
     c0f:	44 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%r8d
     c16:	b9 01 00 00 00       	mov    $0x1,%ecx
     c1b:	31 d2                	xor    %edx,%edx
     c1d:	4c 89 ff             	mov    %r15,%rdi
     c20:	4c 89 d6             	mov    %r10,%rsi
     c23:	e8 00 00 00 00       	callq  c28 <dafs_lite_transaction_for_time_and_link.constprop.4+0x148>

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
     c28:	44 8b 05 00 00 00 00 	mov    0x0(%rip),%r8d        # c2f <dafs_lite_transaction_for_time_and_link.constprop.4+0x14f>

	pi->log_tail = pi_tail;
     c2f:	48 8b bd 58 ff ff ff 	mov    -0xa8(%rbp),%rdi
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
     c36:	44 89 e1             	mov    %r12d,%ecx
     c39:	83 e1 3f             	and    $0x3f,%ecx
	if (support_clwb) {
     c3c:	31 f6                	xor    %esi,%esi
     c3e:	4c 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%r9
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
     c45:	83 c1 40             	add    $0x40,%ecx
	if (support_clwb) {
     c48:	44 8b 9d 48 ff ff ff 	mov    -0xb8(%rbp),%r11d
     c4f:	45 85 c0             	test   %r8d,%r8d
     c52:	49 89 7d 50          	mov    %rdi,0x50(%r13)
     c56:	0f 84 05 01 00 00    	je     d61 <dafs_lite_transaction_for_time_and_link.constprop.4+0x281>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
     c5c:	89 f2                	mov    %esi,%edx
     c5e:	4c 01 e2             	add    %r12,%rdx
     c61:	66 0f ae 32          	clwb   (%rdx)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     c65:	83 c6 40             	add    $0x40,%esi
     c68:	39 f1                	cmp    %esi,%ecx
     c6a:	77 f0                	ja     c5c <dafs_lite_transaction_for_time_and_link.constprop.4+0x17c>

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
     c6c:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # c72 <dafs_lite_transaction_for_time_and_link.constprop.4+0x192>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
     c72:	89 de                	mov    %ebx,%esi
	if (support_clwb) {
     c74:	31 c9                	xor    %ecx,%ecx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
     c76:	83 e6 3f             	and    $0x3f,%esi
	nova_flush_buffer(&pi->log_tail, CACHELINE_SIZE, 0);
	pidir->log_tail = pidir_tail;
     c79:	49 c7 41 50 00 00 00 	movq   $0x0,0x50(%r9)
     c80:	00 
     c81:	83 c6 40             	add    $0x40,%esi
	if (support_clwb) {
     c84:	85 ff                	test   %edi,%edi
     c86:	0f 84 e9 00 00 00    	je     d75 <dafs_lite_transaction_for_time_and_link.constprop.4+0x295>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
     c8c:	89 ca                	mov    %ecx,%edx
     c8e:	48 01 da             	add    %rbx,%rdx
     c91:	66 0f ae 32          	clwb   (%rdx)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     c95:	83 c1 40             	add    $0x40,%ecx
     c98:	39 ce                	cmp    %ecx,%esi
     c9a:	77 f0                	ja     c8c <dafs_lite_transaction_for_time_and_link.constprop.4+0x1ac>
	nova_flush_buffer(&pidir->log_tail, CACHELINE_SIZE, 0);
	if (invalidate) {
     c9c:	45 85 db             	test   %r11d,%r11d
     c9f:	74 32                	je     cd3 <dafs_lite_transaction_for_time_and_link.constprop.4+0x1f3>
		pi->valid = 0;
     ca1:	41 c6 45 02 00       	movb   $0x0,0x2(%r13)
		nova_flush_buffer(&pi->valid, CACHELINE_SIZE, 0);
     ca6:	49 83 c5 02          	add    $0x2,%r13

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
     caa:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # cb0 <dafs_lite_transaction_for_time_and_link.constprop.4+0x1d0>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
     cb0:	44 89 ee             	mov    %r13d,%esi
	if (support_clwb) {
     cb3:	31 c9                	xor    %ecx,%ecx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
     cb5:	83 e6 3f             	and    $0x3f,%esi
     cb8:	83 c6 40             	add    $0x40,%esi
	if (support_clwb) {
     cbb:	85 d2                	test   %edx,%edx
     cbd:	0f 84 c6 00 00 00    	je     d89 <dafs_lite_transaction_for_time_and_link.constprop.4+0x2a9>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
     cc3:	89 ca                	mov    %ecx,%edx
     cc5:	4c 01 ea             	add    %r13,%rdx
     cc8:	66 0f ae 32          	clwb   (%rdx)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     ccc:	83 c1 40             	add    $0x40,%ecx
     ccf:	39 ce                	cmp    %ecx,%esi
     cd1:	77 f0                	ja     cc3 <dafs_lite_transaction_for_time_and_link.constprop.4+0x1e3>
	/* TODO: Fix me. */
}

static inline void PERSISTENT_BARRIER(void)
{
	asm volatile ("sfence\n" : : );
     cd3:	0f ae f8             	sfence 
	}
	PERSISTENT_BARRIER();

	nova_commit_lite_transaction(sb, journal_tail, cpu);
     cd6:	8b 95 68 ff ff ff    	mov    -0x98(%rbp),%edx
     cdc:	4c 89 ff             	mov    %r15,%rdi
     cdf:	48 89 c6             	mov    %rax,%rsi
     ce2:	e8 00 00 00 00       	callq  ce7 <dafs_lite_transaction_for_time_and_link.constprop.4+0x207>
	return arch_spin_trylock(&(lock)->raw_lock);
}

static inline void do_raw_spin_unlock(raw_spinlock_t *lock) __releases(lock)
{
	arch_spin_unlock(&lock->raw_lock);
     ce7:	48 8b bd 60 ff ff ff 	mov    -0xa0(%rbp),%rdi
     cee:	49 03 be b8 00 00 00 	add    0xb8(%r14),%rdi
     cf5:	ff 14 25 00 00 00 00 	callq  *0x0
	spin_unlock(&sbi->journal_locks[cpu]);
	NOVA_END_TIMING(link_trans_t, trans_time);
     cfc:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # d02 <dafs_lite_transaction_for_time_and_link.constprop.4+0x222>
     d02:	85 c9                	test   %ecx,%ecx
     d04:	74 2e                	je     d34 <dafs_lite_transaction_for_time_and_link.constprop.4+0x254>
     d06:	48 8d 7d 80          	lea    -0x80(%rbp),%rdi
     d0a:	e8 00 00 00 00       	callq  d0f <dafs_lite_transaction_for_time_and_link.constprop.4+0x22f>
     d0f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
     d13:	48 2b 85 70 ff ff ff 	sub    -0x90(%rbp),%rax
     d1a:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
     d21:	48 2b 85 78 ff ff ff 	sub    -0x88(%rbp),%rax
     d28:	48 03 45 88          	add    -0x78(%rbp),%rax
     d2c:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # d34 <dafs_lite_transaction_for_time_and_link.constprop.4+0x254>
     d33:	00 
     d34:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # d3c <dafs_lite_transaction_for_time_and_link.constprop.4+0x25c>
     d3b:	00 
    //nova_dbg("%s end",__func__);
}
     d3c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
     d40:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
     d47:	00 00 
     d49:	0f 85 62 01 00 00    	jne    eb1 <dafs_lite_transaction_for_time_and_link.constprop.4+0x3d1>
     d4f:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
     d56:	5b                   	pop    %rbx
     d57:	41 5c                	pop    %r12
     d59:	41 5d                	pop    %r13
     d5b:	41 5e                	pop    %r14
     d5d:	41 5f                	pop    %r15
     d5f:	5d                   	pop    %rbp
     d60:	c3                   	retq   
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
     d61:	89 f2                	mov    %esi,%edx
     d63:	4c 01 e2             	add    %r12,%rdx
     d66:	0f ae 3a             	clflush (%rdx)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     d69:	83 c6 40             	add    $0x40,%esi
     d6c:	39 f1                	cmp    %esi,%ecx
     d6e:	77 f1                	ja     d61 <dafs_lite_transaction_for_time_and_link.constprop.4+0x281>
     d70:	e9 f7 fe ff ff       	jmpq   c6c <dafs_lite_transaction_for_time_and_link.constprop.4+0x18c>
			_mm_clflush(buf + i);
     d75:	89 ca                	mov    %ecx,%edx
     d77:	48 01 da             	add    %rbx,%rdx
     d7a:	0f ae 3a             	clflush (%rdx)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     d7d:	83 c1 40             	add    $0x40,%ecx
     d80:	39 ce                	cmp    %ecx,%esi
     d82:	77 f1                	ja     d75 <dafs_lite_transaction_for_time_and_link.constprop.4+0x295>
     d84:	e9 13 ff ff ff       	jmpq   c9c <dafs_lite_transaction_for_time_and_link.constprop.4+0x1bc>
			_mm_clflush(buf + i);
     d89:	89 ca                	mov    %ecx,%edx
     d8b:	4c 01 ea             	add    %r13,%rdx
     d8e:	0f ae 3a             	clflush (%rdx)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     d91:	83 c1 40             	add    $0x40,%ecx
     d94:	39 ce                	cmp    %ecx,%esi
     d96:	77 f1                	ja     d89 <dafs_lite_transaction_for_time_and_link.constprop.4+0x2a9>
     d98:	e9 36 ff ff ff       	jmpq   cd3 <dafs_lite_transaction_for_time_and_link.constprop.4+0x1f3>
     d9d:	49 8b 46 18          	mov    0x18(%r14),%rax
	entry.addrs[1] = (u64)nova_get_addr_off(sbi, &pidir->log_tail);
	entry.addrs[1] |= (u64)8 << 56;
	entry.values[1] = pidir->log_tail;

	if (invalidate) {
		entry.addrs[2] = (u64)nova_get_addr_off(sbi, &pi->valid);
     da1:	4d 8d 45 02          	lea    0x2(%r13),%r8
     da5:	49 39 c0             	cmp    %rax,%r8
     da8:	0f 82 08 01 00 00    	jb     eb6 <dafs_lite_transaction_for_time_and_link.constprop.4+0x3d6>
     dae:	48 89 c2             	mov    %rax,%rdx
     db1:	49 03 56 48          	add    0x48(%r14),%rdx
     db5:	49 39 d0             	cmp    %rdx,%r8
     db8:	0f 83 f8 00 00 00    	jae    eb6 <dafs_lite_transaction_for_time_and_link.constprop.4+0x3d6>
		entry.addrs[2] |= (u64)1 << 56;
     dbe:	49 29 c0             	sub    %rax,%r8
     dc1:	48 b8 00 00 00 00 00 	movabs $0x100000000000000,%rax
     dc8:	00 00 01 
     dcb:	49 09 c0             	or     %rax,%r8
		entry.values[2] = pi->valid;
     dce:	41 0f b6 45 02       	movzbl 0x2(%r13),%eax
	entry.addrs[1] |= (u64)8 << 56;
	entry.values[1] = pidir->log_tail;

	if (invalidate) {
		entry.addrs[2] = (u64)nova_get_addr_off(sbi, &pi->valid);
		entry.addrs[2] |= (u64)1 << 56;
     dd3:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
		entry.values[2] = pi->valid;
     dd7:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
     ddb:	e9 ec fd ff ff       	jmpq   bcc <dafs_lite_transaction_for_time_and_link.constprop.4+0xec>
     de0:	48 8d bd 70 ff ff ff 	lea    -0x90(%rbp),%rdi
     de7:	44 89 85 60 ff ff ff 	mov    %r8d,-0xa0(%rbp)
     dee:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
     df5:	e8 00 00 00 00       	callq  dfa <dafs_lite_transaction_for_time_and_link.constprop.4+0x31a>
     dfa:	44 8b 9d 60 ff ff ff 	mov    -0xa0(%rbp),%r11d
     e01:	4c 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%r9
     e08:	e9 25 fd ff ff       	jmpq   b32 <dafs_lite_transaction_for_time_and_link.constprop.4+0x52>
     e0d:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
     e14:	ba 1a 02 00 00       	mov    $0x21a,%edx
     e19:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     e20:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     e27:	4c 89 95 50 ff ff ff 	mov    %r10,-0xb0(%rbp)
     e2e:	44 89 9d 60 ff ff ff 	mov    %r11d,-0xa0(%rbp)
     e35:	4c 89 8d 68 ff ff ff 	mov    %r9,-0x98(%rbp)
     e3c:	e8 00 00 00 00       	callq  e41 <dafs_lite_transaction_for_time_and_link.constprop.4+0x361>
     e41:	49 8b 46 18          	mov    0x18(%r14),%rax
     e45:	4c 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%r10
     e4c:	44 8b 9d 60 ff ff ff 	mov    -0xa0(%rbp),%r11d
     e53:	4c 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%r9
     e5a:	e9 05 fd ff ff       	jmpq   b64 <dafs_lite_transaction_for_time_and_link.constprop.4+0x84>
     e5f:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
     e66:	ba 1a 02 00 00       	mov    $0x21a,%edx
     e6b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     e72:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     e79:	4c 89 95 50 ff ff ff 	mov    %r10,-0xb0(%rbp)
     e80:	44 89 9d 60 ff ff ff 	mov    %r11d,-0xa0(%rbp)
     e87:	4c 89 8d 68 ff ff ff 	mov    %r9,-0x98(%rbp)
     e8e:	e8 00 00 00 00       	callq  e93 <dafs_lite_transaction_for_time_and_link.constprop.4+0x3b3>
     e93:	49 8b 46 18          	mov    0x18(%r14),%rax
     e97:	4c 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%r10
     e9e:	44 8b 9d 60 ff ff ff 	mov    -0xa0(%rbp),%r11d
     ea5:	4c 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%r9
     eac:	e9 f3 fc ff ff       	jmpq   ba4 <dafs_lite_transaction_for_time_and_link.constprop.4+0xc4>

	nova_commit_lite_transaction(sb, journal_tail, cpu);
	spin_unlock(&sbi->journal_locks[cpu]);
	NOVA_END_TIMING(link_trans_t, trans_time);
    //nova_dbg("%s end",__func__);
}
     eb1:	e8 00 00 00 00       	callq  eb6 <dafs_lite_transaction_for_time_and_link.constprop.4+0x3d6>
     eb6:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
     ebd:	ba 1a 02 00 00       	mov    $0x21a,%edx
     ec2:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     ec9:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     ed0:	4c 89 95 48 ff ff ff 	mov    %r10,-0xb8(%rbp)
     ed7:	44 89 9d 50 ff ff ff 	mov    %r11d,-0xb0(%rbp)
     ede:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
     ee5:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)
     eec:	e8 00 00 00 00       	callq  ef1 <dafs_lite_transaction_for_time_and_link.constprop.4+0x411>
     ef1:	49 8b 46 18          	mov    0x18(%r14),%rax
     ef5:	4c 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%r10
     efc:	44 8b 9d 50 ff ff ff 	mov    -0xb0(%rbp),%r11d
     f03:	4c 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%r9
     f0a:	4c 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%r8
     f11:	e9 a8 fe ff ff       	jmpq   dbe <dafs_lite_transaction_for_time_and_link.constprop.4+0x2de>
     f16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     f1d:	00 00 00 

0000000000000f20 <dafs_append_link_change_entry>:

/* Returns new tail after append 
 * 这个没有改动*/
int dafs_append_link_change_entry(struct super_block *sb,
	struct nova_inode *pi, struct inode *inode, u64 tail, u64 *new_tail)
{
     f20:	e8 00 00 00 00       	callq  f25 <dafs_append_link_change_entry+0x5>
     f25:	55                   	push   %rbp
     f26:	48 89 e5             	mov    %rsp,%rbp
     f29:	41 55                	push   %r13
     f2b:	41 54                	push   %r12
     f2d:	53                   	push   %rbx
     f2e:	49 89 fd             	mov    %rdi,%r13
     f31:	49 89 d4             	mov    %rdx,%r12
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;
     f34:	48 83 ea 78          	sub    $0x78,%rdx

/* Returns new tail after append 
 * 这个没有改动*/
int dafs_append_link_change_entry(struct super_block *sb,
	struct nova_inode *pi, struct inode *inode, u64 tail, u64 *new_tail)
{
     f38:	4c 89 c3             	mov    %r8,%rbx
     f3b:	48 83 ec 48          	sub    $0x48,%rsp
	int extended = 0;
	size_t size = sizeof(struct nova_link_change_entry);
	timing_t append_time;

    //nova_dbg("%s start",__func__);
	NOVA_START_TIMING(append_link_change_t, append_time);
     f3f:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # f45 <dafs_append_link_change_entry+0x25>
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;
	struct nova_link_change_entry *entry;
    //struct ptr_pair *pair;
	u64 curr_p;
	int extended = 0;
     f45:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%rbp)

/* Returns new tail after append 
 * 这个没有改动*/
int dafs_append_link_change_entry(struct super_block *sb,
	struct nova_inode *pi, struct inode *inode, u64 tail, u64 *new_tail)
{
     f4c:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     f53:	00 00 
     f55:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
     f59:	31 c0                	xor    %eax,%eax
	int extended = 0;
	size_t size = sizeof(struct nova_link_change_entry);
	timing_t append_time;

    //nova_dbg("%s start",__func__);
	NOVA_START_TIMING(append_link_change_t, append_time);
     f5b:	85 ff                	test   %edi,%edi
     f5d:	0f 85 f3 00 00 00    	jne    1056 <dafs_append_link_change_entry+0x136>
	//nova_dbg("%s: inode %lu attr change\n",
	//			__func__, inode->i_ino);

	curr_p = nova_get_append_head(sb, pi, sih, tail, size, &extended);
     f63:	4c 8d 4d bc          	lea    -0x44(%rbp),%r9
     f67:	41 b8 20 00 00 00    	mov    $0x20,%r8d
     f6d:	4c 89 ef             	mov    %r13,%rdi
     f70:	e8 00 00 00 00       	callq  f75 <dafs_append_link_change_entry+0x55>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     f75:	49 8b 95 b0 03 00 00 	mov    0x3b0(%r13),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     f7c:	48 85 c0             	test   %rax,%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     f7f:	48 8b 72 18          	mov    0x18(%rdx),%rsi
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     f83:	0f 84 c1 00 00 00    	je     104a <dafs_append_link_change_entry+0x12a>
     f89:	48 01 c6             	add    %rax,%rsi
     f8c:	89 f7                	mov    %esi,%edi
     f8e:	83 e7 3f             	and    $0x3f,%edi
     f91:	83 c7 20             	add    $0x20,%edi
	//if (curr_p == 0)
        //return 0;
		//return -ENOMEM;

	entry = (struct nova_link_change_entry *)nova_get_block(sb, curr_p);
	entry->entry_type = LINK_CHANGE;
     f94:	c6 06 04             	movb   $0x4,(%rsi)
	entry->links = cpu_to_le16(inode->i_nlink);
     f97:	41 8b 54 24 48       	mov    0x48(%r12),%edx

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
     f9c:	31 c9                	xor    %ecx,%ecx
     f9e:	66 89 56 02          	mov    %dx,0x2(%rsi)
	entry->ctime = cpu_to_le32(inode->i_ctime.tv_sec);
     fa2:	49 8b 54 24 78       	mov    0x78(%r12),%rdx
     fa7:	89 56 04             	mov    %edx,0x4(%rsi)
	entry->flags = cpu_to_le32(inode->i_flags);
     faa:	41 8b 54 24 0c       	mov    0xc(%r12),%edx
     faf:	89 56 08             	mov    %edx,0x8(%rsi)
	entry->generation = cpu_to_le32(inode->i_generation);
     fb2:	41 8b 94 24 18 02 00 	mov    0x218(%r12),%edx
     fb9:	00 
     fba:	89 56 0c             	mov    %edx,0xc(%rsi)
     fbd:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # fc3 <dafs_append_link_change_entry+0xa3>
     fc3:	85 d2                	test   %edx,%edx
     fc5:	74 72                	je     1039 <dafs_append_link_change_entry+0x119>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
     fc7:	89 ca                	mov    %ecx,%edx
     fc9:	48 01 f2             	add    %rsi,%rdx
     fcc:	66 0f ae 32          	clwb   (%rdx)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
     fd0:	83 c1 40             	add    $0x40,%ecx
     fd3:	39 cf                	cmp    %ecx,%edi
     fd5:	77 f0                	ja     fc7 <dafs_append_link_change_entry+0xa7>
	nova_flush_buffer(entry, size, 0);
	*new_tail = curr_p + size;
     fd7:	48 8d 50 20          	lea    0x20(%rax),%rdx
     fdb:	48 89 13             	mov    %rdx,(%rbx)
	sih->last_link_change = curr_p;
     fde:	49 89 44 24 f8       	mov    %rax,-0x8(%r12)

	NOVA_END_TIMING(append_link_change_t, append_time);
     fe3:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # fe9 <dafs_append_link_change_entry+0xc9>
     fe9:	85 c0                	test   %eax,%eax
     feb:	74 28                	je     1015 <dafs_append_link_change_entry+0xf5>
     fed:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
     ff1:	e8 00 00 00 00       	callq  ff6 <dafs_append_link_change_entry+0xd6>
     ff6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
     ffa:	48 2b 45 c0          	sub    -0x40(%rbp),%rax
     ffe:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    1005:	48 2b 45 c8          	sub    -0x38(%rbp),%rax
    1009:	48 03 45 d8          	add    -0x28(%rbp),%rax
    100d:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 1015 <dafs_append_link_change_entry+0xf5>
    1014:	00 
    1015:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 101d <dafs_append_link_change_entry+0xfd>
    101c:	00 
    //nova_dbg("%s end",__func__);
	return 0;
}
    101d:	31 c0                	xor    %eax,%eax
    101f:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
    1023:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    102a:	00 00 
    102c:	75 4e                	jne    107c <dafs_append_link_change_entry+0x15c>
    102e:	48 83 c4 48          	add    $0x48,%rsp
    1032:	5b                   	pop    %rbx
    1033:	41 5c                	pop    %r12
    1035:	41 5d                	pop    %r13
    1037:	5d                   	pop    %rbp
    1038:	c3                   	retq   
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    1039:	89 ca                	mov    %ecx,%edx
    103b:	48 01 f2             	add    %rsi,%rdx
    103e:	0f ae 3a             	clflush (%rdx)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    1041:	83 c1 40             	add    $0x40,%ecx
    1044:	39 cf                	cmp    %ecx,%edi
    1046:	77 f1                	ja     1039 <dafs_append_link_change_entry+0x119>
    1048:	eb 8d                	jmp    fd7 <dafs_append_link_change_entry+0xb7>
    104a:	bf 20 00 00 00       	mov    $0x20,%edi
    104f:	31 f6                	xor    %esi,%esi
    1051:	e9 3e ff ff ff       	jmpq   f94 <dafs_append_link_change_entry+0x74>
    1056:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
    105a:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    105e:	48 89 75 a8          	mov    %rsi,-0x58(%rbp)
    1062:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
    1066:	e8 00 00 00 00       	callq  106b <dafs_append_link_change_entry+0x14b>
    106b:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
    106f:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    1073:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    1077:	e9 e7 fe ff ff       	jmpq   f63 <dafs_append_link_change_entry+0x43>
    107c:	e8 00 00 00 00       	callq  1081 <dafs_append_link_change_entry+0x161>
    1081:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    1086:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    108d:	00 00 00 

0000000000001090 <dafs_rename>:
	return err;
}

static int dafs_rename(struct inode *old_dir, struct dentry *old_dentry, 
        struct inode *new_dir, struct dentry *new_dentry)
{
    1090:	e8 00 00 00 00       	callq  1095 <dafs_rename+0x5>
    1095:	55                   	push   %rbp
    1096:	48 89 e5             	mov    %rsp,%rbp
    1099:	41 57                	push   %r15
    109b:	41 56                	push   %r14
    109d:	41 55                	push   %r13
    109f:	41 54                	push   %r12
    10a1:	49 89 f5             	mov    %rsi,%r13
    10a4:	53                   	push   %rbx
    10a5:	49 89 cf             	mov    %rcx,%r15
    10a8:	48 83 ec 58          	sub    $0x58,%rsp
    struct inode *old_inode = old_dentry->d_inode;
    10ac:	48 8b 5e 30          	mov    0x30(%rsi),%rbx
    struct inode *new_inode = new_dentry->d_inode;
    10b0:	4c 8b 61 30          	mov    0x30(%rcx),%r12
	return err;
}

static int dafs_rename(struct inode *old_dir, struct dentry *old_dentry, 
        struct inode *new_dir, struct dentry *new_dentry)
{
    10b4:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    10bb:	00 00 
    10bd:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
    10c2:	31 c0                	xor    %eax,%eax
    //int change_parent = 0;
    //u64 journal_tail;
    timing_t rename_time;

    //nova_dbg("%s start", __func__); 
	nova_dbgv("%s: rename %s to %s,\n", __func__,
    10c4:	f6 05 00 00 00 00 10 	testb  $0x10,0x0(%rip)        # 10cb <dafs_rename+0x3b>
	return err;
}

static int dafs_rename(struct inode *old_dir, struct dentry *old_dentry, 
        struct inode *new_dir, struct dentry *new_dentry)
{
    10cb:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
    10d0:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
    struct inode *old_inode = old_dentry->d_inode;
    struct inode *new_inode = new_dentry->d_inode;
    struct super_block *sb = old_inode->i_sb;
    10d5:	4c 8b 73 28          	mov    0x28(%rbx),%r14
    struct nova_inode *new_pi = NULL;
    //struct nova_inode *new_pidir = NULL, *old_pidir = NULL;
    //struct nova_lite_journal_entry entry, entry1;
    //struct nova_dentry *father_entry = NULL;
    //char *head_addr = NULL;
    u64 new_pi_tail = 0;
    10d9:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
    10e0:	00 00 
    //int change_parent = 0;
    //u64 journal_tail;
    timing_t rename_time;

    //nova_dbg("%s start", __func__); 
	nova_dbgv("%s: rename %s to %s,\n", __func__,
    10e2:	0f 85 47 02 00 00    	jne    132f <dafs_rename+0x29f>
			old_dentry->d_name.name, new_dentry->d_name.name);
	nova_dbgv("%s: %s inode %lu, old dir %lu, new dir %lu, new inode %lu\n",
			__func__, S_ISDIR(old_inode->i_mode) ? "dir" : "normal",
			old_inode->i_ino, old_dir->i_ino, new_dir->i_ino,
			new_inode ? new_inode->i_ino : 0);
	NOVA_START_TIMING(rename_t, rename_time);
    10e8:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # 10ee <dafs_rename+0x5e>
    10ee:	85 ff                	test   %edi,%edi
    10f0:	0f 85 57 01 00 00    	jne    124d <dafs_rename+0x1bd>

    /*检查rename的情况*/
    if(new_inode){
        err = -ENOMEM;
        if(S_ISDIR(old_inode->i_mode) && !dafs_empty_dir(new_inode, new_dentry))
    10f6:	0f b7 03             	movzwl (%rbx),%eax
    10f9:	66 25 00 f0          	and    $0xf000,%ax
			old_inode->i_ino, old_dir->i_ino, new_dir->i_ino,
			new_inode ? new_inode->i_ino : 0);
	NOVA_START_TIMING(rename_t, rename_time);

    /*检查rename的情况*/
    if(new_inode){
    10fd:	4d 85 e4             	test   %r12,%r12
    1100:	74 6f                	je     1171 <dafs_rename+0xe1>
        err = -ENOMEM;
        if(S_ISDIR(old_inode->i_mode) && !dafs_empty_dir(new_inode, new_dentry))
    1102:	66 3d 00 40          	cmp    $0x4000,%ax
    1106:	0f 84 86 01 00 00    	je     1292 <dafs_rename+0x202>

    } else {
        
        if(new_inode){
            /*first remove the old entry in the new directory*/
            err = dafs_remove_dentry(new_dentry);
    110c:	4c 89 ff             	mov    %r15,%rdi
    110f:	e8 00 00 00 00       	callq  1114 <dafs_rename+0x84>
            if (err)
    1114:	85 c0                	test   %eax,%eax
    1116:	74 63                	je     117b <dafs_rename+0xeb>

	NOVA_END_TIMING(rename_t, rename_time);
    //nova_dbg("%s end",__func__);
	return 0;
out:
	nova_err(sb, "%s return %d\n", __func__, err);
    1118:	89 c1                	mov    %eax,%ecx
    111a:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    1121:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1128:	4c 89 f7             	mov    %r14,%rdi
    112b:	89 44 24 20          	mov    %eax,0x20(%rsp)
    112f:	e8 00 00 00 00       	callq  1134 <dafs_rename+0xa4>
	NOVA_END_TIMING(rename_t, rename_time);
    1134:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 113a <dafs_rename+0xaa>
    113a:	85 c0                	test   %eax,%eax
    113c:	8b 44 24 20          	mov    0x20(%rsp),%eax
    1140:	0f 85 16 01 00 00    	jne    125c <dafs_rename+0x1cc>
    1146:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 114e <dafs_rename+0xbe>
    114d:	00 
	return err;
}
    114e:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
    1153:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
    115a:	00 00 
    115c:	0f 85 62 02 00 00    	jne    13c4 <dafs_rename+0x334>
    1162:	48 83 c4 58          	add    $0x58,%rsp
    1166:	5b                   	pop    %rbx
    1167:	41 5c                	pop    %r12
    1169:	41 5d                	pop    %r13
    116b:	41 5e                	pop    %r14
    116d:	41 5f                	pop    %r15
    116f:	5d                   	pop    %rbp
    1170:	c3                   	retq   
    if(new_inode){
        err = -ENOMEM;
        if(S_ISDIR(old_inode->i_mode) && !dafs_empty_dir(new_inode, new_dentry))
            goto out;
    } else {
        if(S_ISDIR(old_inode->i_mode)){
    1171:	66 3d 00 40          	cmp    $0x4000,%ax
    1175:	0f 84 82 01 00 00    	je     12fd <dafs_rename+0x26d>
            err = dafs_remove_dentry(new_dentry);
            if (err)
                goto out;
        }

        err =__rename_file_dentry(old_dentry, new_dentry);
    117b:	4c 89 fe             	mov    %r15,%rsi
    117e:	4c 89 ef             	mov    %r13,%rdi
    1181:	e8 00 00 00 00       	callq  1186 <dafs_rename+0xf6>
        if(err)
    1186:	85 c0                	test   %eax,%eax
    1188:	75 8e                	jne    1118 <dafs_rename+0x88>
            goto out;
        err = dafs_remove_dentry(old_dentry);
    118a:	4c 89 ef             	mov    %r13,%rdi
    118d:	e8 00 00 00 00       	callq  1192 <dafs_rename+0x102>
		inc_nlink(new_dir);

    if (dec_link < 0)
		drop_nlink(old_dir);

	if (new_inode) {
    1192:	4d 85 e4             	test   %r12,%r12
    1195:	74 70                	je     1207 <dafs_rename+0x177>
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
    1197:	49 8b 44 24 c8       	mov    -0x38(%r12),%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    119c:	49 8b 96 b0 03 00 00 	mov    0x3b0(%r14),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    11a3:	49 89 c5             	mov    %rax,%r13
    11a6:	4c 03 6a 18          	add    0x18(%rdx),%r13
    11aa:	48 85 c0             	test   %rax,%rax
    11ad:	b8 00 00 00 00       	mov    $0x0,%eax
    11b2:	4c 0f 44 e8          	cmove  %rax,%r13
/* does not take xtime_lock */
struct timespec __current_kernel_time(void);

static inline struct timespec current_kernel_time(void)
{
	struct timespec64 now = current_kernel_time64();
    11b6:	e8 00 00 00 00       	callq  11bb <dafs_rename+0x12b>
		new_pi = nova_get_inode(sb, new_inode);
		new_inode->i_ctime = CURRENT_TIME;
    11bb:	49 89 44 24 78       	mov    %rax,0x78(%r12)
    11c0:	49 89 94 24 80 00 00 	mov    %rdx,0x80(%r12)
    11c7:	00 

		if (S_ISDIR(old_inode->i_mode)) {
    11c8:	0f b7 03             	movzwl (%rbx),%eax
    11cb:	66 25 00 f0          	and    $0xf000,%ax
    11cf:	66 3d 00 40          	cmp    $0x4000,%ax
    11d3:	0f 84 3c 01 00 00    	je     1315 <dafs_rename+0x285>
			if (new_inode->i_nlink)
				drop_nlink(new_inode);
		}
		if (new_inode->i_nlink)
    11d9:	41 8b 54 24 48       	mov    0x48(%r12),%edx
    11de:	85 d2                	test   %edx,%edx
    11e0:	74 08                	je     11ea <dafs_rename+0x15a>
			drop_nlink(new_inode);
    11e2:	4c 89 e7             	mov    %r12,%rdi
    11e5:	e8 00 00 00 00       	callq  11ea <dafs_rename+0x15a>

		err = dafs_append_link_change_entry(sb, new_pi,
    11ea:	4c 8d 44 24 28       	lea    0x28(%rsp),%r8
    11ef:	31 c9                	xor    %ecx,%ecx
    11f1:	4c 89 e2             	mov    %r12,%rdx
    11f4:	4c 89 ee             	mov    %r13,%rsi
    11f7:	4c 89 f7             	mov    %r14,%rdi
    11fa:	e8 00 00 00 00       	callq  11ff <dafs_rename+0x16f>
						new_inode, 0, &new_pi_tail);
		if (err)
    11ff:	85 c0                	test   %eax,%eax
    1201:	0f 85 11 ff ff ff    	jne    1118 <dafs_rename+0x88>
			goto out;
	}

	NOVA_END_TIMING(rename_t, rename_time);
    1207:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 120d <dafs_rename+0x17d>
    120d:	85 f6                	test   %esi,%esi
    120f:	74 2d                	je     123e <dafs_rename+0x1ae>
	getnstimeofday64(ts);
}

static inline void getrawmonotonic(struct timespec *ts)
{
	getrawmonotonic64(ts);
    1211:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
    1216:	e8 00 00 00 00       	callq  121b <dafs_rename+0x18b>
    121b:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
    1220:	48 2b 44 24 30       	sub    0x30(%rsp),%rax
    1225:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    122c:	48 2b 44 24 38       	sub    0x38(%rsp),%rax
    1231:	48 03 44 24 48       	add    0x48(%rsp),%rax
    1236:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 123e <dafs_rename+0x1ae>
    123d:	00 
    123e:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 1246 <dafs_rename+0x1b6>
    1245:	00 
    //nova_dbg("%s end",__func__);
	return 0;
    1246:	31 c0                	xor    %eax,%eax
    1248:	e9 01 ff ff ff       	jmpq   114e <dafs_rename+0xbe>
    124d:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
    1252:	e8 00 00 00 00       	callq  1257 <dafs_rename+0x1c7>
    1257:	e9 9a fe ff ff       	jmpq   10f6 <dafs_rename+0x66>
    125c:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
    1261:	e8 00 00 00 00       	callq  1266 <dafs_rename+0x1d6>
out:
	nova_err(sb, "%s return %d\n", __func__, err);
	NOVA_END_TIMING(rename_t, rename_time);
    1266:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
    126b:	48 2b 54 24 30       	sub    0x30(%rsp),%rdx
    1270:	8b 44 24 20          	mov    0x20(%rsp),%eax
    1274:	48 69 d2 00 ca 9a 3b 	imul   $0x3b9aca00,%rdx,%rdx
    127b:	48 2b 54 24 38       	sub    0x38(%rsp),%rdx
    1280:	48 03 54 24 48       	add    0x48(%rsp),%rdx
    1285:	65 48 01 15 00 00 00 	add    %rdx,%gs:0x0(%rip)        # 128d <dafs_rename+0x1fd>
    128c:	00 
    128d:	e9 b4 fe ff ff       	jmpq   1146 <dafs_rename+0xb6>
	NOVA_START_TIMING(rename_t, rename_time);

    /*检查rename的情况*/
    if(new_inode){
        err = -ENOMEM;
        if(S_ISDIR(old_inode->i_mode) && !dafs_empty_dir(new_inode, new_dentry))
    1292:	4c 89 fe             	mov    %r15,%rsi
    1295:	4c 89 e7             	mov    %r12,%rdi
    1298:	e8 00 00 00 00       	callq  129d <dafs_rename+0x20d>
    129d:	85 c0                	test   %eax,%eax
    129f:	75 0a                	jne    12ab <dafs_rename+0x21b>
			new_inode ? new_inode->i_ino : 0);
	NOVA_START_TIMING(rename_t, rename_time);

    /*检查rename的情况*/
    if(new_inode){
        err = -ENOMEM;
    12a1:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    12a6:	e9 6d fe ff ff       	jmpq   1118 <dafs_rename+0x88>
        }
    }

	
    /*文件夹要减少一个link*/
	if (S_ISDIR(old_inode->i_mode)) {
    12ab:	0f b7 03             	movzwl (%rbx),%eax
    12ae:	66 25 00 f0          	and    $0xf000,%ax
    12b2:	66 3d 00 40          	cmp    $0x4000,%ax
    12b6:	0f 85 50 fe ff ff    	jne    110c <dafs_rename+0x7c>
    if(S_ISDIR(old_inode->i_mode)){

        if(new_inode){
            /*first remove the old entry in the new directory
            * 新节点最多就是个空文件夹*/
            err = dafs_remove_dentry(new_dentry);
    12bc:	4c 89 ff             	mov    %r15,%rdi
    12bf:	e8 00 00 00 00       	callq  12c4 <dafs_rename+0x234>
            if (err)
    12c4:	85 c0                	test   %eax,%eax
    12c6:	0f 85 4c fe ff ff    	jne    1118 <dafs_rename+0x88>
                goto out;
        }
        err = __rename_dir_direntry(old_dentry, new_dentry);
    12cc:	4c 89 fe             	mov    %r15,%rsi
    12cf:	4c 89 ef             	mov    %r13,%rdi
    12d2:	e8 00 00 00 00       	callq  12d7 <dafs_rename+0x247>
        if(err)
    12d7:	85 c0                	test   %eax,%eax
    12d9:	0f 85 39 fe ff ff    	jne    1118 <dafs_rename+0x88>
   
    
    /*make log invalid*/
    //delete_dir_log(sb);
	
	if (inc_link)
    12df:	4d 85 e4             	test   %r12,%r12
    12e2:	75 0a                	jne    12ee <dafs_rename+0x25e>
		inc_nlink(new_dir);
    12e4:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    12e9:	e8 00 00 00 00       	callq  12ee <dafs_rename+0x25e>

    if (dec_link < 0)
		drop_nlink(old_dir);
    12ee:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
    12f3:	e8 00 00 00 00       	callq  12f8 <dafs_rename+0x268>
    12f8:	e9 95 fe ff ff       	jmpq   1192 <dafs_rename+0x102>
        if(S_ISDIR(old_inode->i_mode) && !dafs_empty_dir(new_inode, new_dentry))
            goto out;
    } else {
        if(S_ISDIR(old_inode->i_mode)){
            err = -EMLINK;
            if(new_dir->i_nlink >= NOVA_LINK_MAX)
    12fd:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    1302:	81 78 48 ff 7c 00 00 	cmpl   $0x7cff,0x48(%rax)
    1309:	76 c1                	jbe    12cc <dafs_rename+0x23c>
        err = -ENOMEM;
        if(S_ISDIR(old_inode->i_mode) && !dafs_empty_dir(new_inode, new_dentry))
            goto out;
    } else {
        if(S_ISDIR(old_inode->i_mode)){
            err = -EMLINK;
    130b:	b8 e1 ff ff ff       	mov    $0xffffffe1,%eax
    1310:	e9 03 fe ff ff       	jmpq   1118 <dafs_rename+0x88>
	if (new_inode) {
		new_pi = nova_get_inode(sb, new_inode);
		new_inode->i_ctime = CURRENT_TIME;

		if (S_ISDIR(old_inode->i_mode)) {
			if (new_inode->i_nlink)
    1315:	41 8b 4c 24 48       	mov    0x48(%r12),%ecx
    131a:	85 c9                	test   %ecx,%ecx
    131c:	0f 84 c8 fe ff ff    	je     11ea <dafs_rename+0x15a>
				drop_nlink(new_inode);
    1322:	4c 89 e7             	mov    %r12,%rdi
    1325:	e8 00 00 00 00       	callq  132a <dafs_rename+0x29a>
    132a:	e9 aa fe ff ff       	jmpq   11d9 <dafs_rename+0x149>
    //int change_parent = 0;
    //u64 journal_tail;
    timing_t rename_time;

    //nova_dbg("%s start", __func__); 
	nova_dbgv("%s: rename %s to %s,\n", __func__,
    132f:	48 8b 56 28          	mov    0x28(%rsi),%rdx
    1333:	48 8b 49 28          	mov    0x28(%rcx),%rcx
    1337:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    133e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1345:	e8 00 00 00 00       	callq  134a <dafs_rename+0x2ba>
			old_dentry->d_name.name, new_dentry->d_name.name);
	nova_dbgv("%s: %s inode %lu, old dir %lu, new dir %lu, new inode %lu\n",
    134a:	f6 05 00 00 00 00 10 	testb  $0x10,0x0(%rip)        # 1351 <dafs_rename+0x2c1>
    1351:	0f 84 91 fd ff ff    	je     10e8 <dafs_rename+0x58>
    1357:	4d 85 e4             	test   %r12,%r12
    135a:	74 6d                	je     13c9 <dafs_rename+0x339>
    135c:	49 8b 74 24 40       	mov    0x40(%r12),%rsi
    1361:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    1366:	48 8b 4b 40          	mov    0x40(%rbx),%rcx
    136a:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    1371:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1378:	48 8b 40 40          	mov    0x40(%rax),%rax
    137c:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    1381:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    1386:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9
    138b:	48 8b 40 40          	mov    0x40(%rax),%rax
    138f:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    1394:	0f b7 03             	movzwl (%rbx),%eax
    1397:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
    139c:	48 89 34 24          	mov    %rsi,(%rsp)
    13a0:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    13a7:	66 25 00 f0          	and    $0xf000,%ax
    13ab:	66 3d 00 40          	cmp    $0x4000,%ax
    13af:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
    13b6:	48 0f 44 d0          	cmove  %rax,%rdx
    13ba:	e8 00 00 00 00       	callq  13bf <dafs_rename+0x32f>
    13bf:	e9 24 fd ff ff       	jmpq   10e8 <dafs_rename+0x58>
	return 0;
out:
	nova_err(sb, "%s return %d\n", __func__, err);
	NOVA_END_TIMING(rename_t, rename_time);
	return err;
}
    13c4:	e8 00 00 00 00       	callq  13c9 <dafs_rename+0x339>
    timing_t rename_time;

    //nova_dbg("%s start", __func__); 
	nova_dbgv("%s: rename %s to %s,\n", __func__,
			old_dentry->d_name.name, new_dentry->d_name.name);
	nova_dbgv("%s: %s inode %lu, old dir %lu, new dir %lu, new inode %lu\n",
    13c9:	31 f6                	xor    %esi,%esi
    13cb:	eb 94                	jmp    1361 <dafs_rename+0x2d1>
    13cd:	0f 1f 00             	nopl   (%rax)

00000000000013d0 <dafs_rmdir>:
	goto out;
}


static int dafs_rmdir(struct inode *dir, struct dentry *dentry)
{
    13d0:	e8 00 00 00 00       	callq  13d5 <dafs_rmdir+0x5>
    13d5:	55                   	push   %rbp
    13d6:	48 89 e5             	mov    %rsp,%rbp
    13d9:	41 57                	push   %r15
    13db:	41 56                	push   %r14
    13dd:	41 55                	push   %r13
    13df:	41 54                	push   %r12
    13e1:	49 89 f5             	mov    %rsi,%r13
    13e4:	53                   	push   %rbx
    13e5:	49 89 fc             	mov    %rdi,%r12
    13e8:	48 83 ec 38          	sub    $0x38,%rsp
    //nova_dbg("%s:dafs start to rmdir",__func__);
    struct inode *inode = dentry->d_inode;
    13ec:	48 8b 5e 30          	mov    0x30(%rsi),%rbx
    struct dafs_dentry *de;
    struct super_block *sb = dir->i_sb;
    13f0:	4c 8b 77 28          	mov    0x28(%rdi),%r14
	goto out;
}


static int dafs_rmdir(struct inode *dir, struct dentry *dentry)
{
    13f4:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    13fb:	00 00 
    13fd:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    1402:	31 c0                	xor    %eax,%eax
    //struct dzt_entry_info *ei;
    //struct dzt_entry_info *dzt_eis[FREE_BATCH];
    //int nr=0, i, ret;
    //u64 ei_index = 0;

    nova_dbg("%s:dafs start to rmdir",__func__);
    1404:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    140b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
    1412:	48 8b 43 c8          	mov    -0x38(%rbx),%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    1416:	49 8b 96 b0 03 00 00 	mov    0x3b0(%r14),%rdx
    //nova_dbg("%s:dafs start to rmdir",__func__);
    struct inode *inode = dentry->d_inode;
    struct dafs_dentry *de;
    struct super_block *sb = dir->i_sb;
    struct nova_inode *pi = nova_get_inode(sb, inode), *pidir;
    u64 pidir_tail = 0, pi_tail = 0;
    141d:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
    1424:	00 00 
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    1426:	49 89 c7             	mov    %rax,%r15
    1429:	4c 03 7a 18          	add    0x18(%rdx),%r15
    142d:	48 85 c0             	test   %rax,%rax
    1430:	b8 00 00 00 00       	mov    $0x0,%eax
    1435:	4c 0f 44 f8          	cmove  %rax,%r15
    //struct dzt_entry_info *ei;
    //struct dzt_entry_info *dzt_eis[FREE_BATCH];
    //int nr=0, i, ret;
    //u64 ei_index = 0;

    nova_dbg("%s:dafs start to rmdir",__func__);
    1439:	e8 00 00 00 00       	callq  143e <dafs_rmdir+0x6e>
	NOVA_START_TIMING(rmdir_t, rmdir_time);
    143e:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # 1444 <dafs_rmdir+0x74>
    1444:	85 c9                	test   %ecx,%ecx
    1446:	0f 85 62 01 00 00    	jne    15ae <dafs_rmdir+0x1de>
	if (!inode){
    144c:	48 85 db             	test   %rbx,%rbx
    144f:	0f 84 a6 01 00 00    	je     15fb <dafs_rmdir+0x22b>
        BUG();
		return -ENOENT;
    }

	nova_dbg("%s: name %s\n", __func__, dentry->d_name.name);
    1455:	49 8b 55 28          	mov    0x28(%r13),%rdx
    1459:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1460:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1467:	e8 00 00 00 00       	callq  146c <dafs_rmdir+0x9c>
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
    146c:	49 8b 44 24 c8       	mov    -0x38(%r12),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    1471:	48 85 c0             	test   %rax,%rax
    1474:	0f 84 7f 01 00 00    	je     15f9 <dafs_rmdir+0x229>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    147a:	49 8b 96 b0 03 00 00 	mov    0x3b0(%r14),%rdx
	pidir = nova_get_inode(sb, dir);
	if (!pidir){
    1481:	48 03 42 18          	add    0x18(%rdx),%rax
    1485:	48 89 04 24          	mov    %rax,(%rsp)
    1489:	0f 84 6a 01 00 00    	je     15f9 <dafs_rmdir+0x229>
    struct super_block *sb = dir->i_sb;
    struct dafs_dentry *direntry;
    u64 ino;
   
    //nova_dbg("%s: start-- dentry is %s ",__func__, dentry->d_name.name);
    direntry = dafs_find_direntry(sb, dentry,1,0);
    148f:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
    1494:	31 c9                	xor    %ecx,%ecx
    1496:	ba 01 00 00 00       	mov    $0x1,%edx
    149b:	4c 89 ee             	mov    %r13,%rsi
    149e:	e8 00 00 00 00       	callq  14a3 <dafs_rmdir+0xd3>
    if(direntry == NULL) { 
    14a3:	48 85 c0             	test   %rax,%rax
    14a6:	0f 84 51 01 00 00    	je     15fd <dafs_rmdir+0x22d>
        BUG();
		return -EINVAL;
    }
    //nova_dbg("%s:dafs start to rmdir",__func__);
    /*not sure to add read hot degree*/
    if(dafs_inode_by_name(dir, dentry, &de) == 0){
    14ac:	48 83 78 18 00       	cmpq   $0x0,0x18(%rax)
    14b1:	0f 84 46 01 00 00    	je     15fd <dafs_rmdir+0x22d>
        nova_dbg("%s dentry name, %s", __func__, dentry->d_name.name);
        BUG();
        return -ENOENT;
    }
    if(!dafs_empty_dir(inode, dentry)){
    14b7:	4c 89 ee             	mov    %r13,%rsi
    14ba:	48 89 df             	mov    %rbx,%rdi
    14bd:	e8 00 00 00 00       	callq  14c2 <dafs_rmdir+0xf2>
    14c2:	85 c0                	test   %eax,%eax
    14c4:	0f 84 4c 01 00 00    	je     1616 <dafs_rmdir+0x246>
        BUG();
        return err;
    }
    
    
	nova_dbg("%s: inode %lu, dir %lu, link %d\n", __func__,
    14ca:	48 8b 53 40          	mov    0x40(%rbx),%rdx
    14ce:	49 8b 4c 24 40       	mov    0x40(%r12),%rcx
    14d3:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    14da:	45 8b 44 24 48       	mov    0x48(%r12),%r8d
    14df:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    14e6:	e8 00 00 00 00       	callq  14eb <dafs_rmdir+0x11b>
				inode->i_ino, dir->i_ino, dir->i_nlink);

	if (inode->i_nlink != 2)
    14eb:	8b 53 48             	mov    0x48(%rbx),%edx
    14ee:	83 fa 02             	cmp    $0x2,%edx
    14f1:	74 0d                	je     1500 <dafs_rmdir+0x130>
		nova_dbgv("empty directory %lu has nlink!=2 (%d), dir %lu",
    14f3:	f6 05 00 00 00 00 10 	testb  $0x10,0x0(%rip)        # 14fa <dafs_rmdir+0x12a>
    14fa:	0f 85 1d 01 00 00    	jne    161d <dafs_rmdir+0x24d>
				inode->i_ino, inode->i_nlink, dir->i_ino);

    /*add log to dzt for suddenly shut down*/
    //record_dir_log(sb, dentry, NULL, DIR_RMDIR);
    err = dafs_rm_dir(dentry, -1);
    1500:	4c 89 ef             	mov    %r13,%rdi
    1503:	be ff ff ff ff       	mov    $0xffffffff,%esi
    1508:	e8 00 00 00 00       	callq  150d <dafs_rmdir+0x13d>

	if (err)
    150d:	85 c0                	test   %eax,%eax
		nova_dbgv("empty directory %lu has nlink!=2 (%d), dir %lu",
				inode->i_ino, inode->i_nlink, dir->i_ino);

    /*add log to dzt for suddenly shut down*/
    //record_dir_log(sb, dentry, NULL, DIR_RMDIR);
    err = dafs_rm_dir(dentry, -1);
    150f:	41 89 c5             	mov    %eax,%r13d

	if (err)
    1512:	75 4d                	jne    1561 <dafs_rmdir+0x191>
		goto end_rmdir;

	/*inode->i_version++; */
	clear_nlink(inode);
    1514:	48 89 df             	mov    %rbx,%rdi
    1517:	e8 00 00 00 00       	callq  151c <dafs_rmdir+0x14c>
	inode->i_ctime = dir->i_ctime;
    151c:	49 8b 94 24 80 00 00 	mov    0x80(%r12),%rdx
    1523:	00 
    1524:	49 8b 44 24 78       	mov    0x78(%r12),%rax
    1529:	48 89 93 80 00 00 00 	mov    %rdx,0x80(%rbx)
    1530:	48 89 43 78          	mov    %rax,0x78(%rbx)

	if (dir->i_nlink)
    1534:	41 8b 54 24 48       	mov    0x48(%r12),%edx
    1539:	85 d2                	test   %edx,%edx
    153b:	0f 85 ab 00 00 00    	jne    15ec <dafs_rmdir+0x21c>

    /*finish log make it invalid*/
    //delete_dir_log(sb);

    /* not decided*/
    err = dafs_append_link_change_entry(sb, pi, inode, 0, &pi_tail);
    1541:	4c 8d 44 24 08       	lea    0x8(%rsp),%r8
    1546:	31 c9                	xor    %ecx,%ecx
    1548:	48 89 da             	mov    %rbx,%rdx
    154b:	4c 89 fe             	mov    %r15,%rsi
    154e:	4c 89 f7             	mov    %r14,%rdi
    1551:	e8 00 00 00 00       	callq  1556 <dafs_rmdir+0x186>
	if (err)
    1556:	85 c0                	test   %eax,%eax

    /*finish log make it invalid*/
    //delete_dir_log(sb);

    /* not decided*/
    err = dafs_append_link_change_entry(sb, pi, inode, 0, &pi_tail);
    1558:	41 89 c5             	mov    %eax,%r13d
	if (err)
    155b:	0f 84 d6 00 00 00    	je     1637 <dafs_rmdir+0x267>
        }while(nr==FREE_BATCH);*/
    nova_dbg("%s:dafs end rmdir",__func__);
	return err;

end_rmdir:
	nova_err(sb, "%s return %d\n", __func__, err);
    1561:	44 89 e9             	mov    %r13d,%ecx
    1564:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    156b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1572:	4c 89 f7             	mov    %r14,%rdi
    1575:	e8 00 00 00 00       	callq  157a <dafs_rmdir+0x1aa>
	NOVA_END_TIMING(rmdir_t, rmdir_time);
    157a:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 1580 <dafs_rmdir+0x1b0>
    1580:	85 c0                	test   %eax,%eax
    1582:	75 39                	jne    15bd <dafs_rmdir+0x1ed>
    1584:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 158c <dafs_rmdir+0x1bc>
    158b:	00 
	return err;
}
    158c:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
    1591:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
    1598:	00 00 
    159a:	44 89 e8             	mov    %r13d,%eax
    159d:	75 79                	jne    1618 <dafs_rmdir+0x248>
    159f:	48 83 c4 38          	add    $0x38,%rsp
    15a3:	5b                   	pop    %rbx
    15a4:	41 5c                	pop    %r12
    15a6:	41 5d                	pop    %r13
    15a8:	41 5e                	pop    %r14
    15aa:	41 5f                	pop    %r15
    15ac:	5d                   	pop    %rbp
    15ad:	c3                   	retq   
    15ae:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    15b3:	e8 00 00 00 00       	callq  15b8 <dafs_rmdir+0x1e8>
    15b8:	e9 8f fe ff ff       	jmpq   144c <dafs_rmdir+0x7c>
    15bd:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
    15c2:	e8 00 00 00 00       	callq  15c7 <dafs_rmdir+0x1f7>
    nova_dbg("%s:dafs end rmdir",__func__);
	return err;

end_rmdir:
	nova_err(sb, "%s return %d\n", __func__, err);
	NOVA_END_TIMING(rmdir_t, rmdir_time);
    15c7:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    15cc:	48 2b 44 24 10       	sub    0x10(%rsp),%rax
    15d1:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    15d8:	48 2b 44 24 18       	sub    0x18(%rsp),%rax
    15dd:	48 03 44 24 28       	add    0x28(%rsp),%rax
    15e2:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 15ea <dafs_rmdir+0x21a>
    15e9:	00 
    15ea:	eb 98                	jmp    1584 <dafs_rmdir+0x1b4>
	/*inode->i_version++; */
	clear_nlink(inode);
	inode->i_ctime = dir->i_ctime;

	if (dir->i_nlink)
		drop_nlink(dir);
    15ec:	4c 89 e7             	mov    %r12,%rdi
    15ef:	e8 00 00 00 00       	callq  15f4 <dafs_rmdir+0x224>
    15f4:	e9 48 ff ff ff       	jmpq   1541 <dafs_rmdir+0x171>
    }

	nova_dbg("%s: name %s\n", __func__, dentry->d_name.name);
	pidir = nova_get_inode(sb, dir);
	if (!pidir){
        BUG();
    15f9:	0f 0b                	ud2    
    //u64 ei_index = 0;

    nova_dbg("%s:dafs start to rmdir",__func__);
	NOVA_START_TIMING(rmdir_t, rmdir_time);
	if (!inode){
        BUG();
    15fb:	0f 0b                	ud2    
		return -EINVAL;
    }
    //nova_dbg("%s:dafs start to rmdir",__func__);
    /*not sure to add read hot degree*/
    if(dafs_inode_by_name(dir, dentry, &de) == 0){
        nova_dbg("%s dentry name, %s", __func__, dentry->d_name.name);
    15fd:	49 8b 55 28          	mov    0x28(%r13),%rdx
    1601:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1608:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    160f:	e8 00 00 00 00       	callq  1614 <dafs_rmdir+0x244>
        BUG();
    1614:	0f 0b                	ud2    
        return -ENOENT;
    }
    if(!dafs_empty_dir(inode, dentry)){
        BUG();
    1616:	0f 0b                	ud2    

end_rmdir:
	nova_err(sb, "%s return %d\n", __func__, err);
	NOVA_END_TIMING(rmdir_t, rmdir_time);
	return err;
}
    1618:	e8 00 00 00 00       	callq  161d <dafs_rmdir+0x24d>
    
	nova_dbg("%s: inode %lu, dir %lu, link %d\n", __func__,
				inode->i_ino, dir->i_ino, dir->i_nlink);

	if (inode->i_nlink != 2)
		nova_dbgv("empty directory %lu has nlink!=2 (%d), dir %lu",
    161d:	49 8b 4c 24 40       	mov    0x40(%r12),%rcx
    1622:	48 8b 73 40          	mov    0x40(%rbx),%rsi
    1626:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    162d:	e8 00 00 00 00       	callq  1632 <dafs_rmdir+0x262>
    1632:	e9 c9 fe ff ff       	jmpq   1500 <dafs_rmdir+0x130>
		goto end_rmdir;


    //pidir_tail = pidir->log_tail;

	dafs_lite_transaction_for_time_and_link(sb, pi, pidir,
    1637:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    163c:	48 8b 14 24          	mov    (%rsp),%rdx
    1640:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    1646:	4c 89 fe             	mov    %r15,%rsi
    1649:	4c 89 f7             	mov    %r14,%rdi
    164c:	e8 8f f4 ff ff       	callq  ae0 <dafs_lite_transaction_for_time_and_link.constprop.4>
						pi_tail, pidir_tail, 1);

	NOVA_END_TIMING(rmdir_t, rmdir_time);
    1651:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 1658 <dafs_rmdir+0x288>
    1658:	74 2d                	je     1687 <dafs_rmdir+0x2b7>
    165a:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
    165f:	e8 00 00 00 00       	callq  1664 <dafs_rmdir+0x294>
    1664:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    1669:	48 2b 44 24 10       	sub    0x10(%rsp),%rax
    166e:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    1675:	48 2b 44 24 18       	sub    0x18(%rsp),%rax
    167a:	48 03 44 24 28       	add    0x28(%rsp),%rax
    167f:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 1687 <dafs_rmdir+0x2b7>
    1686:	00 
                if(ret)
                    return -EINVAL;
            }
            ei_index ++;
        }while(nr==FREE_BATCH);*/
    nova_dbg("%s:dafs end rmdir",__func__);
    1687:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    168e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    //pidir_tail = pidir->log_tail;

	dafs_lite_transaction_for_time_and_link(sb, pi, pidir,
						pi_tail, pidir_tail, 1);

	NOVA_END_TIMING(rmdir_t, rmdir_time);
    1695:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 169d <dafs_rmdir+0x2cd>
    169c:	00 
                if(ret)
                    return -EINVAL;
            }
            ei_index ++;
        }while(nr==FREE_BATCH);*/
    nova_dbg("%s:dafs end rmdir",__func__);
    169d:	e8 00 00 00 00       	callq  16a2 <dafs_rmdir+0x2d2>
	return err;
    16a2:	e9 e5 fe ff ff       	jmpq   158c <dafs_rmdir+0x1bc>
    16a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    16ae:	00 00 

00000000000016b0 <dafs_unlink>:
	return err;

}

static int dafs_unlink(struct inode *dir, struct dentry *dentry)
{
    16b0:	e8 00 00 00 00       	callq  16b5 <dafs_unlink+0x5>
    16b5:	55                   	push   %rbp
    16b6:	48 89 e5             	mov    %rsp,%rbp
    16b9:	41 57                	push   %r15
    16bb:	41 56                	push   %r14
    16bd:	41 55                	push   %r13
    16bf:	41 54                	push   %r12
    16c1:	49 89 ff             	mov    %rdi,%r15
    16c4:	53                   	push   %rbx
    16c5:	48 89 f3             	mov    %rsi,%rbx
    16c8:	48 83 ec 38          	sub    $0x38,%rsp
    struct inode *inode = dentry->d_inode;
    struct super_block *sb = dir->i_sb;
    16cc:	4c 8b 67 28          	mov    0x28(%rdi),%r12

}

static int dafs_unlink(struct inode *dir, struct dentry *dentry)
{
    struct inode *inode = dentry->d_inode;
    16d0:	4c 8b 4e 30          	mov    0x30(%rsi),%r9
	return err;

}

static int dafs_unlink(struct inode *dir, struct dentry *dentry)
{
    16d4:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    16db:	00 00 
    16dd:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    16e2:	31 c0                	xor    %eax,%eax
    int invalidate = 0;
    timing_t unlink_time;

    //nova_dbg("%s start", __func__);
    //BUG();
	NOVA_START_TIMING(unlink_t, unlink_time);
    16e4:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # 16ea <dafs_unlink+0x3a>
    16ea:	49 8b 94 24 b0 03 00 	mov    0x3b0(%r12),%rdx
    16f1:	00 
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
    16f2:	49 8b 41 c8          	mov    -0x38(%r9),%rax
    struct inode *inode = dentry->d_inode;
    struct super_block *sb = dir->i_sb;
    int retval = -ENOMEM;
    struct nova_inode *pi = nova_get_inode(sb, inode);
    struct nova_inode *pidir;
    u64 pidir_tail = 0, pi_tail = 0;
    16f6:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
    16fd:	00 00 
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    16ff:	48 8b 52 18          	mov    0x18(%rdx),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    1703:	48 85 c0             	test   %rax,%rax
    1706:	4c 8d 2c 02          	lea    (%rdx,%rax,1),%r13
    170a:	b8 00 00 00 00       	mov    $0x0,%eax
    170f:	4c 0f 44 e8          	cmove  %rax,%r13
    int invalidate = 0;
    timing_t unlink_time;

    //nova_dbg("%s start", __func__);
    //BUG();
	NOVA_START_TIMING(unlink_t, unlink_time);
    1713:	85 c9                	test   %ecx,%ecx
    1715:	0f 85 34 01 00 00    	jne    184f <dafs_unlink+0x19f>
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
    171b:	4d 8b 77 c8          	mov    -0x38(%r15),%r14
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    171f:	4d 85 f6             	test   %r14,%r14
    1722:	74 77                	je     179b <dafs_unlink+0xeb>

	pidir = nova_get_inode(sb, dir);
	if (!pidir)
    1724:	49 01 d6             	add    %rdx,%r14
    1727:	74 72                	je     179b <dafs_unlink+0xeb>
		goto out;

	nova_dbgv("%s: %s\n", __func__, dentry->d_name.name);
    1729:	f6 05 00 00 00 00 10 	testb  $0x10,0x0(%rip)        # 1730 <dafs_unlink+0x80>
    1730:	0f 85 8e 01 00 00    	jne    18c4 <dafs_unlink+0x214>
	nova_dbgv("%s: inode %lu, dir %lu\n", __func__,
				inode->i_ino, dir->i_ino);
    //注意更改tail
    retval = dafs_remove_dentry(dentry);
    1736:	48 89 df             	mov    %rbx,%rdi
    1739:	4c 89 0c 24          	mov    %r9,(%rsp)
    173d:	e8 00 00 00 00       	callq  1742 <dafs_unlink+0x92>

	if (retval)
    1742:	85 c0                	test   %eax,%eax

	nova_dbgv("%s: %s\n", __func__, dentry->d_name.name);
	nova_dbgv("%s: inode %lu, dir %lu\n", __func__,
				inode->i_ino, dir->i_ino);
    //注意更改tail
    retval = dafs_remove_dentry(dentry);
    1744:	89 c3                	mov    %eax,%ebx

	if (retval)
    1746:	74 5a                	je     17a2 <dafs_unlink+0xf2>

	NOVA_END_TIMING(unlink_t, unlink_time);
	return 0;

out:
	nova_err(sb, "%s return %d\n", __func__, retval);
    1748:	89 d9                	mov    %ebx,%ecx
    174a:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    1751:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1758:	4c 89 e7             	mov    %r12,%rdi
    175b:	e8 00 00 00 00       	callq  1760 <dafs_unlink+0xb0>
	NOVA_END_TIMING(unlink_t, unlink_time);
    1760:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 1766 <dafs_unlink+0xb6>
    1766:	85 c0                	test   %eax,%eax
    1768:	0f 85 04 01 00 00    	jne    1872 <dafs_unlink+0x1c2>
    //nova_dbg("%s end",__func__);
	return retval;
    176e:	89 d8                	mov    %ebx,%eax
	NOVA_END_TIMING(unlink_t, unlink_time);
	return 0;

out:
	nova_err(sb, "%s return %d\n", __func__, retval);
	NOVA_END_TIMING(unlink_t, unlink_time);
    1770:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 1778 <dafs_unlink+0xc8>
    1777:	00 
    //nova_dbg("%s end",__func__);
	return retval;
}
    1778:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
    177d:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
    1784:	00 00 
    1786:	0f 85 33 01 00 00    	jne    18bf <dafs_unlink+0x20f>
    178c:	48 83 c4 38          	add    $0x38,%rsp
    1790:	5b                   	pop    %rbx
    1791:	41 5c                	pop    %r12
    1793:	41 5d                	pop    %r13
    1795:	41 5e                	pop    %r14
    1797:	41 5f                	pop    %r15
    1799:	5d                   	pop    %rbp
    179a:	c3                   	retq   

static int dafs_unlink(struct inode *dir, struct dentry *dentry)
{
    struct inode *inode = dentry->d_inode;
    struct super_block *sb = dir->i_sb;
    int retval = -ENOMEM;
    179b:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
    17a0:	eb a6                	jmp    1748 <dafs_unlink+0x98>
    retval = dafs_remove_dentry(dentry);

	if (retval)
		goto out;

	inode->i_ctime = dir->i_ctime;
    17a2:	49 8b 47 78          	mov    0x78(%r15),%rax
    17a6:	4c 8b 0c 24          	mov    (%rsp),%r9
    17aa:	49 8b 97 80 00 00 00 	mov    0x80(%r15),%rdx
    17b1:	49 89 41 78          	mov    %rax,0x78(%r9)

	if (inode->i_nlink == 1)
    17b5:	41 8b 41 48          	mov    0x48(%r9),%eax
    retval = dafs_remove_dentry(dentry);

	if (retval)
		goto out;

	inode->i_ctime = dir->i_ctime;
    17b9:	49 89 91 80 00 00 00 	mov    %rdx,0x80(%r9)

	if (inode->i_nlink == 1)
    17c0:	83 f8 01             	cmp    $0x1,%eax
    17c3:	0f 84 db 00 00 00    	je     18a4 <dafs_unlink+0x1f4>
    struct super_block *sb = dir->i_sb;
    int retval = -ENOMEM;
    struct nova_inode *pi = nova_get_inode(sb, inode);
    struct nova_inode *pidir;
    u64 pidir_tail = 0, pi_tail = 0;
    int invalidate = 0;
    17c9:	45 31 ff             	xor    %r15d,%r15d
	inode->i_ctime = dir->i_ctime;

	if (inode->i_nlink == 1)
		invalidate = 1;

	if (inode->i_nlink) {
    17cc:	85 c0                	test   %eax,%eax
    17ce:	0f 85 d6 00 00 00    	jne    18aa <dafs_unlink+0x1fa>
		drop_nlink(inode);
	}

    /*not decided 返回值没有弄好*/
    retval = dafs_append_link_change_entry(sb, pi, inode, 0, &pi_tail);
    17d4:	4c 8d 44 24 08       	lea    0x8(%rsp),%r8
    17d9:	31 c9                	xor    %ecx,%ecx
    17db:	4c 89 ca             	mov    %r9,%rdx
    17de:	4c 89 ee             	mov    %r13,%rsi
    17e1:	4c 89 e7             	mov    %r12,%rdi
    17e4:	e8 00 00 00 00       	callq  17e9 <dafs_unlink+0x139>
	if (retval)
    17e9:	85 c0                	test   %eax,%eax
	if (inode->i_nlink) {
		drop_nlink(inode);
	}

    /*not decided 返回值没有弄好*/
    retval = dafs_append_link_change_entry(sb, pi, inode, 0, &pi_tail);
    17eb:	89 c3                	mov    %eax,%ebx
	if (retval)
    17ed:	0f 85 55 ff ff ff    	jne    1748 <dafs_unlink+0x98>
		goto out;

	dafs_lite_transaction_for_time_and_link(sb, pi, pidir,
    17f3:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    17f8:	4c 89 f2             	mov    %r14,%rdx
    17fb:	45 89 f8             	mov    %r15d,%r8d
    17fe:	4c 89 ee             	mov    %r13,%rsi
    1801:	4c 89 e7             	mov    %r12,%rdi
    1804:	e8 d7 f2 ff ff       	callq  ae0 <dafs_lite_transaction_for_time_and_link.constprop.4>
					pi_tail, pidir_tail, invalidate);

	NOVA_END_TIMING(unlink_t, unlink_time);
    1809:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 180f <dafs_unlink+0x15f>
    180f:	85 d2                	test   %edx,%edx
    1811:	74 2d                	je     1840 <dafs_unlink+0x190>
    1813:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
    1818:	e8 00 00 00 00       	callq  181d <dafs_unlink+0x16d>
    181d:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    1822:	48 2b 44 24 10       	sub    0x10(%rsp),%rax
    1827:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    182e:	48 2b 44 24 18       	sub    0x18(%rsp),%rax
    1833:	48 03 44 24 28       	add    0x28(%rsp),%rax
    1838:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 1840 <dafs_unlink+0x190>
    183f:	00 
    1840:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 1848 <dafs_unlink+0x198>
    1847:	00 
	return 0;
    1848:	31 c0                	xor    %eax,%eax
    184a:	e9 29 ff ff ff       	jmpq   1778 <dafs_unlink+0xc8>
    184f:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    1854:	4c 89 0c 24          	mov    %r9,(%rsp)
    1858:	e8 00 00 00 00       	callq  185d <dafs_unlink+0x1ad>
    185d:	49 8b 84 24 b0 03 00 	mov    0x3b0(%r12),%rax
    1864:	00 
    1865:	4c 8b 0c 24          	mov    (%rsp),%r9
    1869:	48 8b 50 18          	mov    0x18(%rax),%rdx
    186d:	e9 a9 fe ff ff       	jmpq   171b <dafs_unlink+0x6b>
    1872:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
    1877:	e8 00 00 00 00       	callq  187c <dafs_unlink+0x1cc>

out:
	nova_err(sb, "%s return %d\n", __func__, retval);
	NOVA_END_TIMING(unlink_t, unlink_time);
    187c:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    1881:	48 2b 44 24 10       	sub    0x10(%rsp),%rax
    1886:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    188d:	48 2b 44 24 18       	sub    0x18(%rsp),%rax
    1892:	48 03 44 24 28       	add    0x28(%rsp),%rax
    1897:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 189f <dafs_unlink+0x1ef>
    189e:	00 
    189f:	e9 ca fe ff ff       	jmpq   176e <dafs_unlink+0xbe>
		goto out;

	inode->i_ctime = dir->i_ctime;

	if (inode->i_nlink == 1)
		invalidate = 1;
    18a4:	41 bf 01 00 00 00    	mov    $0x1,%r15d

	if (inode->i_nlink) {
		drop_nlink(inode);
    18aa:	4c 89 cf             	mov    %r9,%rdi
    18ad:	4c 89 0c 24          	mov    %r9,(%rsp)
    18b1:	e8 00 00 00 00       	callq  18b6 <dafs_unlink+0x206>
    18b6:	4c 8b 0c 24          	mov    (%rsp),%r9
    18ba:	e9 15 ff ff ff       	jmpq   17d4 <dafs_unlink+0x124>
out:
	nova_err(sb, "%s return %d\n", __func__, retval);
	NOVA_END_TIMING(unlink_t, unlink_time);
    //nova_dbg("%s end",__func__);
	return retval;
}
    18bf:	e8 00 00 00 00       	callq  18c4 <dafs_unlink+0x214>

	pidir = nova_get_inode(sb, dir);
	if (!pidir)
		goto out;

	nova_dbgv("%s: %s\n", __func__, dentry->d_name.name);
    18c4:	48 8b 53 28          	mov    0x28(%rbx),%rdx
    18c8:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    18cf:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    18d6:	4c 89 0c 24          	mov    %r9,(%rsp)
    18da:	e8 00 00 00 00       	callq  18df <dafs_unlink+0x22f>
	nova_dbgv("%s: inode %lu, dir %lu\n", __func__,
    18df:	f6 05 00 00 00 00 10 	testb  $0x10,0x0(%rip)        # 18e6 <dafs_unlink+0x236>
    18e6:	4c 8b 0c 24          	mov    (%rsp),%r9
    18ea:	0f 84 46 fe ff ff    	je     1736 <dafs_unlink+0x86>
    18f0:	49 8b 51 40          	mov    0x40(%r9),%rdx
    18f4:	49 8b 4f 40          	mov    0x40(%r15),%rcx
    18f8:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    18ff:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1906:	e8 00 00 00 00       	callq  190b <dafs_unlink+0x25b>
    190b:	4c 8b 0c 24          	mov    (%rsp),%r9
    190f:	e9 22 fe ff ff       	jmpq   1736 <dafs_unlink+0x86>
    1914:	66 90                	xchg   %ax,%ax
    1916:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    191d:	00 00 00 

0000000000001920 <dafs_link>:
	pi->i_generation	= entry->generation;

	/* Do not flush now */
}
static int dafs_link(struct dentry *dest_dentry, struct inode *dir, struct dentry *dentry)
{
    1920:	e8 00 00 00 00       	callq  1925 <dafs_link+0x5>
    1925:	55                   	push   %rbp
    1926:	48 89 e5             	mov    %rsp,%rbp
    1929:	41 57                	push   %r15
    192b:	41 56                	push   %r14
    192d:	41 55                	push   %r13
    192f:	41 54                	push   %r12
    1931:	49 89 f6             	mov    %rsi,%r14
    1934:	53                   	push   %rbx
    1935:	48 83 ec 40          	sub    $0x40,%rsp
    struct super_block *sb = dir->i_sb;
    1939:	4c 8b 6e 28          	mov    0x28(%rsi),%r13
	pi->i_generation	= entry->generation;

	/* Do not flush now */
}
static int dafs_link(struct dentry *dest_dentry, struct inode *dir, struct dentry *dentry)
{
    193d:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
    struct super_block *sb = dir->i_sb;
    struct inode *inode = dest_dentry->d_inode;
    1941:	4c 8b 7f 30          	mov    0x30(%rdi),%r15
	pi->i_generation	= entry->generation;

	/* Do not flush now */
}
static int dafs_link(struct dentry *dest_dentry, struct inode *dir, struct dentry *dentry)
{
    1945:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
    1949:	65 48 8b 0c 25 28 00 	mov    %gs:0x28,%rcx
    1950:	00 00 
    1952:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    1956:	31 c9                	xor    %ecx,%ecx
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    1958:	49 8b 95 b0 03 00 00 	mov    0x3b0(%r13),%rdx
    int err = -ENOMEM;
    timing_t link_time;
    int file_type;

    //nova_dbg("%s start",__func__);
    NOVA_START_TIMING(link_t, link_time);
    195f:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # 1965 <dafs_link+0x45>
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
    1965:	49 8b 47 c8          	mov    -0x38(%r15),%rax
    struct super_block *sb = dir->i_sb;
    struct inode *inode = dest_dentry->d_inode;
    //struct inode *src_inode = dentry->d_inode;
    struct nova_inode *pi = nova_get_inode(sb, inode);
    struct nova_inode *pidir;
    u64 pidir_tail = 0, pi_tail = 0;
    1969:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
    1970:	00 
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    1971:	4c 8b 62 18          	mov    0x18(%rdx),%r12
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    1975:	48 85 c0             	test   %rax,%rax
    1978:	49 8d 1c 04          	lea    (%r12,%rax,1),%rbx
    197c:	b8 00 00 00 00       	mov    $0x0,%eax
    1981:	48 0f 44 d8          	cmove  %rax,%rbx
    int err = -ENOMEM;
    timing_t link_time;
    int file_type;

    //nova_dbg("%s start",__func__);
    NOVA_START_TIMING(link_t, link_time);
    1985:	85 c9                	test   %ecx,%ecx
    1987:	0f 85 19 01 00 00    	jne    1aa6 <dafs_link+0x186>
    
	if (inode->i_nlink >= NOVA_LINK_MAX) {
    198d:	41 81 7f 48 ff 7c 00 	cmpl   $0x7cff,0x48(%r15)
    1994:	00 
    1995:	0f 87 6c 01 00 00    	ja     1b07 <dafs_link+0x1e7>
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
    199b:	48 8b 56 c8          	mov    -0x38(%rsi),%rdx
		goto out;
	}

	pidir = nova_get_inode(sb, dir);
	if (!pidir) {
		err = -EINVAL;
    199f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    19a4:	48 85 d2             	test   %rdx,%rdx
    19a7:	0f 84 88 00 00 00    	je     1a35 <dafs_link+0x115>
		err = -EMLINK;
		goto out;
	}

	pidir = nova_get_inode(sb, dir);
	if (!pidir) {
    19ad:	49 01 d4             	add    %rdx,%r12
    19b0:	0f 84 ba 01 00 00    	je     1b70 <dafs_link+0x250>
		err = -EINVAL;
		goto out;
	}

	ihold(inode);
    19b6:	4c 89 ff             	mov    %r15,%rdi
    19b9:	e8 00 00 00 00       	callq  19be <dafs_link+0x9e>
	nova_dbgv("%s: name %s, dest %s\n", __func__,
    19be:	f6 05 00 00 00 00 10 	testb  $0x10,0x0(%rip)        # 19c5 <dafs_link+0xa5>
    19c5:	0f 85 50 01 00 00    	jne    1b1b <dafs_link+0x1fb>
    if(S_ISDIR(inode->i_mode))
        file_type = 1;
    else 
        file_type = 0;

    err = dafs_add_dentry(dentry, inode->i_ino, 0, file_type);
    19cb:	41 0f b7 07          	movzwl (%r15),%eax
    19cf:	49 8b 77 40          	mov    0x40(%r15),%rsi
    19d3:	31 c9                	xor    %ecx,%ecx
    19d5:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    19d9:	66 25 00 f0          	and    $0xf000,%ax
    19dd:	66 3d 00 40          	cmp    $0x4000,%ax
    19e1:	0f 94 c1             	sete   %cl
    19e4:	31 d2                	xor    %edx,%edx
    19e6:	e8 00 00 00 00       	callq  19eb <dafs_link+0xcb>
	if (err) {
    19eb:	85 c0                	test   %eax,%eax
    19ed:	89 45 98             	mov    %eax,-0x68(%rbp)
    19f0:	74 6d                	je     1a5f <dafs_link+0x13f>
		iput(inode);
    19f2:	4c 89 ff             	mov    %r15,%rdi
    19f5:	e8 00 00 00 00       	callq  19fa <dafs_link+0xda>
		goto out;
    19fa:	8b 45 98             	mov    -0x68(%rbp),%eax
    /*pidir_tail not been changed*/
	dafs_lite_transaction_for_time_and_link(sb, pi, pidir,
						pi_tail, pidir_tail, 0);

out:
	NOVA_END_TIMING(link_t, link_time);
    19fd:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 1a03 <dafs_link+0xe3>
    1a03:	85 d2                	test   %edx,%edx
    1a05:	74 2e                	je     1a35 <dafs_link+0x115>
    1a07:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
    1a0b:	89 45 a0             	mov    %eax,-0x60(%rbp)
    1a0e:	e8 00 00 00 00       	callq  1a13 <dafs_link+0xf3>
    1a13:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
    1a17:	48 2b 55 b0          	sub    -0x50(%rbp),%rdx
    1a1b:	8b 45 a0             	mov    -0x60(%rbp),%eax
    1a1e:	48 69 d2 00 ca 9a 3b 	imul   $0x3b9aca00,%rdx,%rdx
    1a25:	48 2b 55 b8          	sub    -0x48(%rbp),%rdx
    1a29:	48 03 55 c8          	add    -0x38(%rbp),%rdx
    1a2d:	65 48 01 15 00 00 00 	add    %rdx,%gs:0x0(%rip)        # 1a35 <dafs_link+0x115>
    1a34:	00 
    1a35:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 1a3d <dafs_link+0x11d>
    1a3c:	00 
    //nova_dbg("%s end",__func__);
	return err;

}
    1a3d:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    1a41:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    1a48:	00 00 
    1a4a:	0f 85 1b 01 00 00    	jne    1b6b <dafs_link+0x24b>
    1a50:	48 83 c4 40          	add    $0x40,%rsp
    1a54:	5b                   	pop    %rbx
    1a55:	41 5c                	pop    %r12
    1a57:	41 5d                	pop    %r13
    1a59:	41 5e                	pop    %r14
    1a5b:	41 5f                	pop    %r15
    1a5d:	5d                   	pop    %rbp
    1a5e:	c3                   	retq   
	if (err) {
		iput(inode);
		goto out;
	}

	inode->i_ctime = CURRENT_TIME_SEC;
    1a5f:	e8 00 00 00 00       	callq  1a64 <dafs_link+0x144>
	inc_nlink(inode);
    1a64:	4c 89 ff             	mov    %r15,%rdi
	if (err) {
		iput(inode);
		goto out;
	}

	inode->i_ctime = CURRENT_TIME_SEC;
    1a67:	49 89 47 78          	mov    %rax,0x78(%r15)
    1a6b:	49 c7 87 80 00 00 00 	movq   $0x0,0x80(%r15)
    1a72:	00 00 00 00 
	inc_nlink(inode);
    1a76:	e8 00 00 00 00       	callq  1a7b <dafs_link+0x15b>

    /*this is for inode log to record*/
	err = dafs_append_link_change_entry(sb, pi, inode, 0, &pi_tail);
    1a7b:	4c 8d 45 a8          	lea    -0x58(%rbp),%r8
    1a7f:	31 c9                	xor    %ecx,%ecx
    1a81:	4c 89 fa             	mov    %r15,%rdx
    1a84:	48 89 de             	mov    %rbx,%rsi
    1a87:	4c 89 ef             	mov    %r13,%rdi
    1a8a:	e8 00 00 00 00       	callq  1a8f <dafs_link+0x16f>
	if (err) {
    1a8f:	85 c0                	test   %eax,%eax
    1a91:	74 48                	je     1adb <dafs_link+0x1bb>
		iput(inode);
    1a93:	4c 89 ff             	mov    %r15,%rdi
    1a96:	89 45 a0             	mov    %eax,-0x60(%rbp)
    1a99:	e8 00 00 00 00       	callq  1a9e <dafs_link+0x17e>
		goto out;
    1a9e:	8b 45 a0             	mov    -0x60(%rbp),%eax
    1aa1:	e9 57 ff ff ff       	jmpq   19fd <dafs_link+0xdd>
    1aa6:	48 8d 7d b0          	lea    -0x50(%rbp),%rdi
    1aaa:	e8 00 00 00 00       	callq  1aaf <dafs_link+0x18f>
    int file_type;

    //nova_dbg("%s start",__func__);
    NOVA_START_TIMING(link_t, link_time);
    
	if (inode->i_nlink >= NOVA_LINK_MAX) {
    1aaf:	41 81 7f 48 ff 7c 00 	cmpl   $0x7cff,0x48(%r15)
    1ab6:	00 
    1ab7:	77 58                	ja     1b11 <dafs_link+0x1f1>
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
    1ab9:	49 8b 56 c8          	mov    -0x38(%r14),%rdx
    1abd:	49 8b 85 b0 03 00 00 	mov    0x3b0(%r13),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    1ac4:	48 85 d2             	test   %rdx,%rdx
    1ac7:	4c 8b 60 18          	mov    0x18(%rax),%r12
		goto out;
	}

	pidir = nova_get_inode(sb, dir);
	if (!pidir) {
		err = -EINVAL;
    1acb:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    1ad0:	0f 84 27 ff ff ff    	je     19fd <dafs_link+0xdd>
    1ad6:	e9 d2 fe ff ff       	jmpq   19ad <dafs_link+0x8d>
	if (err) {
		iput(inode);
		goto out;
	}

	d_instantiate(dentry, inode);
    1adb:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    1adf:	4c 89 fe             	mov    %r15,%rsi
    1ae2:	89 45 98             	mov    %eax,-0x68(%rbp)
    1ae5:	e8 00 00 00 00       	callq  1aea <dafs_link+0x1ca>
    /*pidir_tail not been changed*/
	dafs_lite_transaction_for_time_and_link(sb, pi, pidir,
    1aea:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
    1aee:	45 31 c0             	xor    %r8d,%r8d
    1af1:	4c 89 e2             	mov    %r12,%rdx
    1af4:	48 89 de             	mov    %rbx,%rsi
    1af7:	4c 89 ef             	mov    %r13,%rdi
    1afa:	e8 e1 ef ff ff       	callq  ae0 <dafs_lite_transaction_for_time_and_link.constprop.4>
    1aff:	8b 45 98             	mov    -0x68(%rbp),%eax
    1b02:	e9 f6 fe ff ff       	jmpq   19fd <dafs_link+0xdd>

    //nova_dbg("%s start",__func__);
    NOVA_START_TIMING(link_t, link_time);
    
	if (inode->i_nlink >= NOVA_LINK_MAX) {
		err = -EMLINK;
    1b07:	b8 e1 ff ff ff       	mov    $0xffffffe1,%eax
    1b0c:	e9 24 ff ff ff       	jmpq   1a35 <dafs_link+0x115>
    1b11:	b8 e1 ff ff ff       	mov    $0xffffffe1,%eax
    1b16:	e9 e2 fe ff ff       	jmpq   19fd <dafs_link+0xdd>
		err = -EINVAL;
		goto out;
	}

	ihold(inode);
	nova_dbgv("%s: name %s, dest %s\n", __func__,
    1b1b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    1b1f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1b26:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1b2d:	48 8b 48 28          	mov    0x28(%rax),%rcx
    1b31:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
    1b35:	48 8b 50 28          	mov    0x28(%rax),%rdx
    1b39:	e8 00 00 00 00       	callq  1b3e <dafs_link+0x21e>
			dentry->d_name.name, dest_dentry->d_name.name);
	nova_dbgv("%s: inode %lu, dir %lu\n", __func__,
    1b3e:	f6 05 00 00 00 00 10 	testb  $0x10,0x0(%rip)        # 1b45 <dafs_link+0x225>
    1b45:	0f 84 80 fe ff ff    	je     19cb <dafs_link+0xab>
    1b4b:	49 8b 4e 40          	mov    0x40(%r14),%rcx
    1b4f:	49 8b 57 40          	mov    0x40(%r15),%rdx
    1b53:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1b5a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1b61:	e8 00 00 00 00       	callq  1b66 <dafs_link+0x246>
    1b66:	e9 60 fe ff ff       	jmpq   19cb <dafs_link+0xab>
out:
	NOVA_END_TIMING(link_t, link_time);
    //nova_dbg("%s end",__func__);
	return err;

}
    1b6b:	e8 00 00 00 00       	callq  1b70 <dafs_link+0x250>
		goto out;
	}

	pidir = nova_get_inode(sb, dir);
	if (!pidir) {
		err = -EINVAL;
    1b70:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    1b75:	e9 83 fe ff ff       	jmpq   19fd <dafs_link+0xdd>
    1b7a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000001b80 <dafs_apply_link_change_entry>:
    //nova_dbg("%s end",__func__);
}

void dafs_apply_link_change_entry(struct nova_inode *pi,
	struct nova_link_change_entry *entry)
{
    1b80:	e8 00 00 00 00       	callq  1b85 <dafs_apply_link_change_entry+0x5>
	if (entry->entry_type != LINK_CHANGE)
    1b85:	80 3e 04             	cmpb   $0x4,(%rsi)
    //nova_dbg("%s end",__func__);
}

void dafs_apply_link_change_entry(struct nova_inode *pi,
	struct nova_link_change_entry *entry)
{
    1b88:	55                   	push   %rbp
    1b89:	48 89 e5             	mov    %rsp,%rbp
	if (entry->entry_type != LINK_CHANGE)
    1b8c:	75 1c                	jne    1baa <dafs_apply_link_change_entry+0x2a>
		BUG();

	pi->i_links_count	= entry->links;
    1b8e:	0f b7 46 02          	movzwl 0x2(%rsi),%eax
	pi->i_ctime		= entry->ctime;
	pi->i_flags		= entry->flags;
	pi->i_generation	= entry->generation;

	/* Do not flush now */
}
    1b92:	5d                   	pop    %rbp
	struct nova_link_change_entry *entry)
{
	if (entry->entry_type != LINK_CHANGE)
		BUG();

	pi->i_links_count	= entry->links;
    1b93:	66 89 47 1e          	mov    %ax,0x1e(%rdi)
	pi->i_ctime		= entry->ctime;
    1b97:	8b 46 04             	mov    0x4(%rsi),%eax
    1b9a:	89 47 10             	mov    %eax,0x10(%rdi)
	pi->i_flags		= entry->flags;
    1b9d:	8b 46 08             	mov    0x8(%rsi),%eax
    1ba0:	89 47 04             	mov    %eax,0x4(%rdi)
	pi->i_generation	= entry->generation;
    1ba3:	8b 46 0c             	mov    0xc(%rsi),%eax
    1ba6:	89 47 38             	mov    %eax,0x38(%rdi)

	/* Do not flush now */
}
    1ba9:	c3                   	retq   

void dafs_apply_link_change_entry(struct nova_inode *pi,
	struct nova_link_change_entry *entry)
{
	if (entry->entry_type != LINK_CHANGE)
		BUG();
    1baa:	0f 0b                	ud2    
    1bac:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000001bb0 <dafs_get_parent>:
	NOVA_END_TIMING(rename_t, rename_time);
	return err;
}

struct dentry *dafs_get_parent(struct dentry *child)
{
    1bb0:	e8 00 00 00 00       	callq  1bb5 <dafs_get_parent+0x5>
    1bb5:	55                   	push   %rbp
    struct dafs_dentry *de;
    ino_t ino;
  
    //nova_dbg("%s start",__func__);
    //nova_dbg("%s: dafs start get [parent]",__func__);
    de = dafs_find_direntry(sb, child,1,0);
    1bb6:	31 c9                	xor    %ecx,%ecx
    1bb8:	ba 01 00 00 00       	mov    $0x1,%edx
	NOVA_END_TIMING(rename_t, rename_time);
	return err;
}

struct dentry *dafs_get_parent(struct dentry *child)
{
    1bbd:	48 89 e5             	mov    %rsp,%rbp
    1bc0:	53                   	push   %rbx
    struct inode *inode;
    struct super_block *sb = child->d_inode->i_sb;
    1bc1:	48 8b 47 30          	mov    0x30(%rdi),%rax
	NOVA_END_TIMING(rename_t, rename_time);
	return err;
}

struct dentry *dafs_get_parent(struct dentry *child)
{
    1bc5:	48 89 fb             	mov    %rdi,%rbx
    struct dafs_dentry *de;
    ino_t ino;
  
    //nova_dbg("%s start",__func__);
    //nova_dbg("%s: dafs start get [parent]",__func__);
    de = dafs_find_direntry(sb, child,1,0);
    1bc8:	48 89 de             	mov    %rbx,%rsi
    1bcb:	48 8b 78 28          	mov    0x28(%rax),%rdi
    1bcf:	e8 00 00 00 00       	callq  1bd4 <dafs_get_parent+0x24>
    1bd4:	48 89 c2             	mov    %rax,%rdx
    if(!de)
        return ERR_PTR(-ENOENT);
    1bd7:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
    ino_t ino;
  
    //nova_dbg("%s start",__func__);
    //nova_dbg("%s: dafs start get [parent]",__func__);
    de = dafs_find_direntry(sb, child,1,0);
    if(!de)
    1bde:	48 85 d2             	test   %rdx,%rdx
    1be1:	74 1e                	je     1c01 <dafs_get_parent+0x51>
        return ERR_PTR(-ENOENT);
    ino = le64_to_cpu(de->ino);
    1be3:	48 8b 72 18          	mov    0x18(%rdx),%rsi

    if(ino)
    1be7:	48 85 f6             	test   %rsi,%rsi
    1bea:	74 15                	je     1c01 <dafs_get_parent+0x51>
        inode = nova_iget(child->d_inode->i_sb, ino);
    1bec:	48 8b 43 30          	mov    0x30(%rbx),%rax
    1bf0:	48 8b 78 28          	mov    0x28(%rax),%rdi
    1bf4:	e8 00 00 00 00       	callq  1bf9 <dafs_get_parent+0x49>
    else 
        return ERR_PTR(-ENOENT);

    return d_obtain_alias(inode); 
    1bf9:	48 89 c7             	mov    %rax,%rdi
    1bfc:	e8 00 00 00 00       	callq  1c01 <dafs_get_parent+0x51>
}
    1c01:	5b                   	pop    %rbx
    1c02:	5d                   	pop    %rbp
    1c03:	c3                   	retq   
