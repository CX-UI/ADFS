
dafs_dir.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <find_dzt>:
/* find currect zone
 * ph record file ful name
 * 反向查找
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
       0:	55                   	push   %rbp
       1:	48 89 e5             	mov    %rsp,%rbp
       4:	41 56                	push   %r14
       6:	41 55                	push   %r13
       8:	41 54                	push   %r12
       a:	53                   	push   %rbx
       b:	49 89 f5             	mov    %rsi,%r13
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
       e:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
/* find currect zone
 * ph record file ful name
 * 反向查找
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
      15:	48 89 d3             	mov    %rdx,%rbx
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
      18:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
      1f:	48 89 f2             	mov    %rsi,%rdx
      22:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
      29:	4c 8b b0 d8 0d 00 00 	mov    0xdd8(%rax),%r14
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
      30:	e8 00 00 00 00       	callq  35 <find_dzt+0x35>
    tlen = strlen(phstr);
      35:	4c 89 ef             	mov    %r13,%rdi
      38:	e8 00 00 00 00       	callq  3d <find_dzt+0x3d>
    nova_dbg("%s length is %llu", __func__, tlen);
      3d:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    tlen = strlen(phstr);
      44:	49 89 c4             	mov    %rax,%r12
    nova_dbg("%s length is %llu", __func__, tlen);
      47:	48 89 c2             	mov    %rax,%rdx
      4a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
      51:	e8 00 00 00 00       	callq  56 <find_dzt+0x56>
    memcpy(phs, phstr, tlen);
      56:	4c 89 e2             	mov    %r12,%rdx
      59:	4c 89 ee             	mov    %r13,%rsi
      5c:	48 89 df             	mov    %rbx,%rdi
      5f:	e8 00 00 00 00       	callq  64 <find_dzt+0x64>
    phs[tlen]='\0';
      64:	42 c6 04 23 00       	movb   $0x0,(%rbx,%r12,1)
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
      69:	be 2f 00 00 00       	mov    $0x2f,%esi
            return dzt_ei;
        }
    }while(1);
    */
    /*root dir*/
    memcpy(phs, "/", 1);
      6e:	c6 03 2f             	movb   $0x2f,(%rbx)
    phs[1]='\0';
      71:	c6 43 01 00          	movb   $0x0,0x1(%rbx)
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
      75:	4c 89 f7             	mov    %r14,%rdi
      78:	e8 00 00 00 00       	callq  7d <find_dzt+0x7d>
    if(!dzt_ei){
      7d:	48 85 c0             	test   %rax,%rax
      80:	74 09                	je     8b <find_dzt+0x8b>
        return ERR_PTR(-EINVAL);
    }

    //nova_dbg("dafs finish finding dzt:%d, zone addr 0x%llu",dzt_ei->dzt_eno, dzt_ei->dz_addr);
    return dzt_ei;
}
      82:	5b                   	pop    %rbx
      83:	41 5c                	pop    %r12
      85:	41 5d                	pop    %r13
      87:	41 5e                	pop    %r14
      89:	5d                   	pop    %rbp
      8a:	c3                   	retq   
      8b:	e8 00 00 00 00       	callq  90 <get_dentry_path.isra.4>

0000000000000090 <get_dentry_path.isra.4>:
    return 0;

}

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
      90:	55                   	push   %rbp
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
      91:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    return 0;

}

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
      98:	48 89 e5             	mov    %rsp,%rbp
      9b:	41 57                	push   %r15
      9d:	41 56                	push   %r14
      9f:	41 55                	push   %r13
      a1:	41 54                	push   %r12
      a3:	49 89 fe             	mov    %rdi,%r14
      a6:	53                   	push   %rbx
      a7:	48 83 ec 10          	sub    $0x10,%rsp
{
    struct inode *dir = dentry->d_parent->d_inode;
      ab:	48 8b 47 18          	mov    0x18(%rdi),%rax
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
      af:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
      b6:	48 8b 40 30          	mov    0x30(%rax),%rax
      ba:	4c 8b 68 28          	mov    0x28(%rax),%r13

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
      be:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
      c5:	00 00 
    struct nova_sb_info *sbi = NOVA_SB(sb);
    char *ph, *buf, *tem, *ppath;
    //char *buf = NULL, *ppath=NULL, *tem=NULL;
    struct fs_struct *fs = current->fs;
      c7:	4c 8b a0 30 06 00 00 	mov    0x630(%rax),%r12
      ce:	49 8b 9d b0 03 00 00 	mov    0x3b0(%r13),%rbx
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
      d5:	e8 00 00 00 00       	callq  da <get_dentry_path.isra.4+0x4a>
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
      da:	4d 85 ed             	test   %r13,%r13
      dd:	0f 84 80 00 00 00    	je     163 <get_dentry_path.isra.4+0xd3>
    BUG_ON(sbi==NULL);
      e3:	48 85 db             	test   %rbx,%rbx
      e6:	74 7d                	je     165 <get_dentry_path.isra.4+0xd5>
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
      e8:	49 8d 7c 24 04       	lea    0x4(%r12),%rdi
    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
      ed:	c6 83 d8 01 00 00 00 	movb   $0x0,0x1d8(%rbx)
    buf[0]='\0';
      f4:	c6 83 d7 05 00 00 00 	movb   $0x0,0x5d7(%rbx)
    tem[0]='\0';
      fb:	c6 83 d6 09 00 00 00 	movb   $0x0,0x9d6(%rbx)
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
     102:	4c 8d ab d8 01 00 00 	lea    0x1d8(%rbx),%r13
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
     109:	e8 00 00 00 00       	callq  10e <get_dentry_path.isra.4+0x7e>
    vfsmnt = mntget(fs->pwd.mnt);
     10e:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
     113:	e8 00 00 00 00       	callq  118 <get_dentry_path.isra.4+0x88>
    if(!vfsmnt){
     118:	48 85 c0             	test   %rax,%rax
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
     11b:	49 89 c7             	mov    %rax,%r15
    if(!vfsmnt){
     11e:	74 47                	je     167 <get_dentry_path.isra.4+0xd7>
 *
 * Atomically adds @i to @v and returns @i + @v
 */
static __always_inline int atomic_add_return(int i, atomic_t *v)
{
	return i + xadd(&v->counter, i);
     120:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
     125:	f0 41 0f c1 44 24 04 	lock xadd %eax,0x4(%r12)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
     12c:	49 8b 76 28          	mov    0x28(%r14),%rsi
     130:	49 c7 c1 00 00 00 00 	mov    $0x0,%r9
     137:	b9 02 00 00 00       	mov    $0x2,%ecx
     13c:	4c 89 cf             	mov    %r9,%rdi
     13f:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
     141:	75 60                	jne    1a3 <get_dentry_path.isra.4+0x113>
        memcpy(buf,"/",1);
        buf[1]='\0';
    }else{
        //nova_dbg("%s root dentry",__func__);
        memcpy(ph, "/", 1);
     143:	c6 83 d8 01 00 00 2f 	movb   $0x2f,0x1d8(%rbx)
        ph[1]='\0';
     14a:	c6 83 d9 01 00 00 00 	movb   $0x0,0x1d9(%rbx)
    //nova_dbg("dafs finish get dentry path");
ERR:
    nova_dbg("%s ful ph is %s len %llu, sbi %s ",__func__,ph, strlen(ph), sbi->ph_f);
    BUG_ON(ph==NULL);
    return ph;
}
     151:	48 83 c4 10          	add    $0x10,%rsp
     155:	4c 89 e8             	mov    %r13,%rax
     158:	5b                   	pop    %rbx
     159:	41 5c                	pop    %r12
     15b:	41 5d                	pop    %r13
     15d:	41 5e                	pop    %r14
     15f:	41 5f                	pop    %r15
     161:	5d                   	pop    %rbp
     162:	c3                   	retq   
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
     163:	0f 0b                	ud2    
    BUG_ON(sbi==NULL);
     165:	0f 0b                	ud2    
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    if(!vfsmnt){
        nova_dbg("not find mnt");
     167:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     16e:	e8 00 00 00 00       	callq  173 <get_dentry_path.isra.4+0xe3>
    
    //kfree(buf);
    //kfree(tem);
    //nova_dbg("dafs finish get dentry path");
ERR:
    nova_dbg("%s ful ph is %s len %llu, sbi %s ",__func__,ph, strlen(ph), sbi->ph_f);
     173:	31 c0                	xor    %eax,%eax
     175:	4c 89 ef             	mov    %r13,%rdi
     178:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
     17c:	f2 ae                	repnz scas %es:(%rdi),%al
     17e:	4d 89 e8             	mov    %r13,%r8
     181:	4c 89 ea             	mov    %r13,%rdx
     184:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     18b:	48 89 c8             	mov    %rcx,%rax
     18e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     195:	48 f7 d0             	not    %rax
     198:	48 8d 48 ff          	lea    -0x1(%rax),%rcx
     19c:	e8 00 00 00 00       	callq  1a1 <get_dentry_path.isra.4+0x111>
     1a1:	eb ae                	jmp    151 <get_dentry_path.isra.4+0xc1>
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
     1a3:	4c 8d a3 d7 05 00 00 	lea    0x5d7(%rbx),%r12
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
        memcpy(buf,"/",1);
     1aa:	c6 83 d7 05 00 00 2f 	movb   $0x2f,0x5d7(%rbx)
        buf[1]='\0';
     1b1:	c6 83 d8 05 00 00 00 	movb   $0x0,0x5d8(%rbx)
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
     1b8:	4c 89 e7             	mov    %r12,%rdi
     1bb:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
     1bf:	e8 00 00 00 00       	callq  1c4 <get_dentry_path.isra.4+0x134>
     1c4:	ba 2f 00 00 00       	mov    $0x2f,%edx
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
     1c9:	49 8d 7c 04 01       	lea    0x1(%r12,%rax,1),%rdi
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
     1ce:	66 41 89 14 04       	mov    %dx,(%r12,%rax,1)
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
     1d3:	49 8b 76 28          	mov    0x28(%r14),%rsi
     1d7:	e8 00 00 00 00       	callq  1dc <get_dentry_path.isra.4+0x14c>
        p_dentry = tem_dentry->d_parent;
     1dc:	4d 8b 76 18          	mov    0x18(%r14),%r14
        //plen = strlen(buf);
        //buf[plen]='\0';
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
     1e0:	4c 8b 4d d0          	mov    -0x30(%rbp),%r9
     1e4:	b9 02 00 00 00       	mov    $0x2,%ecx
     1e9:	49 8b 76 28          	mov    0x28(%r14),%rsi
     1ed:	4c 89 cf             	mov    %r9,%rdi
     1f0:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
     1f2:	75 c4                	jne    1b8 <get_dentry_path.isra.4+0x128>
     1f4:	49 8b 46 30          	mov    0x30(%r14),%rax
     1f8:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
     1fd:	75 b9                	jne    1b8 <get_dentry_path.isra.4+0x128>

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
     1ff:	48 8d 83 d6 09 00 00 	lea    0x9d6(%rbx),%rax
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
     206:	4c 89 e2             	mov    %r12,%rdx
     209:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     210:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     217:	4c 89 4d c8          	mov    %r9,-0x38(%rbp)

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
     21b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
     21f:	e8 00 00 00 00       	callq  224 <get_dentry_path.isra.4+0x194>
    tlen = strlen(buf);
     224:	31 c0                	xor    %eax,%eax
     226:	4c 89 e7             	mov    %r12,%rdi
     229:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
     22d:	f2 ae                	repnz scas %es:(%rdi),%al
    memcpy(tem, buf, tlen);
     22f:	48 8d bb d6 09 00 00 	lea    0x9d6(%rbx),%rdi
     236:	4c 89 e6             	mov    %r12,%rsi
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    tlen = strlen(buf);
     239:	48 f7 d1             	not    %rcx
     23c:	4c 8d 71 ff          	lea    -0x1(%rcx),%r14
    memcpy(tem, buf, tlen);
     240:	4c 89 f2             	mov    %r14,%rdx
     243:	e8 00 00 00 00       	callq  248 <get_dentry_path.isra.4+0x1b8>
    tem[tlen]='\0';
     248:	4c 8b 4d c8          	mov    -0x38(%rbp),%r9
     24c:	42 c6 84 33 d6 09 00 	movb   $0x0,0x9d6(%rbx,%r14,1)
     253:	00 00 
    do{
        ppath = strrchr(tem, '/');
     255:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
     259:	be 2f 00 00 00       	mov    $0x2f,%esi
     25e:	4c 89 4d c8          	mov    %r9,-0x38(%rbp)
     262:	e8 00 00 00 00       	callq  267 <get_dentry_path.isra.4+0x1d7>
     267:	48 89 c3             	mov    %rax,%rbx
        plen = strlen(ppath);
     26a:	48 89 c7             	mov    %rax,%rdi
     26d:	e8 00 00 00 00       	callq  272 <get_dentry_path.isra.4+0x1e2>
        phlen = tlen - plen;
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
     272:	48 89 de             	mov    %rbx,%rsi
     275:	4c 89 ef             	mov    %r13,%rdi
    memcpy(tem, buf, tlen);
    tem[tlen]='\0';
    do{
        ppath = strrchr(tem, '/');
        plen = strlen(ppath);
        phlen = tlen - plen;
     278:	49 29 c6             	sub    %rax,%r14
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
     27b:	e8 00 00 00 00       	callq  280 <get_dentry_path.isra.4+0x1f0>
        memcpy(tem, buf, tlen);
     280:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
     284:	4c 89 e6             	mov    %r12,%rsi
     287:	4c 89 f2             	mov    %r14,%rdx
     28a:	48 89 df             	mov    %rbx,%rdi
     28d:	e8 00 00 00 00       	callq  292 <get_dentry_path.isra.4+0x202>
        tem[tlen]='\0';
        if(!strcmp(tem,"/"))
     292:	4c 8b 4d c8          	mov    -0x38(%rbp),%r9
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
        memcpy(tem, buf, tlen);
        tem[tlen]='\0';
     296:	48 89 de             	mov    %rbx,%rsi
     299:	42 c6 04 33 00       	movb   $0x0,(%rbx,%r14,1)
        if(!strcmp(tem,"/"))
     29e:	b9 02 00 00 00       	mov    $0x2,%ecx
     2a3:	4c 89 cf             	mov    %r9,%rdi
     2a6:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
     2a8:	75 ab                	jne    255 <get_dentry_path.isra.4+0x1c5>
            break;
    }while(1);

    //BUG_ON(strlen(ph)==1023);
    nova_dbg("%s ful ph is %s sbi is %s",__func__,ph, sbi->ph_f);
     2aa:	4c 89 e9             	mov    %r13,%rcx
     2ad:	4c 89 ea             	mov    %r13,%rdx
     2b0:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     2b7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     2be:	e8 00 00 00 00       	callq  2c3 <get_dentry_path.isra.4+0x233>
    //BUG_ON(ph==NULL);
    
    mntput(vfsmnt);
     2c3:	4c 89 ff             	mov    %r15,%rdi
     2c6:	e8 00 00 00 00       	callq  2cb <get_dentry_path.isra.4+0x23b>
     2cb:	e9 a3 fe ff ff       	jmpq   173 <get_dentry_path.isra.4+0xe3>

00000000000002d0 <kzalloc.constprop.8>:
/**
 * kzalloc - allocate memory. The memory is set to zero.
 * @size: how many bytes of memory are required.
 * @flags: the type of memory to allocate (see kmalloc).
 */
static inline void *kzalloc(size_t size, gfp_t flags)
     2d0:	55                   	push   %rbp
			return kmem_cache_alloc_trace(kmalloc_caches[index],
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
     2d1:	be d0 80 00 00       	mov    $0x80d0,%esi
/**
 * kzalloc - allocate memory. The memory is set to zero.
 * @size: how many bytes of memory are required.
 * @flags: the type of memory to allocate (see kmalloc).
 */
static inline void *kzalloc(size_t size, gfp_t flags)
     2d6:	48 89 e5             	mov    %rsp,%rbp
			return kmem_cache_alloc_trace(kmalloc_caches[index],
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
     2d9:	e8 00 00 00 00       	callq  2de <kzalloc.constprop.8+0xe>
 * @flags: the type of memory to allocate (see kmalloc).
 */
static inline void *kzalloc(size_t size, gfp_t flags)
{
	return kmalloc(size, flags | __GFP_ZERO);
}
     2de:	5d                   	pop    %rbp
     2df:	c3                   	retq   

00000000000002e0 <tes_empty_zone>:
//char *fph = (char *)kmalloc(sizeof(char)*DAFS_PATH_LEN,GFP_KERNEL);
//char *phname =(char *)kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
//char *phn = (char *)kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);

void tes_empty_zone(struct super_block *sb, struct zone_ptr *z_p)
{
     2e0:	e8 00 00 00 00       	callq  2e5 <tes_empty_zone+0x5>
     2e5:	48 8b 0e             	mov    (%rsi),%rcx
     2e8:	55                   	push   %rbp
     2e9:	31 c0                	xor    %eax,%eax
     2eb:	48 89 e5             	mov    %rsp,%rbp

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
     2ee:	48 0f a3 01          	bt     %rax,(%rcx)
     2f2:	19 d2                	sbb    %edx,%edx
    u32 pos = 0, epos = 0;
    u32 bitpos = 0;

    while(pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
     2f4:	85 d2                	test   %edx,%edx
     2f6:	75 0a                	jne    302 <tes_empty_zone+0x22>
     2f8:	48 8d 50 01          	lea    0x1(%rax),%rdx
     2fc:	48 0f a3 11          	bt     %rdx,(%rcx)
     300:	19 d2                	sbb    %edx,%edx
     302:	48 83 c0 02          	add    $0x2,%rax
void tes_empty_zone(struct super_block *sb, struct zone_ptr *z_p)
{
    u32 pos = 0, epos = 0;
    u32 bitpos = 0;

    while(pos<NR_DENTRY_IN_ZONE){
     306:	48 3d fe ff 01 00    	cmp    $0x1fffe,%rax
     30c:	75 e0                	jne    2ee <tes_empty_zone+0xe>
            pos++;
            epos++;
        }
    }
    //nova_dbg("%s: empty pos num %d",__func__, epos);
}
     30e:	5d                   	pop    %rbp
     30f:	c3                   	retq   

0000000000000310 <delete_dir_info>:

/*delete dir_info entry*/
int delete_dir_info(struct dzt_entry_info *ei, u64 hashname)
{
     310:	e8 00 00 00 00       	callq  315 <delete_dir_info+0x5>
     315:	55                   	push   %rbp
    struct dir_info *dir_i;
    struct file_p *o_sf;
    struct list_head *this=NULL, *head=NULL, *next=NULL;

    //nova_dbg("%s start",__func__);
    dir_i = radix_tree_delete(&ei->dir_tree, hashname);
     316:	48 83 c7 38          	add    $0x38,%rdi
    //nova_dbg("%s: empty pos num %d",__func__, epos);
}

/*delete dir_info entry*/
int delete_dir_info(struct dzt_entry_info *ei, u64 hashname)
{
     31a:	48 89 e5             	mov    %rsp,%rbp
     31d:	41 55                	push   %r13
     31f:	41 54                	push   %r12
     321:	53                   	push   %rbx
    struct dir_info *dir_i;
    struct file_p *o_sf;
    struct list_head *this=NULL, *head=NULL, *next=NULL;

    //nova_dbg("%s start",__func__);
    dir_i = radix_tree_delete(&ei->dir_tree, hashname);
     322:	e8 00 00 00 00       	callq  327 <delete_dir_info+0x17>
    if(!dir_i){
     327:	48 85 c0             	test   %rax,%rax
     32a:	74 59                	je     385 <delete_dir_info+0x75>
        //nova_dbg("dir info not found");
        goto OUT;
    }
    //nova_dbg("dir sub num is %llu",dir_i->sub_num);
    head = &dir_i->sub_file;
    list_for_each_safe(this, next, head) {
     32c:	48 8b 78 18          	mov    0x18(%rax),%rdi
    if(!dir_i){
        //nova_dbg("dir info not found");
        goto OUT;
    }
    //nova_dbg("dir sub num is %llu",dir_i->sub_num);
    head = &dir_i->sub_file;
     330:	4c 8d 60 18          	lea    0x18(%rax),%r12
     334:	49 89 c5             	mov    %rax,%r13
    list_for_each_safe(this, next, head) {
     337:	48 8b 1f             	mov    (%rdi),%rbx
     33a:	49 39 fc             	cmp    %rdi,%r12
     33d:	48 89 d8             	mov    %rbx,%rax
     340:	75 05                	jne    347 <delete_dir_info+0x37>
     342:	eb 39                	jmp    37d <delete_dir_info+0x6d>
     344:	48 89 c3             	mov    %rax,%rbx
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
     347:	48 8b 57 08          	mov    0x8(%rdi),%rdx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
     34b:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = next;
     34f:	48 89 02             	mov    %rax,(%rdx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
     352:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
     359:	00 ad de 
     35c:	48 89 07             	mov    %rax,(%rdi)
	entry->prev = LIST_POISON2;
     35f:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
     366:	00 ad de 
     369:	48 89 47 08          	mov    %rax,0x8(%rdi)
        o_sf = list_entry(this, struct file_p, list);
        //nova_dbg("list pos %d",o_sf->pos);
        //find bug
        list_del(&o_sf->list);
        kfree(o_sf);
     36d:	e8 00 00 00 00       	callq  372 <delete_dir_info+0x62>
        //nova_dbg("dir info not found");
        goto OUT;
    }
    //nova_dbg("dir sub num is %llu",dir_i->sub_num);
    head = &dir_i->sub_file;
    list_for_each_safe(this, next, head) {
     372:	49 39 dc             	cmp    %rbx,%r12
     375:	48 8b 03             	mov    (%rbx),%rax
     378:	48 89 df             	mov    %rbx,%rdi
     37b:	75 c7                	jne    344 <delete_dir_info+0x34>
        //find bug
        list_del(&o_sf->list);
        kfree(o_sf);
    }

    kfree(dir_i);
     37d:	4c 89 ef             	mov    %r13,%rdi
     380:	e8 00 00 00 00       	callq  385 <delete_dir_info+0x75>
OUT:
    //nova_dbg("%s end",__func__);
    return 0;
}
     385:	5b                   	pop    %rbx
     386:	31 c0                	xor    %eax,%eax
     388:	41 5c                	pop    %r12
     38a:	41 5d                	pop    %r13
     38c:	5d                   	pop    %rbp
     38d:	c3                   	retq   
     38e:	66 90                	xchg   %ax,%ax

0000000000000390 <delete_dir_tree>:

/*delete dir_info tree*/
int delete_dir_tree(struct dzt_entry_info *ei)
{
     390:	e8 00 00 00 00       	callq  395 <delete_dir_tree+0x5>
     395:	55                   	push   %rbp
    struct dir_info *dir_i;
    struct dir_info *entries[FREE_BATCH];
    struct file_p *o_sf;
    struct list_head *head, *this, *next;
    u64 key, dir_index=0;
     396:	31 d2                	xor    %edx,%edx
    return 0;
}

/*delete dir_info tree*/
int delete_dir_tree(struct dzt_entry_info *ei)
{
     398:	48 89 e5             	mov    %rsp,%rbp
     39b:	41 57                	push   %r15
     39d:	41 56                	push   %r14
     39f:	41 55                	push   %r13
     3a1:	41 54                	push   %r12
     3a3:	53                   	push   %rbx
     3a4:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
     3ab:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     3b2:	00 00 
     3b4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     3b8:	31 c0                	xor    %eax,%eax
     3ba:	48 8d 47 38          	lea    0x38(%rdi),%rax
     3be:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    u64 key, dir_index=0;
    int nr, i;
    void *ret;

    do {
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
     3c5:	48 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%rdi
     3cc:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
     3d3:	b9 10 00 00 00       	mov    $0x10,%ecx
     3d8:	e8 00 00 00 00       	callq  3dd <delete_dir_tree+0x4d>
        for(i=0; i<nr; i++) {
     3dd:	85 c0                	test   %eax,%eax
    u64 key, dir_index=0;
    int nr, i;
    void *ret;

    do {
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
     3df:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
        for(i=0; i<nr; i++) {
     3e5:	0f 8e c6 00 00 00    	jle    4b1 <delete_dir_tree+0x121>
     3eb:	83 e8 01             	sub    $0x1,%eax
     3ee:	4c 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%r14
     3f5:	48 8d 84 c5 58 ff ff 	lea    -0xa8(%rbp,%rax,8),%rax
     3fc:	ff 
     3fd:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
            dir_i = entries[i];
     404:	4d 8b 2e             	mov    (%r14),%r13
            key = dir_i->dir_hash;
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
     407:	48 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%rdi

    do {
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
        for(i=0; i<nr; i++) {
            dir_i = entries[i];
            key = dir_i->dir_hash;
     40e:	49 8b 45 10          	mov    0x10(%r13),%rax
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
            head = &dir_i->sub_file;
     412:	4d 8d 65 18          	lea    0x18(%r13),%r12
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
        for(i=0; i<nr; i++) {
            dir_i = entries[i];
            key = dir_i->dir_hash;
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
     416:	48 89 c6             	mov    %rax,%rsi

    do {
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
        for(i=0; i<nr; i++) {
            dir_i = entries[i];
            key = dir_i->dir_hash;
     419:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
     420:	e8 00 00 00 00       	callq  425 <delete_dir_tree+0x95>
            head = &dir_i->sub_file;
            list_for_each_safe(this, next, head) {
     425:	49 8b 7d 18          	mov    0x18(%r13),%rdi
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
        for(i=0; i<nr; i++) {
            dir_i = entries[i];
            key = dir_i->dir_hash;
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
     429:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
            head = &dir_i->sub_file;
            list_for_each_safe(this, next, head) {
     430:	4c 8b 3f             	mov    (%rdi),%r15
     433:	49 39 fc             	cmp    %rdi,%r12
     436:	4c 89 fb             	mov    %r15,%rbx
     439:	75 05                	jne    440 <delete_dir_tree+0xb0>
     43b:	eb 39                	jmp    476 <delete_dir_tree+0xe6>
     43d:	4c 89 fb             	mov    %r15,%rbx
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
     440:	48 8b 57 08          	mov    0x8(%rdi),%rdx
	entry->next = LIST_POISON1;
     444:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
     44b:	00 ad de 
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
     44e:	49 89 57 08          	mov    %rdx,0x8(%r15)
	prev->next = next;
     452:	4c 89 3a             	mov    %r15,(%rdx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
     455:	48 89 07             	mov    %rax,(%rdi)
	entry->prev = LIST_POISON2;
     458:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
     45f:	00 ad de 
     462:	48 89 47 08          	mov    %rax,0x8(%rdi)
                o_sf = list_entry(this, struct file_p, list);
                list_del(&o_sf->list);
                kfree(o_sf);
     466:	e8 00 00 00 00       	callq  46b <delete_dir_tree+0xdb>
            dir_i = entries[i];
            key = dir_i->dir_hash;
            dir_index = dir_i->dir_hash;
            ret = radix_tree_delete(&ei->dir_tree, key);
            head = &dir_i->sub_file;
            list_for_each_safe(this, next, head) {
     46b:	49 39 dc             	cmp    %rbx,%r12
     46e:	4d 8b 3f             	mov    (%r15),%r15
     471:	48 89 df             	mov    %rbx,%rdi
     474:	75 c7                	jne    43d <delete_dir_tree+0xad>
                o_sf = list_entry(this, struct file_p, list);
                list_del(&o_sf->list);
                kfree(o_sf);
            }
            if(!ret)
     476:	48 83 bd 48 ff ff ff 	cmpq   $0x0,-0xb8(%rbp)
     47d:	00 
     47e:	74 35                	je     4b5 <delete_dir_tree+0x125>
                return -EINVAL;
                //nova_dbg("ret is NULL\n");
            kfree(dir_i);
     480:	4c 89 ef             	mov    %r13,%rdi
     483:	49 83 c6 08          	add    $0x8,%r14
     487:	e8 00 00 00 00       	callq  48c <delete_dir_tree+0xfc>
    int nr, i;
    void *ret;

    do {
        nr = radix_tree_gang_lookup(&ei->dir_tree, (void **)entries, dir_index, FREE_BATCH);
        for(i=0; i<nr; i++) {
     48c:	4c 3b b5 30 ff ff ff 	cmp    -0xd0(%rbp),%r14
     493:	0f 85 6b ff ff ff    	jne    404 <delete_dir_tree+0x74>
            if(!ret)
                return -EINVAL;
                //nova_dbg("ret is NULL\n");
            kfree(dir_i);
        }
        dir_index ++;
     499:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
     4a0:	48 83 c2 01          	add    $0x1,%rdx
    } while (nr==FREE_BATCH);
     4a4:	83 bd 2c ff ff ff 10 	cmpl   $0x10,-0xd4(%rbp)
     4ab:	0f 84 14 ff ff ff    	je     3c5 <delete_dir_tree+0x35>

    return 0;
     4b1:	31 c0                	xor    %eax,%eax
     4b3:	eb 05                	jmp    4ba <delete_dir_tree+0x12a>
                o_sf = list_entry(this, struct file_p, list);
                list_del(&o_sf->list);
                kfree(o_sf);
            }
            if(!ret)
                return -EINVAL;
     4b5:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
        }
        dir_index ++;
    } while (nr==FREE_BATCH);

    return 0;
}
     4ba:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
     4be:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
     4c5:	00 00 
     4c7:	75 12                	jne    4db <delete_dir_tree+0x14b>
     4c9:	48 81 c4 b0 00 00 00 	add    $0xb0,%rsp
     4d0:	5b                   	pop    %rbx
     4d1:	41 5c                	pop    %r12
     4d3:	41 5d                	pop    %r13
     4d5:	41 5e                	pop    %r14
     4d7:	41 5f                	pop    %r15
     4d9:	5d                   	pop    %rbp
     4da:	c3                   	retq   
     4db:	e8 00 00 00 00       	callq  4e0 <add_dir_info>

00000000000004e0 <add_dir_info>:

}*/

/*add dir_info_entry in dir_info_tree*/
struct dir_info *add_dir_info(struct dzt_entry_info *ei, u64 hash_name, u32 pos)
{
     4e0:	e8 00 00 00 00       	callq  4e5 <add_dir_info+0x5>
     4e5:	55                   	push   %rbp
     4e6:	48 89 e5             	mov    %rsp,%rbp
     4e9:	41 56                	push   %r14
     4eb:	41 55                	push   %r13
     4ed:	41 54                	push   %r12
     4ef:	49 89 fc             	mov    %rdi,%r12
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
     4f2:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 4f9 <add_dir_info+0x19>
     4f9:	53                   	push   %rbx
     4fa:	49 89 f5             	mov    %rsi,%r13
     4fd:	41 89 d6             	mov    %edx,%r14d
     500:	be d0 80 00 00       	mov    $0x80d0,%esi
     505:	ba 28 00 00 00       	mov    $0x28,%edx
     50a:	e8 00 00 00 00       	callq  50f <add_dir_info+0x2f>
     50f:	48 89 c3             	mov    %rax,%rbx
    new_dir->r_f = 0;
    new_dir->sub_s = 0;
    new_dir->f_s = 0;
    new_dir->prio = LEVEL_0;
    new_dir->sub_num = 0;
    new_dir->dir_hash = hash_name;
     512:	4c 89 68 10          	mov    %r13,0x10(%rax)
    new_dir->dir_pos = pos;
     516:	44 89 70 04          	mov    %r14d,0x4(%rax)
{
    struct dir_info *new_dir;

    //nova_dbg("dafs add dir info in radix tree");
    new_dir = kzalloc(sizeof(struct dir_info), GFP_KERNEL);
    new_dir->r_f = 0;
     51a:	c6 00 00             	movb   $0x0,(%rax)
    new_dir->sub_s = 0;
     51d:	c6 40 01 00          	movb   $0x0,0x1(%rax)
    new_dir->prio = LEVEL_0;
    new_dir->sub_num = 0;
    new_dir->dir_hash = hash_name;
    new_dir->dir_pos = pos;
    //nova_dbg("dir hash name is %llu", hash_name);
    INIT_LIST_HEAD(&new_dir->sub_file);
     521:	48 8d 40 18          	lea    0x18(%rax),%rax

    //nova_dbg("dafs add dir info in radix tree");
    new_dir = kzalloc(sizeof(struct dir_info), GFP_KERNEL);
    new_dir->r_f = 0;
    new_dir->sub_s = 0;
    new_dir->f_s = 0;
     525:	c6 40 ea 00          	movb   $0x0,-0x16(%rax)
    new_dir->prio = LEVEL_0;
     529:	c6 40 eb 00          	movb   $0x0,-0x15(%rax)
    new_dir->sub_num = 0;
    new_dir->dir_hash = hash_name;
    new_dir->dir_pos = pos;
    //nova_dbg("dir hash name is %llu", hash_name);
    INIT_LIST_HEAD(&new_dir->sub_file);
    radix_tree_insert(&ei->dir_tree, hash_name, new_dir);
     52d:	49 8d 7c 24 38       	lea    0x38(%r12),%rdi
    new_dir = kzalloc(sizeof(struct dir_info), GFP_KERNEL);
    new_dir->r_f = 0;
    new_dir->sub_s = 0;
    new_dir->f_s = 0;
    new_dir->prio = LEVEL_0;
    new_dir->sub_num = 0;
     532:	48 c7 40 f0 00 00 00 	movq   $0x0,-0x10(%rax)
     539:	00 
    new_dir->dir_hash = hash_name;
    new_dir->dir_pos = pos;
    //nova_dbg("dir hash name is %llu", hash_name);
    INIT_LIST_HEAD(&new_dir->sub_file);
    radix_tree_insert(&ei->dir_tree, hash_name, new_dir);
     53a:	48 89 da             	mov    %rbx,%rdx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
     53d:	48 89 43 18          	mov    %rax,0x18(%rbx)
	list->prev = list;
     541:	48 89 43 20          	mov    %rax,0x20(%rbx)
     545:	4c 89 ee             	mov    %r13,%rsi
     548:	e8 00 00 00 00       	callq  54d <add_dir_info+0x6d>
    return new_dir;
}
     54d:	48 89 d8             	mov    %rbx,%rax
     550:	5b                   	pop    %rbx
     551:	41 5c                	pop    %r12
     553:	41 5d                	pop    %r13
     555:	41 5e                	pop    %r14
     557:	5d                   	pop    %rbp
     558:	c3                   	retq   
     559:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000000560 <update_read_hot>:

/*update read frequency when read happens*/
int update_read_hot(struct dzt_entry_info *dzt_ei, u64 hn)
{
     560:	e8 00 00 00 00       	callq  565 <update_read_hot+0x5>
     565:	55                   	push   %rbp
    struct dir_info *dir_info;
    dir_info = radix_tree_lookup(&dzt_ei->dir_tree, hn);
     566:	48 83 c7 38          	add    $0x38,%rdi
    return new_dir;
}

/*update read frequency when read happens*/
int update_read_hot(struct dzt_entry_info *dzt_ei, u64 hn)
{
     56a:	48 89 e5             	mov    %rsp,%rbp
    struct dir_info *dir_info;
    dir_info = radix_tree_lookup(&dzt_ei->dir_tree, hn);
     56d:	e8 00 00 00 00       	callq  572 <update_read_hot+0x12>
    if(!dir_info)
     572:	48 85 c0             	test   %rax,%rax
     575:	74 07                	je     57e <update_read_hot+0x1e>
        BUG();
    dir_info->r_f++;
     577:	80 00 01             	addb   $0x1,(%rax)

    return 0;
}
     57a:	31 c0                	xor    %eax,%eax
     57c:	5d                   	pop    %rbp
     57d:	c3                   	retq   
int update_read_hot(struct dzt_entry_info *dzt_ei, u64 hn)
{
    struct dir_info *dir_info;
    dir_info = radix_tree_lookup(&dzt_ei->dir_tree, hn);
    if(!dir_info)
        BUG();
     57e:	0f 0b                	ud2    

0000000000000580 <dafs_readdir>:
    
}

/*遍历文件夹，dir_emit填充到用户空间*/
static int dafs_readdir(struct file *file, struct dir_context *ctx)
{
     580:	e8 00 00 00 00       	callq  585 <dafs_readdir+0x5>
     585:	55                   	push   %rbp
     586:	48 89 e5             	mov    %rsp,%rbp
     589:	41 57                	push   %r15
     58b:	41 56                	push   %r14
     58d:	41 55                	push   %r13
     58f:	41 54                	push   %r12
     591:	53                   	push   %rbx
     592:	48 89 f3             	mov    %rsi,%rbx
    u32 de_pos;
    timing_t readdir_time;

    //nova_dbg("%s: inode ino %llu, dentry ino %llu",__func__, inode->i_ino, dentry->d_inode->i_ino);

    nova_dbg("%s start",__func__);
     595:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    
}

/*遍历文件夹，dir_emit填充到用户空间*/
static int dafs_readdir(struct file *file, struct dir_context *ctx)
{
     59c:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
     5a0:	4c 8b 6f 20          	mov    0x20(%rdi),%r13
    struct inode *inode = file_inode(file);
    struct super_block *sb = inode->i_sb;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct nova_inode *pidir;
    struct nova_inode *child_pi;
    struct dentry *dentry = file->f_path.dentry; 
     5a4:	4c 8b 7f 18          	mov    0x18(%rdi),%r15
    u32 de_pos;
    timing_t readdir_time;

    //nova_dbg("%s: inode ino %llu, dentry ino %llu",__func__, inode->i_ino, dentry->d_inode->i_ino);

    nova_dbg("%s start",__func__);
     5a8:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    
}

/*遍历文件夹，dir_emit填充到用户空间*/
static int dafs_readdir(struct file *file, struct dir_context *ctx)
{
     5af:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     5b6:	00 00 
     5b8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     5bc:	31 c0                	xor    %eax,%eax
    struct inode *inode = file_inode(file);
    struct super_block *sb = inode->i_sb;
     5be:	4d 8b 65 28          	mov    0x28(%r13),%r12
     5c2:	4d 8b b4 24 b0 03 00 	mov    0x3b0(%r12),%r14
     5c9:	00 
    u32 de_pos;
    timing_t readdir_time;

    //nova_dbg("%s: inode ino %llu, dentry ino %llu",__func__, inode->i_ino, dentry->d_inode->i_ino);

    nova_dbg("%s start",__func__);
     5ca:	e8 00 00 00 00       	callq  5cf <dafs_readdir+0x4f>
    NOVA_START_TIMING(readdir_t, readdir_time);
     5cf:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 5d5 <dafs_readdir+0x55>
     5d5:	85 d2                	test   %edx,%edx
     5d7:	75 32                	jne    60b <dafs_readdir+0x8b>
    
    pidir = nova_get_inode(sb ,inode);
    pos = ctx->pos;
     5d9:	4c 8b 53 08          	mov    0x8(%rbx),%r10

    
    if(pos == READDIR_END){
     5dd:	49 83 fa ff          	cmp    $0xffffffffffffffff,%r10
     5e1:	75 74                	jne    657 <dafs_readdir+0xd7>
    //kfree(tem);
    //kfree(phn);
    //kfree(buf);
    //kfree(ppath);
OUT:
	NOVA_END_TIMING(readdir_t, readdir_time);
     5e3:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 5eb <dafs_readdir+0x6b>
     5ea:	00 
	//nova_dbg("%s readdir return", __func__);
	return 0;

}
     5eb:	31 c0                	xor    %eax,%eax
     5ed:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
     5f1:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
     5f8:	00 00 
     5fa:	75 56                	jne    652 <dafs_readdir+0xd2>
     5fc:	48 83 ec 80          	sub    $0xffffffffffffff80,%rsp
     600:	5b                   	pop    %rbx
     601:	41 5c                	pop    %r12
     603:	41 5d                	pop    %r13
     605:	41 5e                	pop    %r14
     607:	41 5f                	pop    %r15
     609:	5d                   	pop    %rbp
     60a:	c3                   	retq   
	getnstimeofday64(ts);
}

static inline void getrawmonotonic(struct timespec *ts)
{
	getrawmonotonic64(ts);
     60b:	48 8d 7d b0          	lea    -0x50(%rbp),%rdi
     60f:	e8 00 00 00 00       	callq  614 <dafs_readdir+0x94>

    nova_dbg("%s start",__func__);
    NOVA_START_TIMING(readdir_t, readdir_time);
    
    pidir = nova_get_inode(sb ,inode);
    pos = ctx->pos;
     614:	4c 8b 53 08          	mov    0x8(%rbx),%r10

    
    if(pos == READDIR_END){
     618:	49 83 fa ff          	cmp    $0xffffffffffffffff,%r10
     61c:	75 39                	jne    657 <dafs_readdir+0xd7>
    //kfree(tem);
    //kfree(phn);
    //kfree(buf);
    //kfree(ppath);
OUT:
	NOVA_END_TIMING(readdir_t, readdir_time);
     61e:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 624 <dafs_readdir+0xa4>
     624:	85 c0                	test   %eax,%eax
     626:	74 bb                	je     5e3 <dafs_readdir+0x63>
     628:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
     62c:	e8 00 00 00 00       	callq  631 <dafs_readdir+0xb1>
     631:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
     635:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
     639:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
     640:	48 2b 45 b8          	sub    -0x48(%rbp),%rax
     644:	48 03 45 c8          	add    -0x38(%rbp),%rax
     648:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 650 <dafs_readdir+0xd0>
     64f:	00 
     650:	eb 91                	jmp    5e3 <dafs_readdir+0x63>
	//nova_dbg("%s readdir return", __func__);
	return 0;

}
     652:	e8 00 00 00 00       	callq  657 <dafs_readdir+0xd7>
        //BUG();
        goto OUT;
    } 
    path.mnt = file->f_path.mnt;
    path.dentry = file->f_path.dentry;
    ppath = get_dentry_path(dentry, 1);
     657:	4c 89 ff             	mov    %r15,%rdi
     65a:	4c 89 55 80          	mov    %r10,-0x80(%rbp)
     65e:	e8 2d fa ff ff       	callq  90 <get_dentry_path.isra.4>
    nova_dbg("%s file get path innitial is %s",__func__,ppath);
     663:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     66a:	48 89 c2             	mov    %rax,%rdx
     66d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     674:	e8 00 00 00 00       	callq  679 <dafs_readdir+0xf9>
    ppath = sbi->ph_f; 
     679:	4d 8d 86 d8 01 00 00 	lea    0x1d8(%r14),%r8
    phlen = strlen(ppath);
    phn = &sbi->ph_dzt;
     680:	4d 8d 8e d7 05 00 00 	lea    0x5d7(%r14),%r9
    phname = &sbi->ph_name;
     687:	4d 8d 9e d6 09 00 00 	lea    0x9d6(%r14),%r11
    phname[0]='\0';
     68e:	41 c6 86 d6 09 00 00 	movb   $0x0,0x9d6(%r14)
     695:	00 
    phn[0]='\0';
     696:	41 c6 86 d7 05 00 00 	movb   $0x0,0x5d7(%r14)
     69d:	00 
        memcpy(ppath+tlen, end, 1);
    }
    nova_dbg("%s file get path is %s",__func__,ppath);
    */

    ei = find_dzt(sb, ppath, phn);
     69e:	4c 89 e7             	mov    %r12,%rdi
     6a1:	4c 89 ca             	mov    %r9,%rdx
     6a4:	4c 89 c6             	mov    %r8,%rsi
    ppath = get_dentry_path(dentry, 1);
    nova_dbg("%s file get path innitial is %s",__func__,ppath);
    ppath = sbi->ph_f; 
    phlen = strlen(ppath);
    phn = &sbi->ph_dzt;
    phname = &sbi->ph_name;
     6a7:	4c 89 5d 88          	mov    %r11,-0x78(%rbp)
        memcpy(ppath+tlen, end, 1);
    }
    nova_dbg("%s file get path is %s",__func__,ppath);
    */

    ei = find_dzt(sb, ppath, phn);
     6ab:	4c 89 4d 90          	mov    %r9,-0x70(%rbp)
     6af:	4c 89 45 98          	mov    %r8,-0x68(%rbp)
     6b3:	e8 48 f9 ff ff       	callq  0 <find_dzt>
    if(!ei){
     6b8:	48 85 c0             	test   %rax,%rax
        memcpy(ppath+tlen, end, 1);
    }
    nova_dbg("%s file get path is %s",__func__,ppath);
    */

    ei = find_dzt(sb, ppath, phn);
     6bb:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
    if(!ei){
     6c2:	4c 8b 45 98          	mov    -0x68(%rbp),%r8
     6c6:	4c 8b 4d 90          	mov    -0x70(%rbp),%r9
     6ca:	4c 8b 5d 88          	mov    -0x78(%rbp),%r11
     6ce:	4c 8b 55 80          	mov    -0x80(%rbp),%r10
     6d2:	0f 84 7b 04 00 00    	je     b53 <dafs_readdir+0x5d3>
        BUG();
    }
    ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->dz_addr);
     6d8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     6df:	49 8b 94 24 b0 03 00 	mov    0x3b0(%r12),%rdx
     6e6:	00 
    phlen = strlen(phn);
     6e7:	4c 89 cf             	mov    %r9,%rdi

    ei = find_dzt(sb, ppath, phn);
    if(!ei){
        BUG();
    }
    ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->dz_addr);
     6ea:	48 8b 40 10          	mov    0x10(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     6ee:	49 89 c7             	mov    %rax,%r15
     6f1:	4c 03 7a 18          	add    0x18(%rdx),%r15
     6f5:	48 85 c0             	test   %rax,%rax
     6f8:	b8 00 00 00 00       	mov    $0x0,%eax
     6fd:	4c 0f 44 f8          	cmove  %rax,%r15
    phlen = strlen(phn);
     701:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
     705:	48 89 f1             	mov    %rsi,%rcx
     708:	f2 ae                	repnz scas %es:(%rdi),%al
     70a:	48 f7 d1             	not    %rcx
     70d:	48 89 ca             	mov    %rcx,%rdx
     710:	48 01 f2             	add    %rsi,%rdx
    if(phlen==1){
     713:	48 83 fa 01          	cmp    $0x1,%rdx
     717:	0f 84 ee 03 00 00    	je     b0b <dafs_readdir+0x58b>
     71d:	4c 89 55 90          	mov    %r10,-0x70(%rbp)
        flen = strlen(ppath);
        memcpy(phname, ppath, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ppath)-phlen;
     721:	4c 89 c7             	mov    %r8,%rdi
     724:	48 89 f1             	mov    %rsi,%rcx
     727:	f2 ae                	repnz scas %es:(%rdi),%al
        memcpy(phname, ppath+phlen, flen);
     729:	49 8d 34 10          	lea    (%r8,%rdx,1),%rsi
     72d:	4c 89 df             	mov    %r11,%rdi
    if(phlen==1){
        flen = strlen(ppath);
        memcpy(phname, ppath, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ppath)-phlen;
     730:	48 89 c8             	mov    %rcx,%rax
     733:	48 f7 d0             	not    %rax
     736:	48 8d 48 ff          	lea    -0x1(%rax),%rcx
     73a:	48 29 d1             	sub    %rdx,%rcx
        memcpy(phname, ppath+phlen, flen);
     73d:	48 89 ca             	mov    %rcx,%rdx
     740:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
     744:	e8 00 00 00 00       	callq  749 <dafs_readdir+0x1c9>
        phname[flen]='\0';
     749:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
     74d:	4c 8b 55 90          	mov    -0x70(%rbp),%r10
        flen = strlen(ppath);
        memcpy(phname, ppath, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ppath)-phlen;
        memcpy(phname, ppath+phlen, flen);
     751:	49 89 c3             	mov    %rax,%r11
        phname[flen]='\0';
     754:	41 c6 84 0e d6 09 00 	movb   $0x0,0x9d6(%r14,%rcx,1)
     75b:	00 00 
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     75d:	85 c9                	test   %ecx,%ecx
     75f:	0f 8e f2 03 00 00    	jle    b57 <dafs_readdir+0x5d7>
     765:	8d 41 ff             	lea    -0x1(%rcx),%eax
     768:	45 31 c9             	xor    %r9d,%r9d
     76b:	49 8d 74 03 01       	lea    0x1(%r11,%rax,1),%rsi
     770:	4c 89 d8             	mov    %r11,%rax
		hash = hash * seed + (*str++);
     773:	4c 89 ca             	mov    %r9,%rdx
     776:	48 83 c0 01          	add    $0x1,%rax
     77a:	48 c1 e2 05          	shl    $0x5,%rdx
     77e:	4c 29 ca             	sub    %r9,%rdx
     781:	49 89 d1             	mov    %rdx,%r9
     784:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
     789:	49 01 d1             	add    %rdx,%r9
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     78c:	48 39 c6             	cmp    %rax,%rsi
     78f:	75 e2                	jne    773 <dafs_readdir+0x1f3>
    }
    ph_hash = BKDRHash(phname, flen);
    nova_dbg("%s dentry name is %s, len is %llu, value is %llu",__func__,phname,flen,ph_hash);
     791:	4d 89 c8             	mov    %r9,%r8
     794:	4c 89 da             	mov    %r11,%rdx
     797:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     79e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     7a5:	4c 89 55 90          	mov    %r10,-0x70(%rbp)
     7a9:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
     7ad:	e8 00 00 00 00       	callq  7b2 <dafs_readdir+0x232>
    ht_head = ei->ht_head;
    ret = lookup_in_hashtable(sb, ht_head, ph_hash, 1, &de_pos);
     7b2:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
     7b9:	4c 8b 4d 98          	mov    -0x68(%rbp),%r9
     7bd:	4c 8d 45 a4          	lea    -0x5c(%rbp),%r8
     7c1:	b9 01 00 00 00       	mov    $0x1,%ecx
     7c6:	4c 89 e7             	mov    %r12,%rdi
     7c9:	48 8b 70 18          	mov    0x18(%rax),%rsi
     7cd:	4c 89 ca             	mov    %r9,%rdx
     7d0:	e8 00 00 00 00       	callq  7d5 <dafs_readdir+0x255>
    if(!ret){
     7d5:	85 c0                	test   %eax,%eax
     7d7:	4c 8b 4d 98          	mov    -0x68(%rbp),%r9
     7db:	4c 8b 55 90          	mov    -0x70(%rbp),%r10
     7df:	0f 84 70 03 00 00    	je     b55 <dafs_readdir+0x5d5>
        //nova_dbg("%s not find dentry in nvm",__func__);
        BUG();
    }
    
    f_de = &ze->dentry[de_pos];
    ino = le64_to_cpu(f_de->ino);
     7e5:	8b 55 a4             	mov    -0x5c(%rbp),%edx
     7e8:	49 89 d0             	mov    %rdx,%r8
     7eb:	49 c1 e0 07          	shl    $0x7,%r8
     7ef:	4d 01 f8             	add    %r15,%r8
     7f2:	49 8b 88 98 40 00 00 	mov    0x4098(%r8),%rcx
    if(ino!=inode->i_ino){
     7f9:	49 3b 4d 40          	cmp    0x40(%r13),%rcx
     7fd:	0f 85 4e 03 00 00    	jne    b51 <dafs_readdir+0x5d1>
          
        f_de = &ze->dentry[de_pos];
    }

    hashname = ph_hash;
    dir = radix_tree_lookup(&ei->dir_tree, hashname);
     803:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
     80a:	4c 89 ce             	mov    %r9,%rsi
     80d:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
     811:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
     815:	4c 89 55 98          	mov    %r10,-0x68(%rbp)
     819:	4c 89 45 80          	mov    %r8,-0x80(%rbp)
     81d:	48 8d 78 38          	lea    0x38(%rax),%rdi
     821:	e8 00 00 00 00       	callq  826 <dafs_readdir+0x2a6>
    //BUG_ON(dir==NULL);
    if(f_de->file_type==ROOT_DIRECTORY && (ino!=NOVA_ROOT_INO)){
     826:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
          
        f_de = &ze->dentry[de_pos];
    }

    hashname = ph_hash;
    dir = radix_tree_lookup(&ei->dir_tree, hashname);
     82a:	49 89 c5             	mov    %rax,%r13
    //BUG_ON(dir==NULL);
    if(f_de->file_type==ROOT_DIRECTORY && (ino!=NOVA_ROOT_INO)){
     82d:	4c 8b 55 98          	mov    -0x68(%rbp),%r10
     831:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
     835:	48 8d 82 81 00 00 00 	lea    0x81(%rdx),%rax
     83c:	48 c1 e0 07          	shl    $0x7,%rax
     840:	41 80 7c 07 02 02    	cmpb   $0x2,0x2(%r15,%rax,1)
     846:	0f 85 90 02 00 00    	jne    adc <dafs_readdir+0x55c>
     84c:	48 83 f9 01          	cmp    $0x1,%rcx
     850:	0f 84 86 02 00 00    	je     adc <dafs_readdir+0x55c>
        isroot = 1;
        ei_hn = f_de->dzt_hn;
        dzt_m = sbi->dzt_m_info;
        sei = radix_tree_lookup(&dzt_m->dzt_root, ei_hn);
     856:	4c 8b 45 80          	mov    -0x80(%rbp),%r8
     85a:	49 8b be d8 0d 00 00 	mov    0xdd8(%r14),%rdi
     861:	48 89 4d 88          	mov    %rcx,-0x78(%rbp)
     865:	4c 89 55 90          	mov    %r10,-0x70(%rbp)
     869:	49 8b b0 a8 40 00 00 	mov    0x40a8(%r8),%rsi
     870:	e8 00 00 00 00       	callq  875 <dafs_readdir+0x2f5>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     875:	49 8b 94 24 b0 03 00 	mov    0x3b0(%r12),%rdx
     87c:	00 
     87d:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
        //nova_dbg("%s:new root zone addr is %llu",__func__, sei->dz_addr);
        /*update ze*/
        ze = (struct dafs_zone_entry *)nova_get_block(sb, sei->dz_addr);
     884:	48 8b 40 10          	mov    0x10(%rax),%rax
        ei = sei;
    }

    head = &dir->sub_file;
    //nova_dbg("%s:dir_subfile num is%d, zone addr is %llu",__func__,dir->sub_num, ei->dz_addr);
    list_for_each(this, head){
     888:	4c 8b 55 90          	mov    -0x70(%rbp),%r10
     88c:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     890:	49 89 c7             	mov    %rax,%r15
     893:	4c 03 7a 18          	add    0x18(%rdx),%r15
     897:	48 85 c0             	test   %rax,%rax
     89a:	b8 00 00 00 00       	mov    $0x0,%eax
     89f:	4c 0f 44 f8          	cmove  %rax,%r15
        /*update ze*/
        ze = (struct dafs_zone_entry *)nova_get_block(sb, sei->dz_addr);
        ei = sei;
    }

    head = &dir->sub_file;
     8a3:	49 8d 45 18          	lea    0x18(%r13),%rax
    //nova_dbg("%s:dir_subfile num is%d, zone addr is %llu",__func__,dir->sub_num, ei->dz_addr);
    list_for_each(this, head){
     8a7:	4d 8b 6d 18          	mov    0x18(%r13),%r13
        /*update ze*/
        ze = (struct dafs_zone_entry *)nova_get_block(sb, sei->dz_addr);
        ei = sei;
    }

    head = &dir->sub_file;
     8ab:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    //nova_dbg("%s:dir_subfile num is%d, zone addr is %llu",__func__,dir->sub_num, ei->dz_addr);
    list_for_each(this, head){
     8af:	4c 39 e8             	cmp    %r13,%rax
     8b2:	0f 84 17 02 00 00    	je     acf <dafs_readdir+0x54f>
        tem_sf = list_entry(this, struct file_p, list);
        f_pos = tem_sf->pos;
     8b8:	45 8b 75 10          	mov    0x10(%r13),%r14d
        if(!f_pos && !isroot){
     8bc:	c6 85 77 ff ff ff 00 	movb   $0x0,-0x89(%rbp)
            ctx->pos = READDIR_END;
            BUG();
            goto OUT;
        }

        de = &ze->dentry[f_pos];
     8c3:	49 8d 86 81 00 00 00 	lea    0x81(%r14),%rax
     8ca:	48 c1 e0 07          	shl    $0x7,%rax
     8ce:	4c 01 f8             	add    %r15,%rax
        //nova_dbg("%s:list subfile name:%s, pos id %d",__func__, de->name,f_pos);
        type = nova_get_entry_type((void *)de);
        if(type != DAFS_DIR_ENTRY){
     8d1:	80 38 06             	cmpb   $0x6,(%rax)
     8d4:	0f 85 6b 01 00 00    	jne    a45 <dafs_readdir+0x4c5>
     8da:	4c 89 65 90          	mov    %r12,-0x70(%rbp)
     8de:	4c 89 f2             	mov    %r14,%rdx
     8e1:	48 c7 85 78 ff ff ff 	movq   $0x0,-0x88(%rbp)
     8e8:	00 00 00 00 
     8ec:	49 89 de             	mov    %rbx,%r14
     8ef:	45 31 c0             	xor    %r8d,%r8d
     8f2:	49 89 c4             	mov    %rax,%r12
     8f5:	4c 89 d3             	mov    %r10,%rbx
     8f8:	49 89 d1             	mov    %rdx,%r9
     8fb:	49 c1 e1 07          	shl    $0x7,%r9
     8ff:	4d 01 f9             	add    %r15,%r9
            //nova_dbg ("unknown type\n");
            BUG();
            return -EINVAL;
        }

        if(de->file_type == NORMAL_DIRECTORY){
     902:	41 80 b9 82 40 00 00 	cmpb   $0x1,0x4082(%r9)
     909:	01 
     90a:	0f 84 37 01 00 00    	je     a47 <dafs_readdir+0x4c7>
			"name %s, namelen %u, rec len %u\n", f_pos,
			de->entry_type, le64_to_cpu(de->ino),
			de->name, de->name_len,
			DAFS_DEF_DENTRY_SIZE);*/

        if(de->ino>0){
     910:	48 c1 e2 07          	shl    $0x7,%rdx
     914:	4d 8b 94 17 98 40 00 	mov    0x4098(%r15,%rdx,1),%r10
     91b:	00 
     91c:	4d 85 d2             	test   %r10,%r10
     91f:	0f 84 e4 00 00 00    	je     a09 <dafs_readdir+0x489>
            ino = __le64_to_cpu(de->ino);
            pos = BKDRHash(de->name, de->name_len);
     925:	41 0f b6 89 81 40 00 	movzbl 0x4081(%r9),%ecx
     92c:	00 
     92d:	49 8d 84 17 b0 40 00 	lea    0x40b0(%r15,%rdx,1),%rax
     934:	00 
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     935:	84 c9                	test   %cl,%cl
     937:	0f 84 4e 01 00 00    	je     a8b <dafs_readdir+0x50b>
     93d:	8d 51 ff             	lea    -0x1(%rcx),%edx
     940:	31 db                	xor    %ebx,%ebx
     942:	48 8d 4c 10 01       	lea    0x1(%rax,%rdx,1),%rcx
		hash = hash * seed + (*str++);
     947:	48 89 da             	mov    %rbx,%rdx
     94a:	48 83 c0 01          	add    $0x1,%rax
     94e:	48 c1 e2 05          	shl    $0x5,%rdx
     952:	48 29 da             	sub    %rbx,%rdx
     955:	48 89 d3             	mov    %rdx,%rbx
     958:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
     95d:	48 01 d3             	add    %rdx,%rbx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     960:	48 39 c1             	cmp    %rax,%rcx
     963:	75 e2                	jne    947 <dafs_readdir+0x3c7>
            //BUG();
            ret = nova_get_inode_address(sb, ino, &pi_addr, 0);
     965:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
     969:	48 8d 55 a8          	lea    -0x58(%rbp),%rdx
     96d:	31 c9                	xor    %ecx,%ecx
     96f:	4c 89 d6             	mov    %r10,%rsi
     972:	4c 89 45 80          	mov    %r8,-0x80(%rbp)
     976:	4c 89 55 88          	mov    %r10,-0x78(%rbp)
     97a:	e8 00 00 00 00       	callq  97f <dafs_readdir+0x3ff>
            //BUG_ON(ret==0);
            if(ret){
     97f:	85 c0                	test   %eax,%eax
     981:	4c 8b 55 88          	mov    -0x78(%rbp),%r10
     985:	4c 8b 45 80          	mov    -0x80(%rbp),%r8
     989:	0f 85 d0 01 00 00    	jne    b5f <dafs_readdir+0x5df>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
     98f:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
                BUG();
				ctx->pos = READDIR_END;
				return ret;
            }

            child_pi = nova_get_block(sb, pi_addr);
     993:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
     997:	48 8b 92 b0 03 00 00 	mov    0x3b0(%rdx),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
     99e:	48 89 c1             	mov    %rax,%rcx
     9a1:	48 03 4a 18          	add    0x18(%rdx),%rcx
     9a5:	48 85 c0             	test   %rax,%rax
     9a8:	b8 00 00 00 00       	mov    $0x0,%eax
     9ad:	48 0f 45 c1          	cmovne %rcx,%rax
			//nova_dbgv("ctx: pos %d ino %llu, name %s, "
			//	"name_len %u, de_len %u\n", f_pos,
			//	(u64)ino, de->name, de->name_len,
			//	DAFS_DEF_DENTRY_SIZE);
			if (prev_de &&!dir_emit(ctx, prev_de->name,
     9b1:	4d 85 c0             	test   %r8,%r8
     9b4:	49 89 c3             	mov    %rax,%r11
     9b7:	74 43                	je     9fc <dafs_readdir+0x47c>
     9b9:	48 89 45 80          	mov    %rax,-0x80(%rbp)

static inline bool dir_emit(struct dir_context *ctx,
			    const char *name, int namelen,
			    u64 ino, unsigned type)
{
	return ctx->actor(ctx, name, namelen, ctx->pos, ino, type) == 0;
     9bd:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
     9c4:	49 8d 70 30          	lea    0x30(%r8),%rsi
     9c8:	41 0f b6 50 01       	movzbl 0x1(%r8),%edx
     9cd:	4c 89 55 88          	mov    %r10,-0x78(%rbp)
     9d1:	4d 89 d0             	mov    %r10,%r8
     9d4:	49 8b 4e 08          	mov    0x8(%r14),%rcx
     9d8:	4c 89 f7             	mov    %r14,%rdi
     9db:	44 0f b7 48 1c       	movzwl 0x1c(%rax),%r9d
     9e0:	66 41 c1 e9 0c       	shr    $0xc,%r9w
     9e5:	41 83 e1 0f          	and    $0xf,%r9d
     9e9:	41 ff 16             	callq  *(%r14)
     9ec:	85 c0                	test   %eax,%eax
     9ee:	4c 8b 55 88          	mov    -0x78(%rbp),%r10
     9f2:	4c 8b 5d 80          	mov    -0x80(%rbp),%r11
     9f6:	0f 85 65 01 00 00    	jne    b61 <dafs_readdir+0x5e1>
     9fc:	4c 89 d1             	mov    %r10,%rcx
				//nova_dbg("Here: pos %llu\n", ctx->pos);
                BUG();
				return 0;
			}
            prev_de = de;
            prev_child_pi = child_pi;
     9ff:	4c 89 9d 78 ff ff ff 	mov    %r11,-0x88(%rbp)
     a06:	4d 89 e0             	mov    %r12,%r8

        }
        ctx->pos = pos;
     a09:	49 89 5e 08          	mov    %rbx,0x8(%r14)
        ei = sei;
    }

    head = &dir->sub_file;
    //nova_dbg("%s:dir_subfile num is%d, zone addr is %llu",__func__,dir->sub_num, ei->dz_addr);
    list_for_each(this, head){
     a0d:	4d 8b 6d 00          	mov    0x0(%r13),%r13
     a11:	4c 3b 6d 98          	cmp    -0x68(%rbp),%r13
     a15:	74 7b                	je     a92 <dafs_readdir+0x512>
        tem_sf = list_entry(this, struct file_p, list);
        f_pos = tem_sf->pos;
     a17:	41 8b 55 10          	mov    0x10(%r13),%edx
        if(!f_pos && !isroot){
     a1b:	85 d2                	test   %edx,%edx
     a1d:	75 0d                	jne    a2c <dafs_readdir+0x4ac>
     a1f:	80 bd 77 ff ff ff 00 	cmpb   $0x0,-0x89(%rbp)
     a26:	0f 85 37 01 00 00    	jne    b63 <dafs_readdir+0x5e3>
            ctx->pos = READDIR_END;
            BUG();
            goto OUT;
        }

        de = &ze->dentry[f_pos];
     a2c:	4c 8d a2 81 00 00 00 	lea    0x81(%rdx),%r12
     a33:	49 c1 e4 07          	shl    $0x7,%r12
     a37:	4d 01 fc             	add    %r15,%r12
        //nova_dbg("%s:list subfile name:%s, pos id %d",__func__, de->name,f_pos);
        type = nova_get_entry_type((void *)de);
        if(type != DAFS_DIR_ENTRY){
     a3a:	41 80 3c 24 06       	cmpb   $0x6,(%r12)
     a3f:	0f 84 b3 fe ff ff    	je     8f8 <dafs_readdir+0x378>
            //nova_dbg ("unknown type\n");
            BUG();
     a45:	0f 0b                	ud2    
            return -EINVAL;
        }

        if(de->file_type == NORMAL_DIRECTORY){
            dir_hn = le64_to_cpu(de->hname);
            update_read_hot(ei, dir_hn);
     a47:	49 8b b1 a8 40 00 00 	mov    0x40a8(%r9),%rsi
     a4e:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
     a55:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
     a5c:	48 89 8d 60 ff ff ff 	mov    %rcx,-0xa0(%rbp)
     a63:	4c 89 45 80          	mov    %r8,-0x80(%rbp)
     a67:	4c 89 4d 88          	mov    %r9,-0x78(%rbp)
     a6b:	e8 00 00 00 00       	callq  a70 <dafs_readdir+0x4f0>
     a70:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
     a77:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
     a7e:	4c 8b 45 80          	mov    -0x80(%rbp),%r8
     a82:	4c 8b 4d 88          	mov    -0x78(%rbp),%r9
     a86:	e9 85 fe ff ff       	jmpq   910 <dafs_readdir+0x390>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
     a8b:	31 db                	xor    %ebx,%ebx
     a8d:	e9 d3 fe ff ff       	jmpq   965 <dafs_readdir+0x3e5>

        }
        ctx->pos = pos;
        //n++
    }
	if (prev_de &&!dir_emit(ctx, prev_de->name, prev_de->name_len, 
     a92:	4d 85 c0             	test   %r8,%r8
     a95:	49 89 da             	mov    %rbx,%r10
     a98:	4c 89 f3             	mov    %r14,%rbx
     a9b:	74 32                	je     acf <dafs_readdir+0x54f>
     a9d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
     aa4:	41 0f b6 50 01       	movzbl 0x1(%r8),%edx
     aa9:	49 8d 70 30          	lea    0x30(%r8),%rsi
     aad:	4c 89 f7             	mov    %r14,%rdi
     ab0:	49 89 c8             	mov    %rcx,%r8
     ab3:	4c 89 d1             	mov    %r10,%rcx
     ab6:	44 0f b7 48 1c       	movzwl 0x1c(%rax),%r9d
     abb:	66 41 c1 e9 0c       	shr    $0xc,%r9w
     ac0:	41 83 e1 0f          	and    $0xf,%r9d
     ac4:	41 ff 16             	callq  *(%r14)
     ac7:	85 c0                	test   %eax,%eax
     ac9:	0f 85 99 00 00 00    	jne    b68 <dafs_readdir+0x5e8>
                ino, IF2DT(le16_to_cpu(prev_child_pi->i_mode)))) {
			//nova_dbg("Here: pos %llu\n", ctx->pos);
            BUG();
			return 0;
	}
    ctx->pos = READDIR_END;
     acf:	48 c7 43 08 ff ff ff 	movq   $0xffffffffffffffff,0x8(%rbx)
     ad6:	ff 
     ad7:	e9 42 fb ff ff       	jmpq   61e <dafs_readdir+0x9e>
        /*update ze*/
        ze = (struct dafs_zone_entry *)nova_get_block(sb, sei->dz_addr);
        ei = sei;
    }

    head = &dir->sub_file;
     adc:	49 8d 45 18          	lea    0x18(%r13),%rax
    //nova_dbg("%s:dir_subfile num is%d, zone addr is %llu",__func__,dir->sub_num, ei->dz_addr);
    list_for_each(this, head){
     ae0:	4d 8b 6d 18          	mov    0x18(%r13),%r13
        /*update ze*/
        ze = (struct dafs_zone_entry *)nova_get_block(sb, sei->dz_addr);
        ei = sei;
    }

    head = &dir->sub_file;
     ae4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    //nova_dbg("%s:dir_subfile num is%d, zone addr is %llu",__func__,dir->sub_num, ei->dz_addr);
    list_for_each(this, head){
     ae8:	4c 39 e8             	cmp    %r13,%rax
     aeb:	74 e2                	je     acf <dafs_readdir+0x54f>
        tem_sf = list_entry(this, struct file_p, list);
        f_pos = tem_sf->pos;
     aed:	45 8b 75 10          	mov    0x10(%r13),%r14d
        if(!f_pos && !isroot){
     af1:	c6 85 77 ff ff ff 01 	movb   $0x1,-0x89(%rbp)
     af8:	45 85 f6             	test   %r14d,%r14d
     afb:	0f 85 c2 fd ff ff    	jne    8c3 <dafs_readdir+0x343>
            ctx->pos = READDIR_END;
     b01:	48 c7 43 08 ff ff ff 	movq   $0xffffffffffffffff,0x8(%rbx)
     b08:	ff 
            BUG();
     b09:	0f 0b                	ud2    
     b0b:	4c 89 55 88          	mov    %r10,-0x78(%rbp)
        BUG();
    }
    ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ppath);
     b0f:	4c 89 c7             	mov    %r8,%rdi
     b12:	48 89 f1             	mov    %rsi,%rcx
     b15:	f2 ae                	repnz scas %es:(%rdi),%al
        memcpy(phname, ppath, flen);
     b17:	4c 89 df             	mov    %r11,%rdi
        BUG();
    }
    ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ppath);
     b1a:	48 f7 d1             	not    %rcx
     b1d:	49 89 c9             	mov    %rcx,%r9
     b20:	48 8d 0c 31          	lea    (%rcx,%rsi,1),%rcx
        memcpy(phname, ppath, flen);
     b24:	4c 89 c6             	mov    %r8,%rsi
        BUG();
    }
    ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ppath);
     b27:	4c 89 4d 90          	mov    %r9,-0x70(%rbp)
        memcpy(phname, ppath, flen);
     b2b:	48 89 ca             	mov    %rcx,%rdx
     b2e:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
     b32:	e8 00 00 00 00       	callq  b37 <dafs_readdir+0x5b7>
        phname[flen]='\0';
     b37:	4c 8b 4d 90          	mov    -0x70(%rbp),%r9
    }
    ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ppath);
        memcpy(phname, ppath, flen);
     b3b:	49 89 c3             	mov    %rax,%r11
     b3e:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
     b42:	4c 8b 55 88          	mov    -0x78(%rbp),%r10
        phname[flen]='\0';
     b46:	42 c6 44 08 ff 00    	movb   $0x0,-0x1(%rax,%r9,1)
     b4c:	e9 0c fc ff ff       	jmpq   75d <dafs_readdir+0x1dd>
    }
    
    f_de = &ze->dentry[de_pos];
    ino = le64_to_cpu(f_de->ino);
    if(ino!=inode->i_ino){
        BUG();
     b51:	0f 0b                	ud2    
    nova_dbg("%s file get path is %s",__func__,ppath);
    */

    ei = find_dzt(sb, ppath, phn);
    if(!ei){
        BUG();
     b53:	0f 0b                	ud2    
    nova_dbg("%s dentry name is %s, len is %llu, value is %llu",__func__,phname,flen,ph_hash);
    ht_head = ei->ht_head;
    ret = lookup_in_hashtable(sb, ht_head, ph_hash, 1, &de_pos);
    if(!ret){
        //nova_dbg("%s not find dentry in nvm",__func__);
        BUG();
     b55:	0f 0b                	ud2    
     b57:	45 31 c9             	xor    %r9d,%r9d
     b5a:	e9 32 fc ff ff       	jmpq   791 <dafs_readdir+0x211>
            ret = nova_get_inode_address(sb, ino, &pi_addr, 0);
            //BUG_ON(ret==0);
            if(ret){
				//nova_dbgv("%s: get child inode %lu address "
				//	"failed %d\n", __func__, ino, ret);
                BUG();
     b5f:	0f 0b                	ud2    
			//	DAFS_DEF_DENTRY_SIZE);
			if (prev_de &&!dir_emit(ctx, prev_de->name,
				prev_de->name_len, ino,
				IF2DT(le16_to_cpu(prev_child_pi->i_mode)))) {
				//nova_dbg("Here: pos %llu\n", ctx->pos);
                BUG();
     b61:	0f 0b                	ud2    
     b63:	4c 89 f3             	mov    %r14,%rbx
     b66:	eb 99                	jmp    b01 <dafs_readdir+0x581>
        //n++
    }
	if (prev_de &&!dir_emit(ctx, prev_de->name, prev_de->name_len, 
                ino, IF2DT(le16_to_cpu(prev_child_pi->i_mode)))) {
			//nova_dbg("Here: pos %llu\n", ctx->pos);
            BUG();
     b68:	0f 0b                	ud2    
     b6a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000000b70 <dafs_rebuild_dir_time_and_size>:
    return dzt_ei;
}

void dafs_rebuild_dir_time_and_size(struct super_block *sb,
	struct nova_inode *pi, int link_change, struct inode *dir)
{
     b70:	e8 00 00 00 00       	callq  b75 <dafs_rebuild_dir_time_and_size+0x5>
    unsigned short links_count;

	if (!pi)
     b75:	48 85 f6             	test   %rsi,%rsi
     b78:	74 46                	je     bc0 <dafs_rebuild_dir_time_and_size+0x50>
    return dzt_ei;
}

void dafs_rebuild_dir_time_and_size(struct super_block *sb,
	struct nova_inode *pi, int link_change, struct inode *dir)
{
     b7a:	55                   	push   %rbp
     b7b:	48 89 e5             	mov    %rsp,%rbp
     b7e:	41 55                	push   %r13
     b80:	41 54                	push   %r12
     b82:	53                   	push   %rbx
     b83:	48 89 f3             	mov    %rsi,%rbx
     b86:	49 89 cc             	mov    %rcx,%r12
     b89:	41 89 d5             	mov    %edx,%r13d
    unsigned short links_count;

	if (!pi)
		return;

	pi->i_ctime = CURRENT_TIME_SEC.tv_sec;
     b8c:	e8 00 00 00 00       	callq  b91 <dafs_rebuild_dir_time_and_size+0x21>
     b91:	89 43 10             	mov    %eax,0x10(%rbx)
	pi->i_mtime = CURRENT_TIME_SEC.tv_sec;
     b94:	e8 00 00 00 00       	callq  b99 <dafs_rebuild_dir_time_and_size+0x29>
	pi->i_size = DAFS_DEF_DENTRY_SIZE;
     b99:	48 c7 43 08 80 00 00 	movq   $0x80,0x8(%rbx)
     ba0:	00 

	if (!pi)
		return;

	pi->i_ctime = CURRENT_TIME_SEC.tv_sec;
	pi->i_mtime = CURRENT_TIME_SEC.tv_sec;
     ba1:	89 43 14             	mov    %eax,0x14(%rbx)
	pi->i_size = DAFS_DEF_DENTRY_SIZE;
    links_count = cpu_to_le16(dir->i_nlink);
     ba4:	41 8b 44 24 48       	mov    0x48(%r12),%eax
    //nova_dbg("%s dir links is %d", __func__, links_count);
	if (links_count == 0 && link_change == -1)
     ba9:	66 85 c0             	test   %ax,%ax
     bac:	75 14                	jne    bc2 <dafs_rebuild_dir_time_and_size+0x52>
		links_count = 0;
     bae:	31 d2                	xor    %edx,%edx
	pi->i_ctime = CURRENT_TIME_SEC.tv_sec;
	pi->i_mtime = CURRENT_TIME_SEC.tv_sec;
	pi->i_size = DAFS_DEF_DENTRY_SIZE;
    links_count = cpu_to_le16(dir->i_nlink);
    //nova_dbg("%s dir links is %d", __func__, links_count);
	if (links_count == 0 && link_change == -1)
     bb0:	41 83 fd ff          	cmp    $0xffffffff,%r13d
     bb4:	75 0c                	jne    bc2 <dafs_rebuild_dir_time_and_size+0x52>
		links_count = 0;
	else
		links_count += link_change;
	pi->i_links_count = links_count;
     bb6:	66 89 53 1e          	mov    %dx,0x1e(%rbx)
}
     bba:	5b                   	pop    %rbx
     bbb:	41 5c                	pop    %r12
     bbd:	41 5d                	pop    %r13
     bbf:	5d                   	pop    %rbp
     bc0:	f3 c3                	repz retq 
    links_count = cpu_to_le16(dir->i_nlink);
    //nova_dbg("%s dir links is %d", __func__, links_count);
	if (links_count == 0 && link_change == -1)
		links_count = 0;
	else
		links_count += link_change;
     bc2:	42 8d 14 28          	lea    (%rax,%r13,1),%edx
	pi->i_links_count = links_count;
     bc6:	66 89 53 1e          	mov    %dx,0x1e(%rbx)
}
     bca:	5b                   	pop    %rbx
     bcb:	41 5c                	pop    %r12
     bcd:	41 5d                	pop    %r13
     bcf:	5d                   	pop    %rbp
     bd0:	eb ee                	jmp    bc0 <dafs_rebuild_dir_time_and_size+0x50>
     bd2:	0f 1f 40 00          	nopl   0x0(%rax)
     bd6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     bdd:	00 00 00 

0000000000000be0 <record_dir_log>:

/*record dir operation in logs*/
void record_dir_log(struct super_block *sb, struct dentry *src, struct dentry *des, int type)
{
     be0:	e8 00 00 00 00       	callq  be5 <record_dir_log+0x5>
     be5:	55                   	push   %rbp
     be6:	48 89 e5             	mov    %rsp,%rbp
     be9:	41 57                	push   %r15
     beb:	41 56                	push   %r14
     bed:	41 55                	push   %r13
     bef:	41 54                	push   %r12
     bf1:	49 89 f7             	mov    %rsi,%r15
     bf4:	53                   	push   %rbx
     bf5:	48 83 ec 58          	sub    $0x58,%rsp
}

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
     bf9:	48 8b 46 18          	mov    0x18(%rsi),%rax
	pi->i_links_count = links_count;
}

/*record dir operation in logs*/
void record_dir_log(struct super_block *sb, struct dentry *src, struct dentry *des, int type)
{
     bfd:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
     c01:	48 8b 9f b0 03 00 00 	mov    0x3b0(%rdi),%rbx
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
     c08:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     c0f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
	pi->i_links_count = links_count;
}

/*record dir operation in logs*/
void record_dir_log(struct super_block *sb, struct dentry *src, struct dentry *des, int type)
{
     c16:	89 4d a4             	mov    %ecx,-0x5c(%rbp)
     c19:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
     c1d:	48 8b 40 30          	mov    0x30(%rax),%rax
	pi->i_links_count = links_count;
}

/*record dir operation in logs*/
void record_dir_log(struct super_block *sb, struct dentry *src, struct dentry *des, int type)
{
     c21:	65 48 8b 0c 25 28 00 	mov    %gs:0x28,%rcx
     c28:	00 00 
     c2a:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
     c2e:	31 c9                	xor    %ecx,%ecx

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
     c30:	4c 8b 60 28          	mov    0x28(%rax),%r12
     c34:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
     c3b:	00 00 
    struct nova_sb_info *sbi = NOVA_SB(sb);
    char *ph, *buf, *tem, *ppath;
    //char *buf = NULL, *ppath=NULL, *tem=NULL;
    struct fs_struct *fs = current->fs;
     c3d:	4c 8b a8 30 06 00 00 	mov    0x630(%rax),%r13
     c44:	4d 8b b4 24 b0 03 00 	mov    0x3b0(%r12),%r14
     c4b:	00 
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
     c4c:	e8 00 00 00 00       	callq  c51 <record_dir_log+0x71>
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
     c51:	4d 85 e4             	test   %r12,%r12
     c54:	0f 84 43 04 00 00    	je     109d <record_dir_log+0x4bd>
    BUG_ON(sbi==NULL);
     c5a:	4d 85 f6             	test   %r14,%r14
     c5d:	0f 84 38 04 00 00    	je     109b <record_dir_log+0x4bb>
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
     c63:	49 8d 7d 04          	lea    0x4(%r13),%rdi
    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
     c67:	41 c6 86 d8 01 00 00 	movb   $0x0,0x1d8(%r14)
     c6e:	00 
    buf[0]='\0';
     c6f:	41 c6 86 d7 05 00 00 	movb   $0x0,0x5d7(%r14)
     c76:	00 
    tem[0]='\0';
     c77:	41 c6 86 d6 09 00 00 	movb   $0x0,0x9d6(%r14)
     c7e:	00 
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
     c7f:	4d 8d a6 d8 01 00 00 	lea    0x1d8(%r14),%r12
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
     c86:	e8 00 00 00 00       	callq  c8b <record_dir_log+0xab>
    vfsmnt = mntget(fs->pwd.mnt);
     c8b:	49 8b 7d 28          	mov    0x28(%r13),%rdi
     c8f:	e8 00 00 00 00       	callq  c94 <record_dir_log+0xb4>
    if(!vfsmnt){
     c94:	48 85 c0             	test   %rax,%rax
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
     c97:	49 89 c1             	mov    %rax,%r9
    if(!vfsmnt){
     c9a:	0f 84 90 05 00 00    	je     1230 <record_dir_log+0x650>
     ca0:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
     ca5:	f0 41 0f c1 45 04    	lock xadd %eax,0x4(%r13)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
     cab:	49 8b 77 28          	mov    0x28(%r15),%rsi
     caf:	49 c7 c0 00 00 00 00 	mov    $0x0,%r8
     cb6:	b9 02 00 00 00       	mov    $0x2,%ecx
     cbb:	4c 89 c7             	mov    %r8,%rdi
     cbe:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
     cc0:	0f 85 16 04 00 00    	jne    10dc <record_dir_log+0x4fc>
        memcpy(buf,"/",1);
        buf[1]='\0';
    }else{
        //nova_dbg("%s root dentry",__func__);
        memcpy(ph, "/", 1);
     cc6:	41 c6 86 d8 01 00 00 	movb   $0x2f,0x1d8(%r14)
     ccd:	2f 
        ph[1]='\0';
     cce:	41 c6 86 d9 01 00 00 	movb   $0x0,0x1d9(%r14)
     cd5:	00 
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
     cd6:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    src_pn = get_dentry_path(src,0);
    phname = &sbi->ph_name;
    phname[0]='\0';
    phn = &sbi->ph_dzt;
     cda:	48 8d 83 d7 05 00 00 	lea    0x5d7(%rbx),%rax
	cpu = smp_processor_id();
	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    src_pn = get_dentry_path(src,0);
    phname = &sbi->ph_name;
    phname[0]='\0';
     ce1:	c6 83 d6 09 00 00 00 	movb   $0x0,0x9d6(%rbx)
    phn = &sbi->ph_dzt;
    phn[0]='\0';
     ce8:	c6 83 d7 05 00 00 00 	movb   $0x0,0x5d7(%rbx)
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
     cef:	4c 89 e2             	mov    %r12,%rdx
     cf2:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    src_pn = get_dentry_path(src,0);
    phname = &sbi->ph_name;
    phname[0]='\0';
    phn = &sbi->ph_dzt;
     cf9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
     cfd:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
//debug
	cpu = smp_processor_id();
	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    src_pn = get_dentry_path(src,0);
    phname = &sbi->ph_name;
     d04:	4c 8d b3 d6 09 00 00 	lea    0x9d6(%rbx),%r14
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
     d0b:	48 8b 81 b0 03 00 00 	mov    0x3b0(%rcx),%rax
     d12:	4c 8b b8 d8 0d 00 00 	mov    0xdd8(%rax),%r15
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
     d19:	e8 00 00 00 00       	callq  d1e <record_dir_log+0x13e>
    tlen = strlen(phstr);
     d1e:	4c 89 e7             	mov    %r12,%rdi
     d21:	e8 00 00 00 00       	callq  d26 <record_dir_log+0x146>
    nova_dbg("%s length is %llu", __func__, tlen);
     d26:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     d2d:	48 89 c2             	mov    %rax,%rdx
     d30:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    tlen = strlen(phstr);
     d37:	49 89 c5             	mov    %rax,%r13
    nova_dbg("%s length is %llu", __func__, tlen);
     d3a:	e8 00 00 00 00       	callq  d3f <record_dir_log+0x15f>
    memcpy(phs, phstr, tlen);
     d3f:	48 8d bb d7 05 00 00 	lea    0x5d7(%rbx),%rdi
     d46:	4c 89 ea             	mov    %r13,%rdx
     d49:	4c 89 e6             	mov    %r12,%rsi
     d4c:	e8 00 00 00 00       	callq  d51 <record_dir_log+0x171>
    phs[tlen]='\0';
     d51:	42 c6 84 2b d7 05 00 	movb   $0x0,0x5d7(%rbx,%r13,1)
     d58:	00 00 
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
     d5a:	be 2f 00 00 00       	mov    $0x2f,%esi
            return dzt_ei;
        }
    }while(1);
    */
    /*root dir*/
    memcpy(phs, "/", 1);
     d5f:	c6 83 d7 05 00 00 2f 	movb   $0x2f,0x5d7(%rbx)
    phs[1]='\0';
     d66:	c6 83 d8 05 00 00 00 	movb   $0x0,0x5d8(%rbx)
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
     d6d:	4c 89 ff             	mov    %r15,%rdi
     d70:	e8 00 00 00 00       	callq  d75 <record_dir_log+0x195>
    if(!dzt_ei){
     d75:	48 85 c0             	test   %rax,%rax
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
     d78:	49 89 c5             	mov    %rax,%r13
    if(!dzt_ei){
     d7b:	0f 84 56 03 00 00    	je     10d7 <record_dir_log+0x4f7>
    phn[0]='\0';

    //phname = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    src_ei = find_dzt(sb, src_pn, phn);
    phlen = strlen(phn);
     d81:	48 8d bb d7 05 00 00 	lea    0x5d7(%rbx),%rdi
     d88:	e8 00 00 00 00       	callq  d8d <record_dir_log+0x1ad>
    if(phlen==1){
     d8d:	48 83 f8 01          	cmp    $0x1,%rax
     d91:	0f 84 dd 02 00 00    	je     1074 <record_dir_log+0x494>
        flen = strlen(src_pn);
        memcpy(phname, src_pn, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(src_pn)-phlen;
     d97:	4c 89 e7             	mov    %r12,%rdi
     d9a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
     d9e:	e8 00 00 00 00       	callq  da3 <record_dir_log+0x1c3>
     da3:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
        memcpy(phname, src_pn+phlen, flen);
     da7:	4c 89 f7             	mov    %r14,%rdi
    if(phlen==1){
        flen = strlen(src_pn);
        memcpy(phname, src_pn, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(src_pn)-phlen;
     daa:	48 29 f0             	sub    %rsi,%rax
        memcpy(phname, src_pn+phlen, flen);
     dad:	4c 01 e6             	add    %r12,%rsi
    if(phlen==1){
        flen = strlen(src_pn);
        memcpy(phname, src_pn, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(src_pn)-phlen;
     db0:	49 89 c7             	mov    %rax,%r15
        memcpy(phname, src_pn+phlen, flen);
     db3:	48 89 c2             	mov    %rax,%rdx
     db6:	e8 00 00 00 00       	callq  dbb <record_dir_log+0x1db>
        phname[flen]='\0';
     dbb:	42 c6 84 3b d6 09 00 	movb   $0x0,0x9d6(%rbx,%r15,1)
     dc2:	00 00 
	int i;

	for (i = 0; i < length; i++) {
     dc4:	45 85 ff             	test   %r15d,%r15d
     dc7:	0f 8e fb 02 00 00    	jle    10c8 <record_dir_log+0x4e8>
     dcd:	41 8d 47 ff          	lea    -0x1(%r15),%eax
     dd1:	45 31 ff             	xor    %r15d,%r15d
     dd4:	49 8d 4c 06 01       	lea    0x1(%r14,%rax,1),%rcx
     dd9:	4c 89 f0             	mov    %r14,%rax
		hash = hash * seed + (*str++);
     ddc:	4c 89 fa             	mov    %r15,%rdx
     ddf:	48 83 c0 01          	add    $0x1,%rax
     de3:	48 c1 e2 05          	shl    $0x5,%rdx
     de7:	4c 29 fa             	sub    %r15,%rdx
     dea:	49 89 d7             	mov    %rdx,%r15
     ded:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
     df2:	49 01 d7             	add    %rdx,%r15
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     df5:	48 39 c8             	cmp    %rcx,%rax
     df8:	75 e2                	jne    ddc <record_dir_log+0x1fc>
    }
    src_hn = BKDRHash(phname, flen);
    sdz_hn = src_ei->hash_name;
     dfa:	49 8b 45 30          	mov    0x30(%r13),%rax
     dfe:	48 89 45 98          	mov    %rax,-0x68(%rbp)

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    if(!des) {
     e02:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
     e06:	48 85 c0             	test   %rax,%rax
     e09:	0f 84 5b 02 00 00    	je     106a <record_dir_log+0x48a>
}

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
     e0f:	48 8b 40 18          	mov    0x18(%rax),%rax
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
     e13:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     e1a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
     e21:	48 8b 40 30          	mov    0x30(%rax),%rax
     e25:	48 8b 50 28          	mov    0x28(%rax),%rdx
     e29:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
     e30:	00 00 
    struct nova_sb_info *sbi = NOVA_SB(sb);
    char *ph, *buf, *tem, *ppath;
    //char *buf = NULL, *ppath=NULL, *tem=NULL;
    struct fs_struct *fs = current->fs;
     e32:	4c 8b a0 30 06 00 00 	mov    0x630(%rax),%r12
     e39:	4c 8b aa b0 03 00 00 	mov    0x3b0(%rdx),%r13
     e40:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
     e44:	e8 00 00 00 00       	callq  e49 <record_dir_log+0x269>
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
     e49:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
     e4d:	48 85 d2             	test   %rdx,%rdx
     e50:	0f 84 47 02 00 00    	je     109d <record_dir_log+0x4bd>
    BUG_ON(sbi==NULL);
     e56:	4d 85 ed             	test   %r13,%r13
     e59:	0f 84 3c 02 00 00    	je     109b <record_dir_log+0x4bb>
    ph = &sbi->ph_f;
     e5f:	49 8d 85 d8 01 00 00 	lea    0x1d8(%r13),%rax
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
     e66:	49 8d 7c 24 04       	lea    0x4(%r12),%rdi
    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
     e6b:	41 c6 85 d8 01 00 00 	movb   $0x0,0x1d8(%r13)
     e72:	00 
    buf[0]='\0';
     e73:	41 c6 85 d7 05 00 00 	movb   $0x0,0x5d7(%r13)
     e7a:	00 
    tem[0]='\0';
     e7b:	41 c6 85 d6 09 00 00 	movb   $0x0,0x9d6(%r13)
     e82:	00 
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
     e83:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
     e87:	e8 00 00 00 00       	callq  e8c <record_dir_log+0x2ac>
    vfsmnt = mntget(fs->pwd.mnt);
     e8c:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
     e91:	e8 00 00 00 00       	callq  e96 <record_dir_log+0x2b6>
    if(!vfsmnt){
     e96:	48 85 c0             	test   %rax,%rax
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
     e99:	49 89 c3             	mov    %rax,%r11
    if(!vfsmnt){
     e9c:	0f 84 c3 03 00 00    	je     1265 <record_dir_log+0x685>
     ea2:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
     ea7:	f0 41 0f c1 44 24 04 	lock xadd %eax,0x4(%r12)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
     eae:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
     eb2:	49 c7 c0 00 00 00 00 	mov    $0x0,%r8
     eb9:	b9 02 00 00 00       	mov    $0x2,%ecx
     ebe:	4c 89 c7             	mov    %r8,%rdi
     ec1:	48 8b 70 28          	mov    0x28(%rax),%rsi
     ec5:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
     ec7:	0f 85 dc 03 00 00    	jne    12a9 <record_dir_log+0x6c9>
        memcpy(buf,"/",1);
        buf[1]='\0';
    }else{
        //nova_dbg("%s root dentry",__func__);
        memcpy(ph, "/", 1);
     ecd:	41 c6 85 d8 01 00 00 	movb   $0x2f,0x1d8(%r13)
     ed4:	2f 
        ph[1]='\0';
     ed5:	41 c6 85 d9 01 00 00 	movb   $0x0,0x1d9(%r13)
     edc:	00 
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
     edd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
     ee1:	4c 8b 65 b8          	mov    -0x48(%rbp),%r12
     ee5:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     eec:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
     ef3:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
     efa:	4c 89 e2             	mov    %r12,%rdx
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
     efd:	4c 8b a8 d8 0d 00 00 	mov    0xdd8(%rax),%r13
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
     f04:	e8 00 00 00 00       	callq  f09 <record_dir_log+0x329>
    tlen = strlen(phstr);
     f09:	4c 89 e7             	mov    %r12,%rdi
     f0c:	4c 89 65 b8          	mov    %r12,-0x48(%rbp)
     f10:	e8 00 00 00 00       	callq  f15 <record_dir_log+0x335>
    nova_dbg("%s length is %llu", __func__, tlen);
     f15:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     f1c:	48 89 c2             	mov    %rax,%rdx
     f1f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    tlen = strlen(phstr);
     f26:	49 89 c4             	mov    %rax,%r12
    nova_dbg("%s length is %llu", __func__, tlen);
     f29:	e8 00 00 00 00       	callq  f2e <record_dir_log+0x34e>
    memcpy(phs, phstr, tlen);
     f2e:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
     f32:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
     f36:	4c 89 e2             	mov    %r12,%rdx
     f39:	e8 00 00 00 00       	callq  f3e <record_dir_log+0x35e>
    phs[tlen]='\0';
     f3e:	42 c6 84 23 d7 05 00 	movb   $0x0,0x5d7(%rbx,%r12,1)
     f45:	00 00 
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
     f47:	be 2f 00 00 00       	mov    $0x2f,%esi
            return dzt_ei;
        }
    }while(1);
    */
    /*root dir*/
    memcpy(phs, "/", 1);
     f4c:	c6 83 d7 05 00 00 2f 	movb   $0x2f,0x5d7(%rbx)
    phs[1]='\0';
     f53:	c6 83 d8 05 00 00 00 	movb   $0x0,0x5d8(%rbx)
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
     f5a:	4c 89 ef             	mov    %r13,%rdi
     f5d:	e8 00 00 00 00       	callq  f62 <record_dir_log+0x382>
    if(!dzt_ei){
     f62:	48 85 c0             	test   %rax,%rax
     f65:	0f 84 6c 01 00 00    	je     10d7 <record_dir_log+0x4f7>
    else {
        ph = get_dentry_path(des,0);
        //memcpy(phname, ph, strlen(ph)+1);
        dzt_ei = find_dzt(sb, ph, phn);
        des_dz_hn = dzt_ei->hash_name;
        phlen = strlen(phn);
     f6b:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    }
    else {
        ph = get_dentry_path(des,0);
        //memcpy(phname, ph, strlen(ph)+1);
        dzt_ei = find_dzt(sb, ph, phn);
        des_dz_hn = dzt_ei->hash_name;
     f6f:	4c 8b 60 30          	mov    0x30(%rax),%r12
        phlen = strlen(phn);
     f73:	e8 00 00 00 00       	callq  f78 <record_dir_log+0x398>
        if(phlen==1){
     f78:	48 83 f8 01          	cmp    $0x1,%rax
     f7c:	0f 84 1d 01 00 00    	je     109f <record_dir_log+0x4bf>
            flen = strlen(ph);
            memcpy(phname, ph, flen);
            phname[flen]='\0';
        } else {
            flen = strlen(ph)-phlen;
     f82:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
     f86:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
     f8a:	e8 00 00 00 00       	callq  f8f <record_dir_log+0x3af>
     f8f:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
            memcpy(phname, ph+phlen, flen);
     f93:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
     f97:	4c 89 f7             	mov    %r14,%rdi
        if(phlen==1){
            flen = strlen(ph);
            memcpy(phname, ph, flen);
            phname[flen]='\0';
        } else {
            flen = strlen(ph)-phlen;
     f9a:	48 29 d0             	sub    %rdx,%rax
            memcpy(phname, ph+phlen, flen);
     f9d:	48 01 d6             	add    %rdx,%rsi
        if(phlen==1){
            flen = strlen(ph);
            memcpy(phname, ph, flen);
            phname[flen]='\0';
        } else {
            flen = strlen(ph)-phlen;
     fa0:	49 89 c5             	mov    %rax,%r13
            memcpy(phname, ph+phlen, flen);
     fa3:	48 89 c2             	mov    %rax,%rdx
     fa6:	e8 00 00 00 00       	callq  fab <record_dir_log+0x3cb>
            phname[flen]='\0';
     fab:	42 c6 84 2b d6 09 00 	movb   $0x0,0x9d6(%rbx,%r13,1)
     fb2:	00 00 
     fb4:	45 85 ed             	test   %r13d,%r13d
     fb7:	0f 8e 13 01 00 00    	jle    10d0 <record_dir_log+0x4f0>
     fbd:	41 8d 45 ff          	lea    -0x1(%r13),%eax
     fc1:	31 db                	xor    %ebx,%ebx
     fc3:	49 8d 54 06 01       	lea    0x1(%r14,%rax,1),%rdx
		hash = hash * seed + (*str++);
     fc8:	48 89 d8             	mov    %rbx,%rax
     fcb:	49 83 c6 01          	add    $0x1,%r14
     fcf:	48 c1 e0 05          	shl    $0x5,%rax
     fd3:	48 29 d8             	sub    %rbx,%rax
     fd6:	48 89 c3             	mov    %rax,%rbx
     fd9:	49 0f be 46 ff       	movsbq -0x1(%r14),%rax
     fde:	48 01 c3             	add    %rax,%rbx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
     fe1:	49 39 d6             	cmp    %rdx,%r14
     fe4:	75 e2                	jne    fc8 <record_dir_log+0x3e8>
        //kfree(ph);
    }

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    dzt_blk = dafs_get_dzt_block(sb);
     fe6:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
     fea:	4c 89 f7             	mov    %r14,%rdi
     fed:	e8 00 00 00 00       	callq  ff2 <record_dir_log+0x412>
    make_dzt_ptr(sb, &dzt_p);
     ff2:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
     ff6:	4c 89 f7             	mov    %r14,%rdi
        //kfree(ph);
    }

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    dzt_blk = dafs_get_dzt_block(sb);
     ff9:	49 89 c5             	mov    %rax,%r13
    make_dzt_ptr(sb, &dzt_p);
     ffc:	e8 00 00 00 00       	callq  1001 <record_dir_log+0x421>
    dlog = (struct direntry_log*)&dzt_blk->dzt_entry[DAFS_DZT_ENTRIES_IN_BLOCK];
    test_and_set_bit_le(bitpos, (void *)dzt_p->bitmap);
    1001:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    1005:	ba 48 00 00 00       	mov    $0x48,%edx
    100a:	48 8b 00             	mov    (%rax),%rax
    100d:	f0 48 0f ab 10       	lock bts %rdx,(%rax)
    1012:	72 00                	jb     1014 <record_dir_log+0x434>

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    /*not decided*/
    dlog->type_d = type;
    1014:	0f b6 45 a4          	movzbl -0x5c(%rbp),%eax
    dlog->des_hashname = cpu_to_le64(des_hn);

    //kfree(src_pn);
    //kfree(phname);
    //kfree(phn);
    kfree(dzt_p);
    1018:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    /*not decided*/
    dlog->type_d = type;
    dlog->src_dz_hn = cpu_to_le64(sdz_hn);
    dlog->src_hashname = cpu_to_le64(src_hn);
    101c:	4d 89 bd 28 10 00 00 	mov    %r15,0x1028(%r13)
    dlog->des_dz_hn = cpu_to_le64(des_dz_hn);
    1023:	4d 89 a5 18 10 00 00 	mov    %r12,0x1018(%r13)
    dlog->des_hashname = cpu_to_le64(des_hn);
    102a:	49 89 9d 20 10 00 00 	mov    %rbx,0x1020(%r13)
    test_and_set_bit_le(bitpos, (void *)dzt_p->bitmap);

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    /*not decided*/
    dlog->type_d = type;
    1031:	41 88 85 08 10 00 00 	mov    %al,0x1008(%r13)
    dlog->src_dz_hn = cpu_to_le64(sdz_hn);
    1038:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    103c:	49 89 85 10 10 00 00 	mov    %rax,0x1010(%r13)
    dlog->des_hashname = cpu_to_le64(des_hn);

    //kfree(src_pn);
    //kfree(phname);
    //kfree(phn);
    kfree(dzt_p);
    1043:	e8 00 00 00 00       	callq  1048 <record_dir_log+0x468>
    //nova_dbg("%s end record log",__func__);
}
    1048:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    104c:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    1053:	00 00 
    1055:	0f 85 d0 01 00 00    	jne    122b <record_dir_log+0x64b>
    105b:	48 83 c4 58          	add    $0x58,%rsp
    105f:	5b                   	pop    %rbx
    1060:	41 5c                	pop    %r12
    1062:	41 5d                	pop    %r13
    1064:	41 5e                	pop    %r14
    1066:	41 5f                	pop    %r15
    1068:	5d                   	pop    %rbp
    1069:	c3                   	retq   
    sdz_hn = src_ei->hash_name;

	pair = nova_get_journal_pointers(sb, cpu);
    //nova_dbg("journal tail %llu, with head %llu", le64_to_cpu(pair->journal_tail), le64_to_cpu(pair->journal_head));
    if(!des) {
        des_hn = 0;
    106a:	31 db                	xor    %ebx,%ebx
        des_dz_hn = 0;
    106c:	45 31 e4             	xor    %r12d,%r12d
    106f:	e9 72 ff ff ff       	jmpq   fe6 <record_dir_log+0x406>
    //phname = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    src_ei = find_dzt(sb, src_pn, phn);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(src_pn);
    1074:	4c 89 e7             	mov    %r12,%rdi
    1077:	e8 00 00 00 00       	callq  107c <record_dir_log+0x49c>
        memcpy(phname, src_pn, flen);
    107c:	4c 89 e6             	mov    %r12,%rsi
    //phname = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*(strlen(src_pn)+1), GFP_KERNEL);
    src_ei = find_dzt(sb, src_pn, phn);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(src_pn);
    107f:	49 89 c7             	mov    %rax,%r15
        memcpy(phname, src_pn, flen);
    1082:	48 89 c2             	mov    %rax,%rdx
    1085:	4c 89 f7             	mov    %r14,%rdi
    1088:	e8 00 00 00 00       	callq  108d <record_dir_log+0x4ad>
        phname[flen]='\0';
    108d:	42 c6 84 3b d6 09 00 	movb   $0x0,0x9d6(%rbx,%r15,1)
    1094:	00 00 
    1096:	e9 29 fd ff ff       	jmpq   dc4 <record_dir_log+0x1e4>
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    109b:	0f 0b                	ud2    
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    109d:	0f 0b                	ud2    
        //memcpy(phname, ph, strlen(ph)+1);
        dzt_ei = find_dzt(sb, ph, phn);
        des_dz_hn = dzt_ei->hash_name;
        phlen = strlen(phn);
        if(phlen==1){
            flen = strlen(ph);
    109f:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    10a3:	e8 00 00 00 00       	callq  10a8 <record_dir_log+0x4c8>
            memcpy(phname, ph, flen);
    10a8:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
        //memcpy(phname, ph, strlen(ph)+1);
        dzt_ei = find_dzt(sb, ph, phn);
        des_dz_hn = dzt_ei->hash_name;
        phlen = strlen(phn);
        if(phlen==1){
            flen = strlen(ph);
    10ac:	49 89 c5             	mov    %rax,%r13
            memcpy(phname, ph, flen);
    10af:	48 89 c2             	mov    %rax,%rdx
    10b2:	4c 89 f7             	mov    %r14,%rdi
    10b5:	e8 00 00 00 00       	callq  10ba <record_dir_log+0x4da>
            phname[flen]='\0';
    10ba:	42 c6 84 2b d6 09 00 	movb   $0x0,0x9d6(%rbx,%r13,1)
    10c1:	00 00 
    10c3:	e9 ec fe ff ff       	jmpq   fb4 <record_dir_log+0x3d4>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    10c8:	45 31 ff             	xor    %r15d,%r15d
    10cb:	e9 2a fd ff ff       	jmpq   dfa <record_dir_log+0x21a>
    10d0:	31 db                	xor    %ebx,%ebx
    10d2:	e9 0f ff ff ff       	jmpq   fe6 <record_dir_log+0x406>
    10d7:	e8 00 00 00 00       	callq  10dc <record_dir_log+0x4fc>
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    10dc:	4d 8d ae d7 05 00 00 	lea    0x5d7(%r14),%r13
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
        memcpy(buf,"/",1);
    10e3:	41 c6 86 d7 05 00 00 	movb   $0x2f,0x5d7(%r14)
    10ea:	2f 
        buf[1]='\0';
    10eb:	41 c6 86 d8 05 00 00 	movb   $0x0,0x5d8(%r14)
    10f2:	00 
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    10f3:	4c 89 ef             	mov    %r13,%rdi
    10f6:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
    10fa:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
    10fe:	e8 00 00 00 00       	callq  1103 <record_dir_log+0x523>
    1103:	b9 2f 00 00 00       	mov    $0x2f,%ecx
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    1108:	49 8d 7c 05 01       	lea    0x1(%r13,%rax,1),%rdi
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    110d:	66 41 89 4c 05 00    	mov    %cx,0x0(%r13,%rax,1)
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    1113:	49 8b 77 28          	mov    0x28(%r15),%rsi
    1117:	e8 00 00 00 00       	callq  111c <record_dir_log+0x53c>
        p_dentry = tem_dentry->d_parent;
    111c:	4d 8b 7f 18          	mov    0x18(%r15),%r15
        //plen = strlen(buf);
        //buf[plen]='\0';
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
    1120:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
    1124:	b9 02 00 00 00       	mov    $0x2,%ecx
    1129:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
    112d:	49 8b 77 28          	mov    0x28(%r15),%rsi
    1131:	4c 89 c7             	mov    %r8,%rdi
    1134:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    1136:	75 bb                	jne    10f3 <record_dir_log+0x513>
    1138:	49 8b 47 30          	mov    0x30(%r15),%rax
    113c:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
    1141:	75 b0                	jne    10f3 <record_dir_log+0x513>

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    1143:	49 8d 86 d6 09 00 00 	lea    0x9d6(%r14),%rax
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    114a:	4c 89 ea             	mov    %r13,%rdx
    114d:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1154:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    115b:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    115f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    1163:	e8 00 00 00 00       	callq  1168 <record_dir_log+0x588>
    tlen = strlen(buf);
    1168:	31 c0                	xor    %eax,%eax
    116a:	4c 89 ef             	mov    %r13,%rdi
    116d:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    1171:	f2 ae                	repnz scas %es:(%rdi),%al
    memcpy(tem, buf, tlen);
    1173:	49 8d be d6 09 00 00 	lea    0x9d6(%r14),%rdi
    117a:	4c 89 ee             	mov    %r13,%rsi
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    tlen = strlen(buf);
    117d:	48 f7 d1             	not    %rcx
    1180:	4c 8d 79 ff          	lea    -0x1(%rcx),%r15
    memcpy(tem, buf, tlen);
    1184:	4c 89 fa             	mov    %r15,%rdx
    1187:	e8 00 00 00 00       	callq  118c <record_dir_log+0x5ac>
    tem[tlen]='\0';
    118c:	4c 8b 4d 98          	mov    -0x68(%rbp),%r9
    1190:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
    1194:	43 c6 84 3e d6 09 00 	movb   $0x0,0x9d6(%r14,%r15,1)
    119b:	00 00 
    119d:	49 89 de             	mov    %rbx,%r14
    do{
        ppath = strrchr(tem, '/');
    11a0:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    11a4:	be 2f 00 00 00       	mov    $0x2f,%esi
    11a9:	4c 89 45 98          	mov    %r8,-0x68(%rbp)
    11ad:	4c 89 4d a8          	mov    %r9,-0x58(%rbp)
    11b1:	e8 00 00 00 00       	callq  11b6 <record_dir_log+0x5d6>
    11b6:	48 89 c3             	mov    %rax,%rbx
        plen = strlen(ppath);
    11b9:	48 89 c7             	mov    %rax,%rdi
    11bc:	e8 00 00 00 00       	callq  11c1 <record_dir_log+0x5e1>
        phlen = tlen - plen;
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    11c1:	48 89 de             	mov    %rbx,%rsi
    11c4:	4c 89 e7             	mov    %r12,%rdi
    memcpy(tem, buf, tlen);
    tem[tlen]='\0';
    do{
        ppath = strrchr(tem, '/');
        plen = strlen(ppath);
        phlen = tlen - plen;
    11c7:	49 29 c7             	sub    %rax,%r15
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    11ca:	e8 00 00 00 00       	callq  11cf <record_dir_log+0x5ef>
        memcpy(tem, buf, tlen);
    11cf:	48 8b 5d b8          	mov    -0x48(%rbp),%rbx
    11d3:	4c 89 ee             	mov    %r13,%rsi
    11d6:	4c 89 fa             	mov    %r15,%rdx
    11d9:	48 89 df             	mov    %rbx,%rdi
    11dc:	e8 00 00 00 00       	callq  11e1 <record_dir_log+0x601>
        tem[tlen]='\0';
        if(!strcmp(tem,"/"))
    11e1:	4c 8b 45 98          	mov    -0x68(%rbp),%r8
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
        memcpy(tem, buf, tlen);
        tem[tlen]='\0';
    11e5:	48 89 de             	mov    %rbx,%rsi
    11e8:	42 c6 04 3b 00       	movb   $0x0,(%rbx,%r15,1)
        if(!strcmp(tem,"/"))
    11ed:	b9 02 00 00 00       	mov    $0x2,%ecx
    11f2:	4c 8b 4d a8          	mov    -0x58(%rbp),%r9
    11f6:	4c 89 c7             	mov    %r8,%rdi
    11f9:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    11fb:	75 a3                	jne    11a0 <record_dir_log+0x5c0>
            break;
    }while(1);

    //BUG_ON(strlen(ph)==1023);
    nova_dbg("%s ful ph is %s sbi is %s",__func__,ph, sbi->ph_f);
    11fd:	4c 89 e1             	mov    %r12,%rcx
    1200:	4c 89 e2             	mov    %r12,%rdx
    1203:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    120a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1211:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
    1215:	4c 89 f3             	mov    %r14,%rbx
    1218:	e8 00 00 00 00       	callq  121d <record_dir_log+0x63d>
    //BUG_ON(ph==NULL);
    
    mntput(vfsmnt);
    121d:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
    1221:	4c 89 cf             	mov    %r9,%rdi
    1224:	e8 00 00 00 00       	callq  1229 <record_dir_log+0x649>
    1229:	eb 11                	jmp    123c <record_dir_log+0x65c>
    //kfree(src_pn);
    //kfree(phname);
    //kfree(phn);
    kfree(dzt_p);
    //nova_dbg("%s end record log",__func__);
}
    122b:	e8 00 00 00 00       	callq  1230 <record_dir_log+0x650>
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    if(!vfsmnt){
        nova_dbg("not find mnt");
    1230:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1237:	e8 00 00 00 00       	callq  123c <record_dir_log+0x65c>
    
    //kfree(buf);
    //kfree(tem);
    //nova_dbg("dafs finish get dentry path");
ERR:
    nova_dbg("%s ful ph is %s len %llu, sbi %s ",__func__,ph, strlen(ph), sbi->ph_f);
    123c:	4c 89 e7             	mov    %r12,%rdi
    123f:	e8 00 00 00 00       	callq  1244 <record_dir_log+0x664>
    1244:	4d 89 e0             	mov    %r12,%r8
    1247:	48 89 c1             	mov    %rax,%rcx
    124a:	4c 89 e2             	mov    %r12,%rdx
    124d:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1254:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    125b:	e8 00 00 00 00       	callq  1260 <record_dir_log+0x680>
    1260:	e9 71 fa ff ff       	jmpq   cd6 <record_dir_log+0xf6>
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    if(!vfsmnt){
        nova_dbg("not find mnt");
    1265:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    126c:	e8 00 00 00 00       	callq  1271 <record_dir_log+0x691>
    
    //kfree(buf);
    //kfree(tem);
    //nova_dbg("dafs finish get dentry path");
ERR:
    nova_dbg("%s ful ph is %s len %llu, sbi %s ",__func__,ph, strlen(ph), sbi->ph_f);
    1271:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    1275:	31 c0                	xor    %eax,%eax
    1277:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    127b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1282:	f2 ae                	repnz scas %es:(%rdi),%al
    1284:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    1288:	48 89 c8             	mov    %rcx,%rax
    128b:	48 f7 d0             	not    %rax
    128e:	48 8d 48 ff          	lea    -0x1(%rax),%rcx
    1292:	49 89 f8             	mov    %rdi,%r8
    1295:	48 89 fa             	mov    %rdi,%rdx
    1298:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    129f:	e8 00 00 00 00       	callq  12a4 <record_dir_log+0x6c4>
    12a4:	e9 34 fc ff ff       	jmpq   edd <record_dir_log+0x2fd>
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    12a9:	4d 8d a5 d7 05 00 00 	lea    0x5d7(%r13),%r12
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
        memcpy(buf,"/",1);
    12b0:	41 c6 85 d7 05 00 00 	movb   $0x2f,0x5d7(%r13)
    12b7:	2f 
        buf[1]='\0';
    12b8:	41 c6 85 d8 05 00 00 	movb   $0x0,0x5d8(%r13)
    12bf:	00 
    12c0:	4c 89 6d 90          	mov    %r13,-0x70(%rbp)
    12c4:	49 89 dd             	mov    %rbx,%r13
    12c7:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    12cb:	4c 89 e7             	mov    %r12,%rdi
    12ce:	4c 89 45 88          	mov    %r8,-0x78(%rbp)
    12d2:	4c 89 5d b0          	mov    %r11,-0x50(%rbp)
    12d6:	e8 00 00 00 00       	callq  12db <record_dir_log+0x6fb>
    12db:	ba 2f 00 00 00       	mov    $0x2f,%edx
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    12e0:	49 8d 7c 04 01       	lea    0x1(%r12,%rax,1),%rdi
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    12e5:	66 41 89 14 04       	mov    %dx,(%r12,%rax,1)
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    12ea:	48 8b 73 28          	mov    0x28(%rbx),%rsi
    12ee:	e8 00 00 00 00       	callq  12f3 <record_dir_log+0x713>
        p_dentry = tem_dentry->d_parent;
    12f3:	48 8b 5b 18          	mov    0x18(%rbx),%rbx
        //plen = strlen(buf);
        //buf[plen]='\0';
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
    12f7:	4c 8b 45 88          	mov    -0x78(%rbp),%r8
    12fb:	b9 02 00 00 00       	mov    $0x2,%ecx
    1300:	4c 8b 5d b0          	mov    -0x50(%rbp),%r11
    1304:	48 8b 73 28          	mov    0x28(%rbx),%rsi
    1308:	4c 89 c7             	mov    %r8,%rdi
    130b:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    130d:	75 bc                	jne    12cb <record_dir_log+0x6eb>
    130f:	48 8b 43 30          	mov    0x30(%rbx),%rax
    1313:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
    1318:	75 b1                	jne    12cb <record_dir_log+0x6eb>
    131a:	4c 89 eb             	mov    %r13,%rbx
    131d:	4c 8b 6d 90          	mov    -0x70(%rbp),%r13
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    1321:	4c 89 e2             	mov    %r12,%rdx
    1324:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    132b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1332:	4c 89 5d 80          	mov    %r11,-0x80(%rbp)

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    1336:	49 8d 85 d6 09 00 00 	lea    0x9d6(%r13),%rax
    133d:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    1341:	e8 00 00 00 00       	callq  1346 <record_dir_log+0x766>
    tlen = strlen(buf);
    1346:	31 c0                	xor    %eax,%eax
    1348:	4c 89 e7             	mov    %r12,%rdi
    134b:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    134f:	f2 ae                	repnz scas %es:(%rdi),%al
    memcpy(tem, buf, tlen);
    1351:	49 8d bd d6 09 00 00 	lea    0x9d6(%r13),%rdi
    1358:	4c 89 e6             	mov    %r12,%rsi
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    tlen = strlen(buf);
    135b:	48 f7 d1             	not    %rcx
    135e:	48 89 c8             	mov    %rcx,%rax
    1361:	48 83 e8 01          	sub    $0x1,%rax
    memcpy(tem, buf, tlen);
    1365:	48 89 c2             	mov    %rax,%rdx
    1368:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    136c:	e8 00 00 00 00       	callq  1371 <record_dir_log+0x791>
    tem[tlen]='\0';
    1371:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    1375:	4c 8b 5d 80          	mov    -0x80(%rbp),%r11
    1379:	4c 8b 45 88          	mov    -0x78(%rbp),%r8
    137d:	41 c6 84 05 d6 09 00 	movb   $0x0,0x9d6(%r13,%rax,1)
    1384:	00 00 
    1386:	4d 89 f5             	mov    %r14,%r13
    1389:	49 89 de             	mov    %rbx,%r14
    138c:	4c 89 db             	mov    %r11,%rbx
    do{
        ppath = strrchr(tem, '/');
    138f:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
    1393:	be 2f 00 00 00       	mov    $0x2f,%esi
    1398:	4c 89 45 80          	mov    %r8,-0x80(%rbp)
    139c:	e8 00 00 00 00       	callq  13a1 <record_dir_log+0x7c1>
        plen = strlen(ppath);
    13a1:	48 89 c7             	mov    %rax,%rdi
    13a4:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    13a8:	e8 00 00 00 00       	callq  13ad <record_dir_log+0x7cd>
        phlen = tlen - plen;
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    13ad:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    13b1:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    memcpy(tem, buf, tlen);
    tem[tlen]='\0';
    do{
        ppath = strrchr(tem, '/');
        plen = strlen(ppath);
        phlen = tlen - plen;
    13b5:	48 29 45 b0          	sub    %rax,-0x50(%rbp)
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    13b9:	e8 00 00 00 00       	callq  13be <record_dir_log+0x7de>
        memcpy(tem, buf, tlen);
    13be:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
    13c2:	4c 89 e6             	mov    %r12,%rsi
    13c5:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    13c9:	e8 00 00 00 00       	callq  13ce <record_dir_log+0x7ee>
        tem[tlen]='\0';
    13ce:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
    13d2:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
        if(!strcmp(tem,"/"))
    13d6:	4c 8b 45 80          	mov    -0x80(%rbp),%r8
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
        memcpy(tem, buf, tlen);
        tem[tlen]='\0';
    13da:	c6 04 0e 00          	movb   $0x0,(%rsi,%rcx,1)
        if(!strcmp(tem,"/"))
    13de:	b9 02 00 00 00       	mov    $0x2,%ecx
    13e3:	4c 89 c7             	mov    %r8,%rdi
    13e6:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    13e8:	75 a5                	jne    138f <record_dir_log+0x7af>
            break;
    }while(1);

    //BUG_ON(strlen(ph)==1023);
    nova_dbg("%s ful ph is %s sbi is %s",__func__,ph, sbi->ph_f);
    13ea:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    13ee:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    13f5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    13fc:	48 89 5d b0          	mov    %rbx,-0x50(%rbp)
    1400:	4c 89 f3             	mov    %r14,%rbx
    1403:	4d 89 ee             	mov    %r13,%r14
    1406:	48 89 d1             	mov    %rdx,%rcx
    1409:	e8 00 00 00 00       	callq  140e <record_dir_log+0x82e>
    //BUG_ON(ph==NULL);
    
    mntput(vfsmnt);
    140e:	4c 8b 5d b0          	mov    -0x50(%rbp),%r11
    1412:	4c 89 df             	mov    %r11,%rdi
    1415:	e8 00 00 00 00       	callq  141a <record_dir_log+0x83a>
    141a:	e9 52 fe ff ff       	jmpq   1271 <record_dir_log+0x691>
    141f:	90                   	nop

0000000000001420 <delete_dir_log>:
    //nova_dbg("%s end record log",__func__);
}

/*delete dir operation log*/
void delete_dir_log(struct super_block *sb)
{
    1420:	e8 00 00 00 00       	callq  1425 <delete_dir_log+0x5>
    1425:	55                   	push   %rbp
    1426:	48 89 e5             	mov    %rsp,%rbp
    1429:	48 83 ec 10          	sub    $0x10,%rsp
    //struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_ptr *dzt_p;
    u32 bitpos = DAFS_DZT_ENTRIES_IN_BLOCK;

    //nova_dbg("%s start",__func__);
    make_dzt_ptr(sb, &dzt_p);
    142d:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
    //nova_dbg("%s end record log",__func__);
}

/*delete dir operation log*/
void delete_dir_log(struct super_block *sb)
{
    1431:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    1438:	00 00 
    143a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    143e:	31 c0                	xor    %eax,%eax
    //struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_ptr *dzt_p;
    u32 bitpos = DAFS_DZT_ENTRIES_IN_BLOCK;

    //nova_dbg("%s start",__func__);
    make_dzt_ptr(sb, &dzt_p);
    1440:	e8 00 00 00 00       	callq  1445 <delete_dir_log+0x25>
    test_and_clear_bit_le(bitpos, (void *)dzt_p->bitmap);
    1445:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_clear_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "btr", *addr, "Ir", nr, "%0", "c");
    1449:	ba 48 00 00 00       	mov    $0x48,%edx
    144e:	48 8b 00             	mov    (%rax),%rax
    1451:	f0 48 0f b3 10       	lock btr %rdx,(%rax)
    1456:	72 00                	jb     1458 <delete_dir_log+0x38>
    kfree(dzt_p);
    1458:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
    145c:	e8 00 00 00 00       	callq  1461 <delete_dir_log+0x41>
}
    1461:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1465:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    146c:	00 00 
    146e:	75 02                	jne    1472 <delete_dir_log+0x52>
    1470:	c9                   	leaveq 
    1471:	c3                   	retq   
    1472:	e8 00 00 00 00       	callq  1477 <delete_dir_log+0x57>
    1477:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    147e:	00 00 

0000000000001480 <ext_de_name>:
* nameflag = 0 => name
* nameflag = 1==> fulname*/
void ext_de_name(struct super_block *sb, struct dzt_entry_info *ei, struct dafs_zone_entry *ze,\
        struct zone_ptr *p, int cur_pos, int name_len, const char *name, int name_flag)

{
    1480:	e8 00 00 00 00       	callq  1485 <ext_de_name+0x5>
    1485:	55                   	push   %rbp
    1486:	48 89 e5             	mov    %rsp,%rbp
    1489:	41 57                	push   %r15
    148b:	41 56                	push   %r14
    148d:	41 55                	push   %r13
    148f:	41 54                	push   %r12
    1491:	49 89 ce             	mov    %rcx,%r14
    1494:	53                   	push   %rbx
    1495:	49 63 d8             	movslq %r8d,%rbx
    1498:	45 89 c8             	mov    %r9d,%r8d
    149b:	49 89 fd             	mov    %rdi,%r13
    149e:	49 89 d4             	mov    %rdx,%r12
    u32 bitpos, ext_pos, ext_num;
  
    //nova_dbg("%s start, dentry pos %d",__func__, cur_pos);
    //BUG_ON(ze==NULL);
    de = &ze->dentry[cur_pos];
    cur_pos ++;
    14a1:	8d 4b 01             	lea    0x1(%rbx),%ecx
* nameflag = 0 => name
* nameflag = 1==> fulname*/
void ext_de_name(struct super_block *sb, struct dzt_entry_info *ei, struct dafs_zone_entry *ze,\
        struct zone_ptr *p, int cur_pos, int name_len, const char *name, int name_flag)

{
    14a4:	48 83 ec 18          	sub    $0x18,%rsp
  
    //nova_dbg("%s start, dentry pos %d",__func__, cur_pos);
    //BUG_ON(ze==NULL);
    de = &ze->dentry[cur_pos];
    cur_pos ++;
    if(name_flag == 0){
    14a8:	44 8b 4d 18          	mov    0x18(%rbp),%r9d
* nameflag = 0 => name
* nameflag = 1==> fulname*/
void ext_de_name(struct super_block *sb, struct dzt_entry_info *ei, struct dafs_zone_entry *ze,\
        struct zone_ptr *p, int cur_pos, int name_len, const char *name, int name_flag)

{
    14ac:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    14b0:	4c 8b 7d 10          	mov    0x10(%rbp),%r15
  
    //nova_dbg("%s start, dentry pos %d",__func__, cur_pos);
    //BUG_ON(ze==NULL);
    de = &ze->dentry[cur_pos];
    cur_pos ++;
    if(name_flag == 0){
    14b4:	45 85 c9             	test   %r9d,%r9d
    14b7:	0f 85 33 02 00 00    	jne    16f0 <ext_de_name+0x270>
        /*judge name len && set dentry name*/
        if(name_len <= LARGE_NAME_LEN){
    14bd:	41 83 f8 70          	cmp    $0x70,%r8d
    14c1:	0f 8f ab 00 00 00    	jg     1572 <ext_de_name+0xf2>
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    14c7:	4c 89 f2             	mov    %r14,%rdx
    14ca:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de->next = de_ext;
    14ce:	48 c1 e3 07          	shl    $0x7,%rbx
    if(name_flag == 0){
        /*judge name len && set dentry name*/
        if(name_len <= LARGE_NAME_LEN){
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    14d2:	e8 00 00 00 00       	callq  14d7 <ext_de_name+0x57>
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de->next = de_ext;
            memcpy(de_ext->name, name, name_len);
    14d7:	4c 63 45 d0          	movslq -0x30(%rbp),%r8
        /*judge name len && set dentry name*/
        if(name_len <= LARGE_NAME_LEN){
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
    14db:	89 c2                	mov    %eax,%edx
    14dd:	48 81 c2 81 00 00 00 	add    $0x81,%rdx
    14e4:	48 c1 e2 07          	shl    $0x7,%rdx
    14e8:	4c 01 e2             	add    %r12,%rdx
            de->next = de_ext;
            memcpy(de_ext->name, name, name_len);
    14eb:	49 83 f8 08          	cmp    $0x8,%r8
        if(name_len <= LARGE_NAME_LEN){
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de->next = de_ext;
    14ef:	49 89 94 1c b0 40 00 	mov    %rdx,0x40b0(%r12,%rbx,1)
    14f6:	00 
            memcpy(de_ext->name, name, name_len);
    14f7:	48 8d 4a 10          	lea    0x10(%rdx),%rcx
    14fb:	0f 83 67 04 00 00    	jae    1968 <ext_de_name+0x4e8>
    1501:	41 f6 c0 04          	test   $0x4,%r8b
    1505:	0f 85 11 05 00 00    	jne    1a1c <ext_de_name+0x59c>
    150b:	4d 85 c0             	test   %r8,%r8
    150e:	74 12                	je     1522 <ext_de_name+0xa2>
    1510:	41 0f b6 37          	movzbl (%r15),%esi
    1514:	41 f6 c0 02          	test   $0x2,%r8b
    1518:	40 88 72 10          	mov    %sil,0x10(%rdx)
    151c:	0f 85 1b 05 00 00    	jne    1a3d <ext_de_name+0x5bd>
            de_ext->name[name_len]='\0';
    1522:	42 c6 44 02 10 00    	movb   $0x0,0x10(%rdx,%r8,1)
            de_ext->ext_pos = cpu_to_le32(ext_pos);
    1528:	89 42 04             	mov    %eax,0x4(%rdx)
	__clear_bit(nr ^ BITOP_LE_SWIZZLE, addr);
}

static inline int test_and_set_bit_le(int nr, void *addr)
{
	return test_and_set_bit(nr ^ BITOP_LE_SWIZZLE, addr);
    152b:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax
            //de_ext->next = NULL;
            bitpos = ext_pos*2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
    152f:	49 8b 0e             	mov    (%r14),%rcx
    1532:	48 98                	cltq   
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    1534:	f0 48 0f ab 01       	lock bts %rax,(%rcx)
    1539:	72 00                	jb     153b <ext_de_name+0xbb>

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
    153b:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # 1541 <ext_de_name+0xc1>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    1541:	89 d6                	mov    %edx,%esi
	if (support_clwb) {
    1543:	31 c9                	xor    %ecx,%ecx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    1545:	83 e6 3f             	and    $0x3f,%esi
    1548:	83 ee 80             	sub    $0xffffff80,%esi
	if (support_clwb) {
    154b:	85 ff                	test   %edi,%edi
    154d:	0f 84 01 04 00 00    	je     1954 <ext_de_name+0x4d4>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    1553:	89 c8                	mov    %ecx,%eax
    1555:	48 01 d0             	add    %rdx,%rax
    1558:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    155c:	83 c1 40             	add    $0x40,%ecx
    155f:	39 ce                	cmp    %ecx,%esi
    1561:	77 f0                	ja     1553 <ext_de_name+0xd3>
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
        }
    }
    //nova_dbg("%s end",__func__);
}
    1563:	48 83 c4 18          	add    $0x18,%rsp
    1567:	5b                   	pop    %rbx
    1568:	41 5c                	pop    %r12
    156a:	41 5d                	pop    %r13
    156c:	41 5e                	pop    %r14
    156e:	41 5f                	pop    %r15
    1570:	5d                   	pop    %rbp
    1571:	c3                   	retq   
            bitpos = ext_pos*2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
        } else {
            //de->ext_flag = 1;
            ext_len = name_len - LARGE_NAME_LEN -1;
    1572:	41 8d 58 8f          	lea    -0x71(%r8),%ebx
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    1576:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    157a:	4c 89 f2             	mov    %r14,%rdx
            bitpos = ext_pos*2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
        } else {
            //de->ext_flag = 1;
            ext_len = name_len - LARGE_NAME_LEN -1;
    157d:	48 63 c3             	movslq %ebx,%rax
    1580:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    1584:	e8 00 00 00 00       	callq  1589 <ext_de_name+0x109>
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
    1589:	41 89 c0             	mov    %eax,%r8d
            memcpy(de_ext->name, name, LARGE_NAME_LEN);
    158c:	49 8b 0f             	mov    (%r15),%rcx
    158f:	8d 54 00 01          	lea    0x1(%rax,%rax,1),%edx
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
        } else {
            //de->ext_flag = 1;
            ext_len = name_len - LARGE_NAME_LEN -1;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
    1593:	49 81 c0 81 00 00 00 	add    $0x81,%r8
    159a:	49 c1 e0 07          	shl    $0x7,%r8
    159e:	48 63 d2             	movslq %edx,%rdx
    15a1:	4b 8d 1c 04          	lea    (%r12,%r8,1),%rbx
            memcpy(de_ext->name, name, LARGE_NAME_LEN);
    15a5:	48 89 4b 10          	mov    %rcx,0x10(%rbx)
    15a9:	49 8b 4f 08          	mov    0x8(%r15),%rcx
    15ad:	48 89 4b 18          	mov    %rcx,0x18(%rbx)
    15b1:	49 8b 4f 10          	mov    0x10(%r15),%rcx
    15b5:	48 89 4b 20          	mov    %rcx,0x20(%rbx)
    15b9:	49 8b 4f 18          	mov    0x18(%r15),%rcx
    15bd:	48 89 4b 28          	mov    %rcx,0x28(%rbx)
    15c1:	49 8b 4f 20          	mov    0x20(%r15),%rcx
    15c5:	48 89 4b 30          	mov    %rcx,0x30(%rbx)
    15c9:	49 8b 4f 28          	mov    0x28(%r15),%rcx
    15cd:	48 89 4b 38          	mov    %rcx,0x38(%rbx)
    15d1:	49 8b 4f 30          	mov    0x30(%r15),%rcx
    15d5:	48 89 4b 40          	mov    %rcx,0x40(%rbx)
    15d9:	49 8b 4f 38          	mov    0x38(%r15),%rcx
    15dd:	48 89 4b 48          	mov    %rcx,0x48(%rbx)
    15e1:	49 8b 4f 40          	mov    0x40(%r15),%rcx
    15e5:	48 89 4b 50          	mov    %rcx,0x50(%rbx)
    15e9:	49 8b 4f 48          	mov    0x48(%r15),%rcx
    15ed:	48 89 4b 58          	mov    %rcx,0x58(%rbx)
    15f1:	49 8b 4f 50          	mov    0x50(%r15),%rcx
    15f5:	48 89 4b 60          	mov    %rcx,0x60(%rbx)
    15f9:	49 8b 4f 58          	mov    0x58(%r15),%rcx
    15fd:	48 89 4b 68          	mov    %rcx,0x68(%rbx)
    1601:	49 8b 4f 60          	mov    0x60(%r15),%rcx
    1605:	48 89 4b 70          	mov    %rcx,0x70(%rbx)
    1609:	49 8b 4f 68          	mov    0x68(%r15),%rcx
            de_ext->name[LARGE_NAME_LEN]='\0';
    160d:	c6 83 80 00 00 00 00 	movb   $0x0,0x80(%rbx)
            de_ext->ext_pos = cpu_to_le32(ext_pos);
    1614:	89 43 04             	mov    %eax,0x4(%rbx)
        } else {
            //de->ext_flag = 1;
            ext_len = name_len - LARGE_NAME_LEN -1;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            memcpy(de_ext->name, name, LARGE_NAME_LEN);
    1617:	48 89 4b 78          	mov    %rcx,0x78(%rbx)
            de_ext->name[LARGE_NAME_LEN]='\0';
            de_ext->ext_pos = cpu_to_le32(ext_pos);
            bitpos = ext_pos*2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
    161b:	49 8b 0e             	mov    (%r14),%rcx
    161e:	f0 48 0f ab 11       	lock bts %rdx,(%rcx)
    1623:	72 00                	jb     1625 <ext_de_name+0x1a5>

            //de_ext->name[name_len]="/0";
            /*at most 2 extend dentry*/
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
    1625:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    1629:	4c 89 ef             	mov    %r13,%rdi
    162c:	89 c1                	mov    %eax,%ecx
    162e:	4c 89 f2             	mov    %r14,%rdx
    1631:	e8 00 00 00 00       	callq  1636 <ext_de_name+0x1b6>
    1636:	89 c0                	mov    %eax,%eax
            //de_ext->next = cpu_to_le64(ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de_ext->next = tem_ext;
            memcpy(tem_ext->name, name + LARGE_NAME_LEN, ext_len);
    1638:	49 8d 77 70          	lea    0x70(%r15),%rsi
    163c:	4c 8b 7d c8          	mov    -0x38(%rbp),%r15
            bitpos = ext_pos*2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);

            //de_ext->name[name_len]="/0";
            /*at most 2 extend dentry*/
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
    1640:	49 89 c5             	mov    %rax,%r13
            //de_ext->next = cpu_to_le64(ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
    1643:	48 05 81 00 00 00    	add    $0x81,%rax
    1649:	48 c1 e0 07          	shl    $0x7,%rax
    164d:	49 01 c4             	add    %rax,%r12
            de_ext->next = tem_ext;
            memcpy(tem_ext->name, name + LARGE_NAME_LEN, ext_len);
    1650:	4c 89 fa             	mov    %r15,%rdx
    1653:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
            //de_ext->name[name_len]="/0";
            /*at most 2 extend dentry*/
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
            //de_ext->next = cpu_to_le64(ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de_ext->next = tem_ext;
    1658:	4c 89 63 08          	mov    %r12,0x8(%rbx)
            memcpy(tem_ext->name, name + LARGE_NAME_LEN, ext_len);
    165c:	e8 00 00 00 00       	callq  1661 <ext_de_name+0x1e1>
    1661:	43 8d 44 2d 01       	lea    0x1(%r13,%r13,1),%eax
            tem_ext->name[ext_len]='\0';
    1666:	43 c6 44 3c 10 00    	movb   $0x0,0x10(%r12,%r15,1)
            //tem_ext->next = NULL;
            tem_ext->ext_pos = cpu_to_le32(ext_pos);
    166c:	45 89 6c 24 04       	mov    %r13d,0x4(%r12)
            bitpos = ext_pos *2 +1;
            test_and_set_bit_le(bitpos,(void *)p->statemap);
    1671:	49 8b 16             	mov    (%r14),%rdx
    1674:	48 98                	cltq   
    1676:	f0 48 0f ab 02       	lock bts %rax,(%rdx)
    167b:	72 00                	jb     167d <ext_de_name+0x1fd>

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
    167d:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 1683 <ext_de_name+0x203>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    1683:	89 d9                	mov    %ebx,%ecx
	if (support_clwb) {
    1685:	31 d2                	xor    %edx,%edx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    1687:	83 e1 3f             	and    $0x3f,%ecx
    168a:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    168d:	85 f6                	test   %esi,%esi
    168f:	74 3a                	je     16cb <ext_de_name+0x24b>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    1691:	89 d0                	mov    %edx,%eax
    1693:	48 01 d8             	add    %rbx,%rax
    1696:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    169a:	83 c2 40             	add    $0x40,%edx
    169d:	39 d1                	cmp    %edx,%ecx
    169f:	77 f0                	ja     1691 <ext_de_name+0x211>

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
    16a1:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 16a7 <ext_de_name+0x227>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    16a7:	44 89 e1             	mov    %r12d,%ecx
	if (support_clwb) {
    16aa:	31 d2                	xor    %edx,%edx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    16ac:	83 e1 3f             	and    $0x3f,%ecx
    16af:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    16b2:	85 c0                	test   %eax,%eax
    16b4:	74 26                	je     16dc <ext_de_name+0x25c>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    16b6:	89 d0                	mov    %edx,%eax
    16b8:	4c 01 e0             	add    %r12,%rax
    16bb:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    16bf:	83 c2 40             	add    $0x40,%edx
    16c2:	39 d1                	cmp    %edx,%ecx
    16c4:	77 f0                	ja     16b6 <ext_de_name+0x236>
    16c6:	e9 98 fe ff ff       	jmpq   1563 <ext_de_name+0xe3>
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    16cb:	89 d0                	mov    %edx,%eax
    16cd:	48 01 d8             	add    %rbx,%rax
    16d0:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    16d3:	83 c2 40             	add    $0x40,%edx
    16d6:	39 d1                	cmp    %edx,%ecx
    16d8:	77 f1                	ja     16cb <ext_de_name+0x24b>
    16da:	eb c5                	jmp    16a1 <ext_de_name+0x221>
			_mm_clflush(buf + i);
    16dc:	89 d0                	mov    %edx,%eax
    16de:	4c 01 e0             	add    %r12,%rax
    16e1:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    16e4:	83 c2 40             	add    $0x40,%edx
    16e7:	39 d1                	cmp    %edx,%ecx
    16e9:	77 f1                	ja     16dc <ext_de_name+0x25c>
    16eb:	e9 73 fe ff ff       	jmpq   1563 <ext_de_name+0xe3>
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
            nova_flush_buffer(tem_ext, DAFS_DEF_DENTRY_SIZE, 0);
        }
    } else {
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    16f0:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    16f4:	4c 89 f2             	mov    %r14,%rdx
    16f7:	44 89 45 c8          	mov    %r8d,-0x38(%rbp)
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
        de->ful_name.fn_ext = de_ext;
    16fb:	48 c1 e3 07          	shl    $0x7,%rbx
            test_and_set_bit_le(bitpos,(void *)p->statemap);
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
            nova_flush_buffer(tem_ext, DAFS_DEF_DENTRY_SIZE, 0);
        }
    } else {
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    16ff:	e8 00 00 00 00       	callq  1704 <ext_de_name+0x284>
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
        de->ful_name.fn_ext = de_ext;

        if(name_len <= (LARGE_NAME_LEN)){
    1704:	4c 63 45 c8          	movslq -0x38(%rbp),%r8
            test_and_set_bit_le(bitpos,(void *)p->statemap);
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
            nova_flush_buffer(tem_ext, DAFS_DEF_DENTRY_SIZE, 0);
        }
    } else {
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
    1708:	41 89 c1             	mov    %eax,%r9d
    170b:	4d 89 cb             	mov    %r9,%r11
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
    170e:	49 81 c1 81 00 00 00 	add    $0x81,%r9
    1715:	49 c1 e1 07          	shl    $0x7,%r9
    1719:	4d 01 e1             	add    %r12,%r9
        de->ful_name.fn_ext = de_ext;

        if(name_len <= (LARGE_NAME_LEN)){
    171c:	41 83 f8 70          	cmp    $0x70,%r8d
            nova_flush_buffer(tem_ext, DAFS_DEF_DENTRY_SIZE, 0);
        }
    } else {
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
        de->ful_name.fn_ext = de_ext;
    1720:	4d 89 8c 1c d8 40 00 	mov    %r9,0x40d8(%r12,%rbx,1)
    1727:	00 

        if(name_len <= (LARGE_NAME_LEN)){
    1728:	0f 8e 6b 02 00 00    	jle    1999 <ext_de_name+0x519>
            //de_ext->next = NULL;
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
        }else {
            ext_len = 0;
            ext_num = name_len/(LARGE_NAME_LEN);
    172e:	44 89 c0             	mov    %r8d,%eax
    1731:	ba 93 24 49 92       	mov    $0x92492493,%edx
    1736:	f7 ea                	imul   %edx
    1738:	44 89 c0             	mov    %r8d,%eax
    173b:	c1 f8 1f             	sar    $0x1f,%eax
    173e:	44 01 c2             	add    %r8d,%edx
    1741:	c1 fa 06             	sar    $0x6,%edx
    1744:	29 c2                	sub    %eax,%edx
    1746:	43 8d 44 1b 01       	lea    0x1(%r11,%r11,1),%eax
    174b:	89 55 c0             	mov    %edx,-0x40(%rbp)
            ext_num++;
            //ext_pos = cur_pos;
            //if(name_len%(LARGE_NAME_LEN)>ext_num)
                //ext_num++;
            memcpy(de_ext->name, name, LARGE_NAME_LEN);
    174e:	49 8b 17             	mov    (%r15),%rdx
    1751:	48 98                	cltq   
    1753:	49 89 51 10          	mov    %rdx,0x10(%r9)
    1757:	49 8b 57 08          	mov    0x8(%r15),%rdx
    175b:	49 89 51 18          	mov    %rdx,0x18(%r9)
    175f:	49 8b 57 10          	mov    0x10(%r15),%rdx
    1763:	49 89 51 20          	mov    %rdx,0x20(%r9)
    1767:	49 8b 57 18          	mov    0x18(%r15),%rdx
    176b:	49 89 51 28          	mov    %rdx,0x28(%r9)
    176f:	49 8b 57 20          	mov    0x20(%r15),%rdx
    1773:	49 89 51 30          	mov    %rdx,0x30(%r9)
    1777:	49 8b 57 28          	mov    0x28(%r15),%rdx
    177b:	49 89 51 38          	mov    %rdx,0x38(%r9)
    177f:	49 8b 57 30          	mov    0x30(%r15),%rdx
    1783:	49 89 51 40          	mov    %rdx,0x40(%r9)
    1787:	49 8b 57 38          	mov    0x38(%r15),%rdx
    178b:	49 89 51 48          	mov    %rdx,0x48(%r9)
    178f:	49 8b 57 40          	mov    0x40(%r15),%rdx
    1793:	49 89 51 50          	mov    %rdx,0x50(%r9)
    1797:	49 8b 57 48          	mov    0x48(%r15),%rdx
    179b:	49 89 51 58          	mov    %rdx,0x58(%r9)
    179f:	49 8b 57 50          	mov    0x50(%r15),%rdx
    17a3:	49 89 51 60          	mov    %rdx,0x60(%r9)
    17a7:	49 8b 57 58          	mov    0x58(%r15),%rdx
    17ab:	49 89 51 68          	mov    %rdx,0x68(%r9)
    17af:	49 8b 57 60          	mov    0x60(%r15),%rdx
    17b3:	49 89 51 70          	mov    %rdx,0x70(%r9)
    17b7:	49 8b 57 68          	mov    0x68(%r15),%rdx
            de_ext->name[LARGE_NAME_LEN]='\0';
    17bb:	41 c6 81 80 00 00 00 	movb   $0x0,0x80(%r9)
    17c2:	00 
            de_ext->ext_pos = cpu_to_le32(ext_pos);
    17c3:	45 89 59 04          	mov    %r11d,0x4(%r9)
            ext_num = name_len/(LARGE_NAME_LEN);
            ext_num++;
            //ext_pos = cur_pos;
            //if(name_len%(LARGE_NAME_LEN)>ext_num)
                //ext_num++;
            memcpy(de_ext->name, name, LARGE_NAME_LEN);
    17c7:	49 89 51 78          	mov    %rdx,0x78(%r9)
            de_ext->name[LARGE_NAME_LEN]='\0';
            de_ext->ext_pos = cpu_to_le32(ext_pos);
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
    17cb:	49 8b 16             	mov    (%r14),%rdx
    17ce:	f0 48 0f ab 02       	lock bts %rax,(%rdx)
    17d3:	72 00                	jb     17d5 <ext_de_name+0x355>
            ext_num--;
            ext_len += LARGE_NAME_LEN;
            name_len -= LARGE_NAME_LEN;
    17d5:	41 8d 40 90          	lea    -0x70(%r8),%eax
    17d9:	89 45 c4             	mov    %eax,-0x3c(%rbp)
            while(ext_num > 1) {
    17dc:	8b 45 c0             	mov    -0x40(%rbp),%eax
    17df:	83 f8 01             	cmp    $0x1,%eax
    17e2:	0f 84 49 02 00 00    	je     1a31 <ext_de_name+0x5b1>
    17e8:	83 e8 02             	sub    $0x2,%eax
    17eb:	49 8d 5f 70          	lea    0x70(%r15),%rbx
    17ef:	48 89 c2             	mov    %rax,%rdx
    17f2:	48 c1 e0 07          	shl    $0x7,%rax
    17f6:	48 c1 e2 04          	shl    $0x4,%rdx
    17fa:	48 29 d0             	sub    %rdx,%rax
    17fd:	4d 8d bc 07 e0 00 00 	lea    0xe0(%r15,%rax,1),%r15
    1804:	00 
                ext_pos =  find_invalid_id(sb, ei, p, ext_pos);
    1805:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    1809:	44 89 d9             	mov    %r11d,%ecx
    180c:	4c 89 f2             	mov    %r14,%rdx
    180f:	4c 89 ef             	mov    %r13,%rdi
    1812:	4c 89 4d c8          	mov    %r9,-0x38(%rbp)
    1816:	e8 00 00 00 00       	callq  181b <ext_de_name+0x39b>
    181b:	41 89 c0             	mov    %eax,%r8d
                tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
                de_ext->next = tem_ext;
    181e:	4c 8b 4d c8          	mov    -0x38(%rbp),%r9
            test_and_set_bit_le(bitpos, (void *)p->statemap);
            ext_num--;
            ext_len += LARGE_NAME_LEN;
            name_len -= LARGE_NAME_LEN;
            while(ext_num > 1) {
                ext_pos =  find_invalid_id(sb, ei, p, ext_pos);
    1822:	4d 89 c3             	mov    %r8,%r11
                tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
    1825:	49 81 c0 81 00 00 00 	add    $0x81,%r8
    182c:	49 c1 e0 07          	shl    $0x7,%r8
    1830:	43 8d 44 1b 01       	lea    0x1(%r11,%r11,1),%eax
    1835:	4d 01 e0             	add    %r12,%r8
                de_ext->next = tem_ext;
    1838:	4d 89 41 08          	mov    %r8,0x8(%r9)
                memcpy(tem_ext->name, name + ext_len, LARGE_NAME_LEN);
    183c:	48 8b 13             	mov    (%rbx),%rdx
    183f:	48 98                	cltq   
    1841:	49 89 50 10          	mov    %rdx,0x10(%r8)
    1845:	48 8b 53 08          	mov    0x8(%rbx),%rdx
    1849:	49 89 50 18          	mov    %rdx,0x18(%r8)
    184d:	48 8b 53 10          	mov    0x10(%rbx),%rdx
    1851:	49 89 50 20          	mov    %rdx,0x20(%r8)
    1855:	48 8b 53 18          	mov    0x18(%rbx),%rdx
    1859:	49 89 50 28          	mov    %rdx,0x28(%r8)
    185d:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    1861:	49 89 50 30          	mov    %rdx,0x30(%r8)
    1865:	48 8b 53 28          	mov    0x28(%rbx),%rdx
    1869:	49 89 50 38          	mov    %rdx,0x38(%r8)
    186d:	48 8b 53 30          	mov    0x30(%rbx),%rdx
    1871:	49 89 50 40          	mov    %rdx,0x40(%r8)
    1875:	48 8b 53 38          	mov    0x38(%rbx),%rdx
    1879:	49 89 50 48          	mov    %rdx,0x48(%r8)
    187d:	48 8b 53 40          	mov    0x40(%rbx),%rdx
    1881:	49 89 50 50          	mov    %rdx,0x50(%r8)
    1885:	48 8b 53 48          	mov    0x48(%rbx),%rdx
    1889:	49 89 50 58          	mov    %rdx,0x58(%r8)
    188d:	48 8b 53 50          	mov    0x50(%rbx),%rdx
    1891:	49 89 50 60          	mov    %rdx,0x60(%r8)
    1895:	48 8b 53 58          	mov    0x58(%rbx),%rdx
    1899:	49 89 50 68          	mov    %rdx,0x68(%r8)
    189d:	48 8b 53 60          	mov    0x60(%rbx),%rdx
    18a1:	49 89 50 70          	mov    %rdx,0x70(%r8)
    18a5:	48 8b 53 68          	mov    0x68(%rbx),%rdx
                tem_ext->name[LARGE_NAME_LEN]='\0';
    18a9:	41 c6 80 80 00 00 00 	movb   $0x0,0x80(%r8)
    18b0:	00 
                tem_ext->ext_pos = cpu_to_le32(ext_pos);
    18b1:	45 89 58 04          	mov    %r11d,0x4(%r8)
            name_len -= LARGE_NAME_LEN;
            while(ext_num > 1) {
                ext_pos =  find_invalid_id(sb, ei, p, ext_pos);
                tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
                de_ext->next = tem_ext;
                memcpy(tem_ext->name, name + ext_len, LARGE_NAME_LEN);
    18b5:	49 89 50 78          	mov    %rdx,0x78(%r8)
                tem_ext->name[LARGE_NAME_LEN]='\0';
                tem_ext->ext_pos = cpu_to_le32(ext_pos);
                bitpos = ext_pos *2+1;
                test_and_set_bit_le(bitpos, (void *)p->statemap);
    18b9:	49 8b 16             	mov    (%r14),%rdx
    18bc:	f0 48 0f ab 02       	lock bts %rax,(%rdx)
    18c1:	72 00                	jb     18c3 <ext_de_name+0x443>
    18c3:	48 83 c3 70          	add    $0x70,%rbx
            ext_num--;
            ext_len += LARGE_NAME_LEN;
            name_len -= LARGE_NAME_LEN;
            while(ext_num > 1) {
                ext_pos =  find_invalid_id(sb, ei, p, ext_pos);
                tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
    18c7:	4d 89 c1             	mov    %r8,%r9
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
            ext_num--;
            ext_len += LARGE_NAME_LEN;
            name_len -= LARGE_NAME_LEN;
            while(ext_num > 1) {
    18ca:	4c 39 fb             	cmp    %r15,%rbx
    18cd:	0f 85 32 ff ff ff    	jne    1805 <ext_de_name+0x385>
    18d3:	6b 45 c0 90          	imul   $0xffffff90,-0x40(%rbp),%eax
    18d7:	8b 7d c4             	mov    -0x3c(%rbp),%edi
    18da:	8d 44 07 70          	lea    0x70(%rdi,%rax,1),%eax
    18de:	89 45 c4             	mov    %eax,-0x3c(%rbp)
                de_ext = tem_ext;
                name_len -= LARGE_NAME_LEN;
                ext_len += LARGE_NAME_LEN;
                ext_num--;
            }
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
    18e1:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    18e5:	4c 89 ef             	mov    %r13,%rdi
    18e8:	44 89 d9             	mov    %r11d,%ecx
    18eb:	4c 89 f2             	mov    %r14,%rdx
    18ee:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
    18f2:	e8 00 00 00 00       	callq  18f7 <ext_de_name+0x477>
    18f7:	89 c0                	mov    %eax,%eax
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de_ext->next = tem_ext;
            memcpy(tem_ext->name, name+ext_len, name_len);
    18f9:	48 63 5d c4          	movslq -0x3c(%rbp),%rbx
                ext_len += LARGE_NAME_LEN;
                ext_num--;
            }
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de_ext->next = tem_ext;
    18fd:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
                de_ext = tem_ext;
                name_len -= LARGE_NAME_LEN;
                ext_len += LARGE_NAME_LEN;
                ext_num--;
            }
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
    1901:	49 89 c5             	mov    %rax,%r13
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
    1904:	48 05 81 00 00 00    	add    $0x81,%rax
            de_ext->next = tem_ext;
            memcpy(tem_ext->name, name+ext_len, name_len);
    190a:	4c 89 fe             	mov    %r15,%rsi
                name_len -= LARGE_NAME_LEN;
                ext_len += LARGE_NAME_LEN;
                ext_num--;
            }
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
    190d:	48 c1 e0 07          	shl    $0x7,%rax
    1911:	49 01 c4             	add    %rax,%r12
            de_ext->next = tem_ext;
            memcpy(tem_ext->name, name+ext_len, name_len);
    1914:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
    1919:	48 89 da             	mov    %rbx,%rdx
                ext_len += LARGE_NAME_LEN;
                ext_num--;
            }
            ext_pos = find_invalid_id(sb, ei, p, ext_pos);
            tem_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de_ext->next = tem_ext;
    191c:	4d 89 60 08          	mov    %r12,0x8(%r8)
            memcpy(tem_ext->name, name+ext_len, name_len);
    1920:	e8 00 00 00 00       	callq  1925 <ext_de_name+0x4a5>
    1925:	43 8d 44 2d 01       	lea    0x1(%r13,%r13,1),%eax
            tem_ext->ext_pos = cpu_to_le32(ext_pos);
    192a:	45 89 6c 24 04       	mov    %r13d,0x4(%r12)
            tem_ext->name[name_len] = '\0';
    192f:	41 c6 44 1c 10 00    	movb   $0x0,0x10(%r12,%rbx,1)
            //tem_ext->next = NULL;
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
    1935:	49 8b 16             	mov    (%r14),%rdx
    1938:	48 98                	cltq   
    193a:	f0 48 0f ab 02       	lock bts %rax,(%rdx)
    193f:	0f 82 1e fc ff ff    	jb     1563 <ext_de_name+0xe3>
        }
    }
    //nova_dbg("%s end",__func__);
}
    1945:	48 83 c4 18          	add    $0x18,%rsp
    1949:	5b                   	pop    %rbx
    194a:	41 5c                	pop    %r12
    194c:	41 5d                	pop    %r13
    194e:	41 5e                	pop    %r14
    1950:	41 5f                	pop    %r15
    1952:	5d                   	pop    %rbp
    1953:	c3                   	retq   
			_mm_clflush(buf + i);
    1954:	89 c8                	mov    %ecx,%eax
    1956:	48 01 d0             	add    %rdx,%rax
    1959:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    195c:	83 c1 40             	add    $0x40,%ecx
    195f:	39 ce                	cmp    %ecx,%esi
    1961:	77 f1                	ja     1954 <ext_de_name+0x4d4>
    1963:	e9 fb fb ff ff       	jmpq   1563 <ext_de_name+0xe3>
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de->next = de_ext;
            memcpy(de_ext->name, name, name_len);
    1968:	49 8b 37             	mov    (%r15),%rsi
    196b:	48 8d 7a 18          	lea    0x18(%rdx),%rdi
    196f:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    1973:	48 89 72 10          	mov    %rsi,0x10(%rdx)
    1977:	4b 8b 74 07 f8       	mov    -0x8(%r15,%r8,1),%rsi
    197c:	4a 89 74 01 f8       	mov    %rsi,-0x8(%rcx,%r8,1)
    1981:	48 29 f9             	sub    %rdi,%rcx
    1984:	4c 89 fe             	mov    %r15,%rsi
    1987:	48 29 ce             	sub    %rcx,%rsi
    198a:	4c 01 c1             	add    %r8,%rcx
    198d:	48 c1 e9 03          	shr    $0x3,%rcx
    1991:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    1994:	e9 89 fb ff ff       	jmpq   1522 <ext_de_name+0xa2>
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
        de->ful_name.fn_ext = de_ext;

        if(name_len <= (LARGE_NAME_LEN)){
            memcpy(de_ext->name, name, name_len);
    1999:	49 83 f8 08          	cmp    $0x8,%r8
    199d:	49 8d 49 10          	lea    0x10(%r9),%rcx
    19a1:	73 4b                	jae    19ee <ext_de_name+0x56e>
    19a3:	41 f6 c0 04          	test   $0x4,%r8b
    19a7:	0f 85 a1 00 00 00    	jne    1a4e <ext_de_name+0x5ce>
    19ad:	4d 85 c0             	test   %r8,%r8
    19b0:	74 18                	je     19ca <ext_de_name+0x54a>
    19b2:	41 0f b6 07          	movzbl (%r15),%eax
    19b6:	41 f6 c0 02          	test   $0x2,%r8b
    19ba:	88 01                	mov    %al,(%rcx)
    19bc:	74 0c                	je     19ca <ext_de_name+0x54a>
    19be:	43 0f b7 44 07 fe    	movzwl -0x2(%r15,%r8,1),%eax
    19c4:	66 42 89 44 01 fe    	mov    %ax,-0x2(%rcx,%r8,1)
    19ca:	43 8d 44 1b 01       	lea    0x1(%r11,%r11,1),%eax
            de_ext->name[name_len]='\0';
    19cf:	43 c6 44 01 10 00    	movb   $0x0,0x10(%r9,%r8,1)
            de_ext->ext_pos = cpu_to_le32(ext_pos);
    19d5:	45 89 59 04          	mov    %r11d,0x4(%r9)
            //de_ext->next = NULL;
            bitpos = ext_pos *2+1;
            test_and_set_bit_le(bitpos, (void *)p->statemap);
    19d9:	49 8b 16             	mov    (%r14),%rdx
    19dc:	48 98                	cltq   
    19de:	f0 48 0f ab 02       	lock bts %rax,(%rdx)
    19e3:	0f 82 7a fb ff ff    	jb     1563 <ext_de_name+0xe3>
    19e9:	e9 57 ff ff ff       	jmpq   1945 <ext_de_name+0x4c5>
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
        de->ful_name.fn_ext = de_ext;

        if(name_len <= (LARGE_NAME_LEN)){
            memcpy(de_ext->name, name, name_len);
    19ee:	49 8b 07             	mov    (%r15),%rax
    19f1:	49 8d 79 18          	lea    0x18(%r9),%rdi
    19f5:	4c 89 fe             	mov    %r15,%rsi
    19f8:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    19fc:	49 89 41 10          	mov    %rax,0x10(%r9)
    1a00:	4b 8b 44 07 f8       	mov    -0x8(%r15,%r8,1),%rax
    1a05:	4a 89 44 01 f8       	mov    %rax,-0x8(%rcx,%r8,1)
    1a0a:	48 29 f9             	sub    %rdi,%rcx
    1a0d:	48 29 ce             	sub    %rcx,%rsi
    1a10:	4c 01 c1             	add    %r8,%rcx
    1a13:	48 c1 e9 03          	shr    $0x3,%rcx
    1a17:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    1a1a:	eb ae                	jmp    19ca <ext_de_name+0x54a>
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de->next = de_ext;
            memcpy(de_ext->name, name, name_len);
    1a1c:	41 8b 37             	mov    (%r15),%esi
    1a1f:	89 72 10             	mov    %esi,0x10(%rdx)
    1a22:	43 8b 74 07 fc       	mov    -0x4(%r15,%r8,1),%esi
    1a27:	42 89 74 01 fc       	mov    %esi,-0x4(%rcx,%r8,1)
    1a2c:	e9 f1 fa ff ff       	jmpq   1522 <ext_de_name+0xa2>
            nova_flush_buffer(de_ext, DAFS_DEF_DENTRY_SIZE, 0);
            nova_flush_buffer(tem_ext, DAFS_DEF_DENTRY_SIZE, 0);
        }
    } else {
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
    1a31:	4d 89 c8             	mov    %r9,%r8
    1a34:	49 83 c7 70          	add    $0x70,%r15
    1a38:	e9 a4 fe ff ff       	jmpq   18e1 <ext_de_name+0x461>
            //ext_num = 1;
            //de->ext_flag = 0;
            ext_pos = find_invalid_id(sb, ei, p, cur_pos);
            de_ext = (struct name_ext *)&ze->dentry[ext_pos];
            de->next = de_ext;
            memcpy(de_ext->name, name, name_len);
    1a3d:	43 0f b7 74 07 fe    	movzwl -0x2(%r15,%r8,1),%esi
    1a43:	66 42 89 74 01 fe    	mov    %si,-0x2(%rcx,%r8,1)
    1a49:	e9 d4 fa ff ff       	jmpq   1522 <ext_de_name+0xa2>
        ext_pos = find_invalid_id(sb, ei, p, cur_pos);
        de_ext = (struct name_ext *)&ze->dentry[ext_pos];
        de->ful_name.fn_ext = de_ext;

        if(name_len <= (LARGE_NAME_LEN)){
            memcpy(de_ext->name, name, name_len);
    1a4e:	41 8b 07             	mov    (%r15),%eax
    1a51:	89 01                	mov    %eax,(%rcx)
    1a53:	43 8b 44 07 fc       	mov    -0x4(%r15,%r8,1),%eax
    1a58:	42 89 44 01 fc       	mov    %eax,-0x4(%rcx,%r8,1)
    1a5d:	e9 68 ff ff ff       	jmpq   19ca <ext_de_name+0x54a>
    1a62:	0f 1f 40 00          	nopl   0x0(%rax)
    1a66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1a6d:	00 00 00 

0000000000001a70 <get_ext_name>:
}

/*get ext name
* fulname & name*/
void get_ext_name(struct name_ext *de_ext, char *name)
{
    1a70:	e8 00 00 00 00       	callq  1a75 <get_ext_name+0x5>
    1a75:	55                   	push   %rbp
    1a76:	ba 70 00 00 00       	mov    $0x70,%edx
    1a7b:	48 89 e5             	mov    %rsp,%rbp
    1a7e:	41 57                	push   %r15
    1a80:	41 56                	push   %r14
    1a82:	41 55                	push   %r13
    1a84:	41 54                	push   %r12
    1a86:	49 89 fc             	mov    %rdi,%r12
    1a89:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 1a90 <get_ext_name+0x20>
    1a90:	53                   	push   %rbx
    1a91:	49 89 f6             	mov    %rsi,%r14
    1a94:	be d0 80 00 00       	mov    $0x80d0,%esi
    1a99:	e8 00 00 00 00       	callq  1a9e <get_ext_name+0x2e>
    1a9e:	49 89 c5             	mov    %rax,%r13
    unsigned short len;
    char *tem = kzalloc(sizeof(char)*LARGE_NAME_LEN, GFP_KERNEL);

    tem_ext = de_ext;
    do{
        len =strlen(tem_ext->name);
    1aa1:	4d 8d 7c 24 10       	lea    0x10(%r12),%r15
    1aa6:	4c 89 ff             	mov    %r15,%rdi
    1aa9:	e8 00 00 00 00       	callq  1aae <get_ext_name+0x3e>
    1aae:	0f b7 d8             	movzwl %ax,%ebx
        memcpy(tem, tem_ext->name, len);
    1ab1:	4c 89 fe             	mov    %r15,%rsi
    1ab4:	4c 89 ef             	mov    %r13,%rdi
    1ab7:	48 89 da             	mov    %rbx,%rdx
    1aba:	e8 00 00 00 00       	callq  1abf <get_ext_name+0x4f>
        tem[len]='\0';
    1abf:	41 c6 44 1d 00 00    	movb   $0x0,0x0(%r13,%rbx,1)
        strcat(name, tem);
    1ac5:	4c 89 ee             	mov    %r13,%rsi
    1ac8:	4c 89 f7             	mov    %r14,%rdi
    1acb:	e8 00 00 00 00       	callq  1ad0 <get_ext_name+0x60>
        tem_ext = tem_ext->next; 
    1ad0:	4d 8b 64 24 08       	mov    0x8(%r12),%r12
    }while(tem_ext);
    1ad5:	4d 85 e4             	test   %r12,%r12
    1ad8:	75 c7                	jne    1aa1 <get_ext_name+0x31>
    
    //strcat(name,"/0");
    kfree(tem);
    1ada:	4c 89 ef             	mov    %r13,%rdi
    1add:	e8 00 00 00 00       	callq  1ae2 <get_ext_name+0x72>
}
    1ae2:	5b                   	pop    %rbx
    1ae3:	41 5c                	pop    %r12
    1ae5:	41 5d                	pop    %r13
    1ae7:	41 5e                	pop    %r14
    1ae9:	41 5f                	pop    %r15
    1aeb:	5d                   	pop    %rbp
    1aec:	c3                   	retq   
    1aed:	0f 1f 00             	nopl   (%rax)

0000000000001af0 <get_de_name>:

/*get dentry name
 * name_type 0 for name, 1 for fulname*/
void get_de_name(struct dafs_dentry *de, struct dafs_zone_entry *ze, char *name, int name_type)
{
    1af0:	e8 00 00 00 00       	callq  1af5 <get_de_name+0x5>
    1af5:	55                   	push   %rbp
    u32 par_pos;

    nlen = de->name_len;
    flen = de->fname_len;

    if(name_type == 0){
    1af6:	85 c9                	test   %ecx,%ecx
}

/*get dentry name
 * name_type 0 for name, 1 for fulname*/
void get_de_name(struct dafs_dentry *de, struct dafs_zone_entry *ze, char *name, int name_type)
{
    1af8:	48 89 e5             	mov    %rsp,%rbp
    1afb:	41 57                	push   %r15
    1afd:	41 56                	push   %r14
    1aff:	41 55                	push   %r13
    1b01:	49 89 d5             	mov    %rdx,%r13
    1b04:	41 54                	push   %r12
    1b06:	53                   	push   %rbx
    1b07:	48 89 fb             	mov    %rdi,%rbx
    unsigned short nlen;
    u64 flen;
    char *tem;
    u32 par_pos;

    nlen = de->name_len;
    1b0a:	44 0f b6 67 01       	movzbl 0x1(%rdi),%r12d
    flen = de->fname_len;

    if(name_type == 0){
    1b0f:	75 45                	jne    1b56 <get_de_name+0x66>
        if(de->ext_flag==1){
    1b11:	66 83 7f 04 01       	cmpw   $0x1,0x4(%rdi)
    1b16:	0f 84 9b 00 00 00    	je     1bb7 <get_de_name+0xc7>
            get_ext_name(de->next, name);
        } else {
            memcpy(name, de->name, nlen);
    1b1c:	41 0f b6 c4          	movzbl %r12b,%eax
    1b20:	48 8d 77 30          	lea    0x30(%rdi),%rsi
    1b24:	83 f8 08             	cmp    $0x8,%eax
    1b27:	73 5f                	jae    1b88 <get_de_name+0x98>
    1b29:	a8 04                	test   $0x4,%al
    1b2b:	0f 85 9e 01 00 00    	jne    1ccf <get_de_name+0x1df>
    1b31:	85 c0                	test   %eax,%eax
    1b33:	74 10                	je     1b45 <get_de_name+0x55>
    1b35:	0f b6 57 30          	movzbl 0x30(%rdi),%edx
    1b39:	a8 02                	test   $0x2,%al
    1b3b:	41 88 55 00          	mov    %dl,0x0(%r13)
    1b3f:	0f 85 a1 01 00 00    	jne    1ce6 <get_de_name+0x1f6>
                }
            }
        }
    }

}
    1b45:	5b                   	pop    %rbx
    if(name_type == 0){
        if(de->ext_flag==1){
            get_ext_name(de->next, name);
        } else {
            memcpy(name, de->name, nlen);
            name[nlen]='\0';
    1b46:	41 c6 44 05 00 00    	movb   $0x0,0x0(%r13,%rax,1)
                }
            }
        }
    }

}
    1b4c:	41 5c                	pop    %r12
    1b4e:	41 5d                	pop    %r13
    1b50:	41 5e                	pop    %r14
    1b52:	41 5f                	pop    %r15
    1b54:	5d                   	pop    %rbp
    1b55:	c3                   	retq   
        } else {
            memcpy(name, de->name, nlen);
            name[nlen]='\0';
        }
    } else {
        if(de->isr_sf==1){
    1b56:	80 7f 03 01          	cmpb   $0x1,0x3(%rdi)
    u64 flen;
    char *tem;
    u32 par_pos;

    nlen = de->name_len;
    flen = de->fname_len;
    1b5a:	4c 8b 7f 10          	mov    0x10(%rdi),%r15
        } else {
            memcpy(name, de->name, nlen);
            name[nlen]='\0';
        }
    } else {
        if(de->isr_sf==1){
    1b5e:	74 0a                	je     1b6a <get_de_name+0x7a>
                name[flen] = '\0';
            } else {
                get_ext_name(de->ful_name.fn_ext, name);
            }
        } else {
            if(de->file_type==NORMAL_FILE){
    1b60:	80 7f 02 00          	cmpb   $0x0,0x2(%rdi)
    1b64:	0f 84 84 00 00 00    	je     1bee <get_de_name+0xfe>

                strcat(name, "/");
                strcat(name, tem);
                kfree(tem);
            } else {
                if(de->ext_flag == 0){
    1b6a:	66 83 7b 04 00       	cmpw   $0x0,0x4(%rbx)
    1b6f:	74 5d                	je     1bce <get_de_name+0xde>
        if(de->isr_sf==1){
            if(de->ext_flag==0){
                memcpy(name, de->ful_name.f_name, flen);
                name[flen] = '\0';
            } else {
                get_ext_name(de->ful_name.fn_ext, name);
    1b71:	48 8b 7b 58          	mov    0x58(%rbx),%rdi
    1b75:	4c 89 ee             	mov    %r13,%rsi
    1b78:	e8 00 00 00 00       	callq  1b7d <get_de_name+0x8d>
                }
            }
        }
    }

}
    1b7d:	5b                   	pop    %rbx
    1b7e:	41 5c                	pop    %r12
    1b80:	41 5d                	pop    %r13
    1b82:	41 5e                	pop    %r14
    1b84:	41 5f                	pop    %r15
    1b86:	5d                   	pop    %rbp
    1b87:	c3                   	retq   

    if(name_type == 0){
        if(de->ext_flag==1){
            get_ext_name(de->next, name);
        } else {
            memcpy(name, de->name, nlen);
    1b88:	48 8b 57 30          	mov    0x30(%rdi),%rdx
    1b8c:	49 8d 7d 08          	lea    0x8(%r13),%rdi
    1b90:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    1b94:	49 89 55 00          	mov    %rdx,0x0(%r13)
    1b98:	89 c2                	mov    %eax,%edx
    1b9a:	48 8b 4c 16 f8       	mov    -0x8(%rsi,%rdx,1),%rcx
    1b9f:	49 89 4c 15 f8       	mov    %rcx,-0x8(%r13,%rdx,1)
    1ba4:	4c 89 e9             	mov    %r13,%rcx
    1ba7:	48 29 f9             	sub    %rdi,%rcx
    1baa:	48 29 ce             	sub    %rcx,%rsi
    1bad:	01 c1                	add    %eax,%ecx
    1baf:	c1 e9 03             	shr    $0x3,%ecx
    1bb2:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    1bb5:	eb 8e                	jmp    1b45 <get_de_name+0x55>
    nlen = de->name_len;
    flen = de->fname_len;

    if(name_type == 0){
        if(de->ext_flag==1){
            get_ext_name(de->next, name);
    1bb7:	48 8b 7f 30          	mov    0x30(%rdi),%rdi
    1bbb:	48 89 d6             	mov    %rdx,%rsi
    1bbe:	e8 00 00 00 00       	callq  1bc3 <get_de_name+0xd3>
                }
            }
        }
    }

}
    1bc3:	5b                   	pop    %rbx
    1bc4:	41 5c                	pop    %r12
    1bc6:	41 5d                	pop    %r13
    1bc8:	41 5e                	pop    %r14
    1bca:	41 5f                	pop    %r15
    1bcc:	5d                   	pop    %rbp
    1bcd:	c3                   	retq   
                strcat(name, "/");
                strcat(name, tem);
                kfree(tem);
            } else {
                if(de->ext_flag == 0){
                    memcpy(name, de->ful_name.f_name, flen);
    1bce:	48 8d 73 58          	lea    0x58(%rbx),%rsi
    1bd2:	4c 89 fa             	mov    %r15,%rdx
    1bd5:	4c 89 ef             	mov    %r13,%rdi
    1bd8:	e8 00 00 00 00       	callq  1bdd <get_de_name+0xed>
                }
            }
        }
    }

}
    1bdd:	5b                   	pop    %rbx
                strcat(name, tem);
                kfree(tem);
            } else {
                if(de->ext_flag == 0){
                    memcpy(name, de->ful_name.f_name, flen);
                    name[flen]='\0';
    1bde:	43 c6 44 3d 00 00    	movb   $0x0,0x0(%r13,%r15,1)
                }
            }
        }
    }

}
    1be4:	41 5c                	pop    %r12
    1be6:	41 5d                	pop    %r13
    1be8:	41 5e                	pop    %r14
    1bea:	41 5f                	pop    %r15
    1bec:	5d                   	pop    %rbp
    1bed:	c3                   	retq   
                get_ext_name(de->ful_name.fn_ext, name);
            }
        } else {
            if(de->file_type==NORMAL_FILE){
                /*get name*/
                tem = kzalloc(sizeof(char)*(nlen+1), GFP_KERNEL);
    1bee:	41 0f b6 c4          	movzbl %r12b,%eax
    1bf2:	49 89 f6             	mov    %rsi,%r14
    1bf5:	48 8d 78 01          	lea    0x1(%rax),%rdi
    1bf9:	e8 d2 e6 ff ff       	callq  2d0 <kzalloc.constprop.8>
                if(de->ext_flag==1){
    1bfe:	66 83 7b 04 01       	cmpw   $0x1,0x4(%rbx)
                get_ext_name(de->ful_name.fn_ext, name);
            }
        } else {
            if(de->file_type==NORMAL_FILE){
                /*get name*/
                tem = kzalloc(sizeof(char)*(nlen+1), GFP_KERNEL);
    1c03:	49 89 c7             	mov    %rax,%r15
                if(de->ext_flag==1){
    1c06:	0f 84 b2 00 00 00    	je     1cbe <get_de_name+0x1ce>
                    get_ext_name(de->next, tem);
                } else {
                    memcpy(tem, de->name, nlen);
    1c0c:	41 0f b6 c4          	movzbl %r12b,%eax
    1c10:	48 8d 73 30          	lea    0x30(%rbx),%rsi
    1c14:	83 f8 08             	cmp    $0x8,%eax
    1c17:	73 6f                	jae    1c88 <get_de_name+0x198>
    1c19:	a8 04                	test   $0x4,%al
    1c1b:	0f 85 d7 00 00 00    	jne    1cf8 <get_de_name+0x208>
    1c21:	85 c0                	test   %eax,%eax
    1c23:	74 0f                	je     1c34 <get_de_name+0x144>
    1c25:	0f b6 53 30          	movzbl 0x30(%rbx),%edx
    1c29:	a8 02                	test   $0x2,%al
    1c2b:	41 88 17             	mov    %dl,(%r15)
    1c2e:	0f 85 da 00 00 00    	jne    1d0e <get_de_name+0x21e>
                    tem[nlen]='\0';
    1c34:	41 c6 04 07 00       	movb   $0x0,(%r15,%rax,1)
                }

                /*get par fulname*/
                par_pos = le32_to_cpu(de->par_pos);
                par_de = &ze->dentry[par_pos];
    1c39:	8b 7b 0c             	mov    0xc(%rbx),%edi
                get_de_name(par_de, ze, name, 1);
    1c3c:	4c 89 ea             	mov    %r13,%rdx
    1c3f:	b9 01 00 00 00       	mov    $0x1,%ecx
    1c44:	4c 89 f6             	mov    %r14,%rsi
                    tem[nlen]='\0';
                }

                /*get par fulname*/
                par_pos = le32_to_cpu(de->par_pos);
                par_de = &ze->dentry[par_pos];
    1c47:	48 81 c7 81 00 00 00 	add    $0x81,%rdi
    1c4e:	48 c1 e7 07          	shl    $0x7,%rdi
    1c52:	4c 01 f7             	add    %r14,%rdi
                get_de_name(par_de, ze, name, 1);
    1c55:	e8 00 00 00 00       	callq  1c5a <get_de_name+0x16a>

                strcat(name, "/");
    1c5a:	4c 89 ef             	mov    %r13,%rdi
    1c5d:	e8 00 00 00 00       	callq  1c62 <get_de_name+0x172>
                strcat(name, tem);
    1c62:	49 8d 7c 05 01       	lea    0x1(%r13,%rax,1),%rdi
    1c67:	4c 89 fe             	mov    %r15,%rsi
                /*get par fulname*/
                par_pos = le32_to_cpu(de->par_pos);
                par_de = &ze->dentry[par_pos];
                get_de_name(par_de, ze, name, 1);

                strcat(name, "/");
    1c6a:	41 c6 44 05 00 2f    	movb   $0x2f,0x0(%r13,%rax,1)
                strcat(name, tem);
    1c70:	e8 00 00 00 00       	callq  1c75 <get_de_name+0x185>
                kfree(tem);
    1c75:	4c 89 ff             	mov    %r15,%rdi
    1c78:	e8 00 00 00 00       	callq  1c7d <get_de_name+0x18d>
                }
            }
        }
    }

}
    1c7d:	5b                   	pop    %rbx
    1c7e:	41 5c                	pop    %r12
    1c80:	41 5d                	pop    %r13
    1c82:	41 5e                	pop    %r14
    1c84:	41 5f                	pop    %r15
    1c86:	5d                   	pop    %rbp
    1c87:	c3                   	retq   
                /*get name*/
                tem = kzalloc(sizeof(char)*(nlen+1), GFP_KERNEL);
                if(de->ext_flag==1){
                    get_ext_name(de->next, tem);
                } else {
                    memcpy(tem, de->name, nlen);
    1c88:	48 8b 53 30          	mov    0x30(%rbx),%rdx
    1c8c:	49 8d 7f 08          	lea    0x8(%r15),%rdi
    1c90:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    1c94:	49 89 17             	mov    %rdx,(%r15)
    1c97:	89 c2                	mov    %eax,%edx
    1c99:	48 8b 4c 16 f8       	mov    -0x8(%rsi,%rdx,1),%rcx
    1c9e:	49 89 4c 17 f8       	mov    %rcx,-0x8(%r15,%rdx,1)
    1ca3:	4c 89 fa             	mov    %r15,%rdx
    1ca6:	48 29 fa             	sub    %rdi,%rdx
    1ca9:	8d 0c 10             	lea    (%rax,%rdx,1),%ecx
    1cac:	48 29 d6             	sub    %rdx,%rsi
    1caf:	89 ca                	mov    %ecx,%edx
    1cb1:	c1 ea 03             	shr    $0x3,%edx
    1cb4:	89 d1                	mov    %edx,%ecx
    1cb6:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    1cb9:	e9 76 ff ff ff       	jmpq   1c34 <get_de_name+0x144>
        } else {
            if(de->file_type==NORMAL_FILE){
                /*get name*/
                tem = kzalloc(sizeof(char)*(nlen+1), GFP_KERNEL);
                if(de->ext_flag==1){
                    get_ext_name(de->next, tem);
    1cbe:	48 8b 7b 30          	mov    0x30(%rbx),%rdi
    1cc2:	48 89 c6             	mov    %rax,%rsi
    1cc5:	e8 00 00 00 00       	callq  1cca <get_de_name+0x1da>
    1cca:	e9 6a ff ff ff       	jmpq   1c39 <get_de_name+0x149>

    if(name_type == 0){
        if(de->ext_flag==1){
            get_ext_name(de->next, name);
        } else {
            memcpy(name, de->name, nlen);
    1ccf:	8b 57 30             	mov    0x30(%rdi),%edx
    1cd2:	41 89 55 00          	mov    %edx,0x0(%r13)
    1cd6:	89 c2                	mov    %eax,%edx
    1cd8:	8b 4c 16 fc          	mov    -0x4(%rsi,%rdx,1),%ecx
    1cdc:	41 89 4c 15 fc       	mov    %ecx,-0x4(%r13,%rdx,1)
    1ce1:	e9 5f fe ff ff       	jmpq   1b45 <get_de_name+0x55>
    1ce6:	89 c2                	mov    %eax,%edx
    1ce8:	0f b7 4c 16 fe       	movzwl -0x2(%rsi,%rdx,1),%ecx
    1ced:	66 41 89 4c 15 fe    	mov    %cx,-0x2(%r13,%rdx,1)
    1cf3:	e9 4d fe ff ff       	jmpq   1b45 <get_de_name+0x55>
                /*get name*/
                tem = kzalloc(sizeof(char)*(nlen+1), GFP_KERNEL);
                if(de->ext_flag==1){
                    get_ext_name(de->next, tem);
                } else {
                    memcpy(tem, de->name, nlen);
    1cf8:	8b 53 30             	mov    0x30(%rbx),%edx
    1cfb:	41 89 17             	mov    %edx,(%r15)
    1cfe:	89 c2                	mov    %eax,%edx
    1d00:	8b 4c 16 fc          	mov    -0x4(%rsi,%rdx,1),%ecx
    1d04:	41 89 4c 17 fc       	mov    %ecx,-0x4(%r15,%rdx,1)
    1d09:	e9 26 ff ff ff       	jmpq   1c34 <get_de_name+0x144>
    1d0e:	89 c2                	mov    %eax,%edx
    1d10:	0f b7 4c 16 fe       	movzwl -0x2(%rsi,%rdx,1),%ecx
    1d15:	66 41 89 4c 17 fe    	mov    %cx,-0x2(%r15,%rdx,1)
    1d1b:	e9 14 ff ff ff       	jmpq   1c34 <get_de_name+0x144>

0000000000001d20 <get_zone_path>:
/*update sub files numbers*/

/*get zone path through root dentry
 * we get charpath when use this function*/
int get_zone_path(struct super_block *sb, struct dzt_entry_info *ei, char *pname, const char *dename)
{
    1d20:	e8 00 00 00 00       	callq  1d25 <get_zone_path+0x5>
    1d25:	55                   	push   %rbp
    1d26:	48 89 e5             	mov    %rsp,%rbp
    1d29:	41 57                	push   %r15
    1d2b:	41 56                	push   %r14
    1d2d:	41 55                	push   %r13
    1d2f:	41 54                	push   %r12
    1d31:	49 89 fd             	mov    %rdi,%r13
    1d34:	53                   	push   %rbx
    1d35:	48 83 ec 30          	sub    $0x30,%rsp
    struct dafs_zone_entry *ze;
    struct dafs_dentry *de;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    1d39:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
/*update sub files numbers*/

/*get zone path through root dentry
 * we get charpath when use this function*/
int get_zone_path(struct super_block *sb, struct dzt_entry_info *ei, char *pname, const char *dename)
{
    1d40:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
    1d44:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
    1d48:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
    struct dafs_zone_entry *ze;
    struct dafs_dentry *de;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    1d4c:	48 8b 80 d8 0d 00 00 	mov    0xdd8(%rax),%rax
    1d53:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    struct dafs_dzt_block *dzt_blk = dafs_get_dzt_block(sb); 
    1d57:	e8 00 00 00 00       	callq  1d5c <get_zone_path+0x3c>
    u32 num = ei->dzt_eno, slen;
    1d5c:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
{
    struct dafs_zone_entry *ze;
    struct dafs_dentry *de;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    struct dafs_dzt_block *dzt_blk = dafs_get_dzt_block(sb); 
    1d60:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    1d64:	be d0 80 00 00       	mov    $0x80d0,%esi
    u64 phlen, hashname;
    char *path, *name;

    //nova_dbg("%s start",__func__);
    phlen = ei->root_len;
    path = kzalloc(sizeof(char )*(phlen+1), GFP_KERNEL);
    1d69:	49 8b 42 28          	mov    0x28(%r10),%rax
    struct dafs_zone_entry *ze;
    struct dafs_dentry *de;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    struct dafs_dzt_block *dzt_blk = dafs_get_dzt_block(sb); 
    u32 num = ei->dzt_eno, slen;
    1d6d:	41 8b 52 08          	mov    0x8(%r10),%edx
    u64 phlen, hashname;
    char *path, *name;

    //nova_dbg("%s start",__func__);
    phlen = ei->root_len;
    path = kzalloc(sizeof(char )*(phlen+1), GFP_KERNEL);
    1d71:	48 8d 58 01          	lea    0x1(%rax),%rbx
    struct dafs_zone_entry *ze;
    struct dafs_dentry *de;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    struct dafs_dzt_block *dzt_blk = dafs_get_dzt_block(sb); 
    u32 num = ei->dzt_eno, slen;
    1d75:	89 55 ac             	mov    %edx,-0x54(%rbp)
    1d78:	48 89 df             	mov    %rbx,%rdi
    1d7b:	e8 00 00 00 00       	callq  1d80 <get_zone_path+0x60>
    1d80:	48 89 df             	mov    %rbx,%rdi
    1d83:	be d0 80 00 00       	mov    $0x80d0,%esi
    1d88:	49 89 c4             	mov    %rax,%r12
    1d8b:	e8 00 00 00 00       	callq  1d90 <get_zone_path+0x70>

    //nova_dbg("%s start",__func__);
    phlen = ei->root_len;
    path = kzalloc(sizeof(char )*(phlen+1), GFP_KERNEL);
    name = kzalloc(sizeof(char)*(phlen+1), GFP_KERNEL);
    while(num!=0){
    1d90:	8b 55 ac             	mov    -0x54(%rbp),%edx
    1d93:	48 89 c3             	mov    %rax,%rbx
    1d96:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    1d9a:	85 d2                	test   %edx,%edx
    1d9c:	0f 84 a1 00 00 00    	je     1e43 <get_zone_path+0x123>
        ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->pdz_addr);
    1da2:	49 8b 42 20          	mov    0x20(%r10),%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    1da6:	49 8b 95 b0 03 00 00 	mov    0x3b0(%r13),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    1dad:	41 bf 00 00 00 00    	mov    $0x0,%r15d
        de_pos = ei->rden_pos;
        de = &ze->dentry[de_pos];
    1db3:	41 8b 7a 0c          	mov    0xc(%r10),%edi
        get_de_name(de, ze, name, 1);
    1db7:	b9 01 00 00 00       	mov    $0x1,%ecx
    1dbc:	49 89 c0             	mov    %rax,%r8
    1dbf:	4c 03 42 18          	add    0x18(%rdx),%r8
    1dc3:	48 85 c0             	test   %rax,%rax
    1dc6:	48 89 da             	mov    %rbx,%rdx
    1dc9:	4d 0f 45 f8          	cmovne %r8,%r15
    path = kzalloc(sizeof(char )*(phlen+1), GFP_KERNEL);
    name = kzalloc(sizeof(char)*(phlen+1), GFP_KERNEL);
    while(num!=0){
        ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->pdz_addr);
        de_pos = ei->rden_pos;
        de = &ze->dentry[de_pos];
    1dcd:	48 81 c7 81 00 00 00 	add    $0x81,%rdi
    1dd4:	48 c1 e7 07          	shl    $0x7,%rdi
        get_de_name(de, ze, name, 1);
    1dd8:	4c 89 fe             	mov    %r15,%rsi
    path = kzalloc(sizeof(char )*(phlen+1), GFP_KERNEL);
    name = kzalloc(sizeof(char)*(phlen+1), GFP_KERNEL);
    while(num!=0){
        ze = (struct dafs_zone_entry *)nova_get_block(sb, ei->pdz_addr);
        de_pos = ei->rden_pos;
        de = &ze->dentry[de_pos];
    1ddb:	4c 01 ff             	add    %r15,%rdi
        get_de_name(de, ze, name, 1);
    1dde:	e8 00 00 00 00       	callq  1de3 <get_zone_path+0xc3>
        strcat(name,path);
    1de3:	4c 89 e6             	mov    %r12,%rsi
    1de6:	48 89 df             	mov    %rbx,%rdi
    1de9:	e8 00 00 00 00       	callq  1dee <get_zone_path+0xce>
        slen = strlen(name);
    1dee:	48 89 df             	mov    %rbx,%rdi
    1df1:	e8 00 00 00 00       	callq  1df6 <get_zone_path+0xd6>
    1df6:	41 89 c6             	mov    %eax,%r14d
        memcpy(path, name, slen);
    1df9:	48 89 de             	mov    %rbx,%rsi
    1dfc:	4c 89 e7             	mov    %r12,%rdi
    1dff:	4c 89 f2             	mov    %r14,%rdx
    1e02:	e8 00 00 00 00       	callq  1e07 <get_zone_path+0xe7>
        path[slen]='\0';
    1e07:	43 c6 04 34 00       	movb   $0x0,(%r12,%r14,1)
        num = le64_to_cpu(ze->dz_no);
    1e0c:	41 8b 87 7c 40 00 00 	mov    0x407c(%r15),%eax
        hashname = le64_to_cpu(dzt_blk->dzt_entry[num].hash_name);
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    1e13:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
        strcat(name,path);
        slen = strlen(name);
        memcpy(path, name, slen);
        path[slen]='\0';
        num = le64_to_cpu(ze->dz_no);
        hashname = le64_to_cpu(dzt_blk->dzt_entry[num].hash_name);
    1e17:	48 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%rcx
    1e1e:	00 
        get_de_name(de, ze, name, 1);
        strcat(name,path);
        slen = strlen(name);
        memcpy(path, name, slen);
        path[slen]='\0';
        num = le64_to_cpu(ze->dz_no);
    1e1f:	49 89 c7             	mov    %rax,%r15
        hashname = le64_to_cpu(dzt_blk->dzt_entry[num].hash_name);
    1e22:	48 c1 e0 06          	shl    $0x6,%rax
    1e26:	48 29 c8             	sub    %rcx,%rax
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    1e29:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    1e2d:	48 8b 74 01 78       	mov    0x78(%rcx,%rax,1),%rsi
    1e32:	e8 00 00 00 00       	callq  1e37 <get_zone_path+0x117>

    //nova_dbg("%s start",__func__);
    phlen = ei->root_len;
    path = kzalloc(sizeof(char )*(phlen+1), GFP_KERNEL);
    name = kzalloc(sizeof(char)*(phlen+1), GFP_KERNEL);
    while(num!=0){
    1e37:	45 85 ff             	test   %r15d,%r15d
        slen = strlen(name);
        memcpy(path, name, slen);
        path[slen]='\0';
        num = le64_to_cpu(ze->dz_no);
        hashname = le64_to_cpu(dzt_blk->dzt_entry[num].hash_name);
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    1e3a:	49 89 c2             	mov    %rax,%r10

    //nova_dbg("%s start",__func__);
    phlen = ei->root_len;
    path = kzalloc(sizeof(char )*(phlen+1), GFP_KERNEL);
    name = kzalloc(sizeof(char)*(phlen+1), GFP_KERNEL);
    while(num!=0){
    1e3d:	0f 85 5f ff ff ff    	jne    1da2 <get_zone_path+0x82>
        path[slen]='\0';
        num = le64_to_cpu(ze->dz_no);
        hashname = le64_to_cpu(dzt_blk->dzt_entry[num].hash_name);
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    }
    strcat(path, dename);
    1e43:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
    1e47:	4c 89 e7             	mov    %r12,%rdi
    1e4a:	e8 00 00 00 00       	callq  1e4f <get_zone_path+0x12f>
    slen = strlen(path);
    1e4f:	4c 89 e7             	mov    %r12,%rdi
    1e52:	e8 00 00 00 00       	callq  1e57 <get_zone_path+0x137>
    memcpy(pname, path, slen);
    1e57:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
    1e5b:	41 89 c5             	mov    %eax,%r13d
    1e5e:	4c 89 e6             	mov    %r12,%rsi
    1e61:	4c 89 ea             	mov    %r13,%rdx
    1e64:	4c 89 f7             	mov    %r14,%rdi
    1e67:	e8 00 00 00 00       	callq  1e6c <get_zone_path+0x14c>
    pname[slen]= '\0';
    1e6c:	43 c6 04 2e 00       	movb   $0x0,(%r14,%r13,1)
    //memcpy(pname+strlen(path),end,1);
    kfree(path);
    1e71:	4c 89 e7             	mov    %r12,%rdi
    1e74:	e8 00 00 00 00       	callq  1e79 <get_zone_path+0x159>
    kfree(name);
    1e79:	48 89 df             	mov    %rbx,%rdi
    1e7c:	e8 00 00 00 00       	callq  1e81 <get_zone_path+0x161>
    //nova_dbg("%s end get name %s",__func__,pname);
    return 0;

}
    1e81:	48 83 c4 30          	add    $0x30,%rsp
    1e85:	31 c0                	xor    %eax,%eax
    1e87:	5b                   	pop    %rbx
    1e88:	41 5c                	pop    %r12
    1e8a:	41 5d                	pop    %r13
    1e8c:	41 5e                	pop    %r14
    1e8e:	41 5f                	pop    %r15
    1e90:	5d                   	pop    %rbp
    1e91:	c3                   	retq   
    1e92:	0f 1f 40 00          	nopl   0x0(%rax)
    1e96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1e9d:	00 00 00 

0000000000001ea0 <clear_ext>:

}

/*clear ext bit*/
void clear_ext(struct zone_ptr *p, struct name_ext *de_ext)
{
    1ea0:	e8 00 00 00 00       	callq  1ea5 <clear_ext+0x5>
}

static inline int test_and_clear_bit_le(int nr, void *addr)
{
	return test_and_clear_bit(nr ^ BITOP_LE_SWIZZLE, addr);
    1ea5:	8b 46 04             	mov    0x4(%rsi),%eax
    u32 ext_pos, bitpos;
    
    ext_pos = le32_to_cpu(de_ext->ext_pos);
    bitpos = ext_pos*2+1;
    test_and_clear_bit_le(bitpos, (void *)p->statemap);
    1ea8:	48 8b 17             	mov    (%rdi),%rdx
    1eab:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax
    1eaf:	48 98                	cltq   
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_clear_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "btr", *addr, "Ir", nr, "%0", "c");
    1eb1:	f0 48 0f b3 02       	lock btr %rax,(%rdx)
    1eb6:	72 00                	jb     1eb8 <clear_ext+0x18>
    if(de_ext->next)
    1eb8:	48 8b 76 08          	mov    0x8(%rsi),%rsi
    1ebc:	48 85 f6             	test   %rsi,%rsi
    1ebf:	74 0a                	je     1ecb <clear_ext+0x2b>

}

/*clear ext bit*/
void clear_ext(struct zone_ptr *p, struct name_ext *de_ext)
{
    1ec1:	55                   	push   %rbp
    1ec2:	48 89 e5             	mov    %rsp,%rbp
    
    ext_pos = le32_to_cpu(de_ext->ext_pos);
    bitpos = ext_pos*2+1;
    test_and_clear_bit_le(bitpos, (void *)p->statemap);
    if(de_ext->next)
        clear_ext(p, de_ext->next);
    1ec5:	e8 00 00 00 00       	callq  1eca <clear_ext+0x2a>
}
    1eca:	5d                   	pop    %rbp
    1ecb:	f3 c3                	repz retq 
    1ecd:	0f 1f 00             	nopl   (%rax)

0000000000001ed0 <delete_ext>:

/*test and delete ext name entry*/
int delete_ext(struct zone_ptr *p, struct dafs_dentry *de)
{
    1ed0:	e8 00 00 00 00       	callq  1ed5 <delete_ext+0x5>
    1ed5:	55                   	push   %rbp
    1ed6:	48 89 e5             	mov    %rsp,%rbp
    1ed9:	41 54                	push   %r12
    1edb:	53                   	push   %rbx
    unsigned short ext_flag;
    //struct name_ext *de_ext;

    //nova_dbg("%s start",__func__);
    ext_flag = le16_to_cpu(de->ext_flag);
    switch(ext_flag) {
    1edc:	0f b7 46 04          	movzwl 0x4(%rsi),%eax
        clear_ext(p, de_ext->next);
}

/*test and delete ext name entry*/
int delete_ext(struct zone_ptr *p, struct dafs_dentry *de)
{
    1ee0:	49 89 fc             	mov    %rdi,%r12
    1ee3:	48 89 f3             	mov    %rsi,%rbx
    unsigned short ext_flag;
    //struct name_ext *de_ext;

    //nova_dbg("%s start",__func__);
    ext_flag = le16_to_cpu(de->ext_flag);
    switch(ext_flag) {
    1ee6:	66 83 f8 01          	cmp    $0x1,%ax
    1eea:	74 16                	je     1f02 <delete_ext+0x32>
    1eec:	66 83 f8 02          	cmp    $0x2,%ax
    1ef0:	75 09                	jne    1efb <delete_ext+0x2b>
    case 1:
        clear_ext(p, de->next);
        clear_ext(p, de->ful_name.fn_ext);
        break;
    case 2:
        clear_ext(p, de->ful_name.fn_ext);
    1ef2:	48 8b 76 58          	mov    0x58(%rsi),%rsi
    1ef6:	e8 00 00 00 00       	callq  1efb <delete_ext+0x2b>
        break;
    }
OUT:
    //nova_dbg("%s end",__func__);
    return 0;
}
    1efb:	5b                   	pop    %rbx
    1efc:	31 c0                	xor    %eax,%eax
    1efe:	41 5c                	pop    %r12
    1f00:	5d                   	pop    %rbp
    1f01:	c3                   	retq   
    ext_flag = le16_to_cpu(de->ext_flag);
    switch(ext_flag) {
    case 0:
        goto OUT;
    case 1:
        clear_ext(p, de->next);
    1f02:	48 8b 76 30          	mov    0x30(%rsi),%rsi
    1f06:	e8 00 00 00 00       	callq  1f0b <delete_ext+0x3b>
        clear_ext(p, de->ful_name.fn_ext);
    1f0b:	48 8b 73 58          	mov    0x58(%rbx),%rsi
    1f0f:	4c 89 e7             	mov    %r12,%rdi
    1f12:	e8 00 00 00 00       	callq  1f17 <delete_ext+0x47>
        break;
    }
OUT:
    //nova_dbg("%s end",__func__);
    return 0;
}
    1f17:	5b                   	pop    %rbx
    1f18:	31 c0                	xor    %eax,%eax
    1f1a:	41 5c                	pop    %r12
    1f1c:	5d                   	pop    %rbp
    1f1d:	c3                   	retq   
    1f1e:	66 90                	xchg   %ax,%ax

0000000000001f20 <__remove_direntry>:
}

/**递归删除dentry*/
static int __remove_direntry(struct super_block *sb, struct dafs_dentry *dafs_de,\
        struct dafs_zone_entry *dafs_ze, struct dzt_entry_info *dzt_ei, u32 de_pos)
{
    1f20:	e8 00 00 00 00       	callq  1f25 <__remove_direntry+0x5>
    1f25:	55                   	push   %rbp
    1f26:	48 89 e5             	mov    %rsp,%rbp
    1f29:	41 57                	push   %r15
    1f2b:	41 56                	push   %r14
    1f2d:	41 55                	push   %r13
    1f2f:	41 54                	push   %r12
    1f31:	49 89 fd             	mov    %rdi,%r13
    1f34:	53                   	push   %rbx
    1f35:	49 89 f4             	mov    %rsi,%r12
    1f38:	48 89 d3             	mov    %rdx,%rbx
    1f3b:	49 89 ce             	mov    %rcx,%r14
    1f3e:	45 89 c7             	mov    %r8d,%r15d
    1f41:	48 83 ec 38          	sub    $0x38,%rsp
    1f45:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    1f4c:	00 00 
    1f4e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    1f52:	31 c0                	xor    %eax,%eax
    struct zone_ptr *z_p;
    struct dzt_ptr *dzt_p;
    struct dir_info *old_dir, *par_dir;
    struct list_head *this, *head, *next;
    struct file_p *tem_sf;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    1f54:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
    //d_hn = BKDRHash(dafs_de->ful_name->f_name,d_hlen);
    //temlen = d_hlen - le64_to_cpu(dafs_de->name_len);
    //nova_dbg("%s start",__func__);
    isr_sf = le64_to_cpu(dafs_de->isr_sf);
    
    if(isr_sf!=1){
    1f5b:	80 7e 03 01          	cmpb   $0x1,0x3(%rsi)
    struct zone_ptr *z_p;
    struct dzt_ptr *dzt_p;
    struct dir_info *old_dir, *par_dir;
    struct list_head *this, *head, *next;
    struct file_p *tem_sf;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    1f5f:	48 8b 80 d8 0d 00 00 	mov    0xdd8(%rax),%rax
    1f66:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    isr_sf = le64_to_cpu(dafs_de->isr_sf);
    
    if(isr_sf!=1){
        par_id = le64_to_cpu(dafs_de->par_pos);
        pde = &dafs_ze->dentry[par_id];
        par_hn = le64_to_cpu(pde->hname);
    1f6a:	8b 46 0c             	mov    0xc(%rsi),%eax
    //d_hn = BKDRHash(dafs_de->ful_name->f_name,d_hlen);
    //temlen = d_hlen - le64_to_cpu(dafs_de->name_len);
    //nova_dbg("%s start",__func__);
    isr_sf = le64_to_cpu(dafs_de->isr_sf);
    
    if(isr_sf!=1){
    1f6d:	0f 84 f1 00 00 00    	je     2064 <__remove_direntry+0x144>
        par_id = le64_to_cpu(dafs_de->par_pos);
        pde = &dafs_ze->dentry[par_id];
        par_hn = le64_to_cpu(pde->hname);
    1f73:	48 c1 e0 07          	shl    $0x7,%rax

        /*delete pos in its pardir*/
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    1f77:	48 8d 79 38          	lea    0x38(%rcx),%rdi
    1f7b:	48 8b b4 02 a8 40 00 	mov    0x40a8(%rdx,%rax,1),%rsi
    1f82:	00 
    1f83:	e8 00 00 00 00       	callq  1f88 <__remove_direntry+0x68>
        head = &par_dir->sub_file;
        list_for_each_safe(this, next, head) {
    1f88:	48 8b 70 18          	mov    0x18(%rax),%rsi
        pde = &dafs_ze->dentry[par_id];
        par_hn = le64_to_cpu(pde->hname);

        /*delete pos in its pardir*/
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
        head = &par_dir->sub_file;
    1f8c:	48 8d 48 18          	lea    0x18(%rax),%rcx
        list_for_each_safe(this, next, head) {
    1f90:	48 39 f1             	cmp    %rsi,%rcx
    1f93:	48 8b 3e             	mov    (%rsi),%rdi
    1f96:	74 20                	je     1fb8 <__remove_direntry+0x98>
            tem_sf = list_entry(this, struct file_p, list);
            if(tem_sf->pos == de_pos){
    1f98:	44 3b 7e 10          	cmp    0x10(%rsi),%r15d
    1f9c:	75 12                	jne    1fb0 <__remove_direntry+0x90>
    1f9e:	e9 22 01 00 00       	jmpq   20c5 <__remove_direntry+0x1a5>
    1fa3:	44 39 7f 10          	cmp    %r15d,0x10(%rdi)
    1fa7:	0f 84 1e 01 00 00    	je     20cb <__remove_direntry+0x1ab>
        par_hn = le64_to_cpu(pde->hname);

        /*delete pos in its pardir*/
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
        head = &par_dir->sub_file;
        list_for_each_safe(this, next, head) {
    1fad:	48 89 d7             	mov    %rdx,%rdi
    1fb0:	48 39 f9             	cmp    %rdi,%rcx
    1fb3:	48 8b 17             	mov    (%rdi),%rdx
    1fb6:	75 eb                	jne    1fa3 <__remove_direntry+0x83>
    }
    head = next = this =NULL;

NEXT:    
    //strcat(tem, dafs_ze->root_path);
    if(dafs_de->file_type == ROOT_DIRECTORY){
    1fb8:	41 0f b6 44 24 02    	movzbl 0x2(%r12),%eax
    1fbe:	3c 02                	cmp    $0x2,%al
    1fc0:	0f 84 4b 01 00 00    	je     2111 <__remove_direntry+0x1f1>
        dafs_free_zone_blocks(sb, ei, ei->dz_addr >> PAGE_SHIFT, 1);
        kfree(pname);
        kfree(ei);
        kfree(z_p);
        kfree(dzt_p);
    }else if(dafs_de->file_type == NORMAL_DIRECTORY){
    1fc6:	3c 01                	cmp    $0x1,%al

        /* delete sub files*/
        //nova_dbg("%s remove dir",__func__);
        d_hn = le64_to_cpu(dafs_de->hname);
    1fc8:	49 8b 44 24 28       	mov    0x28(%r12),%rax
        dafs_free_zone_blocks(sb, ei, ei->dz_addr >> PAGE_SHIFT, 1);
        kfree(pname);
        kfree(ei);
        kfree(z_p);
        kfree(dzt_p);
    }else if(dafs_de->file_type == NORMAL_DIRECTORY){
    1fcd:	0f 84 a1 02 00 00    	je     2274 <__remove_direntry+0x354>
        d_hn = le64_to_cpu(dafs_de->hname);
        
        /*delete dir itself*/
        bitpos = de_pos * 2;
        
        make_zone_ptr(&z_p, dafs_ze);
    1fd3:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
    1fd7:	48 89 de             	mov    %rbx,%rsi
        if(!ret)
            return -EINVAL;
    
        kfree(z_p);
    }else{
        d_hn = le64_to_cpu(dafs_de->hname);
    1fda:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        
        /*delete dir itself*/
        bitpos = de_pos * 2;
    1fde:	45 01 ff             	add    %r15d,%r15d
        
        make_zone_ptr(&z_p, dafs_ze);
    1fe1:	e8 00 00 00 00       	callq  1fe6 <__remove_direntry+0xc6>
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    1fe6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    1fea:	49 63 d7             	movslq %r15d,%rdx
    1fed:	48 8b 00             	mov    (%rax),%rax
    1ff0:	f0 48 0f b3 10       	lock btr %rdx,(%rax)
    1ff5:	72 00                	jb     1ff7 <__remove_direntry+0xd7>
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    1ff7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    1ffb:	45 8d 4f 01          	lea    0x1(%r15),%r9d
    1fff:	4d 63 c9             	movslq %r9d,%r9
    2002:	48 8b 00             	mov    (%rax),%rax
    2005:	f0 4c 0f b3 08       	lock btr %r9,(%rax)
    200a:	72 00                	jb     200c <__remove_direntry+0xec>
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn, 1);
    200c:	49 8b 76 18          	mov    0x18(%r14),%rsi
    2010:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    2014:	b9 01 00 00 00       	mov    $0x1,%ecx
    2019:	4c 89 ef             	mov    %r13,%rdi
    201c:	e8 00 00 00 00       	callq  2021 <__remove_direntry+0x101>
        delete_ext(z_p, dafs_de);
    2021:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
        
        make_zone_ptr(&z_p, dafs_ze);
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn, 1);
    2025:	89 c3                	mov    %eax,%ebx
        delete_ext(z_p, dafs_de);
    2027:	4c 89 e6             	mov    %r12,%rsi
    202a:	e8 00 00 00 00       	callq  202f <__remove_direntry+0x10f>
        /*free rf_entry*/
        //delete_rf_entry(dzt_ei, d_hn);
        if(!ret){
    202f:	85 db                	test   %ebx,%ebx
    2031:	0f 84 2d 03 00 00    	je     2364 <__remove_direntry+0x444>
            //nova_dbg("%s make invalid fail",__func__);
            return -EINVAL;
        }
        /*delete in par de*/

        kfree(z_p);
    2037:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    203b:	e8 00 00 00 00       	callq  2040 <__remove_direntry+0x120>
    }
    //nova_dbg("%s end",__func__);
    return 0;
    2040:	31 c0                	xor    %eax,%eax
}
    2042:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    2046:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    204d:	00 00 
    204f:	0f 85 21 03 00 00    	jne    2376 <__remove_direntry+0x456>
    2055:	48 83 c4 38          	add    $0x38,%rsp
    2059:	5b                   	pop    %rbx
    205a:	41 5c                	pop    %r12
    205c:	41 5d                	pop    %r13
    205e:	41 5e                	pop    %r14
    2060:	41 5f                	pop    %r15
    2062:	5d                   	pop    %rbp
    2063:	c3                   	retq   
        }
        //kfree(par_name);
    }else{
        par_id = le64_to_cpu(dafs_de->par_pos);
        pde = &dafs_ze->dentry[par_id];
        ino = le64_to_cpu(pde->ino);
    2064:	48 89 c1             	mov    %rax,%rcx
    2067:	48 c1 e1 07          	shl    $0x7,%rcx
        if(ino==NOVA_ROOT_INO || par_id!=0){
    206b:	48 83 bc 0b 98 40 00 	cmpq   $0x1,0x4098(%rbx,%rcx,1)
    2072:	00 01 
    2074:	74 08                	je     207e <__remove_direntry+0x15e>
    2076:	85 c0                	test   %eax,%eax
    2078:	0f 84 3a ff ff ff    	je     1fb8 <__remove_direntry+0x98>
            par_hn = le64_to_cpu(pde->hname);
    207e:	48 c1 e0 07          	shl    $0x7,%rax
            par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    2082:	49 8d 7e 38          	lea    0x38(%r14),%rdi
    2086:	48 8b b4 03 a8 40 00 	mov    0x40a8(%rbx,%rax,1),%rsi
    208d:	00 
    208e:	e8 00 00 00 00       	callq  2093 <__remove_direntry+0x173>
            head = &par_dir->sub_file;
            list_for_each_safe(this, next, head) {
    2093:	48 8b 70 18          	mov    0x18(%rax),%rsi
        pde = &dafs_ze->dentry[par_id];
        ino = le64_to_cpu(pde->ino);
        if(ino==NOVA_ROOT_INO || par_id!=0){
            par_hn = le64_to_cpu(pde->hname);
            par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
            head = &par_dir->sub_file;
    2097:	48 8d 48 18          	lea    0x18(%rax),%rcx
            list_for_each_safe(this, next, head) {
    209b:	48 39 f1             	cmp    %rsi,%rcx
    209e:	48 8b 3e             	mov    (%rsi),%rdi
    20a1:	0f 84 11 ff ff ff    	je     1fb8 <__remove_direntry+0x98>
                tem_sf = list_entry(this, struct file_p, list);
                if(tem_sf->pos == de_pos){
    20a7:	44 3b 7e 10          	cmp    0x10(%rsi),%r15d
    20ab:	75 0b                	jne    20b8 <__remove_direntry+0x198>
    20ad:	eb 16                	jmp    20c5 <__remove_direntry+0x1a5>
    20af:	44 3b 7f 10          	cmp    0x10(%rdi),%r15d
    20b3:	74 16                	je     20cb <__remove_direntry+0x1ab>
        ino = le64_to_cpu(pde->ino);
        if(ino==NOVA_ROOT_INO || par_id!=0){
            par_hn = le64_to_cpu(pde->hname);
            par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
            head = &par_dir->sub_file;
            list_for_each_safe(this, next, head) {
    20b5:	48 89 d7             	mov    %rdx,%rdi
    20b8:	48 39 f9             	cmp    %rdi,%rcx
    20bb:	48 8b 17             	mov    (%rdi),%rdx
    20be:	75 ef                	jne    20af <__remove_direntry+0x18f>
    20c0:	e9 f3 fe ff ff       	jmpq   1fb8 <__remove_direntry+0x98>
                tem_sf = list_entry(this, struct file_p, list);
                if(tem_sf->pos == de_pos){
    20c5:	48 89 fa             	mov    %rdi,%rdx
    20c8:	48 89 f7             	mov    %rsi,%rdi
    20cb:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    20cf:	48 8b 4f 08          	mov    0x8(%rdi),%rcx
	entry->next = LIST_POISON1;
    20d3:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
    20da:	00 ad de 
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    20dd:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
	prev->next = next;
    20e1:	48 89 11             	mov    %rdx,(%rcx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    20e4:	48 89 07             	mov    %rax,(%rdi)
	entry->prev = LIST_POISON2;
    20e7:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
    20ee:	00 ad de 
    20f1:	48 89 47 08          	mov    %rax,0x8(%rdi)
                    list_del(&tem_sf->list);
                    kfree(tem_sf);
    20f5:	e8 00 00 00 00       	callq  20fa <__remove_direntry+0x1da>
                    par_dir->sub_num--;
    20fa:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    20fe:	48 83 68 08 01       	subq   $0x1,0x8(%rax)
    }
    head = next = this =NULL;

NEXT:    
    //strcat(tem, dafs_ze->root_path);
    if(dafs_de->file_type == ROOT_DIRECTORY){
    2103:	41 0f b6 44 24 02    	movzbl 0x2(%r12),%eax
    2109:	3c 02                	cmp    $0x2,%al
    210b:	0f 85 b5 fe ff ff    	jne    1fc6 <__remove_direntry+0xa6>

        /*delete dir*/
        bitpos = de_pos * 2;

        plen = le64_to_cpu(dafs_de->fname_len);
    2111:	4d 8b 44 24 10       	mov    0x10(%r12),%r8
NEXT:    
    //strcat(tem, dafs_ze->root_path);
    if(dafs_de->file_type == ROOT_DIRECTORY){

        /*delete dir*/
        bitpos = de_pos * 2;
    2116:	43 8d 04 3f          	lea    (%r15,%r15,1),%eax
    211a:	89 45 b0             	mov    %eax,-0x50(%rbp)

        plen = le64_to_cpu(dafs_de->fname_len);
        pname = kzalloc(sizeof(char)*(plen+1), GFP_KERNEL);
    211d:	49 8d 78 01          	lea    0x1(%r8),%rdi
    2121:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
    2125:	e8 a6 e1 ff ff       	callq  2d0 <kzalloc.constprop.8>
        get_de_name(dafs_de, dafs_ze, pname, 1);
    212a:	b9 01 00 00 00       	mov    $0x1,%ecx
    212f:	48 89 c2             	mov    %rax,%rdx
    2132:	48 89 de             	mov    %rbx,%rsi
    2135:	4c 89 e7             	mov    %r12,%rdi

        /*delete dir*/
        bitpos = de_pos * 2;

        plen = le64_to_cpu(dafs_de->fname_len);
        pname = kzalloc(sizeof(char)*(plen+1), GFP_KERNEL);
    2138:	49 89 c7             	mov    %rax,%r15
        get_de_name(dafs_de, dafs_ze, pname, 1);
    213b:	e8 00 00 00 00       	callq  2140 <__remove_direntry+0x220>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    2140:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
    2144:	45 85 c0             	test   %r8d,%r8d
    2147:	0f 8e 21 02 00 00    	jle    236e <__remove_direntry+0x44e>
    214d:	41 8d 40 ff          	lea    -0x1(%r8),%eax
    2151:	45 31 c0             	xor    %r8d,%r8d
    2154:	49 8d 4c 07 01       	lea    0x1(%r15,%rax,1),%rcx
    2159:	4c 89 f8             	mov    %r15,%rax
		hash = hash * seed + (*str++);
    215c:	4c 89 c2             	mov    %r8,%rdx
    215f:	48 83 c0 01          	add    $0x1,%rax
    2163:	48 c1 e2 05          	shl    $0x5,%rdx
    2167:	4c 29 c2             	sub    %r8,%rdx
    216a:	49 89 d0             	mov    %rdx,%r8
    216d:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    2172:	49 01 d0             	add    %rdx,%r8
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    2175:	48 39 c1             	cmp    %rax,%rcx
    2178:	75 e2                	jne    215c <__remove_direntry+0x23c>
        d_hn = BKDRHash(pname, plen);
        
        make_zone_ptr(&z_p, dafs_ze);
    217a:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
    217e:	48 89 de             	mov    %rbx,%rsi
    2181:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
    2185:	e8 00 00 00 00       	callq  218a <__remove_direntry+0x26a>
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    218a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    218e:	48 63 55 b0          	movslq -0x50(%rbp),%rdx
    2192:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
    2196:	48 8b 00             	mov    (%rax),%rax
    2199:	f0 48 0f b3 10       	lock btr %rdx,(%rax)
    219e:	72 00                	jb     21a0 <__remove_direntry+0x280>
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    21a0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    21a4:	48 8b 10             	mov    (%rax),%rdx
    21a7:	8b 45 b0             	mov    -0x50(%rbp),%eax
    21aa:	83 c0 01             	add    $0x1,%eax
    21ad:	48 98                	cltq   
    21af:	f0 48 0f b3 02       	lock btr %rax,(%rdx)
    21b4:	72 00                	jb     21b6 <__remove_direntry+0x296>
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn,  1);
    21b6:	49 8b 76 18          	mov    0x18(%r14),%rsi
    21ba:	4c 89 c2             	mov    %r8,%rdx
    21bd:	b9 01 00 00 00       	mov    $0x1,%ecx
    21c2:	4c 89 ef             	mov    %r13,%rdi
    21c5:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
    21c9:	e8 00 00 00 00       	callq  21ce <__remove_direntry+0x2ae>
        delete_ext(z_p, dafs_de);
    21ce:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    21d2:	4c 89 e6             	mov    %r12,%rsi
        
        make_zone_ptr(&z_p, dafs_ze);
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn,  1);
    21d5:	89 c3                	mov    %eax,%ebx
        delete_ext(z_p, dafs_de);
    21d7:	e8 00 00 00 00       	callq  21dc <__remove_direntry+0x2bc>
        /*free dir_entry*/
        delete_dir_info(dzt_ei, d_hn);
    21dc:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
    21e0:	4c 89 f7             	mov    %r14,%rdi
    21e3:	4c 89 c6             	mov    %r8,%rsi
    21e6:	e8 00 00 00 00       	callq  21eb <__remove_direntry+0x2cb>
        
        if(!ret)
    21eb:	85 db                	test   %ebx,%ebx
    21ed:	0f 84 71 01 00 00    	je     2364 <__remove_direntry+0x444>
         * ei free zone
         * free hash table
         * free zone
         * free ei*/
        hashname = le64_to_cpu(dafs_de->dzt_hn);
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    21f3:	49 8b 74 24 28       	mov    0x28(%r12),%rsi
    21f8:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    21fc:	e8 00 00 00 00       	callq  2201 <__remove_direntry+0x2e1>
        dzt_rno = ei->dzt_eno;
        tail = le64_to_cpu(ei->ht_head);
        free_htable(sb, tail, 1);
    2201:	48 8b 70 18          	mov    0x18(%rax),%rsi
    2205:	ba 01 00 00 00       	mov    $0x1,%edx
    220a:	4c 89 ef             	mov    %r13,%rdi
         * ei free zone
         * free hash table
         * free zone
         * free ei*/
        hashname = le64_to_cpu(dafs_de->dzt_hn);
        ei = radix_tree_lookup(&dzt_m->dzt_root, hashname);
    220d:	48 89 c3             	mov    %rax,%rbx
        dzt_rno = ei->dzt_eno;
    2210:	4c 63 60 08          	movslq 0x8(%rax),%r12
        tail = le64_to_cpu(ei->ht_head);
        free_htable(sb, tail, 1);
    2214:	e8 00 00 00 00       	callq  2219 <__remove_direntry+0x2f9>
        make_dzt_ptr(sb, &dzt_p);
    2219:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
    221d:	4c 89 ef             	mov    %r13,%rdi
    2220:	e8 00 00 00 00       	callq  2225 <__remove_direntry+0x305>
        test_and_clear_bit_le(dzt_rno, (void *)dzt_p->bitmap);
    2225:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    2229:	48 8b 00             	mov    (%rax),%rax
    222c:	f0 4c 0f b3 20       	lock btr %r12,(%rax)
    2231:	72 00                	jb     2233 <__remove_direntry+0x313>
        //delete_rf_tree(ei);
        dafs_free_zone_blocks(sb, ei, ei->dz_addr >> PAGE_SHIFT, 1);
    2233:	48 8b 53 10          	mov    0x10(%rbx),%rdx
    2237:	b9 01 00 00 00       	mov    $0x1,%ecx
    223c:	48 89 de             	mov    %rbx,%rsi
    223f:	4c 89 ef             	mov    %r13,%rdi
    2242:	48 c1 ea 0c          	shr    $0xc,%rdx
    2246:	e8 00 00 00 00       	callq  224b <__remove_direntry+0x32b>
        kfree(pname);
    224b:	4c 89 ff             	mov    %r15,%rdi
    224e:	e8 00 00 00 00       	callq  2253 <__remove_direntry+0x333>
        kfree(ei);
    2253:	48 89 df             	mov    %rbx,%rdi
    2256:	e8 00 00 00 00       	callq  225b <__remove_direntry+0x33b>
        kfree(z_p);
    225b:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    225f:	e8 00 00 00 00       	callq  2264 <__remove_direntry+0x344>
        kfree(dzt_p);
    2264:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    2268:	e8 00 00 00 00       	callq  226d <__remove_direntry+0x34d>
        /*delete in par de*/

        kfree(z_p);
    }
    //nova_dbg("%s end",__func__);
    return 0;
    226d:	31 c0                	xor    %eax,%eax
    226f:	e9 ce fd ff ff       	jmpq   2042 <__remove_direntry+0x122>
    }else if(dafs_de->file_type == NORMAL_DIRECTORY){

        /* delete sub files*/
        //nova_dbg("%s remove dir",__func__);
        d_hn = le64_to_cpu(dafs_de->hname);
        old_dir = radix_tree_lookup(&dzt_ei->dir_tree, d_hn);
    2274:	49 8d 4e 38          	lea    0x38(%r14),%rcx
    2278:	48 89 c6             	mov    %rax,%rsi
        kfree(dzt_p);
    }else if(dafs_de->file_type == NORMAL_DIRECTORY){

        /* delete sub files*/
        //nova_dbg("%s remove dir",__func__);
        d_hn = le64_to_cpu(dafs_de->hname);
    227b:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
        old_dir = radix_tree_lookup(&dzt_ei->dir_tree, d_hn);
    227f:	48 89 cf             	mov    %rcx,%rdi
    2282:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    2286:	e8 00 00 00 00       	callq  228b <__remove_direntry+0x36b>
        if(!old_dir){
    228b:	48 85 c0             	test   %rax,%rax
    228e:	0f 84 d0 00 00 00    	je     2364 <__remove_direntry+0x444>
            //nova_dbg("%s not find dir_info",__func__);
            return -EINVAL;
        }
        head = &old_dir->sub_file;
    2294:	48 8d 48 18          	lea    0x18(%rax),%rcx
        list_for_each_safe(this, next, head) {
    2298:	48 8b 40 18          	mov    0x18(%rax),%rax
        old_dir = radix_tree_lookup(&dzt_ei->dir_tree, d_hn);
        if(!old_dir){
            //nova_dbg("%s not find dir_info",__func__);
            return -EINVAL;
        }
        head = &old_dir->sub_file;
    229c:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
        list_for_each_safe(this, next, head) {
    22a0:	48 39 c1             	cmp    %rax,%rcx
    22a3:	4c 8b 10             	mov    (%rax),%r10
    22a6:	75 05                	jne    22ad <__remove_direntry+0x38d>
    22a8:	eb 39                	jmp    22e3 <__remove_direntry+0x3c3>
    22aa:	49 89 d2             	mov    %rdx,%r10
            tem_sf = list_entry(this, struct file_p, list);
            sub_id = tem_sf->pos;
    22ad:	8b 70 10             	mov    0x10(%rax),%esi
            sde= &dafs_ze->dentry[sub_id];
            //nova_dbg("%s start to delete de %s",__func__, sde->name);
            ret = __remove_direntry(sb, sde, dafs_ze, dzt_ei, sub_id);
    22b0:	48 89 da             	mov    %rbx,%rdx
    22b3:	4c 89 f1             	mov    %r14,%rcx
    22b6:	4c 89 ef             	mov    %r13,%rdi
    22b9:	4c 89 55 b8          	mov    %r10,-0x48(%rbp)
            return -EINVAL;
        }
        head = &old_dir->sub_file;
        list_for_each_safe(this, next, head) {
            tem_sf = list_entry(this, struct file_p, list);
            sub_id = tem_sf->pos;
    22bd:	49 89 f0             	mov    %rsi,%r8
            sde= &dafs_ze->dentry[sub_id];
    22c0:	48 81 c6 81 00 00 00 	add    $0x81,%rsi
    22c7:	48 c1 e6 07          	shl    $0x7,%rsi
    22cb:	48 01 de             	add    %rbx,%rsi
            //nova_dbg("%s start to delete de %s",__func__, sde->name);
            ret = __remove_direntry(sb, sde, dafs_ze, dzt_ei, sub_id);
    22ce:	e8 4d fc ff ff       	callq  1f20 <__remove_direntry>
        if(!old_dir){
            //nova_dbg("%s not find dir_info",__func__);
            return -EINVAL;
        }
        head = &old_dir->sub_file;
        list_for_each_safe(this, next, head) {
    22d3:	4c 8b 55 b8          	mov    -0x48(%rbp),%r10
    22d7:	4c 39 55 b0          	cmp    %r10,-0x50(%rbp)
    22db:	49 8b 12             	mov    (%r10),%rdx
    22de:	4c 89 d0             	mov    %r10,%rax
    22e1:	75 c7                	jne    22aa <__remove_direntry+0x38a>
        }

        /*delete dir itself*/
        bitpos = de_pos * 2;
        
        make_zone_ptr(&z_p, dafs_ze);
    22e3:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
    22e7:	48 89 de             	mov    %rbx,%rsi
            //old_dir->sub_num--;
            //kfree(tem_sf);
        }

        /*delete dir itself*/
        bitpos = de_pos * 2;
    22ea:	45 01 ff             	add    %r15d,%r15d
        
        make_zone_ptr(&z_p, dafs_ze);
    22ed:	e8 00 00 00 00       	callq  22f2 <__remove_direntry+0x3d2>
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    22f2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    22f6:	49 63 d7             	movslq %r15d,%rdx
    22f9:	48 8b 00             	mov    (%rax),%rax
    22fc:	f0 48 0f b3 10       	lock btr %rdx,(%rax)
    2301:	72 00                	jb     2303 <__remove_direntry+0x3e3>
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    2303:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    2307:	45 8d 4f 01          	lea    0x1(%r15),%r9d
    230b:	4d 63 c9             	movslq %r9d,%r9
    230e:	48 8b 00             	mov    (%rax),%rax
    2311:	f0 4c 0f b3 08       	lock btr %r9,(%rax)
    2316:	72 00                	jb     2318 <__remove_direntry+0x3f8>
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn, 1);
    2318:	49 8b 76 18          	mov    0x18(%r14),%rsi
    231c:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
    2320:	b9 01 00 00 00       	mov    $0x1,%ecx
    2325:	4c 89 ef             	mov    %r13,%rdi
    2328:	e8 00 00 00 00       	callq  232d <__remove_direntry+0x40d>
        delete_ext(z_p, dafs_de);
    232d:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
        
        make_zone_ptr(&z_p, dafs_ze);
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
        ret = make_invalid_htable(sb, dzt_ei->ht_head, d_hn, 1);
    2331:	89 c3                	mov    %eax,%ebx
        delete_ext(z_p, dafs_de);
    2333:	4c 89 e6             	mov    %r12,%rsi
    2336:	e8 00 00 00 00       	callq  233b <__remove_direntry+0x41b>

        if(!ret)
    233b:	85 db                	test   %ebx,%ebx
    233d:	74 25                	je     2364 <__remove_direntry+0x444>
            return -EINVAL;
        
        /*free dir_info_entry*/
        old_dir = radix_tree_lookup(&dzt_ei->dir_tree, d_hn);
    233f:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    2343:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    2347:	e8 00 00 00 00       	callq  234c <__remove_direntry+0x42c>
        kfree(old_dir);
    234c:	48 89 c7             	mov    %rax,%rdi
    234f:	e8 00 00 00 00       	callq  2354 <__remove_direntry+0x434>

        if(!ret)
            return -EINVAL;
    
        kfree(z_p);
    2354:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    2358:	e8 00 00 00 00       	callq  235d <__remove_direntry+0x43d>
        /*delete in par de*/

        kfree(z_p);
    }
    //nova_dbg("%s end",__func__);
    return 0;
    235d:	31 c0                	xor    %eax,%eax
    235f:	e9 de fc ff ff       	jmpq   2042 <__remove_direntry+0x122>
        delete_ext(z_p, dafs_de);
        /*free dir_entry*/
        delete_dir_info(dzt_ei, d_hn);
        
        if(!ret)
            return -EINVAL;
    2364:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    2369:	e9 d4 fc ff ff       	jmpq   2042 <__remove_direntry+0x122>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    236e:	45 31 c0             	xor    %r8d,%r8d
    2371:	e9 04 fe ff ff       	jmpq   217a <__remove_direntry+0x25a>

        kfree(z_p);
    }
    //nova_dbg("%s end",__func__);
    return 0;
}
    2376:	e8 00 00 00 00       	callq  237b <__remove_direntry+0x45b>
    237b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002380 <dafs_add_dentry>:
}

/*dafs add dentry in the zone
* and initialize direntry without name*/
int dafs_add_dentry( struct dentry *dentry, u64 ino, int link_change, int file_type)
{
    2380:	e8 00 00 00 00       	callq  2385 <dafs_add_dentry+0x5>
    2385:	55                   	push   %rbp
    2386:	49 89 f1             	mov    %rsi,%r9
    2389:	41 89 d0             	mov    %edx,%r8d
    238c:	41 89 ca             	mov    %ecx,%r10d
    238f:	48 89 e5             	mov    %rsp,%rbp
    2392:	41 57                	push   %r15
    2394:	41 56                	push   %r14
    2396:	41 55                	push   %r13
    2398:	41 54                	push   %r12
    239a:	53                   	push   %rbx
    239b:	48 89 fb             	mov    %rdi,%rbx
    239e:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
    struct nova_inode *pidir;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    unsigned short  namelen = dentry->d_name.len;
    23a5:	44 8b 7f 24          	mov    0x24(%rdi),%r15d
}

/*dafs add dentry in the zone
* and initialize direntry without name*/
int dafs_add_dentry( struct dentry *dentry, u64 ino, int link_change, int file_type)
{
    23a9:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    23b0:	00 00 
    23b2:	48 89 84 24 88 00 00 	mov    %rax,0x88(%rsp)
    23b9:	00 
    23ba:	31 c0                	xor    %eax,%eax
    struct inode *dir = dentry->d_parent->d_inode;
    23bc:	48 8b 47 18          	mov    0x18(%rdi),%rax
    23c0:	4c 8b 68 30          	mov    0x30(%rax),%r13
    
	/*nova_dbg_verbose("%s: dir %lu new inode %llu\n",
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
    23c4:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 23ca <dafs_add_dentry+0x4a>
/*dafs add dentry in the zone
* and initialize direntry without name*/
int dafs_add_dentry( struct dentry *dentry, u64 ino, int link_change, int file_type)
{
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
    23ca:	4d 8b 65 28          	mov    0x28(%r13),%r12
    
	/*nova_dbg_verbose("%s: dir %lu new inode %llu\n",
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
    23ce:	85 c0                	test   %eax,%eax
    23d0:	4d 8b b4 24 b0 03 00 	mov    0x3b0(%r12),%r14
    23d7:	00 
    23d8:	75 30                	jne    240a <dafs_add_dentry+0x8a>
	if (namelen == 0)
    23da:	66 45 85 ff          	test   %r15w,%r15w
    23de:	75 57                	jne    2437 <dafs_add_dentry+0xb7>
		return -EINVAL;
    23e0:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    //kfree(phn);
    kfree(zone_p);
    //nova_dbg("%s: finish, ino %llu, parent name %s",
    //     __func__, dafs_de->ino, dentry->d_parent->d_name.name);
    return ret;
}
    23e5:	48 8b b4 24 88 00 00 	mov    0x88(%rsp),%rsi
    23ec:	00 
    23ed:	65 48 33 34 25 28 00 	xor    %gs:0x28,%rsi
    23f4:	00 00 
    23f6:	75 3a                	jne    2432 <dafs_add_dentry+0xb2>
    23f8:	48 81 c4 90 00 00 00 	add    $0x90,%rsp
    23ff:	5b                   	pop    %rbx
    2400:	41 5c                	pop    %r12
    2402:	41 5d                	pop    %r13
    2404:	41 5e                	pop    %r14
    2406:	41 5f                	pop    %r15
    2408:	5d                   	pop    %rbp
    2409:	c3                   	retq   
    240a:	48 8d 7c 24 68       	lea    0x68(%rsp),%rdi
    240f:	89 4c 24 40          	mov    %ecx,0x40(%rsp)
    2413:	89 54 24 48          	mov    %edx,0x48(%rsp)
    2417:	48 89 74 24 50       	mov    %rsi,0x50(%rsp)
    241c:	e8 00 00 00 00       	callq  2421 <dafs_add_dentry+0xa1>
    2421:	44 8b 54 24 40       	mov    0x40(%rsp),%r10d
    2426:	44 8b 44 24 48       	mov    0x48(%rsp),%r8d
    242b:	4c 8b 4c 24 50       	mov    0x50(%rsp),%r9
    2430:	eb a8                	jmp    23da <dafs_add_dentry+0x5a>
    2432:	e8 00 00 00 00       	callq  2437 <dafs_add_dentry+0xb7>

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
	if (namelen == 0)
		return -EINVAL;
   // nova_dbg("%s:dafs start to add dentry",__func__);
    ph = get_dentry_path(dentry,0);
    2437:	48 89 df             	mov    %rbx,%rdi
    243a:	44 89 54 24 10       	mov    %r10d,0x10(%rsp)
    243f:	44 89 44 24 14       	mov    %r8d,0x14(%rsp)
    2444:	4c 89 4c 24 18       	mov    %r9,0x18(%rsp)
    2449:	e8 42 dc ff ff       	callq  90 <get_dentry_path.isra.4>
    nova_dbg("%s full name is %s",__func__,ph);
    244e:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    2455:	48 89 c2             	mov    %rax,%rdx
    2458:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    245f:	e8 00 00 00 00       	callq  2464 <dafs_add_dentry+0xe4>
    ph = sbi->ph_f;
    2464:	49 8d be d8 01 00 00 	lea    0x1d8(%r14),%rdi

    nova_dbg("%s full name is %s",__func__,ph);
    246b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
	if (namelen == 0)
		return -EINVAL;
   // nova_dbg("%s:dafs start to add dentry",__func__);
    ph = get_dentry_path(dentry,0);
    nova_dbg("%s full name is %s",__func__,ph);
    ph = sbi->ph_f;
    2472:	49 89 ff             	mov    %rdi,%r15

    nova_dbg("%s full name is %s",__func__,ph);
    2475:	48 89 fa             	mov    %rdi,%rdx
    2478:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    247f:	e8 00 00 00 00       	callq  2484 <dafs_add_dentry+0x104>
    flen = strlen(ph);
    2484:	31 c0                	xor    %eax,%eax
    2486:	4c 89 7c 24 30       	mov    %r15,0x30(%rsp)
    248b:	4c 89 ff             	mov    %r15,%rdi
    248e:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    phn = &sbi->ph_dzt;
    phn [0]='\0';
    //phname = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);

    dzt_ei = find_dzt(sb, ph, phn);
    2492:	4c 89 fe             	mov    %r15,%rsi
    ph = get_dentry_path(dentry,0);
    nova_dbg("%s full name is %s",__func__,ph);
    ph = sbi->ph_f;

    nova_dbg("%s full name is %s",__func__,ph);
    flen = strlen(ph);
    2495:	f2 ae                	repnz scas %es:(%rdi),%al
    phn = &sbi->ph_dzt;
    phn [0]='\0';
    //phname = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);

    dzt_ei = find_dzt(sb, ph, phn);
    2497:	4c 89 e7             	mov    %r12,%rdi
    ph = sbi->ph_f;

    nova_dbg("%s full name is %s",__func__,ph);
    flen = strlen(ph);
    phname = &sbi->ph_name;
    phname[0]='\0';
    249a:	41 c6 86 d6 09 00 00 	movb   $0x0,0x9d6(%r14)
    24a1:	00 
    phn = &sbi->ph_dzt;
    phn [0]='\0';
    24a2:	41 c6 86 d7 05 00 00 	movb   $0x0,0x5d7(%r14)
    24a9:	00 
    ph = get_dentry_path(dentry,0);
    nova_dbg("%s full name is %s",__func__,ph);
    ph = sbi->ph_f;

    nova_dbg("%s full name is %s",__func__,ph);
    flen = strlen(ph);
    24aa:	48 f7 d1             	not    %rcx
    24ad:	48 8d 41 ff          	lea    -0x1(%rcx),%rax
    24b1:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
    24b6:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    phname = &sbi->ph_name;
    24bb:	49 8d 86 d6 09 00 00 	lea    0x9d6(%r14),%rax
    24c2:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
    phname[0]='\0';
    phn = &sbi->ph_dzt;
    24c7:	49 8d 86 d7 05 00 00 	lea    0x5d7(%r14),%rax
    phn [0]='\0';
    //phname = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);

    dzt_ei = find_dzt(sb, ph, phn);
    24ce:	48 89 c2             	mov    %rax,%rdx

    nova_dbg("%s full name is %s",__func__,ph);
    flen = strlen(ph);
    phname = &sbi->ph_name;
    phname[0]='\0';
    phn = &sbi->ph_dzt;
    24d1:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    phn [0]='\0';
    //phname = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);

    dzt_ei = find_dzt(sb, ph, phn);
    24d6:	e8 25 db ff ff       	callq  0 <find_dzt>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    24db:	49 8b 94 24 b0 03 00 	mov    0x3b0(%r12),%rdx
    24e2:	00 
    24e3:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb,dzt_ei->dz_addr);
    make_zone_ptr(&zone_p, dafs_ze);
    24e8:	48 8d 7c 24 60       	lea    0x60(%rsp),%rdi
    phn [0]='\0';
    //phname = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);

    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb,dzt_ei->dz_addr);
    24ed:	48 8b 40 10          	mov    0x10(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    24f1:	48 89 c1             	mov    %rax,%rcx
    24f4:	48 03 4a 18          	add    0x18(%rdx),%rcx
    24f8:	48 85 c0             	test   %rax,%rax
    24fb:	b8 00 00 00 00       	mov    $0x0,%eax
    2500:	48 0f 45 c1          	cmovne %rcx,%rax
    char *phname, *ph, *phn;
    //char *phf;
    char *tem;
    unsigned long phlen, temlen, flen, tm_len;
    unsigned short links_count;
    u32 bitpos = 0, cur_pos = 0, par_pos, tem_pos;
    2504:	45 31 ff             	xor    %r15d,%r15d
    //phname = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);

    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb,dzt_ei->dz_addr);
    make_zone_ptr(&zone_p, dafs_ze);
    2507:	48 89 c6             	mov    %rax,%rsi
    250a:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
    250f:	e8 00 00 00 00       	callq  2514 <dafs_add_dentry+0x194>
    2514:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
    char *phname, *ph, *phn;
    //char *phf;
    char *tem;
    unsigned long phlen, temlen, flen, tm_len;
    unsigned short links_count;
    u32 bitpos = 0, cur_pos = 0, par_pos, tem_pos;
    2519:	45 31 db             	xor    %r11d,%r11d
    251c:	4c 8b 4c 24 18       	mov    0x18(%rsp),%r9
    2521:	44 8b 44 24 14       	mov    0x14(%rsp),%r8d
    2526:	44 8b 54 24 10       	mov    0x10(%rsp),%r10d
    252b:	48 8b 08             	mov    (%rax),%rcx
    //phname = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);

    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb,dzt_ei->dz_addr);
    make_zone_ptr(&zone_p, dafs_ze);
    252e:	31 c0                	xor    %eax,%eax
    2530:	eb 19                	jmp    254b <dafs_add_dentry+0x1cb>
    //nova_dbg("%s zone beginning",__func__);
    //tes_empty_zone(sb, zone_p);
    while(cur_pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
            bitpos+=2;
    2532:	41 83 c3 02          	add    $0x2,%r11d
            cur_pos++;
    2536:	41 83 c7 01          	add    $0x1,%r15d
    253a:	48 83 c0 02          	add    $0x2,%rax
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb,dzt_ei->dz_addr);
    make_zone_ptr(&zone_p, dafs_ze);
    //nova_dbg("%s zone beginning",__func__);
    //tes_empty_zone(sb, zone_p);
    while(cur_pos<NR_DENTRY_IN_ZONE){
    253e:	41 81 fb fe ff 01 00 	cmp    $0x1fffe,%r11d
    2545:	0f 84 83 05 00 00    	je     2ace <dafs_add_dentry+0x74e>

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    254b:	48 0f a3 01          	bt     %rax,(%rcx)
    254f:	19 d2                	sbb    %edx,%edx
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
    2551:	85 d2                	test   %edx,%edx
    2553:	75 dd                	jne    2532 <dafs_add_dentry+0x1b2>
    2555:	48 8d 50 01          	lea    0x1(%rax),%rdx
    2559:	48 0f a3 11          	bt     %rdx,(%rcx)
    255d:	19 d2                	sbb    %edx,%edx
    255f:	85 d2                	test   %edx,%edx
    2561:	75 cf                	jne    2532 <dafs_add_dentry+0x1b2>
    if(cur_pos==NR_DENTRY_IN_ZONE){
        BUG();
        dafs_split_zone(sb, NULL, 0, NEGTIVE_SPLIT);
    }*/

    phlen = strlen(phn); 
    2563:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
    2568:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
    256c:	31 c0                	xor    %eax,%eax
    256e:	48 89 f1             	mov    %rsi,%rcx
    2571:	f2 ae                	repnz scas %es:(%rdi),%al
    2573:	48 f7 d1             	not    %rcx
    2576:	48 89 ca             	mov    %rcx,%rdx
    2579:	48 01 f2             	add    %rsi,%rdx
    if(phlen==1){
    257c:	48 83 fa 01          	cmp    $0x1,%rdx
    2580:	0f 84 f9 04 00 00    	je     2a7f <dafs_add_dentry+0x6ff>
        //flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    2586:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
    258b:	44 89 54 24 14       	mov    %r10d,0x14(%rsp)
    2590:	48 89 f1             	mov    %rsi,%rcx
    2593:	44 89 44 24 18       	mov    %r8d,0x18(%rsp)
    2598:	4c 89 4c 24 20       	mov    %r9,0x20(%rsp)
    259d:	44 89 5c 24 28       	mov    %r11d,0x28(%rsp)
    25a2:	f2 ae                	repnz scas %es:(%rdi),%al
        memcpy(phname, ph+phlen, flen);
    25a4:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
    if(phlen==1){
        //flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    25a9:	48 89 c8             	mov    %rcx,%rax
    25ac:	48 f7 d0             	not    %rax
        memcpy(phname, ph+phlen, flen);
    25af:	48 01 d7             	add    %rdx,%rdi
    if(phlen==1){
        //flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    25b2:	48 83 e8 01          	sub    $0x1,%rax
        memcpy(phname, ph+phlen, flen);
    25b6:	48 89 fe             	mov    %rdi,%rsi
    25b9:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
    if(phlen==1){
        //flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    25be:	48 29 d0             	sub    %rdx,%rax
        memcpy(phname, ph+phlen, flen);
    25c1:	48 89 c2             	mov    %rax,%rdx
    25c4:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    25c9:	e8 00 00 00 00       	callq  25ce <dafs_add_dentry+0x24e>
        phname[flen]='\0';
    25ce:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    25d3:	44 8b 54 24 14       	mov    0x14(%rsp),%r10d
    25d8:	44 8b 44 24 18       	mov    0x18(%rsp),%r8d
    25dd:	4c 8b 4c 24 20       	mov    0x20(%rsp),%r9
    25e2:	44 8b 5c 24 28       	mov    0x28(%rsp),%r11d
    25e7:	41 c6 84 06 d6 09 00 	movb   $0x0,0x9d6(%r14,%rax,1)
    25ee:	00 00 
    }

    nova_dbg("%s phname %s",__func__, phname);
    25f0:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
    25f5:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    25fc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2603:	44 89 54 24 10       	mov    %r10d,0x10(%rsp)
    2608:	44 89 44 24 14       	mov    %r8d,0x14(%rsp)
    260d:	41 be 00 00 00 00    	mov    $0x0,%r14d
    2613:	4c 89 4c 24 18       	mov    %r9,0x18(%rsp)
    2618:	44 89 5c 24 20       	mov    %r11d,0x20(%rsp)
    261d:	e8 00 00 00 00       	callq  2622 <dafs_add_dentry+0x2a2>
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
    2622:	49 8b 55 c8          	mov    -0x38(%r13),%rdx
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    2626:	49 8b 84 24 b0 03 00 	mov    0x3b0(%r12),%rax
    262d:	00 
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    262e:	48 89 d1             	mov    %rdx,%rcx
    2631:	48 03 48 18          	add    0x18(%rax),%rcx
    2635:	48 85 d2             	test   %rdx,%rdx
    2638:	4c 0f 45 f1          	cmovne %rcx,%r14
    pidir = nova_get_inode(sb, dir);
    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    263c:	e8 00 00 00 00       	callq  2641 <dafs_add_dentry+0x2c1>
    2641:	49 c7 85 80 00 00 00 	movq   $0x0,0x80(%r13)
    2648:	00 00 00 00 
    264c:	49 89 45 78          	mov    %rax,0x78(%r13)
    2650:	49 8b 95 80 00 00 00 	mov    0x80(%r13),%rdx
    2657:	49 8b 45 78          	mov    0x78(%r13),%rax
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = dentry->d_name.len;
    //dafs_de->file_type = NORMAL_DIRECTORY;       

    links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
    265b:	44 8b 5c 24 20       	mov    0x20(%rsp),%r11d
    2660:	4c 8b 4c 24 18       	mov    0x18(%rsp),%r9
    2665:	44 8b 44 24 14       	mov    0x14(%rsp),%r8d
    266a:	44 8b 54 24 10       	mov    0x10(%rsp),%r10d
        phname[flen]='\0';
    }

    nova_dbg("%s phname %s",__func__, phname);
    pidir = nova_get_inode(sb, dir);
    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    266f:	49 89 55 70          	mov    %rdx,0x70(%r13)
    2673:	49 89 45 68          	mov    %rax,0x68(%r13)
    dir->i_blocks = pidir->i_blocks;
    2677:	49 8b 46 20          	mov    0x20(%r14),%rax

    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    267b:	48 8b 54 24 50       	mov    0x50(%rsp),%rdx
    }

    nova_dbg("%s phname %s",__func__, phname);
    pidir = nova_get_inode(sb, dir);
    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    dir->i_blocks = pidir->i_blocks;
    2680:	49 89 85 98 00 00 00 	mov    %rax,0x98(%r13)

    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    2687:	44 89 f8             	mov    %r15d,%eax
    268a:	48 89 c1             	mov    %rax,%rcx
    268d:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    2692:	48 05 81 00 00 00    	add    $0x81,%rax
    2698:	48 c1 e0 07          	shl    $0x7,%rax
    269c:	48 01 d0             	add    %rdx,%rax
    269f:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    26a4:	48 89 c8             	mov    %rcx,%rax
    26a7:	48 c1 e0 07          	shl    $0x7,%rax
    26ab:	49 89 c6             	mov    %rax,%r14
    26ae:	49 01 d6             	add    %rdx,%r14
    tem_pos = cur_pos;
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    26b1:	41 c6 86 80 40 00 00 	movb   $0x6,0x4080(%r14)
    26b8:	06 
    dafs_de->name_len = dentry->d_name.len;
    26b9:	8b 43 24             	mov    0x24(%rbx),%eax
    26bc:	41 88 86 81 40 00 00 	mov    %al,0x4081(%r14)
    //dafs_de->file_type = NORMAL_DIRECTORY;       

    links_count = cpu_to_le16(dir->i_nlink);
    26c3:	41 8b 55 48          	mov    0x48(%r13),%edx
	if (links_count == 0 && link_change == -1)
    26c7:	66 85 d2             	test   %dx,%dx
    26ca:	0f 85 2f 03 00 00    	jne    29ff <dafs_add_dentry+0x67f>
		links_count = 0;
    26d0:	31 c0                	xor    %eax,%eax
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = dentry->d_name.len;
    //dafs_de->file_type = NORMAL_DIRECTORY;       

    links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
    26d2:	41 83 f8 ff          	cmp    $0xffffffff,%r8d
    26d6:	0f 85 23 03 00 00    	jne    29ff <dafs_add_dentry+0x67f>
		links_count = 0;
	else
		links_count += link_change;
	dafs_de->links_count = cpu_to_le16(links_count);
    26dc:	66 41 89 86 86 40 00 	mov    %ax,0x4086(%r14)
    26e3:	00 
    dafs_de->mtime = cpu_to_le32(dir->i_mtime.tv_sec);
    26e4:	49 8b 45 68          	mov    0x68(%r13),%rax
    26e8:	41 89 86 88 40 00 00 	mov    %eax,0x4088(%r14)
    dafs_de->ino = cpu_to_le64(ino);
    26ef:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    26f4:	48 c1 e0 07          	shl    $0x7,%rax
    26f8:	48 03 44 24 50       	add    0x50(%rsp),%rax
    26fd:	4c 89 88 98 40 00 00 	mov    %r9,0x4098(%rax)
    dafs_de->size = cpu_to_le64(dir->i_size);
    2704:	49 8b 55 50          	mov    0x50(%r13),%rdx
    2708:	48 89 90 a0 40 00 00 	mov    %rdx,0x40a0(%rax)

    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    270f:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
	__clear_bit(nr ^ BITOP_LE_SWIZZLE, addr);
}

static inline int test_and_set_bit_le(int nr, void *addr)
{
	return test_and_set_bit(nr ^ BITOP_LE_SWIZZLE, addr);
    2714:	41 8d 53 01          	lea    0x1(%r11),%edx
    2718:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    271b:	f0 48 0f ab 10       	lock bts %rdx,(%rax)
    2720:	72 00                	jb     2722 <dafs_add_dentry+0x3a2>
    /*judge name len && set dentry name*/
    if(dentry->d_name.len <= SMALL_NAME_LEN){
    2722:	83 7b 24 27          	cmpl   $0x27,0x24(%rbx)
    2726:	44 89 54 24 20       	mov    %r10d,0x20(%rsp)
    272b:	0f 87 8c 02 00 00    	ja     29bd <dafs_add_dentry+0x63d>
        //nova_dbg("dentry not need extension");
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
    2731:	4c 8b 6c 24 30       	mov    0x30(%rsp),%r13
    2736:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    /*judge name len && set dentry name*/
    if(dentry->d_name.len <= SMALL_NAME_LEN){
        //nova_dbg("dentry not need extension");
        dafs_de->ext_flag = 0;
    273b:	66 41 c7 86 84 40 00 	movw   $0x0,0x4084(%r14)
    2742:	00 00 00 
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
    2745:	8b 53 24             	mov    0x24(%rbx),%edx
    2748:	48 8b 73 28          	mov    0x28(%rbx),%rsi
    274c:	49 c1 e5 07          	shl    $0x7,%r13
    2750:	4a 8d bc 28 b0 40 00 	lea    0x40b0(%rax,%r13,1),%rdi
    2757:	00 
    2758:	e8 00 00 00 00       	callq  275d <dafs_add_dentry+0x3dd>
        //nova_dbg("dentry name is %s", dafs_de->name);
        dafs_de->name[dentry->d_name.len] = '\0'; 
    275d:	8b 43 24             	mov    0x24(%rbx),%eax
    2760:	4c 03 6c 24 50       	add    0x50(%rsp),%r13
    2765:	44 8b 54 24 20       	mov    0x20(%rsp),%r10d
    276a:	42 c6 84 28 b0 40 00 	movb   $0x0,0x40b0(%rax,%r13,1)
    2771:	00 00 
        //nova_dbg("%s dentry need extend name entry",__func__);
        dafs_de->ext_flag = 1;
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, dentry->d_name.len, dentry->d_name.name, 0);
    }

    dafs_de->fname_len = cpu_to_le64(flen);
    2773:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    2778:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
    277d:	4c 8b 6c 24 48       	mov    0x48(%rsp),%r13
    2782:	48 c1 e0 07          	shl    $0x7,%rax
    2786:	48 89 f9             	mov    %rdi,%rcx
    2789:	48 01 c1             	add    %rax,%rcx
    278c:	4c 89 a9 90 40 00 00 	mov    %r13,0x4090(%rcx)
    /*set fulname
    * use temlen to find par de*/
    temlen = flen - dentry->d_name.len;
    2793:	8b 53 24             	mov    0x24(%rbx),%edx
    2796:	4c 89 eb             	mov    %r13,%rbx
        //nova_dbg("%s dentry need extend name entry",__func__);
        dafs_de->ext_flag = 1;
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, dentry->d_name.len, dentry->d_name.name, 0);
    }

    dafs_de->fname_len = cpu_to_le64(flen);
    2799:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
    /*set fulname
    * use temlen to find par de*/
    temlen = flen - dentry->d_name.len;
    279e:	49 29 d5             	sub    %rdx,%r13
    tm_len = temlen;
    if(temlen ==1){
    27a1:	49 83 fd 01          	cmp    $0x1,%r13
    27a5:	0f 85 6c 03 00 00    	jne    2b17 <dafs_add_dentry+0x797>
        dafs_de->isr_sf = 1;
        //nova_dbg("dentry is root subfile");
        par_pos =0;
        if(dafs_de->ext_flag==0){
    27ab:	66 41 83 be 84 40 00 	cmpw   $0x0,0x4084(%r14)
    27b2:	00 00 
    /*set fulname
    * use temlen to find par de*/
    temlen = flen - dentry->d_name.len;
    tm_len = temlen;
    if(temlen ==1){
        dafs_de->isr_sf = 1;
    27b4:	41 c6 86 83 40 00 00 	movb   $0x1,0x4083(%r14)
    27bb:	01 
        //nova_dbg("dentry is root subfile");
        par_pos =0;
    27bc:	c7 44 24 5c 00 00 00 	movl   $0x0,0x5c(%rsp)
    27c3:	00 
    27c4:	44 89 54 24 20       	mov    %r10d,0x20(%rsp)
        if(dafs_de->ext_flag==0){
    27c9:	0f 85 0e 03 00 00    	jne    2add <dafs_add_dentry+0x75d>
            //re_len = SMALL_NAME_LEN - dentry->d_name.len;
            if(flen<SMALL_NAME_LEN){
    27cf:	48 83 fb 26          	cmp    $0x26,%rbx
    27d3:	48 89 da             	mov    %rbx,%rdx
    27d6:	0f 87 ff 02 00 00    	ja     2adb <dafs_add_dentry+0x75b>
                memcpy(dafs_de->ful_name.f_name, phname, flen);
    27dc:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
    27e1:	48 8d bc 07 d8 40 00 	lea    0x40d8(%rdi,%rax,1),%rdi
    27e8:	00 
    27e9:	e8 00 00 00 00       	callq  27ee <dafs_add_dentry+0x46e>
                dafs_de->ful_name.f_name[flen]= '\0';
    27ee:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    27f3:	44 8b 54 24 20       	mov    0x20(%rsp),%r10d
    27f8:	c6 84 0b d8 40 00 00 	movb   $0x0,0x40d8(%rbx,%rcx,1)
    27ff:	00 
                ext_de_name(sb ,dzt_ei, dafs_ze, zone_p, tem_pos, flen, phname, 1);
            }
        } else{
            ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos,flen, phname, 1);
        }
        dafs_de->par_pos = cpu_to_le32(par_pos);
    2800:	8b 44 24 5c          	mov    0x5c(%rsp),%eax
    2804:	41 89 86 8c 40 00 00 	mov    %eax,0x408c(%r14)
    /*debug*/
    par_de = &dafs_ze->dentry[par_pos];
    //nova_dbg("%s par name %s",__func__,tem);
    //BUG_ON(le64_to_cpu(par_de->ino)!=dir->i_ino);
 
    hashname = BKDRHash(phname, flen);
    280b:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    2810:	85 c0                	test   %eax,%eax
    2812:	89 c1                	mov    %eax,%ecx
    2814:	0f 8e ee 01 00 00    	jle    2a08 <dafs_add_dentry+0x688>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    281a:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
    281f:	31 c0                	xor    %eax,%eax
    2821:	31 db                	xor    %ebx,%ebx
	int i;

	for (i = 0; i < length; i++) {
		hash = hash * seed + (*str++);
    2823:	48 89 da             	mov    %rbx,%rdx
    2826:	48 c1 e2 05          	shl    $0x5,%rdx
    282a:	48 29 da             	sub    %rbx,%rdx
    282d:	48 89 d3             	mov    %rdx,%rbx
    2830:	48 0f be 14 06       	movsbq (%rsi,%rax,1),%rdx
    2835:	48 83 c0 01          	add    $0x1,%rax
    2839:	48 01 d3             	add    %rdx,%rbx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    283c:	39 c1                	cmp    %eax,%ecx
    283e:	7f e3                	jg     2823 <dafs_add_dentry+0x4a3>
    ht_addr = dzt_ei->ht_head;
    ret = record_pos_htable(sb, ht_addr, hashname, tem_pos, 1);
    2840:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    2845:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    284b:	44 89 f9             	mov    %r15d,%ecx
    284e:	48 89 da             	mov    %rbx,%rdx
    2851:	4c 89 e7             	mov    %r12,%rdi
    2854:	44 89 54 24 20       	mov    %r10d,0x20(%rsp)
    2859:	48 8b 70 18          	mov    0x18(%rax),%rsi
    285d:	e8 00 00 00 00       	callq  2862 <dafs_add_dentry+0x4e2>
    nova_dbg("%s hash value is %llu, name is %s",__func__,hashname, phname);
    2862:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
    2867:	48 89 da             	mov    %rbx,%rdx
    286a:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    2871:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    //nova_dbg("%s par name %s",__func__,tem);
    //BUG_ON(le64_to_cpu(par_de->ino)!=dir->i_ino);
 
    hashname = BKDRHash(phname, flen);
    ht_addr = dzt_ei->ht_head;
    ret = record_pos_htable(sb, ht_addr, hashname, tem_pos, 1);
    2878:	89 44 24 48          	mov    %eax,0x48(%rsp)
    nova_dbg("%s hash value is %llu, name is %s",__func__,hashname, phname);
    287c:	e8 00 00 00 00       	callq  2881 <dafs_add_dentry+0x501>
    if(tm_len>1 || dzt_ei->dzt_eno==0){
    2881:	49 83 fd 01          	cmp    $0x1,%r13
    2885:	44 8b 54 24 20       	mov    0x20(%rsp),%r10d
    288a:	0f 86 be 01 00 00    	jbe    2a4e <dafs_add_dentry+0x6ce>
        if(par_pos==0){
    2890:	8b 44 24 5c          	mov    0x5c(%rsp),%eax
		hash = hash * seed + (*str++);
    2894:	be 2f 00 00 00       	mov    $0x2f,%esi
    2899:	85 c0                	test   %eax,%eax
    289b:	74 11                	je     28ae <dafs_add_dentry+0x52e>
            par_hn = BKDRHash("/",1);
        } else {
            par_de = &dafs_ze->dentry[par_pos];
            par_hn = le64_to_cpu(par_de->hname);
    289d:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
    28a2:	48 c1 e0 07          	shl    $0x7,%rax
    28a6:	48 8b b4 01 a8 40 00 	mov    0x40a8(%rcx,%rax,1),%rsi
    28ad:	00 
        }
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    28ae:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    28b3:	44 89 54 24 40       	mov    %r10d,0x40(%rsp)
    28b8:	48 8d 78 38          	lea    0x38(%rax),%rdi
    28bc:	e8 00 00 00 00       	callq  28c1 <dafs_add_dentry+0x541>
        if(!par_dir){
    28c1:	48 85 c0             	test   %rax,%rax
            par_hn = BKDRHash("/",1);
        } else {
            par_de = &dafs_ze->dentry[par_pos];
            par_hn = le64_to_cpu(par_de->hname);
        }
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    28c4:	49 89 c4             	mov    %rax,%r12
        if(!par_dir){
    28c7:	44 8b 54 24 40       	mov    0x40(%rsp),%r10d
    28cc:	0f 84 07 02 00 00    	je     2ad9 <dafs_add_dentry+0x759>
            BUG();
            goto OUT;

        }
        par_dir->sub_num++;
    28d2:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
    28d7:	bf 14 00 00 00       	mov    $0x14,%edi
    28dc:	44 89 54 24 40       	mov    %r10d,0x40(%rsp)
        tem_sf->pos = tem_pos;
        list_add_tail(&tem_sf->list, &par_dir->sub_file);
    28e1:	49 83 c4 18          	add    $0x18,%r12
            BUG();
            goto OUT;

        }
        par_dir->sub_num++;
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
    28e5:	e8 e6 d9 ff ff       	callq  2d0 <kzalloc.constprop.8>
        tem_sf->pos = tem_pos;
    28ea:	44 89 78 10          	mov    %r15d,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    28ee:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
	prev->next = new;
    28f3:	44 8b 54 24 40       	mov    0x40(%rsp),%r10d
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    28f8:	49 89 44 24 08       	mov    %rax,0x8(%r12)
        list_add_tail(&tem_sf->list, &par_dir->sub_file);
    28fd:	4c 89 20             	mov    %r12,(%rax)
	new->next = next;
	new->prev = prev;
    2900:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    2904:	48 89 02             	mov    %rax,(%rdx)
    }

    dafs_de->hname = cpu_to_le64(hashname);
    2907:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    290c:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
    2911:	48 c1 e0 07          	shl    $0x7,%rax
    /*add dir info if dentry is dir*/
    if(file_type==1){
    2915:	41 83 ea 01          	sub    $0x1,%r10d
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = tem_pos;
        list_add_tail(&tem_sf->list, &par_dir->sub_file);
    }

    dafs_de->hname = cpu_to_le64(hashname);
    2919:	48 89 9c 01 a8 40 00 	mov    %rbx,0x40a8(%rcx,%rax,1)
    2920:	00 
    /*add dir info if dentry is dir*/
    if(file_type==1){
    2921:	0f 84 3b 01 00 00    	je     2a62 <dafs_add_dentry+0x6e2>
        dafs_de->file_type = NORMAL_DIRECTORY;
        add_dir_info(dzt_ei, hashname, tem_pos);
        //dafs_append_dir_init_entries(sb, tem_pos, dzt_ei, ino, dir->i_ino, phname);
    } else {
        dafs_de->file_type = NORMAL_FILE;
    2927:	41 c6 86 82 40 00 00 	movb   $0x0,0x4082(%r14)
    292e:	00 
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    292f:	8b 4c 24 28          	mov    0x28(%rsp),%ecx
	if (support_clwb) {
    2933:	31 d2                	xor    %edx,%edx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    2935:	83 e1 3f             	and    $0x3f,%ecx
    2938:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    293b:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 2942 <dafs_add_dentry+0x5c2>
    2942:	74 66                	je     29aa <dafs_add_dentry+0x62a>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    2944:	89 d0                	mov    %edx,%eax
    2946:	48 03 44 24 28       	add    0x28(%rsp),%rax
    294b:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    294f:	83 c2 40             	add    $0x40,%edx
    2952:	39 d1                	cmp    %edx,%ecx
    2954:	77 ee                	ja     2944 <dafs_add_dentry+0x5c4>
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);

    //nova_dbg("%s end",__func__);
    //tes_empty_zone(sb, zone_p);
OUT:
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    2956:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 295d <dafs_add_dentry+0x5dd>
    295d:	74 30                	je     298f <dafs_add_dentry+0x60f>
    295f:	48 8d 7c 24 78       	lea    0x78(%rsp),%rdi
    2964:	e8 00 00 00 00       	callq  2969 <dafs_add_dentry+0x5e9>
    2969:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
    296e:	48 2b 44 24 68       	sub    0x68(%rsp),%rax
    2973:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    297a:	48 2b 44 24 70       	sub    0x70(%rsp),%rax
    297f:	48 03 84 24 80 00 00 	add    0x80(%rsp),%rax
    2986:	00 
    2987:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 298f <dafs_add_dentry+0x60f>
    298e:	00 
    //kfree(phname);
    //kfree(ph);
    //kfree(phn);
    kfree(zone_p);
    298f:	48 8b 7c 24 60       	mov    0x60(%rsp),%rdi
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);

    //nova_dbg("%s end",__func__);
    //tes_empty_zone(sb, zone_p);
OUT:
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    2994:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 299c <dafs_add_dentry+0x61c>
    299b:	00 
    //kfree(phname);
    //kfree(ph);
    //kfree(phn);
    kfree(zone_p);
    299c:	e8 00 00 00 00       	callq  29a1 <dafs_add_dentry+0x621>
    //nova_dbg("%s: finish, ino %llu, parent name %s",
    //     __func__, dafs_de->ino, dentry->d_parent->d_name.name);
    return ret;
    29a1:	8b 44 24 48          	mov    0x48(%rsp),%eax
    29a5:	e9 3b fa ff ff       	jmpq   23e5 <dafs_add_dentry+0x65>
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    29aa:	89 d0                	mov    %edx,%eax
    29ac:	48 03 44 24 28       	add    0x28(%rsp),%rax
    29b1:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    29b4:	83 c2 40             	add    $0x40,%edx
    29b7:	39 d1                	cmp    %edx,%ecx
    29b9:	77 ef                	ja     29aa <dafs_add_dentry+0x62a>
    29bb:	eb 99                	jmp    2956 <dafs_add_dentry+0x5d6>
        //nova_dbg("dentry name is %s", dafs_de->name);
        dafs_de->name[dentry->d_name.len] = '\0'; 

    } else {
        //nova_dbg("%s dentry need extend name entry",__func__);
        dafs_de->ext_flag = 1;
    29bd:	66 41 c7 86 84 40 00 	movw   $0x1,0x4084(%r14)
    29c4:	00 01 00 
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, dentry->d_name.len, dentry->d_name.name, 0);
    29c7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
    29ce:	00 
    29cf:	45 89 f8             	mov    %r15d,%r8d
    29d2:	48 8b 43 28          	mov    0x28(%rbx),%rax
    29d6:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
    29db:	4c 89 e7             	mov    %r12,%rdi
    29de:	48 8b 54 24 50       	mov    0x50(%rsp),%rdx
    29e3:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
    29e8:	48 89 04 24          	mov    %rax,(%rsp)
    29ec:	44 8b 4b 24          	mov    0x24(%rbx),%r9d
    29f0:	e8 00 00 00 00       	callq  29f5 <dafs_add_dentry+0x675>
    29f5:	44 8b 54 24 20       	mov    0x20(%rsp),%r10d
    29fa:	e9 74 fd ff ff       	jmpq   2773 <dafs_add_dentry+0x3f3>

    links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
		links_count = 0;
	else
		links_count += link_change;
    29ff:	42 8d 04 02          	lea    (%rdx,%r8,1),%eax
    2a03:	e9 d4 fc ff ff       	jmpq   26dc <dafs_add_dentry+0x35c>
    //nova_dbg("%s par name %s",__func__,tem);
    //BUG_ON(le64_to_cpu(par_de->ino)!=dir->i_ino);
 
    hashname = BKDRHash(phname, flen);
    ht_addr = dzt_ei->ht_head;
    ret = record_pos_htable(sb, ht_addr, hashname, tem_pos, 1);
    2a08:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    2a0d:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    2a13:	44 89 f9             	mov    %r15d,%ecx
    2a16:	31 d2                	xor    %edx,%edx
    2a18:	4c 89 e7             	mov    %r12,%rdi
    2a1b:	44 89 54 24 20       	mov    %r10d,0x20(%rsp)
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    2a20:	31 db                	xor    %ebx,%ebx
    2a22:	48 8b 70 18          	mov    0x18(%rax),%rsi
    2a26:	e8 00 00 00 00       	callq  2a2b <dafs_add_dentry+0x6ab>
    nova_dbg("%s hash value is %llu, name is %s",__func__,hashname, phname);
    2a2b:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
    2a30:	31 d2                	xor    %edx,%edx
    2a32:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    2a39:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    //nova_dbg("%s par name %s",__func__,tem);
    //BUG_ON(le64_to_cpu(par_de->ino)!=dir->i_ino);
 
    hashname = BKDRHash(phname, flen);
    ht_addr = dzt_ei->ht_head;
    ret = record_pos_htable(sb, ht_addr, hashname, tem_pos, 1);
    2a40:	89 44 24 48          	mov    %eax,0x48(%rsp)
    nova_dbg("%s hash value is %llu, name is %s",__func__,hashname, phname);
    2a44:	e8 00 00 00 00       	callq  2a49 <dafs_add_dentry+0x6c9>
    2a49:	44 8b 54 24 20       	mov    0x20(%rsp),%r10d
    if(tm_len>1 || dzt_ei->dzt_eno==0){
    2a4e:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    2a53:	83 78 08 00          	cmpl   $0x0,0x8(%rax)
    2a57:	0f 85 aa fe ff ff    	jne    2907 <dafs_add_dentry+0x587>
    2a5d:	e9 2e fe ff ff       	jmpq   2890 <dafs_add_dentry+0x510>

    dafs_de->hname = cpu_to_le64(hashname);
    /*add dir info if dentry is dir*/
    if(file_type==1){
        dafs_de->file_type = NORMAL_DIRECTORY;
        add_dir_info(dzt_ei, hashname, tem_pos);
    2a62:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
    }

    dafs_de->hname = cpu_to_le64(hashname);
    /*add dir info if dentry is dir*/
    if(file_type==1){
        dafs_de->file_type = NORMAL_DIRECTORY;
    2a67:	41 c6 86 82 40 00 00 	movb   $0x1,0x4082(%r14)
    2a6e:	01 
        add_dir_info(dzt_ei, hashname, tem_pos);
    2a6f:	44 89 fa             	mov    %r15d,%edx
    2a72:	48 89 de             	mov    %rbx,%rsi
    2a75:	e8 00 00 00 00       	callq  2a7a <dafs_add_dentry+0x6fa>
    2a7a:	e9 b0 fe ff ff       	jmpq   292f <dafs_add_dentry+0x5af>
    }*/

    phlen = strlen(phn); 
    if(phlen==1){
        //flen = strlen(ph);
        memcpy(phname, ph, flen);
    2a7f:	4c 8b 74 24 40       	mov    0x40(%rsp),%r14
    2a84:	48 8b 54 24 48       	mov    0x48(%rsp),%rdx
    2a89:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
    2a8e:	44 89 54 24 10       	mov    %r10d,0x10(%rsp)
    2a93:	44 89 44 24 14       	mov    %r8d,0x14(%rsp)
    2a98:	4c 89 4c 24 18       	mov    %r9,0x18(%rsp)
    2a9d:	4c 89 f7             	mov    %r14,%rdi
    2aa0:	44 89 5c 24 28       	mov    %r11d,0x28(%rsp)
    2aa5:	e8 00 00 00 00       	callq  2aaa <dafs_add_dentry+0x72a>
        phname[flen]='\0';
    2aaa:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
    2aaf:	44 8b 5c 24 28       	mov    0x28(%rsp),%r11d
    2ab4:	4c 8b 4c 24 18       	mov    0x18(%rsp),%r9
    2ab9:	44 8b 44 24 14       	mov    0x14(%rsp),%r8d
    2abe:	44 8b 54 24 10       	mov    0x10(%rsp),%r10d
    2ac3:	41 c6 44 0e ff 00    	movb   $0x0,-0x1(%r14,%rcx,1)
    2ac9:	e9 22 fb ff ff       	jmpq   25f0 <dafs_add_dentry+0x270>
    2ace:	41 bf ff ff 00 00    	mov    $0xffff,%r15d
    2ad4:	e9 8a fa ff ff       	jmpq   2563 <dafs_add_dentry+0x1e3>
            par_de = &dafs_ze->dentry[par_pos];
            par_hn = le64_to_cpu(par_de->hname);
        }
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
        if(!par_dir){
            BUG();
    2ad9:	0f 0b                	ud2    
            if(flen<SMALL_NAME_LEN){
                memcpy(dafs_de->ful_name.f_name, phname, flen);
                dafs_de->ful_name.f_name[flen]= '\0';
            } else {
                //nova_dbg("%s ful name %s", __func__, phname);
                BUG();
    2adb:	0f 0b                	ud2    
                dafs_de->ext_flag = 2;
                ext_de_name(sb ,dzt_ei, dafs_ze, zone_p, tem_pos, flen, phname, 1);
            }
        } else{
            ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos,flen, phname, 1);
    2add:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
    2ae2:	44 8b 4c 24 48       	mov    0x48(%rsp),%r9d
    2ae7:	45 89 f8             	mov    %r15d,%r8d
    2aea:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
    2aef:	48 8b 54 24 50       	mov    0x50(%rsp),%rdx
    2af4:	4c 89 e7             	mov    %r12,%rdi
    2af7:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
    2afc:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    2b03:	00 
    2b04:	48 89 04 24          	mov    %rax,(%rsp)
    2b08:	e8 00 00 00 00       	callq  2b0d <dafs_add_dentry+0x78d>
    2b0d:	44 8b 54 24 20       	mov    0x20(%rsp),%r10d
    2b12:	e9 e9 fc ff ff       	jmpq   2800 <dafs_add_dentry+0x480>
        }
        dafs_de->par_pos = cpu_to_le32(par_pos);
    } else {
        /*get par de pos*/
        //nova_dbg("dentry is not root subfile");
        tem = kzalloc((temlen+1)*sizeof(char), GFP_KERNEL);
    2b17:	49 8d 7d 01          	lea    0x1(%r13),%rdi
    2b1b:	44 89 54 24 18       	mov    %r10d,0x18(%rsp)
    2b20:	e8 ab d7 ff ff       	callq  2d0 <kzalloc.constprop.8>
        temlen--;
    2b25:	49 8d 4d ff          	lea    -0x1(%r13),%rcx
        memcpy(tem, phname, temlen);
    2b29:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
    2b2e:	48 89 c7             	mov    %rax,%rdi
        }
        dafs_de->par_pos = cpu_to_le32(par_pos);
    } else {
        /*get par de pos*/
        //nova_dbg("dentry is not root subfile");
        tem = kzalloc((temlen+1)*sizeof(char), GFP_KERNEL);
    2b31:	48 89 c3             	mov    %rax,%rbx
        temlen--;
        memcpy(tem, phname, temlen);
    2b34:	48 89 ca             	mov    %rcx,%rdx
    2b37:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
    2b3c:	e8 00 00 00 00       	callq  2b41 <dafs_add_dentry+0x7c1>
    2b41:	44 8b 54 24 18       	mov    0x18(%rsp),%r10d
        tem[temlen]='\0';
        par_hn = BKDRHash(tem, temlen);
    2b46:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
    2b4b:	31 c0                	xor    %eax,%eax
        /*get par de pos*/
        //nova_dbg("dentry is not root subfile");
        tem = kzalloc((temlen+1)*sizeof(char), GFP_KERNEL);
        temlen--;
        memcpy(tem, phname, temlen);
        tem[temlen]='\0';
    2b4d:	42 c6 44 2b ff 00    	movb   $0x0,-0x1(%rbx,%r13,1)
    2b53:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
    2b5a:	00 00 
	int i;

	for (i = 0; i < length; i++) {
    2b5c:	39 c1                	cmp    %eax,%ecx
    2b5e:	7e 19                	jle    2b79 <dafs_add_dentry+0x7f9>
		hash = hash * seed + (*str++);
    2b60:	48 6b 54 24 20 1f    	imul   $0x1f,0x20(%rsp),%rdx
    2b66:	48 0f be 34 03       	movsbq (%rbx,%rax,1),%rsi
    2b6b:	48 83 c0 01          	add    $0x1,%rax
    2b6f:	48 01 f2             	add    %rsi,%rdx
    2b72:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
    2b77:	eb e3                	jmp    2b5c <dafs_add_dentry+0x7dc>
        par_hn = BKDRHash(tem, temlen);
        
        //nova_dbg("%s par name %s",__func__,tem);
        dafs_de->isr_sf = 0;
        if(file_type == 1){
    2b79:	41 83 fa 01          	cmp    $0x1,%r10d
        memcpy(tem, phname, temlen);
        tem[temlen]='\0';
        par_hn = BKDRHash(tem, temlen);
        
        //nova_dbg("%s par name %s",__func__,tem);
        dafs_de->isr_sf = 0;
    2b7d:	41 c6 86 83 40 00 00 	movb   $0x0,0x4083(%r14)
    2b84:	00 
        if(file_type == 1){
    2b85:	74 69                	je     2bf0 <dafs_add_dentry+0x870>
                }
            } else {
                ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, flen, phname, 1);
            }
        } else {
            dafs_de->ful_name.f_name[0]= '\0';
    2b87:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
    2b8c:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
    2b91:	48 c1 e0 07          	shl    $0x7,%rax
    2b95:	c6 84 01 d8 40 00 00 	movb   $0x0,0x40d8(%rcx,%rax,1)
    2b9c:	00 
        }
        
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hn, 1, &par_pos);
    2b9d:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    2ba2:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
    2ba7:	4c 8d 44 24 5c       	lea    0x5c(%rsp),%r8
    2bac:	b9 01 00 00 00       	mov    $0x1,%ecx
    2bb1:	4c 89 e7             	mov    %r12,%rdi
    2bb4:	44 89 54 24 18       	mov    %r10d,0x18(%rsp)
    2bb9:	48 8b 70 18          	mov    0x18(%rax),%rsi
    2bbd:	e8 00 00 00 00       	callq  2bc2 <dafs_add_dentry+0x842>
        //nova_dbg("set par_pos %d", par_pos);
        dafs_de->par_pos = cpu_to_le32(par_pos);
    2bc2:	8b 44 24 5c          	mov    0x5c(%rsp),%eax
        kfree(tem); 
    2bc6:	48 89 df             	mov    %rbx,%rdi
            dafs_de->ful_name.f_name[0]= '\0';
        }
        
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hn, 1, &par_pos);
        //nova_dbg("set par_pos %d", par_pos);
        dafs_de->par_pos = cpu_to_le32(par_pos);
    2bc9:	41 89 86 8c 40 00 00 	mov    %eax,0x408c(%r14)
        kfree(tem); 
    2bd0:	e8 00 00 00 00       	callq  2bd5 <dafs_add_dentry+0x855>
    /*debug*/
    par_de = &dafs_ze->dentry[par_pos];
    //nova_dbg("%s par name %s",__func__,tem);
    //BUG_ON(le64_to_cpu(par_de->ino)!=dir->i_ino);
 
    hashname = BKDRHash(phname, flen);
    2bd5:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    2bda:	44 8b 54 24 18       	mov    0x18(%rsp),%r10d
    2bdf:	85 c0                	test   %eax,%eax
    2be1:	89 c1                	mov    %eax,%ecx
    2be3:	0f 8f 31 fc ff ff    	jg     281a <dafs_add_dentry+0x49a>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    2be9:	31 db                	xor    %ebx,%ebx
    2beb:	e9 50 fc ff ff       	jmpq   2840 <dafs_add_dentry+0x4c0>
        par_hn = BKDRHash(tem, temlen);
        
        //nova_dbg("%s par name %s",__func__,tem);
        dafs_de->isr_sf = 0;
        if(file_type == 1){
           if(dafs_de->ext_flag==0){
    2bf0:	66 41 83 be 84 40 00 	cmpw   $0x0,0x4084(%r14)
    2bf7:	00 00 
    2bf9:	75 5d                	jne    2c58 <dafs_add_dentry+0x8d8>
                if(flen<=SMALL_NAME_LEN){
    2bfb:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    2c00:	48 83 f8 27          	cmp    $0x27,%rax
    2c04:	0f 87 8d 00 00 00    	ja     2c97 <dafs_add_dentry+0x917>
                    //nova_dbg("dafs not need extend fulname");
                    memcpy(dafs_de->ful_name.f_name, phname, flen);
    2c0a:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
    2c0f:	48 8b 54 24 50       	mov    0x50(%rsp),%rdx
    2c14:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
    2c19:	44 89 54 24 14       	mov    %r10d,0x14(%rsp)
    2c1e:	48 c1 e1 07          	shl    $0x7,%rcx
    2c22:	48 8d bc 0a d8 40 00 	lea    0x40d8(%rdx,%rcx,1),%rdi
    2c29:	00 
    2c2a:	48 89 c2             	mov    %rax,%rdx
    2c2d:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
    2c32:	e8 00 00 00 00       	callq  2c37 <dafs_add_dentry+0x8b7>
                    dafs_de->ful_name.f_name[flen]='\0';
    2c37:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    2c3c:	48 03 4c 24 50       	add    0x50(%rsp),%rcx
    2c41:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    2c46:	44 8b 54 24 14       	mov    0x14(%rsp),%r10d
    2c4b:	c6 84 08 d8 40 00 00 	movb   $0x0,0x40d8(%rax,%rcx,1)
    2c52:	00 
    2c53:	e9 45 ff ff ff       	jmpq   2b9d <dafs_add_dentry+0x81d>
    2c58:	44 89 54 24 18       	mov    %r10d,0x18(%rsp)
                    //nova_dbg("%s extend ful name %s ino %llu", __func__, phname, ino);
                    dafs_de->ext_flag = 2;
                    ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, flen, phname, 1);
                }
            } else {
                ext_de_name(sb, dzt_ei, dafs_ze, zone_p, tem_pos, flen, phname, 1);
    2c5d:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
    2c62:	44 8b 4c 24 48       	mov    0x48(%rsp),%r9d
    2c67:	45 89 f8             	mov    %r15d,%r8d
    2c6a:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
    2c6f:	48 8b 54 24 50       	mov    0x50(%rsp),%rdx
    2c74:	4c 89 e7             	mov    %r12,%rdi
    2c77:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
    2c7c:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    2c83:	00 
    2c84:	48 89 04 24          	mov    %rax,(%rsp)
    2c88:	e8 00 00 00 00       	callq  2c8d <dafs_add_dentry+0x90d>
    2c8d:	44 8b 54 24 18       	mov    0x18(%rsp),%r10d
    2c92:	e9 06 ff ff ff       	jmpq   2b9d <dafs_add_dentry+0x81d>
    2c97:	44 89 54 24 18       	mov    %r10d,0x18(%rsp)
                    //nova_dbg("dafs not need extend fulname");
                    memcpy(dafs_de->ful_name.f_name, phname, flen);
                    dafs_de->ful_name.f_name[flen]='\0';
                } else {
                    //nova_dbg("%s extend ful name %s ino %llu", __func__, phname, ino);
                    dafs_de->ext_flag = 2;
    2c9c:	66 41 c7 86 84 40 00 	movw   $0x2,0x4084(%r14)
    2ca3:	00 02 00 
    2ca6:	eb b5                	jmp    2c5d <dafs_add_dentry+0x8dd>
    2ca8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    2caf:	00 

0000000000002cb0 <dafs_find_direntry>:
 * phname full name
 * update flag for whether update
 * ISREAD for readdir flag in get path*/
struct dafs_dentry *dafs_find_direntry(struct super_block *sb, const struct dentry *dentry, int update_flag,
        u32 ISREAD)
{
    2cb0:	e8 00 00 00 00       	callq  2cb5 <dafs_find_direntry+0x5>
    2cb5:	55                   	push   %rbp
    2cb6:	48 89 e5             	mov    %rsp,%rbp
    2cb9:	41 57                	push   %r15
    2cbb:	41 56                	push   %r14
    2cbd:	41 55                	push   %r13
    2cbf:	41 54                	push   %r12
    2cc1:	49 89 f6             	mov    %rsi,%r14
    2cc4:	53                   	push   %rbx
    u32 de_pos, par_pos;
    char *ph, *dot=".", *pdot = "..";
    char *phname, *phn;
    int ret;

    nova_dbg("%s:dafs start to find direntry",__func__);
    2cc5:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 * phname full name
 * update flag for whether update
 * ISREAD for readdir flag in get path*/
struct dafs_dentry *dafs_find_direntry(struct super_block *sb, const struct dentry *dentry, int update_flag,
        u32 ISREAD)
{
    2ccc:	48 89 fb             	mov    %rdi,%rbx
    2ccf:	41 89 d5             	mov    %edx,%r13d
    2cd2:	48 83 ec 48          	sub    $0x48,%rsp
    2cd6:	4c 8b a7 b0 03 00 00 	mov    0x3b0(%rdi),%r12
    u32 de_pos, par_pos;
    char *ph, *dot=".", *pdot = "..";
    char *phname, *phn;
    int ret;

    nova_dbg("%s:dafs start to find direntry",__func__);
    2cdd:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 * phname full name
 * update flag for whether update
 * ISREAD for readdir flag in get path*/
struct dafs_dentry *dafs_find_direntry(struct super_block *sb, const struct dentry *dentry, int update_flag,
        u32 ISREAD)
{
    2ce4:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    2ceb:	00 00 
    2ced:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    2cf1:	31 c0                	xor    %eax,%eax
    u32 de_pos, par_pos;
    char *ph, *dot=".", *pdot = "..";
    char *phname, *phn;
    int ret;

    nova_dbg("%s:dafs start to find direntry",__func__);
    2cf3:	e8 00 00 00 00       	callq  2cf8 <dafs_find_direntry+0x48>
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
    2cf8:	49 8b 46 28          	mov    0x28(%r14),%rax
    2cfc:	b9 02 00 00 00       	mov    $0x2,%ecx
    2d01:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2d08:	48 89 c6             	mov    %rax,%rsi
    2d0b:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    2d0d:	74 13                	je     2d22 <dafs_find_direntry+0x72>
    2d0f:	b9 03 00 00 00       	mov    $0x3,%ecx
    2d14:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2d1b:	48 89 c6             	mov    %rax,%rsi
    2d1e:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    2d20:	75 27                	jne    2d49 <dafs_find_direntry+0x99>
        //nova_dbg("%s init dentry . and ..",__func__);
        return direntry;
    2d22:	31 db                	xor    %ebx,%ebx
    //kfree(phname);
    //kfree(ph);
    //kfree(phn);
    //nova_dbg("%s:dafs finish find direntry",__func__);
    return direntry;
}
    2d24:	48 89 d8             	mov    %rbx,%rax
    2d27:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    2d2b:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    2d32:	00 00 
    2d34:	0f 85 d0 01 00 00    	jne    2f0a <dafs_find_direntry+0x25a>
    2d3a:	48 83 c4 48          	add    $0x48,%rsp
    2d3e:	5b                   	pop    %rbx
    2d3f:	41 5c                	pop    %r12
    2d41:	41 5d                	pop    %r13
    2d43:	41 5e                	pop    %r14
    2d45:	41 5f                	pop    %r15
    2d47:	5d                   	pop    %rbp
    2d48:	c3                   	retq   
    nova_dbg("%s:dafs start to find direntry",__func__);
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
        //nova_dbg("%s init dentry . and ..",__func__);
        return direntry;
    }
    ph = get_dentry_path(dentry,ISREAD);
    2d49:	4c 89 f7             	mov    %r14,%rdi
    flen = strlen(ph);
    phname = &sbi->ph_name;
    2d4c:	4d 8d b4 24 d6 09 00 	lea    0x9d6(%r12),%r14
    2d53:	00 
    nova_dbg("%s:dafs start to find direntry",__func__);
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
        //nova_dbg("%s init dentry . and ..",__func__);
        return direntry;
    }
    ph = get_dentry_path(dentry,ISREAD);
    2d54:	e8 37 d3 ff ff       	callq  90 <get_dentry_path.isra.4>
    flen = strlen(ph);
    2d59:	49 83 cb ff          	or     $0xffffffffffffffff,%r11
    2d5d:	45 31 c0             	xor    %r8d,%r8d
    nova_dbg("%s:dafs start to find direntry",__func__);
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
        //nova_dbg("%s init dentry . and ..",__func__);
        return direntry;
    }
    ph = get_dentry_path(dentry,ISREAD);
    2d60:	49 89 c2             	mov    %rax,%r10
    flen = strlen(ph);
    2d63:	4c 89 d9             	mov    %r11,%rcx
    2d66:	4c 89 5d 90          	mov    %r11,-0x70(%rbp)
    2d6a:	48 89 c7             	mov    %rax,%rdi
    2d6d:	44 88 45 9f          	mov    %r8b,-0x61(%rbp)
    2d71:	44 89 c0             	mov    %r8d,%eax
    phname[0]='\0';
    phn[0]='\0';
    
    //phname = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    dzt_ei = find_dzt(sb, ph, phn);
    2d74:	4c 89 d6             	mov    %r10,%rsi
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
        //nova_dbg("%s init dentry . and ..",__func__);
        return direntry;
    }
    ph = get_dentry_path(dentry,ISREAD);
    flen = strlen(ph);
    2d77:	f2 ae                	repnz scas %es:(%rdi),%al
    phname = &sbi->ph_name;
    phn = &sbi->ph_dzt;
    2d79:	49 8d bc 24 d7 05 00 	lea    0x5d7(%r12),%rdi
    2d80:	00 
    phname[0]='\0';
    2d81:	41 c6 84 24 d6 09 00 	movb   $0x0,0x9d6(%r12)
    2d88:	00 00 
    phn[0]='\0';
    2d8a:	41 c6 84 24 d7 05 00 	movb   $0x0,0x5d7(%r12)
    2d91:	00 00 
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
        //nova_dbg("%s init dentry . and ..",__func__);
        return direntry;
    }
    ph = get_dentry_path(dentry,ISREAD);
    flen = strlen(ph);
    2d93:	48 f7 d1             	not    %rcx
    phname[0]='\0';
    phn[0]='\0';
    
    //phname = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    dzt_ei = find_dzt(sb, ph, phn);
    2d96:	4c 89 55 a8          	mov    %r10,-0x58(%rbp)
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
        //nova_dbg("%s init dentry . and ..",__func__);
        return direntry;
    }
    ph = get_dentry_path(dentry,ISREAD);
    flen = strlen(ph);
    2d9a:	4e 8d 0c 19          	lea    (%rcx,%r11,1),%r9
    phname[0]='\0';
    phn[0]='\0';
    
    //phname = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    dzt_ei = find_dzt(sb, ph, phn);
    2d9e:	48 89 fa             	mov    %rdi,%rdx
    2da1:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    2da5:	48 89 df             	mov    %rbx,%rdi
    if(!strcmp(dentry->d_name.name, dot)|| !strcmp(dentry->d_name.name,pdot)){
        //nova_dbg("%s init dentry . and ..",__func__);
        return direntry;
    }
    ph = get_dentry_path(dentry,ISREAD);
    flen = strlen(ph);
    2da8:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    2dac:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
    phname[0]='\0';
    phn[0]='\0';
    
    //phname = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    dzt_ei = find_dzt(sb, ph, phn);
    2db0:	e8 4b d2 ff ff       	callq  0 <find_dzt>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    2db5:	48 8b 93 b0 03 00 00 	mov    0x3b0(%rbx),%rdx
    2dbc:	49 89 c7             	mov    %rax,%r15
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    2dbf:	48 8b 40 10          	mov    0x10(%rax),%rax
    
    phlen = strlen(phn);
    2dc3:	44 0f b6 45 9f       	movzbl -0x61(%rbp),%r8d
    2dc8:	4c 8b 5d 90          	mov    -0x70(%rbp),%r11
    2dcc:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
    2dd0:	4c 8b 55 a8          	mov    -0x58(%rbp),%r10
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    2dd4:	48 89 c6             	mov    %rax,%rsi
    2dd7:	48 03 72 18          	add    0x18(%rdx),%rsi
    2ddb:	48 85 c0             	test   %rax,%rax
    2dde:	b8 00 00 00 00       	mov    $0x0,%eax
    //phname = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    
    phlen = strlen(phn);
    2de3:	4c 89 d9             	mov    %r11,%rcx
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
    2de6:	4c 8b 4d a0          	mov    -0x60(%rbp),%r9
    2dea:	48 0f 45 c6          	cmovne %rsi,%rax
    2dee:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    //phname = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*(flen+1), GFP_KERNEL);
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    
    phlen = strlen(phn);
    2df2:	44 89 c0             	mov    %r8d,%eax
    2df5:	f2 ae                	repnz scas %es:(%rdi),%al
    2df7:	48 89 ca             	mov    %rcx,%rdx
    2dfa:	48 f7 d2             	not    %rdx
    2dfd:	48 83 ea 01          	sub    $0x1,%rdx
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
    2e01:	48 83 fa 01          	cmp    $0x1,%rdx
    2e05:	0f 84 04 01 00 00    	je     2f0f <dafs_find_direntry+0x25f>
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    2e0b:	4c 89 d7             	mov    %r10,%rdi
    2e0e:	4c 89 d9             	mov    %r11,%rcx
    2e11:	44 89 c0             	mov    %r8d,%eax
    2e14:	f2 ae                	repnz scas %es:(%rdi),%al
        memcpy(phname, ph+phlen, flen);
    2e16:	49 8d 34 12          	lea    (%r10,%rdx,1),%rsi
    2e1a:	4c 89 f7             	mov    %r14,%rdi
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    2e1d:	48 f7 d1             	not    %rcx
    2e20:	49 89 c9             	mov    %rcx,%r9
    2e23:	49 83 e9 01          	sub    $0x1,%r9
    2e27:	49 29 d1             	sub    %rdx,%r9
        memcpy(phname, ph+phlen, flen);
    2e2a:	4c 89 ca             	mov    %r9,%rdx
    2e2d:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
    2e31:	e8 00 00 00 00       	callq  2e36 <dafs_find_direntry+0x186>
        phname[flen]='\0';
    2e36:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
    2e3a:	43 c6 84 0c d6 09 00 	movb   $0x0,0x9d6(%r12,%r9,1)
    2e41:	00 00 
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    2e43:	45 85 c9             	test   %r9d,%r9d
    2e46:	0f 8e e8 00 00 00    	jle    2f34 <dafs_find_direntry+0x284>
    2e4c:	41 8d 41 ff          	lea    -0x1(%r9),%eax
    2e50:	45 31 e4             	xor    %r12d,%r12d
    2e53:	49 8d 4c 06 01       	lea    0x1(%r14,%rax,1),%rcx
    2e58:	4c 89 f0             	mov    %r14,%rax
		hash = hash * seed + (*str++);
    2e5b:	4c 89 e2             	mov    %r12,%rdx
    2e5e:	48 83 c0 01          	add    $0x1,%rax
    2e62:	48 c1 e2 05          	shl    $0x5,%rdx
    2e66:	4c 29 e2             	sub    %r12,%rdx
    2e69:	4c 0f be 60 ff       	movsbq -0x1(%rax),%r12
    2e6e:	49 01 d4             	add    %rdx,%r12
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    2e71:	48 39 c8             	cmp    %rcx,%rax
    2e74:	75 e5                	jne    2e5b <dafs_find_direntry+0x1ab>
    }
    
    ph_hash = BKDRHash(phname, flen);
    nova_dbg("%s phname %s",__func__,phname);
    2e76:	4c 89 f2             	mov    %r14,%rdx
    2e79:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    2e80:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2e87:	e8 00 00 00 00       	callq  2e8c <dafs_find_direntry+0x1dc>
    //BUG_ON(dzt_ei==NULL);
    ht_addr = dzt_ei->ht_head;
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    2e8c:	49 8b 77 18          	mov    0x18(%r15),%rsi
    2e90:	4c 8d 45 cc          	lea    -0x34(%rbp),%r8
    2e94:	b9 01 00 00 00       	mov    $0x1,%ecx
    2e99:	4c 89 e2             	mov    %r12,%rdx
    2e9c:	48 89 df             	mov    %rbx,%rdi
    2e9f:	e8 00 00 00 00       	callq  2ea4 <dafs_find_direntry+0x1f4>
    if(!ret){
    2ea4:	85 c0                	test   %eax,%eax
    2ea6:	0f 84 76 fe ff ff    	je     2d22 <dafs_find_direntry+0x72>
        //nova_dbg("%s not found dentry in hash table value is %llu",__func__, ph_hash);
        goto OUT;
    }
    direntry = &dafs_ze->dentry[de_pos];
    2eac:	8b 45 cc             	mov    -0x34(%rbp),%eax
    2eaf:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
    2eb3:	48 8d 98 81 00 00 00 	lea    0x81(%rax),%rbx
    2eba:	48 c1 e3 07          	shl    $0x7,%rbx
    2ebe:	48 01 d3             	add    %rdx,%rbx
    
    if(update_flag){
    2ec1:	45 85 ed             	test   %r13d,%r13d
    2ec4:	0f 84 5a fe ff ff    	je     2d24 <dafs_find_direntry+0x74>
    2eca:	48 c1 e0 07          	shl    $0x7,%rax
    2ece:	48 01 d0             	add    %rdx,%rax
        if(direntry->file_type == NORMAL_DIRECTORY)
    2ed1:	80 b8 82 40 00 00 01 	cmpb   $0x1,0x4082(%rax)
    2ed8:	74 62                	je     2f3c <dafs_find_direntry+0x28c>
            update_read_hot(dzt_ei, ph_hash);
        else if(direntry->isr_sf!=1){
    2eda:	80 b8 83 40 00 00 01 	cmpb   $0x1,0x4083(%rax)
    2ee1:	0f 84 3d fe ff ff    	je     2d24 <dafs_find_direntry+0x74>
            par_pos = le32_to_cpu(direntry->par_pos);
            ph_hash = le64_to_cpu(&dafs_ze->dentry[par_pos].hname);
    2ee7:	8b 80 8c 40 00 00    	mov    0x408c(%rax),%eax
    2eed:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
            update_read_hot(dzt_ei, ph_hash);
    2ef1:	4c 89 ff             	mov    %r15,%rdi
    if(update_flag){
        if(direntry->file_type == NORMAL_DIRECTORY)
            update_read_hot(dzt_ei, ph_hash);
        else if(direntry->isr_sf!=1){
            par_pos = le32_to_cpu(direntry->par_pos);
            ph_hash = le64_to_cpu(&dafs_ze->dentry[par_pos].hname);
    2ef4:	48 c1 e0 07          	shl    $0x7,%rax
    2ef8:	48 8d b4 02 a8 40 00 	lea    0x40a8(%rdx,%rax,1),%rsi
    2eff:	00 
            update_read_hot(dzt_ei, ph_hash);
    2f00:	e8 00 00 00 00       	callq  2f05 <dafs_find_direntry+0x255>
    2f05:	e9 1a fe ff ff       	jmpq   2d24 <dafs_find_direntry+0x74>
    //kfree(phname);
    //kfree(ph);
    //kfree(phn);
    //nova_dbg("%s:dafs finish find direntry",__func__);
    return direntry;
}
    2f0a:	e8 00 00 00 00       	callq  2f0f <dafs_find_direntry+0x25f>
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    
    phlen = strlen(phn);
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
        memcpy(phname, ph, flen);
    2f0f:	4c 89 ca             	mov    %r9,%rdx
    2f12:	4c 89 d6             	mov    %r10,%rsi
    2f15:	4c 89 f7             	mov    %r14,%rdi
    2f18:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
    2f1c:	e8 00 00 00 00       	callq  2f21 <dafs_find_direntry+0x271>
        phname[flen]='\0';
    2f21:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    2f25:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
    2f29:	41 c6 44 06 ff 00    	movb   $0x0,-0x1(%r14,%rax,1)
    2f2f:	e9 0f ff ff ff       	jmpq   2e43 <dafs_find_direntry+0x193>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    2f34:	45 31 e4             	xor    %r12d,%r12d
    2f37:	e9 3a ff ff ff       	jmpq   2e76 <dafs_find_direntry+0x1c6>
    }
    direntry = &dafs_ze->dentry[de_pos];
    
    if(update_flag){
        if(direntry->file_type == NORMAL_DIRECTORY)
            update_read_hot(dzt_ei, ph_hash);
    2f3c:	4c 89 e6             	mov    %r12,%rsi
    2f3f:	4c 89 ff             	mov    %r15,%rdi
    2f42:	e8 00 00 00 00       	callq  2f47 <dafs_find_direntry+0x297>
    2f47:	e9 d8 fd ff ff       	jmpq   2d24 <dafs_find_direntry+0x74>
    2f4c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000002f50 <dafs_rebuild_dir_inode_tree>:
    return direntry;
}

int dafs_rebuild_dir_inode_tree(struct super_block *sb, struct nova_inode *pi, u64 pi_addr,
	struct nova_inode_info_header *sih)
{
    2f50:	e8 00 00 00 00       	callq  2f55 <dafs_rebuild_dir_inode_tree+0x5>
    2f55:	55                   	push   %rbp
    2f56:	48 89 e5             	mov    %rsp,%rbp
    2f59:	53                   	push   %rbx
    2f5a:	48 89 fb             	mov    %rdi,%rbx
    2f5d:	48 83 ec 40          	sub    $0x40,%rsp
	u64 curr_p;
	//u64 next;
	u8 type;
	//int ret;

	NOVA_START_TIMING(rebuild_dir_t, rebuild_time);
    2f61:	44 8b 0d 00 00 00 00 	mov    0x0(%rip),%r9d        # 2f68 <dafs_rebuild_dir_inode_tree+0x18>
    return direntry;
}

int dafs_rebuild_dir_inode_tree(struct super_block *sb, struct nova_inode *pi, u64 pi_addr,
	struct nova_inode_info_header *sih)
{
    2f68:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    2f6f:	00 00 
    2f71:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    2f75:	31 c0                	xor    %eax,%eax
	u64 curr_p;
	//u64 next;
	u8 type;
	//int ret;

	NOVA_START_TIMING(rebuild_dir_t, rebuild_time);
    2f77:	45 85 c9             	test   %r9d,%r9d
    2f7a:	0f 85 b7 00 00 00    	jne    3037 <dafs_rebuild_dir_inode_tree+0xe7>
	//nova_dbg("Rebuild dir %llu tree\n", ino);

	sih->pi_addr = pi_addr;
    2f80:	48 89 51 40          	mov    %rdx,0x40(%rcx)

	curr_p = pi->log_head;
    2f84:	48 8b 46 48          	mov    0x48(%rsi),%rax
	}*/

	//nova_dbg("Log head 0x%llx, tail 0x%llx\n",
	//			curr_p, pi->log_tail);

    if(!curr_p){
    2f88:	48 85 c0             	test   %rax,%rax
    2f8b:	0f 85 85 00 00 00    	jne    3016 <dafs_rebuild_dir_inode_tree+0xc6>
        sih->log_pages = 0;
    2f91:	48 c7 41 28 00 00 00 	movq   $0x0,0x28(%rcx)
    2f98:	00 
			//nova_dbg_verbose("%s: unknown type %d, 0x%llx\n",
			//				__func__, type, curr_p);
				//NOVA_ASSERT(0);
	}
DIR_TYPE:
	sih->i_size = le64_to_cpu(pi->i_size);
    2f99:	48 8b 46 08          	mov    0x8(%rsi),%rax
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    2f9d:	89 f7                	mov    %esi,%edi
	if (support_clwb) {
    2f9f:	44 8b 05 00 00 00 00 	mov    0x0(%rip),%r8d        # 2fa6 <dafs_rebuild_dir_inode_tree+0x56>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    2fa6:	83 e7 3f             	and    $0x3f,%edi
	if (support_clwb) {
    2fa9:	31 d2                	xor    %edx,%edx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    2fab:	83 c7 5c             	add    $0x5c,%edi
    2fae:	48 89 41 30          	mov    %rax,0x30(%rcx)
	sih->i_mode = le64_to_cpu(pi->i_mode);
    2fb2:	0f b7 46 1c          	movzwl 0x1c(%rsi),%eax
	if (support_clwb) {
    2fb6:	45 85 c0             	test   %r8d,%r8d
    2fb9:	66 89 41 20          	mov    %ax,0x20(%rcx)
    2fbd:	74 46                	je     3005 <dafs_rebuild_dir_inode_tree+0xb5>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    2fbf:	89 d0                	mov    %edx,%eax
    2fc1:	48 01 f0             	add    %rsi,%rax
    2fc4:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    2fc8:	83 c2 40             	add    $0x40,%edx
    2fcb:	39 d7                	cmp    %edx,%edi
    2fcd:	77 f0                	ja     2fbf <dafs_rebuild_dir_inode_tree+0x6f>
    nova_flush_buffer(pi, sizeof(struct nova_inode), 0);

    pi->i_blocks = sih->log_pages;
    2fcf:	48 8b 41 28          	mov    0x28(%rcx),%rax
    2fd3:	48 89 46 20          	mov    %rax,0x20(%rsi)

//	nova_print_dir_tree(sb, sih, ino);
    //dafs_rebuild_dir_time_and_size(sb, pi, entry);
	//nova_dbg("%s:dafs finish rebuild dir inode",__func__);
    NOVA_END_TIMING(rebuild_dir_t, rebuild_time);
    2fd7:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 2fdd <dafs_rebuild_dir_inode_tree+0x8d>
    2fdd:	85 c0                	test   %eax,%eax
    2fdf:	75 7c                	jne    305d <dafs_rebuild_dir_inode_tree+0x10d>
    2fe1:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 2fe9 <dafs_rebuild_dir_inode_tree+0x99>
    2fe8:	00 
    return 0;
}
    2fe9:	31 c0                	xor    %eax,%eax
    2feb:	48 8b 5d f0          	mov    -0x10(%rbp),%rbx
    2fef:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    2ff6:	00 00 
    2ff8:	0f 85 90 00 00 00    	jne    308e <dafs_rebuild_dir_inode_tree+0x13e>
    2ffe:	48 83 c4 40          	add    $0x40,%rsp
    3002:	5b                   	pop    %rbx
    3003:	5d                   	pop    %rbp
    3004:	c3                   	retq   
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    3005:	89 d0                	mov    %edx,%eax
    3007:	48 01 f0             	add    %rsi,%rax
    300a:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    300d:	83 c2 40             	add    $0x40,%edx
    3010:	39 d7                	cmp    %edx,%edi
    3012:	77 f1                	ja     3005 <dafs_rebuild_dir_inode_tree+0xb5>
    3014:	eb b9                	jmp    2fcf <dafs_rebuild_dir_inode_tree+0x7f>
    if(!curr_p){
        sih->log_pages = 0;
        goto DIR_TYPE;
    }

	sih->log_pages = 1;
    3016:	48 c7 41 28 01 00 00 	movq   $0x1,0x28(%rcx)
    301d:	00 
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    301e:	48 8b 93 b0 03 00 00 	mov    0x3b0(%rbx),%rdx
    DAFS_DIR_ENTRY,
};

static inline u8 nova_get_entry_type(void *p)
{
	return *(u8 *)p;
    3025:	48 8b 52 18          	mov    0x18(%rdx),%rdx
		}*/

	addr = (void *)nova_get_block(sb, curr_p);
    //find bug
    type = nova_get_entry_type(addr);
	switch (type) {
    3029:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
    302d:	3c 03                	cmp    $0x3,%al
    302f:	74 5b                	je     308c <dafs_rebuild_dir_inode_tree+0x13c>
    3031:	3c 04                	cmp    $0x4,%al
    3033:	75 55                	jne    308a <dafs_rebuild_dir_inode_tree+0x13a>
			sih->last_setattr = curr_p;
			curr_p += sizeof(struct nova_setattr_logentry);
				//continue;
                break;
		case LINK_CHANGE:
            BUG();
    3035:	0f 0b                	ud2    
    3037:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
    303b:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
    303f:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
    3043:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
    3047:	e8 00 00 00 00       	callq  304c <dafs_rebuild_dir_inode_tree+0xfc>
    304c:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
    3050:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
    3054:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    3058:	e9 23 ff ff ff       	jmpq   2f80 <dafs_rebuild_dir_inode_tree+0x30>
    305d:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
    3061:	e8 00 00 00 00       	callq  3066 <dafs_rebuild_dir_inode_tree+0x116>
    pi->i_blocks = sih->log_pages;

//	nova_print_dir_tree(sb, sih, ino);
    //dafs_rebuild_dir_time_and_size(sb, pi, entry);
	//nova_dbg("%s:dafs finish rebuild dir inode",__func__);
    NOVA_END_TIMING(rebuild_dir_t, rebuild_time);
    3066:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    306a:	48 2b 45 d0          	sub    -0x30(%rbp),%rax
    306e:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    3075:	48 2b 45 d8          	sub    -0x28(%rbp),%rax
    3079:	48 03 45 e8          	add    -0x18(%rbp),%rax
    307d:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 3085 <dafs_rebuild_dir_inode_tree+0x135>
    3084:	00 
    3085:	e9 57 ff ff ff       	jmpq   2fe1 <dafs_rebuild_dir_inode_tree+0x91>
            break;
				//continue;
			//case DIR_LOG:
				//break;
		default:
            BUG();
    308a:	0f 0b                	ud2    
	addr = (void *)nova_get_block(sb, curr_p);
    //find bug
    type = nova_get_entry_type(addr);
	switch (type) {
		case SET_ATTR:
            BUG();
    308c:	0f 0b                	ud2    
//	nova_print_dir_tree(sb, sih, ino);
    //dafs_rebuild_dir_time_and_size(sb, pi, entry);
	//nova_dbg("%s:dafs finish rebuild dir inode",__func__);
    NOVA_END_TIMING(rebuild_dir_t, rebuild_time);
    return 0;
}
    308e:	e8 00 00 00 00       	callq  3093 <dafs_rebuild_dir_inode_tree+0x143>
    3093:	0f 1f 00             	nopl   (%rax)
    3096:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    309d:	00 00 00 

00000000000030a0 <dafs_rm_dir>:
 * 只是先将对应的状态表显示无效
 * 检查是不是根节点
 * 并不含有link的变化
 */
int dafs_rm_dir(struct dentry *dentry, int link_change)
{
    30a0:	e8 00 00 00 00       	callq  30a5 <dafs_rm_dir+0x5>
    30a5:	55                   	push   %rbp
    30a6:	48 89 e5             	mov    %rsp,%rbp
    30a9:	41 57                	push   %r15
    30ab:	41 56                	push   %r14
    30ad:	41 55                	push   %r13
    30af:	41 54                	push   %r12
    30b1:	49 89 fd             	mov    %rdi,%r13
    30b4:	53                   	push   %rbx
    30b5:	48 83 ec 70          	sub    $0x70,%rsp
    30b9:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    30c0:	00 00 
    30c2:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    30c7:	31 c0                	xor    %eax,%eax
    struct inode *dir = dentry->d_parent->d_inode;
    30c9:	48 8b 47 18          	mov    0x18(%rdi),%rax
 * 只是先将对应的状态表显示无效
 * 检查是不是根节点
 * 并不含有link的变化
 */
int dafs_rm_dir(struct dentry *dentry, int link_change)
{
    30cd:	89 74 24 28          	mov    %esi,0x28(%rsp)
    char *phname, *ph, *phn;
    //char *ph;
    int ret;
	timing_t remove_dentry_time;

	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    30d1:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 30d7 <dafs_rm_dir+0x37>
 * 检查是不是根节点
 * 并不含有link的变化
 */
int dafs_rm_dir(struct dentry *dentry, int link_change)
{
    struct inode *dir = dentry->d_parent->d_inode;
    30d7:	4c 8b 78 30          	mov    0x30(%rax),%r15
    char *phname, *ph, *phn;
    //char *ph;
    int ret;
	timing_t remove_dentry_time;

	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    30db:	85 f6                	test   %esi,%esi
 * 并不含有link的变化
 */
int dafs_rm_dir(struct dentry *dentry, int link_change)
{
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
    30dd:	49 8b 5f 28          	mov    0x28(%r15),%rbx
    30e1:	4c 8b b3 b0 03 00 00 	mov    0x3b0(%rbx),%r14
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dafs_dentry *dafs_de, *par_de,*sub_de;
    struct dzt_entry_info *dzt_ei, *sub_ei;
    struct dafs_zone_entry *dafs_ze;
    struct zone_ptr *z_p;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    30e8:	49 8b 86 d8 0d 00 00 	mov    0xdd8(%r14),%rax
    30ef:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    char *phname, *ph, *phn;
    //char *ph;
    int ret;
	timing_t remove_dentry_time;

	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    30f4:	0f 85 3f 05 00 00    	jne    3639 <dafs_rm_dir+0x599>

	if (!dentry->d_name.len){
    30fa:	41 8b 4d 24          	mov    0x24(%r13),%ecx
    30fe:	85 c9                	test   %ecx,%ecx
    3100:	0f 84 21 06 00 00    	je     3727 <dafs_rm_dir+0x687>
        //nova_dbg("%s name is null %s",__func__,dentry->d_name.name);
		return -EINVAL;
    }


	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    3106:	e8 00 00 00 00       	callq  310b <dafs_rm_dir+0x6b>
    310b:	49 c7 87 80 00 00 00 	movq   $0x0,0x80(%r15)
    3112:	00 00 00 00 
    3116:	49 89 47 78          	mov    %rax,0x78(%r15)
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    311a:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
        //nova_dbg("%s name is null %s",__func__,dentry->d_name.name);
		return -EINVAL;
    }


	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    3121:	49 8b 47 78          	mov    0x78(%r15),%rax
    3125:	49 8b 97 80 00 00 00 	mov    0x80(%r15),%rdx
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    312c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
        //nova_dbg("%s name is null %s",__func__,dentry->d_name.name);
		return -EINVAL;
    }


	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    3133:	49 89 47 68          	mov    %rax,0x68(%r15)
    3137:	49 89 57 70          	mov    %rdx,0x70(%r15)
}

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
    313b:	49 8b 45 18          	mov    0x18(%r13),%rax
    struct super_block *sb = dir->i_sb;
    313f:	48 8b 40 30          	mov    0x30(%rax),%rax
    3143:	48 8b 50 28          	mov    0x28(%rax),%rdx
    3147:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    314e:	00 00 
    struct nova_sb_info *sbi = NOVA_SB(sb);
    char *ph, *buf, *tem, *ppath;
    //char *buf = NULL, *ppath=NULL, *tem=NULL;
    struct fs_struct *fs = current->fs;
    3150:	4c 8b a0 30 06 00 00 	mov    0x630(%rax),%r12
    3157:	4c 8b 82 b0 03 00 00 	mov    0x3b0(%rdx),%r8
    315e:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
    3163:	4c 89 44 24 30       	mov    %r8,0x30(%rsp)
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    3168:	e8 00 00 00 00       	callq  316d <dafs_rm_dir+0xcd>
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    316d:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
    3172:	4c 8b 44 24 30       	mov    0x30(%rsp),%r8
    3177:	48 85 d2             	test   %rdx,%rdx
    317a:	0f 84 b1 05 00 00    	je     3731 <dafs_rm_dir+0x691>
    BUG_ON(sbi==NULL);
    3180:	4d 85 c0             	test   %r8,%r8
    3183:	0f 84 aa 05 00 00    	je     3733 <dafs_rm_dir+0x693>
    ph = &sbi->ph_f;
    3189:	49 8d 80 d8 01 00 00 	lea    0x1d8(%r8),%rax
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    3190:	49 8d 7c 24 04       	lea    0x4(%r12),%rdi
    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    3195:	41 c6 80 d8 01 00 00 	movb   $0x0,0x1d8(%r8)
    319c:	00 
    buf[0]='\0';
    319d:	41 c6 80 d7 05 00 00 	movb   $0x0,0x5d7(%r8)
    31a4:	00 
    tem[0]='\0';
    31a5:	41 c6 80 d6 09 00 00 	movb   $0x0,0x9d6(%r8)
    31ac:	00 
    31ad:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    31b2:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    31b7:	e8 00 00 00 00       	callq  31bc <dafs_rm_dir+0x11c>
    vfsmnt = mntget(fs->pwd.mnt);
    31bc:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
    31c1:	e8 00 00 00 00       	callq  31c6 <dafs_rm_dir+0x126>
    if(!vfsmnt){
    31c6:	48 85 c0             	test   %rax,%rax
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    31c9:	49 89 c1             	mov    %rax,%r9
    if(!vfsmnt){
    31cc:	4c 8b 44 24 20       	mov    0x20(%rsp),%r8
    31d1:	0f 84 ea 06 00 00    	je     38c1 <dafs_rm_dir+0x821>
    31d7:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
    31dc:	f0 41 0f c1 44 24 04 	lock xadd %eax,0x4(%r12)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
    31e3:	49 8b 75 28          	mov    0x28(%r13),%rsi
    31e7:	49 c7 c2 00 00 00 00 	mov    $0x0,%r10
    31ee:	b9 02 00 00 00       	mov    $0x2,%ecx
    31f3:	4c 89 d7             	mov    %r10,%rdi
    31f6:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    31f8:	0f 85 49 05 00 00    	jne    3747 <dafs_rm_dir+0x6a7>
        memcpy(buf,"/",1);
        buf[1]='\0';
    }else{
        //nova_dbg("%s root dentry",__func__);
        memcpy(ph, "/", 1);
    31fe:	41 c6 80 d8 01 00 00 	movb   $0x2f,0x1d8(%r8)
    3205:	2f 
        ph[1]='\0';
    3206:	41 c6 80 d9 01 00 00 	movb   $0x0,0x1d9(%r8)
    320d:	00 
	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
 
    //nova_dbg("%s start",__func__);
    ph = get_dentry_path(dentry,0);
    //nova_dbg("%s start dentry %s",__func__,ph);
    flen= strlen(ph);
    320e:	4c 8b 64 24 30       	mov    0x30(%rsp),%r12
    3213:	4c 89 e7             	mov    %r12,%rdi
    3216:	e8 00 00 00 00       	callq  321b <dafs_rm_dir+0x17b>
    321b:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    slen = flen+1;
    phname = &sbi->ph_name;
    phname[0]='\0';
    phn = &sbi->ph_dzt;
    3220:	49 8d 86 d7 05 00 00 	lea    0x5d7(%r14),%rax
    ph = get_dentry_path(dentry,0);
    //nova_dbg("%s start dentry %s",__func__,ph);
    flen= strlen(ph);
    slen = flen+1;
    phname = &sbi->ph_name;
    phname[0]='\0';
    3227:	41 c6 86 d6 09 00 00 	movb   $0x0,0x9d6(%r14)
    322e:	00 
    phn = &sbi->ph_dzt;
    phn[0]='\0';
    322f:	41 c6 86 d7 05 00 00 	movb   $0x0,0x5d7(%r14)
    3236:	00 
    //nova_dbg("%s start",__func__);
    ph = get_dentry_path(dentry,0);
    //nova_dbg("%s start dentry %s",__func__,ph);
    flen= strlen(ph);
    slen = flen+1;
    phname = &sbi->ph_name;
    3237:	49 8d 8e d6 09 00 00 	lea    0x9d6(%r14),%rcx
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    323e:	4c 89 e2             	mov    %r12,%rdx
    //nova_dbg("%s start dentry %s",__func__,ph);
    flen= strlen(ph);
    slen = flen+1;
    phname = &sbi->ph_name;
    phname[0]='\0';
    phn = &sbi->ph_dzt;
    3241:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    3246:	48 8b 83 b0 03 00 00 	mov    0x3b0(%rbx),%rax
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    324d:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    3254:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    //nova_dbg("%s start",__func__);
    ph = get_dentry_path(dentry,0);
    //nova_dbg("%s start dentry %s",__func__,ph);
    flen= strlen(ph);
    slen = flen+1;
    phname = &sbi->ph_name;
    325b:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    3260:	4c 8b a8 d8 0d 00 00 	mov    0xdd8(%rax),%r13
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    3267:	e8 00 00 00 00       	callq  326c <dafs_rm_dir+0x1cc>
    tlen = strlen(phstr);
    326c:	4c 89 e7             	mov    %r12,%rdi
    326f:	4c 89 64 24 30       	mov    %r12,0x30(%rsp)
    3274:	e8 00 00 00 00       	callq  3279 <dafs_rm_dir+0x1d9>
    nova_dbg("%s length is %llu", __func__, tlen);
    3279:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    3280:	48 89 c2             	mov    %rax,%rdx
    3283:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    tlen = strlen(phstr);
    328a:	49 89 c4             	mov    %rax,%r12
    nova_dbg("%s length is %llu", __func__, tlen);
    328d:	e8 00 00 00 00       	callq  3292 <dafs_rm_dir+0x1f2>
    memcpy(phs, phstr, tlen);
    3292:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
    3297:	49 8d be d7 05 00 00 	lea    0x5d7(%r14),%rdi
    329e:	4c 89 e2             	mov    %r12,%rdx
    32a1:	e8 00 00 00 00       	callq  32a6 <dafs_rm_dir+0x206>
    phs[tlen]='\0';
    32a6:	43 c6 84 26 d7 05 00 	movb   $0x0,0x5d7(%r14,%r12,1)
    32ad:	00 00 
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    32af:	4c 89 ef             	mov    %r13,%rdi
            return dzt_ei;
        }
    }while(1);
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    32b2:	41 c6 86 d7 05 00 00 	movb   $0x2f,0x5d7(%r14)
    32b9:	2f 
    phs[1]='\0';
    32ba:	41 c6 86 d8 05 00 00 	movb   $0x0,0x5d8(%r14)
    32c1:	00 
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    32c2:	be 2f 00 00 00       	mov    $0x2f,%esi
    32c7:	e8 00 00 00 00       	callq  32cc <dafs_rm_dir+0x22c>
    if(!dzt_ei){
    32cc:	48 85 c0             	test   %rax,%rax
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    32cf:	49 89 c5             	mov    %rax,%r13
    if(!dzt_ei){
    32d2:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
    32d7:	0f 84 60 04 00 00    	je     373d <dafs_rm_dir+0x69d>
    phn[0]='\0';
    //phname = kmalloc(sizeof(char)*(slen), GFP_KERNEL);
    //phn = kmalloc(sizeof(char)*(slen), GFP_KERNEL);
    //nova_dbg("%s start dentry %s",__func__,ph);
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    32dd:	48 8b 40 10          	mov    0x10(%rax),%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    32e1:	48 8b 93 b0 03 00 00 	mov    0x3b0(%rbx),%rdx
    phlen = strlen(phn);
    32e8:	49 8d be d7 05 00 00 	lea    0x5d7(%r14),%rdi
    32ef:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    32f4:	49 89 c4             	mov    %rax,%r12
    32f7:	4c 03 62 18          	add    0x18(%rdx),%r12
    32fb:	48 85 c0             	test   %rax,%rax
    32fe:	b8 00 00 00 00       	mov    $0x0,%eax
    3303:	4c 0f 44 e0          	cmove  %rax,%r12
    3307:	e8 00 00 00 00       	callq  330c <dafs_rm_dir+0x26c>

    if(phlen==1){
    330c:	83 f8 01             	cmp    $0x1,%eax
    330f:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
    3314:	0f 84 2e 03 00 00    	je     3648 <dafs_rm_dir+0x5a8>
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    331a:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
    331f:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
    3324:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    3329:	e8 00 00 00 00       	callq  332e <dafs_rm_dir+0x28e>
    332e:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
    3333:	41 89 c0             	mov    %eax,%r8d
        memcpy(phname, ph+phlen, flen);
    3336:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx

    if(phlen==1){
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    333b:	41 29 f0             	sub    %esi,%r8d
        memcpy(phname, ph+phlen, flen);
    333e:	89 f6                	mov    %esi,%esi
    3340:	48 03 74 24 30       	add    0x30(%rsp),%rsi
    3345:	45 89 c1             	mov    %r8d,%r9d
    3348:	48 89 cf             	mov    %rcx,%rdi
    334b:	44 89 44 24 20       	mov    %r8d,0x20(%rsp)
    3350:	4c 89 ca             	mov    %r9,%rdx
    3353:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
    3358:	e8 00 00 00 00       	callq  335d <dafs_rm_dir+0x2bd>
        phname[flen]='\0';
    335d:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
    3362:	44 8b 44 24 20       	mov    0x20(%rsp),%r8d
    if(phlen==1){
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
        memcpy(phname, ph+phlen, flen);
    3367:	48 89 c1             	mov    %rax,%rcx
        phname[flen]='\0';
    336a:	43 c6 84 0e d6 09 00 	movb   $0x0,0x9d6(%r14,%r9,1)
    3371:	00 00 
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    3373:	45 85 c0             	test   %r8d,%r8d
    3376:	0f 8e b9 03 00 00    	jle    3735 <dafs_rm_dir+0x695>
    337c:	41 8d 40 ff          	lea    -0x1(%r8),%eax
    3380:	45 31 f6             	xor    %r14d,%r14d
    3383:	48 8d 54 01 01       	lea    0x1(%rcx,%rax,1),%rdx
		hash = hash * seed + (*str++);
    3388:	4c 89 f0             	mov    %r14,%rax
    338b:	48 83 c1 01          	add    $0x1,%rcx
    338f:	48 c1 e0 05          	shl    $0x5,%rax
    3393:	4c 29 f0             	sub    %r14,%rax
    3396:	49 89 c6             	mov    %rax,%r14
    3399:	48 0f be 41 ff       	movsbq -0x1(%rcx),%rax
    339e:	49 01 c6             	add    %rax,%r14
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    33a1:	48 39 ca             	cmp    %rcx,%rdx
    33a4:	75 e2                	jne    3388 <dafs_rm_dir+0x2e8>
    //nova_dbg("%s start hash name is %s ",__func__, phname);
    ph_hash = BKDRHash(phname, flen);
    //nova_dbg("%s end hash",__func__);

    /*lookup in hash table*/
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    33a6:	49 8b 75 18          	mov    0x18(%r13),%rsi
    33aa:	4c 8d 44 24 3c       	lea    0x3c(%rsp),%r8
    33af:	b9 01 00 00 00       	mov    $0x1,%ecx
    33b4:	4c 89 f2             	mov    %r14,%rdx
    33b7:	48 89 df             	mov    %rbx,%rdi
    33ba:	e8 00 00 00 00       	callq  33bf <dafs_rm_dir+0x31f>
    if(!ret){
    33bf:	85 c0                	test   %eax,%eax
    33c1:	0f 84 60 03 00 00    	je     3727 <dafs_rm_dir+0x687>
        //nova_dbg("%s name is %llu ",__func__, ph_hash);
        return -EINVAL;
    }
    dafs_de = &dafs_ze->dentry[de_pos];
    33c7:	8b 7c 24 3c          	mov    0x3c(%rsp),%edi
    33cb:	48 8d 97 81 00 00 00 	lea    0x81(%rdi),%rdx
    33d2:	48 89 f8             	mov    %rdi,%rax
    33d5:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
    33da:	48 c1 e2 07          	shl    $0x7,%rdx
    33de:	49 8d 34 14          	lea    (%r12,%rdx,1),%rsi
        ei_hash = le64_to_cpu(dafs_de->dzt_hn);
        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
        free_zone_area(sb, sub_ei);
    }*/

	links_count = cpu_to_le16(dir->i_nlink);
    33e2:	41 8b 57 48          	mov    0x48(%r15),%edx
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    if(!ret){
        //nova_dbg("%s name is %llu ",__func__, ph_hash);
        return -EINVAL;
    }
    dafs_de = &dafs_ze->dentry[de_pos];
    33e6:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
        free_zone_area(sb, sub_ei);
    }*/

	links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
    33eb:	66 85 d2             	test   %dx,%dx
    33ee:	0f 85 39 02 00 00    	jne    362d <dafs_rm_dir+0x58d>
		links_count = 0;
    33f4:	31 c9                	xor    %ecx,%ecx
        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
        free_zone_area(sb, sub_ei);
    }*/

	links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
    33f6:	83 7c 24 28 ff       	cmpl   $0xffffffff,0x28(%rsp)
    33fb:	0f 85 2c 02 00 00    	jne    362d <dafs_rm_dir+0x58d>
    3401:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
	else
		links_count += link_change;
	dafs_de->links_count = cpu_to_le16(links_count);

    //nova_dbg("%s dafs_de link is: %d",__func__, links_count);
    bitpos = de_pos * 2;
    3406:	01 c0                	add    %eax,%eax
    3408:	89 44 24 28          	mov    %eax,0x28(%rsp)
    340c:	48 c1 e2 07          	shl    $0x7,%rdx
    3410:	49 8d 34 14          	lea    (%r12,%rdx,1),%rsi
	links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
		links_count = 0;
	else
		links_count += link_change;
	dafs_de->links_count = cpu_to_le16(links_count);
    3414:	66 89 8e 86 40 00 00 	mov    %cx,0x4086(%rsi)
    //nova_dbg("%s dafs_de link is: %d",__func__, links_count);
    bitpos = de_pos * 2;
   
    /*remove from par*/
    par_pos = le32_to_cpu(dafs_de->par_pos);
    if(dir->i_ino == NOVA_ROOT_INO || par_pos!=0){
    341b:	49 83 7f 40 01       	cmpq   $0x1,0x40(%r15)
    3420:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)

    //nova_dbg("%s dafs_de link is: %d",__func__, links_count);
    bitpos = de_pos * 2;
   
    /*remove from par*/
    par_pos = le32_to_cpu(dafs_de->par_pos);
    3425:	8b 86 8c 40 00 00    	mov    0x408c(%rsi),%eax
    if(dir->i_ino == NOVA_ROOT_INO || par_pos!=0){
    342b:	0f 84 ac 01 00 00    	je     35dd <dafs_rm_dir+0x53d>
    3431:	85 c0                	test   %eax,%eax
    3433:	0f 85 a4 01 00 00    	jne    35dd <dafs_rm_dir+0x53d>
            }
        }
    } 

CONT:
    make_zone_ptr(&z_p, dafs_ze);
    3439:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
    343e:	4c 89 e6             	mov    %r12,%rsi
    3441:	e8 00 00 00 00       	callq  3446 <dafs_rm_dir+0x3a6>
    test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    3446:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
}

static inline int test_and_clear_bit_le(int nr, void *addr)
{
	return test_and_clear_bit(nr ^ BITOP_LE_SWIZZLE, addr);
    344b:	48 63 54 24 28       	movslq 0x28(%rsp),%rdx
    3450:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_clear_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "btr", *addr, "Ir", nr, "%0", "c");
    3453:	f0 48 0f b3 10       	lock btr %rdx,(%rax)
    3458:	72 00                	jb     345a <dafs_rm_dir+0x3ba>
	bitpos++;
    test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    345a:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
    345f:	48 8b 10             	mov    (%rax),%rdx
    3462:	8b 44 24 28          	mov    0x28(%rsp),%eax
    3466:	83 c0 01             	add    $0x1,%eax
    3469:	48 98                	cltq   
    346b:	f0 48 0f b3 02       	lock btr %rax,(%rdx)
    3470:	72 00                	jb     3472 <dafs_rm_dir+0x3d2>
    make_invalid_htable(sb, dzt_ei->ht_head, ph_hash, 1);
    3472:	49 8b 75 18          	mov    0x18(%r13),%rsi
    3476:	b9 01 00 00 00       	mov    $0x1,%ecx
    347b:	4c 89 f2             	mov    %r14,%rdx
    347e:	48 89 df             	mov    %rbx,%rdi
    3481:	e8 00 00 00 00       	callq  3486 <dafs_rm_dir+0x3e6>
    delete_ext(z_p, dafs_de);
    3486:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
    348b:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
    3490:	e8 00 00 00 00       	callq  3495 <dafs_rm_dir+0x3f5>

    if(dafs_de->file_type == ROOT_DIRECTORY) {
    3495:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    349a:	80 b8 82 40 00 00 02 	cmpb   $0x2,0x4082(%rax)
    34a1:	0f 84 0f 02 00 00    	je     36b6 <dafs_rm_dir+0x616>
    }
    /*make invalid sub file only for empty dir
     * free dir_tree*/
    this = NULL;
    next = NULL;
    rm_dir = radix_tree_delete(&dzt_ei->dir_tree, ph_hash);
    34a7:	49 8d 7d 38          	lea    0x38(%r13),%rdi
    34ab:	4c 89 f6             	mov    %r14,%rsi
    34ae:	e8 00 00 00 00       	callq  34b3 <dafs_rm_dir+0x413>
    //BUG_ON(rm_dir==NULL);
    head = &rm_dir->sub_file;
    list_for_each_safe(this, next, head){
    34b3:	4c 8b 78 18          	mov    0x18(%rax),%r15
     * free dir_tree*/
    this = NULL;
    next = NULL;
    rm_dir = radix_tree_delete(&dzt_ei->dir_tree, ph_hash);
    //BUG_ON(rm_dir==NULL);
    head = &rm_dir->sub_file;
    34b7:	48 8d 70 18          	lea    0x18(%rax),%rsi
    }
    /*make invalid sub file only for empty dir
     * free dir_tree*/
    this = NULL;
    next = NULL;
    rm_dir = radix_tree_delete(&dzt_ei->dir_tree, ph_hash);
    34bb:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    34c0:	4c 89 e8             	mov    %r13,%rax
    //BUG_ON(rm_dir==NULL);
    head = &rm_dir->sub_file;
    34c3:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
    list_for_each_safe(this, next, head){
    34c8:	4d 8b 37             	mov    (%r15),%r14
    34cb:	4c 39 fe             	cmp    %r15,%rsi
    34ce:	4d 89 f5             	mov    %r14,%r13
    34d1:	49 89 c6             	mov    %rax,%r14
    34d4:	75 5a                	jne    3530 <dafs_rm_dir+0x490>
        delete_ext(z_p, dafs_de);
        list_del(&rm_sf->list);
        kfree(rm_sf);
    }

    if(rm_dir)
    34d6:	48 83 7c 24 20 00    	cmpq   $0x0,0x20(%rsp)
    34dc:	74 0a                	je     34e8 <dafs_rm_dir+0x448>
        kfree(rm_dir);
    34de:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    34e3:	e8 00 00 00 00       	callq  34e8 <dafs_rm_dir+0x448>
    //kfree(phname);
    //kfree(ph);
    //kfree(phn);
    
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    34e8:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 34ee <dafs_rm_dir+0x44e>
    34ee:	85 c0                	test   %eax,%eax
    34f0:	0f 85 8e 01 00 00    	jne    3684 <dafs_rm_dir+0x5e4>
    kfree(z_p);
    34f6:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
    //kfree(phname);
    //kfree(ph);
    //kfree(phn);
    
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    34fb:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 3503 <dafs_rm_dir+0x463>
    3502:	00 
    kfree(z_p);
    3503:	e8 00 00 00 00       	callq  3508 <dafs_rm_dir+0x468>
    //nova_dbg("%s end",__func__);
	return 0;
    3508:	31 c0                	xor    %eax,%eax
}
    350a:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
    350f:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    3516:	00 00 
    3518:	0f 85 24 02 00 00    	jne    3742 <dafs_rm_dir+0x6a2>
    351e:	48 83 c4 70          	add    $0x70,%rsp
    3522:	5b                   	pop    %rbx
    3523:	41 5c                	pop    %r12
    3525:	41 5d                	pop    %r13
    3527:	41 5e                	pop    %r14
    3529:	41 5f                	pop    %r15
    352b:	5d                   	pop    %rbp
    352c:	c3                   	retq   
    this = NULL;
    next = NULL;
    rm_dir = radix_tree_delete(&dzt_ei->dir_tree, ph_hash);
    //BUG_ON(rm_dir==NULL);
    head = &rm_dir->sub_file;
    list_for_each_safe(this, next, head){
    352d:	49 89 c5             	mov    %rax,%r13
        //nova_dbg("%s list sub",__func__);
        rm_sf = list_entry(this, struct file_p, list);
        sub_pos = rm_sf->pos;
    3530:	41 8b 57 10          	mov    0x10(%r15),%edx
        bitpos = sub_pos*2;
        sub_de = &dafs_ze->dentry[sub_pos];
        sub_hash = le64_to_cpu(sub_de->hname);
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    3534:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
    3539:	48 8b 09             	mov    (%rcx),%rcx
    head = &rm_dir->sub_file;
    list_for_each_safe(this, next, head){
        //nova_dbg("%s list sub",__func__);
        rm_sf = list_entry(this, struct file_p, list);
        sub_pos = rm_sf->pos;
        bitpos = sub_pos*2;
    353c:	8d 04 12             	lea    (%rdx,%rdx,1),%eax
        sub_de = &dafs_ze->dentry[sub_pos];
        sub_hash = le64_to_cpu(sub_de->hname);
    353f:	48 c1 e2 07          	shl    $0x7,%rdx
    3543:	49 8b 94 14 a8 40 00 	mov    0x40a8(%r12,%rdx,1),%rdx
    354a:	00 
    354b:	48 63 f0             	movslq %eax,%rsi
    354e:	f0 48 0f b3 31       	lock btr %rsi,(%rcx)
    3553:	72 00                	jb     3555 <dafs_rm_dir+0x4b5>
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
	    bitpos++;
        test_and_clear_bit_le(bitpos, (void *)z_p->statemap);
    3555:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
    355a:	83 c0 01             	add    $0x1,%eax
    355d:	48 98                	cltq   
    355f:	48 8b 09             	mov    (%rcx),%rcx
    3562:	f0 48 0f b3 01       	lock btr %rax,(%rcx)
    3567:	72 00                	jb     3569 <dafs_rm_dir+0x4c9>
        make_invalid_htable(sb, dzt_ei->ht_head, sub_hash, 1);
    3569:	49 8b 76 18          	mov    0x18(%r14),%rsi
    356d:	b9 01 00 00 00       	mov    $0x1,%ecx
    3572:	48 89 df             	mov    %rbx,%rdi
    3575:	e8 00 00 00 00       	callq  357a <dafs_rm_dir+0x4da>
        delete_ext(z_p, dafs_de);
    357a:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
    357f:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
    3584:	e8 00 00 00 00       	callq  3589 <dafs_rm_dir+0x4e9>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    3589:	49 8b 47 08          	mov    0x8(%r15),%rax
    358d:	49 8b 17             	mov    (%r15),%rdx
        list_del(&rm_sf->list);
        kfree(rm_sf);
    3590:	4c 89 ff             	mov    %r15,%rdi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    3593:	48 89 42 08          	mov    %rax,0x8(%rdx)
	prev->next = next;
    3597:	48 89 10             	mov    %rdx,(%rax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    359a:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
    35a1:	00 ad de 
    35a4:	49 89 07             	mov    %rax,(%r15)
	entry->prev = LIST_POISON2;
    35a7:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
    35ae:	00 ad de 
    35b1:	49 89 47 08          	mov    %rax,0x8(%r15)
    35b5:	4d 89 ef             	mov    %r13,%r15
    35b8:	e8 00 00 00 00       	callq  35bd <dafs_rm_dir+0x51d>
    this = NULL;
    next = NULL;
    rm_dir = radix_tree_delete(&dzt_ei->dir_tree, ph_hash);
    //BUG_ON(rm_dir==NULL);
    head = &rm_dir->sub_file;
    list_for_each_safe(this, next, head){
    35bd:	4c 39 6c 24 28       	cmp    %r13,0x28(%rsp)
    35c2:	49 8b 45 00          	mov    0x0(%r13),%rax
    35c6:	0f 85 61 ff ff ff    	jne    352d <dafs_rm_dir+0x48d>
        delete_ext(z_p, dafs_de);
        list_del(&rm_sf->list);
        kfree(rm_sf);
    }

    if(rm_dir)
    35cc:	48 83 7c 24 20 00    	cmpq   $0x0,0x20(%rsp)
    35d2:	0f 85 06 ff ff ff    	jne    34de <dafs_rm_dir+0x43e>
    35d8:	e9 0b ff ff ff       	jmpq   34e8 <dafs_rm_dir+0x448>
   
    /*remove from par*/
    par_pos = le32_to_cpu(dafs_de->par_pos);
    if(dir->i_ino == NOVA_ROOT_INO || par_pos!=0){
        par_de = &dafs_ze->dentry[par_pos];
        par_hash = le64_to_cpu(par_de->hname);
    35dd:	48 c1 e0 07          	shl    $0x7,%rax
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    35e1:	49 8d 7d 38          	lea    0x38(%r13),%rdi
    35e5:	49 8b b4 04 a8 40 00 	mov    0x40a8(%r12,%rax,1),%rsi
    35ec:	00 
    35ed:	e8 00 00 00 00       	callq  35f2 <dafs_rm_dir+0x552>
        //BUG_ON(par_dir==NULL);
        head = &par_dir->sub_file;
        list_for_each_safe(this, next, head) {
    35f2:	48 8b 50 18          	mov    0x18(%rax),%rdx
    if(dir->i_ino == NOVA_ROOT_INO || par_pos!=0){
        par_de = &dafs_ze->dentry[par_pos];
        par_hash = le64_to_cpu(par_de->hname);
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        //BUG_ON(par_dir==NULL);
        head = &par_dir->sub_file;
    35f6:	48 8d 48 18          	lea    0x18(%rax),%rcx
        list_for_each_safe(this, next, head) {
    35fa:	48 39 d1             	cmp    %rdx,%rcx
    35fd:	48 8b 3a             	mov    (%rdx),%rdi
    3600:	0f 84 33 fe ff ff    	je     3439 <dafs_rm_dir+0x399>
            rm_sf = list_entry(this, struct file_p, list);
            if(rm_sf->pos == de_pos){
    3606:	8b 74 24 3c          	mov    0x3c(%rsp),%esi
    360a:	39 72 10             	cmp    %esi,0x10(%rdx)
    360d:	75 11                	jne    3620 <dafs_rm_dir+0x580>
    360f:	e9 d8 00 00 00       	jmpq   36ec <dafs_rm_dir+0x64c>
    3614:	39 77 10             	cmp    %esi,0x10(%rdi)
    3617:	0f 84 d2 00 00 00    	je     36ef <dafs_rm_dir+0x64f>
        par_de = &dafs_ze->dentry[par_pos];
        par_hash = le64_to_cpu(par_de->hname);
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        //BUG_ON(par_dir==NULL);
        head = &par_dir->sub_file;
        list_for_each_safe(this, next, head) {
    361d:	48 89 d7             	mov    %rdx,%rdi
    3620:	48 39 f9             	cmp    %rdi,%rcx
    3623:	48 8b 17             	mov    (%rdi),%rdx
    3626:	75 ec                	jne    3614 <dafs_rm_dir+0x574>
    3628:	e9 0c fe ff ff       	jmpq   3439 <dafs_rm_dir+0x399>

	links_count = cpu_to_le16(dir->i_nlink);
	if (links_count == 0 && link_change == -1)
		links_count = 0;
	else
		links_count += link_change;
    362d:	0f b7 4c 24 28       	movzwl 0x28(%rsp),%ecx
    3632:	01 d1                	add    %edx,%ecx
    3634:	e9 c8 fd ff ff       	jmpq   3401 <dafs_rm_dir+0x361>
    3639:	48 8d 7c 24 48       	lea    0x48(%rsp),%rdi
    363e:	e8 00 00 00 00       	callq  3643 <dafs_rm_dir+0x5a3>
    3643:	e9 b2 fa ff ff       	jmpq   30fa <dafs_rm_dir+0x5a>
	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
 
    //nova_dbg("%s start",__func__);
    ph = get_dentry_path(dentry,0);
    //nova_dbg("%s start dentry %s",__func__,ph);
    flen= strlen(ph);
    3648:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);

    if(phlen==1){
        memcpy(phname, ph, flen);
    364d:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
    3652:	48 89 cf             	mov    %rcx,%rdi
    3655:	41 89 c1             	mov    %eax,%r9d
	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
 
    //nova_dbg("%s start",__func__);
    ph = get_dentry_path(dentry,0);
    //nova_dbg("%s start dentry %s",__func__,ph);
    flen= strlen(ph);
    3658:	89 44 24 18          	mov    %eax,0x18(%rsp)
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);

    if(phlen==1){
        memcpy(phname, ph, flen);
    365c:	4c 89 ca             	mov    %r9,%rdx
    365f:	4c 89 4c 24 20       	mov    %r9,0x20(%rsp)
    3664:	e8 00 00 00 00       	callq  3669 <dafs_rm_dir+0x5c9>
        phname[flen]='\0';
    3669:	4c 8b 4c 24 20       	mov    0x20(%rsp),%r9
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);

    if(phlen==1){
        memcpy(phname, ph, flen);
    366e:	48 89 c1             	mov    %rax,%rcx
    3671:	44 8b 44 24 18       	mov    0x18(%rsp),%r8d
        phname[flen]='\0';
    3676:	43 c6 84 0e d6 09 00 	movb   $0x0,0x9d6(%r14,%r9,1)
    367d:	00 00 
    367f:	e9 ef fc ff ff       	jmpq   3373 <dafs_rm_dir+0x2d3>
    3684:	48 8d 7c 24 58       	lea    0x58(%rsp),%rdi
    3689:	e8 00 00 00 00       	callq  368e <dafs_rm_dir+0x5ee>
    //kfree(phname);
    //kfree(ph);
    //kfree(phn);
    
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    368e:	48 8b 44 24 58       	mov    0x58(%rsp),%rax
    3693:	48 2b 44 24 48       	sub    0x48(%rsp),%rax
    3698:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    369f:	48 2b 44 24 50       	sub    0x50(%rsp),%rax
    36a4:	48 03 44 24 60       	add    0x60(%rsp),%rax
    36a9:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 36b1 <dafs_rm_dir+0x611>
    36b0:	00 
    36b1:	e9 40 fe ff ff       	jmpq   34f6 <dafs_rm_dir+0x456>
    make_invalid_htable(sb, dzt_ei->ht_head, ph_hash, 1);
    delete_ext(z_p, dafs_de);

    if(dafs_de->file_type == ROOT_DIRECTORY) {
        //nova_dbg("%s dentry is root zone",__func__);
        delete_dir_info(dzt_ei, ph_hash);
    36b6:	4c 89 f6             	mov    %r14,%rsi
    36b9:	4c 89 ef             	mov    %r13,%rdi
    36bc:	e8 00 00 00 00       	callq  36c1 <dafs_rm_dir+0x621>
        ei_hash = le64_to_cpu(dafs_de->dzt_hn);
    36c1:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
    36c6:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
    delete_ext(z_p, dafs_de);

    if(dafs_de->file_type == ROOT_DIRECTORY) {
        //nova_dbg("%s dentry is root zone",__func__);
        delete_dir_info(dzt_ei, ph_hash);
        ei_hash = le64_to_cpu(dafs_de->dzt_hn);
    36cb:	48 c1 e0 07          	shl    $0x7,%rax
        sub_ei = radix_tree_lookup(&dzt_m->dzt_root, ei_hash);
    36cf:	49 8b b4 04 a8 40 00 	mov    0x40a8(%r12,%rax,1),%rsi
    36d6:	00 
    36d7:	e8 00 00 00 00       	callq  36dc <dafs_rm_dir+0x63c>
        free_zone_area(sb, sub_ei);
    36dc:	48 89 df             	mov    %rbx,%rdi
    36df:	48 89 c6             	mov    %rax,%rsi
    36e2:	e8 00 00 00 00       	callq  36e7 <dafs_rm_dir+0x647>
        goto END;
    36e7:	e9 fc fd ff ff       	jmpq   34e8 <dafs_rm_dir+0x448>
        par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        //BUG_ON(par_dir==NULL);
        head = &par_dir->sub_file;
        list_for_each_safe(this, next, head) {
            rm_sf = list_entry(this, struct file_p, list);
            if(rm_sf->pos == de_pos){
    36ec:	48 89 d7             	mov    %rdx,%rdi
                par_dir->sub_num--;
    36ef:	48 83 68 08 01       	subq   $0x1,0x8(%rax)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    36f4:	48 8b 47 08          	mov    0x8(%rdi),%rax
    36f8:	48 8b 17             	mov    (%rdi),%rdx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    36fb:	48 89 42 08          	mov    %rax,0x8(%rdx)
	prev->next = next;
    36ff:	48 89 10             	mov    %rdx,(%rax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    3702:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
    3709:	00 ad de 
    370c:	48 89 07             	mov    %rax,(%rdi)
	entry->prev = LIST_POISON2;
    370f:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
    3716:	00 ad de 
    3719:	48 89 47 08          	mov    %rax,0x8(%rdi)
                list_del(&rm_sf->list);
                kfree(rm_sf);
    371d:	e8 00 00 00 00       	callq  3722 <dafs_rm_dir+0x682>
                goto CONT;
    3722:	e9 12 fd ff ff       	jmpq   3439 <dafs_rm_dir+0x399>

	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);

	if (!dentry->d_name.len){
        //nova_dbg("%s name is null %s",__func__,dentry->d_name.name);
		return -EINVAL;
    3727:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    372c:	e9 d9 fd ff ff       	jmpq   350a <dafs_rm_dir+0x46a>
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    3731:	0f 0b                	ud2    
    BUG_ON(sbi==NULL);
    3733:	0f 0b                	ud2    
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    3735:	45 31 f6             	xor    %r14d,%r14d
    3738:	e9 69 fc ff ff       	jmpq   33a6 <dafs_rm_dir+0x306>
    373d:	e8 00 00 00 00       	callq  3742 <dafs_rm_dir+0x6a2>
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    kfree(z_p);
    //nova_dbg("%s end",__func__);
	return 0;
}
    3742:	e8 00 00 00 00       	callq  3747 <dafs_rm_dir+0x6a7>
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    3747:	4d 8d a0 d7 05 00 00 	lea    0x5d7(%r8),%r12
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
        memcpy(buf,"/",1);
    374e:	41 c6 80 d7 05 00 00 	movb   $0x2f,0x5d7(%r8)
    3755:	2f 
        buf[1]='\0';
    3756:	41 c6 80 d8 05 00 00 	movb   $0x0,0x5d8(%r8)
    375d:	00 
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    375e:	4c 89 e7             	mov    %r12,%rdi
    3761:	4c 89 4c 24 08       	mov    %r9,0x8(%rsp)
    3766:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
    376b:	4c 89 54 24 20       	mov    %r10,0x20(%rsp)
    3770:	e8 00 00 00 00       	callq  3775 <dafs_rm_dir+0x6d5>
    3775:	ba 2f 00 00 00       	mov    $0x2f,%edx
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    377a:	49 8d 7c 04 01       	lea    0x1(%r12,%rax,1),%rdi
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    377f:	66 41 89 14 04       	mov    %dx,(%r12,%rax,1)
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    3784:	49 8b 75 28          	mov    0x28(%r13),%rsi
    3788:	e8 00 00 00 00       	callq  378d <dafs_rm_dir+0x6ed>
        p_dentry = tem_dentry->d_parent;
    378d:	4d 8b 6d 18          	mov    0x18(%r13),%r13
        //plen = strlen(buf);
        //buf[plen]='\0';
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
    3791:	4c 8b 54 24 20       	mov    0x20(%rsp),%r10
    3796:	b9 02 00 00 00       	mov    $0x2,%ecx
    379b:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
    37a0:	4c 8b 4c 24 08       	mov    0x8(%rsp),%r9
    37a5:	49 8b 75 28          	mov    0x28(%r13),%rsi
    37a9:	4c 89 d7             	mov    %r10,%rdi
    37ac:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    37ae:	75 ae                	jne    375e <dafs_rm_dir+0x6be>
    37b0:	49 8b 45 30          	mov    0x30(%r13),%rax
    37b4:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
    37b9:	75 a3                	jne    375e <dafs_rm_dir+0x6be>

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    37bb:	49 8d 80 d6 09 00 00 	lea    0x9d6(%r8),%rax
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    37c2:	4c 89 e2             	mov    %r12,%rdx
    37c5:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    37cc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    37d3:	4c 89 14 24          	mov    %r10,(%rsp)

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    37d7:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    37dc:	e8 00 00 00 00       	callq  37e1 <dafs_rm_dir+0x741>
    tlen = strlen(buf);
    37e1:	31 c0                	xor    %eax,%eax
    37e3:	4c 89 e7             	mov    %r12,%rdi
    37e6:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    37ea:	f2 ae                	repnz scas %es:(%rdi),%al
    memcpy(tem, buf, tlen);
    37ec:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    37f1:	4c 89 e6             	mov    %r12,%rsi
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    tlen = strlen(buf);
    37f4:	48 f7 d1             	not    %rcx
    37f7:	4c 8d 69 ff          	lea    -0x1(%rcx),%r13
    memcpy(tem, buf, tlen);
    37fb:	4c 89 ea             	mov    %r13,%rdx
    37fe:	e8 00 00 00 00       	callq  3803 <dafs_rm_dir+0x763>
    tem[tlen]='\0';
    3803:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
    3808:	4c 8b 4c 24 08       	mov    0x8(%rsp),%r9
    380d:	4c 89 f0             	mov    %r14,%rax
    3810:	4c 8b 14 24          	mov    (%rsp),%r10
    3814:	49 89 de             	mov    %rbx,%r14
    3817:	48 89 c3             	mov    %rax,%rbx
    381a:	43 c6 84 28 d6 09 00 	movb   $0x0,0x9d6(%r8,%r13,1)
    3821:	00 00 
    do{
        ppath = strrchr(tem, '/');
    3823:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    3828:	be 2f 00 00 00       	mov    $0x2f,%esi
    382d:	4c 89 0c 24          	mov    %r9,(%rsp)
    3831:	4c 89 54 24 08       	mov    %r10,0x8(%rsp)
    3836:	e8 00 00 00 00       	callq  383b <dafs_rm_dir+0x79b>
        plen = strlen(ppath);
    383b:	48 89 c7             	mov    %rax,%rdi
    383e:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    3843:	e8 00 00 00 00       	callq  3848 <dafs_rm_dir+0x7a8>
        phlen = tlen - plen;
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    3848:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
    384d:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
    memcpy(tem, buf, tlen);
    tem[tlen]='\0';
    do{
        ppath = strrchr(tem, '/');
        plen = strlen(ppath);
        phlen = tlen - plen;
    3852:	49 29 c5             	sub    %rax,%r13
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    3855:	e8 00 00 00 00       	callq  385a <dafs_rm_dir+0x7ba>
        memcpy(tem, buf, tlen);
    385a:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    385f:	4c 89 e6             	mov    %r12,%rsi
    3862:	4c 89 ea             	mov    %r13,%rdx
    3865:	e8 00 00 00 00       	callq  386a <dafs_rm_dir+0x7ca>
        tem[tlen]='\0';
    386a:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
        if(!strcmp(tem,"/"))
    386f:	4c 8b 54 24 08       	mov    0x8(%rsp),%r10
    3874:	b9 02 00 00 00       	mov    $0x2,%ecx
    3879:	4c 8b 0c 24          	mov    (%rsp),%r9
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
        memcpy(tem, buf, tlen);
        tem[tlen]='\0';
    387d:	42 c6 04 2e 00       	movb   $0x0,(%rsi,%r13,1)
        if(!strcmp(tem,"/"))
    3882:	4c 89 d7             	mov    %r10,%rdi
    3885:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    3887:	75 9a                	jne    3823 <dafs_rm_dir+0x783>
            break;
    }while(1);

    //BUG_ON(strlen(ph)==1023);
    nova_dbg("%s ful ph is %s sbi is %s",__func__,ph, sbi->ph_f);
    3889:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
    388e:	48 89 d8             	mov    %rbx,%rax
    3891:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    3898:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    389f:	4c 89 4c 24 20       	mov    %r9,0x20(%rsp)
    38a4:	4c 89 f3             	mov    %r14,%rbx
    38a7:	49 89 c6             	mov    %rax,%r14
    38aa:	48 89 d1             	mov    %rdx,%rcx
    38ad:	e8 00 00 00 00       	callq  38b2 <dafs_rm_dir+0x812>
    //BUG_ON(ph==NULL);
    
    mntput(vfsmnt);
    38b2:	4c 8b 4c 24 20       	mov    0x20(%rsp),%r9
    38b7:	4c 89 cf             	mov    %r9,%rdi
    38ba:	e8 00 00 00 00       	callq  38bf <dafs_rm_dir+0x81f>
    38bf:	eb 0c                	jmp    38cd <dafs_rm_dir+0x82d>
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    if(!vfsmnt){
        nova_dbg("not find mnt");
    38c1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    38c8:	e8 00 00 00 00       	callq  38cd <dafs_rm_dir+0x82d>
    
    //kfree(buf);
    //kfree(tem);
    //nova_dbg("dafs finish get dentry path");
ERR:
    nova_dbg("%s ful ph is %s len %llu, sbi %s ",__func__,ph, strlen(ph), sbi->ph_f);
    38cd:	4c 8b 64 24 30       	mov    0x30(%rsp),%r12
    38d2:	4c 89 e7             	mov    %r12,%rdi
    38d5:	e8 00 00 00 00       	callq  38da <dafs_rm_dir+0x83a>
    38da:	4d 89 e0             	mov    %r12,%r8
    38dd:	48 89 c1             	mov    %rax,%rcx
    38e0:	4c 89 e2             	mov    %r12,%rdx
    38e3:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    38ea:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    38f1:	e8 00 00 00 00       	callq  38f6 <dafs_rm_dir+0x856>
    38f6:	e9 13 f9 ff ff       	jmpq   320e <dafs_rm_dir+0x16e>
    38fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003900 <dafs_remove_dentry>:
	return 0;
}

/*remove dir when use rename*/
int dafs_remove_dentry(struct dentry *dentry)
{
    3900:	e8 00 00 00 00       	callq  3905 <dafs_remove_dentry+0x5>
    3905:	55                   	push   %rbp
    3906:	48 89 e5             	mov    %rsp,%rbp
    3909:	41 57                	push   %r15
    390b:	41 56                	push   %r14
    390d:	41 55                	push   %r13
    390f:	41 54                	push   %r12
    3911:	49 89 fe             	mov    %rdi,%r14
    3914:	53                   	push   %rbx
    3915:	48 83 ec 58          	sub    $0x58,%rsp
    //char *ph;
    int ret;
	timing_t remove_dentry_time;

    //nova_dbg("%s start %s",__func__,dentry->d_name.name);
	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    3919:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 391f <dafs_remove_dentry+0x1f>
	return 0;
}

/*remove dir when use rename*/
int dafs_remove_dentry(struct dentry *dentry)
{
    391f:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    3926:	00 00 
    3928:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
    392d:	31 c0                	xor    %eax,%eax
    struct inode *dir = dentry->d_parent->d_inode;
    392f:	48 8b 47 18          	mov    0x18(%rdi),%rax
    //char *ph;
    int ret;
	timing_t remove_dentry_time;

    //nova_dbg("%s start %s",__func__,dentry->d_name.name);
	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    3933:	85 f6                	test   %esi,%esi
}

/*remove dir when use rename*/
int dafs_remove_dentry(struct dentry *dentry)
{
    struct inode *dir = dentry->d_parent->d_inode;
    3935:	4c 8b 68 30          	mov    0x30(%rax),%r13
    struct super_block *sb = dir->i_sb;
    3939:	4d 8b 65 28          	mov    0x28(%r13),%r12
    393d:	49 8b 9c 24 b0 03 00 	mov    0x3b0(%r12),%rbx
    3944:	00 
    //char *ph;
    int ret;
	timing_t remove_dentry_time;

    //nova_dbg("%s start %s",__func__,dentry->d_name.name);
	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);
    3945:	0f 85 cc 02 00 00    	jne    3c17 <dafs_remove_dentry+0x317>

	if (!dentry->d_name.len)
    394b:	41 8b 4e 24          	mov    0x24(%r14),%ecx
    394f:	85 c9                	test   %ecx,%ecx
    3951:	0f 84 fa 02 00 00    	je     3c51 <dafs_remove_dentry+0x351>
		return -EINVAL;


	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    3957:	e8 00 00 00 00       	callq  395c <dafs_remove_dentry+0x5c>
    395c:	49 c7 85 80 00 00 00 	movq   $0x0,0x80(%r13)
    3963:	00 00 00 00 
    3967:	49 89 45 78          	mov    %rax,0x78(%r13)
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    396b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi

	if (!dentry->d_name.len)
		return -EINVAL;


	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    3972:	49 8b 45 78          	mov    0x78(%r13),%rax
    3976:	49 8b 95 80 00 00 00 	mov    0x80(%r13),%rdx
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    397d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi

	if (!dentry->d_name.len)
		return -EINVAL;


	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    3984:	49 89 45 68          	mov    %rax,0x68(%r13)
    3988:	49 89 55 70          	mov    %rdx,0x70(%r13)
}

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
    398c:	49 8b 46 18          	mov    0x18(%r14),%rax
    struct super_block *sb = dir->i_sb;
    3990:	48 8b 40 30          	mov    0x30(%rax),%rax
    3994:	48 8b 50 28          	mov    0x28(%rax),%rdx
    3998:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    399f:	00 00 
    struct nova_sb_info *sbi = NOVA_SB(sb);
    char *ph, *buf, *tem, *ppath;
    //char *buf = NULL, *ppath=NULL, *tem=NULL;
    struct fs_struct *fs = current->fs;
    39a1:	4c 8b a8 30 06 00 00 	mov    0x630(%rax),%r13
    39a8:	4c 8b ba b0 03 00 00 	mov    0x3b0(%rdx),%r15
    39af:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    39b4:	e8 00 00 00 00       	callq  39b9 <dafs_remove_dentry+0xb9>
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    39b9:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
    39be:	48 85 d2             	test   %rdx,%rdx
    39c1:	0f 84 c3 02 00 00    	je     3c8a <dafs_remove_dentry+0x38a>
    BUG_ON(sbi==NULL);
    39c7:	4d 85 ff             	test   %r15,%r15
    39ca:	0f 84 bc 02 00 00    	je     3c8c <dafs_remove_dentry+0x38c>
    ph = &sbi->ph_f;
    39d0:	49 8d 87 d8 01 00 00 	lea    0x1d8(%r15),%rax
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    39d7:	49 8d 7d 04          	lea    0x4(%r13),%rdi
    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    39db:	41 c6 87 d8 01 00 00 	movb   $0x0,0x1d8(%r15)
    39e2:	00 
    buf[0]='\0';
    39e3:	41 c6 87 d7 05 00 00 	movb   $0x0,0x5d7(%r15)
    39ea:	00 
    tem[0]='\0';
    39eb:	41 c6 87 d6 09 00 00 	movb   $0x0,0x9d6(%r15)
    39f2:	00 
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    39f3:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    39f8:	e8 00 00 00 00       	callq  39fd <dafs_remove_dentry+0xfd>
    vfsmnt = mntget(fs->pwd.mnt);
    39fd:	49 8b 7d 28          	mov    0x28(%r13),%rdi
    3a01:	e8 00 00 00 00       	callq  3a06 <dafs_remove_dentry+0x106>
    if(!vfsmnt){
    3a06:	48 85 c0             	test   %rax,%rax
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    3a09:	49 89 c0             	mov    %rax,%r8
    if(!vfsmnt){
    3a0c:	0f 84 01 04 00 00    	je     3e13 <dafs_remove_dentry+0x513>
    3a12:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
    3a17:	f0 41 0f c1 45 04    	lock xadd %eax,0x4(%r13)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
    3a1d:	49 8b 76 28          	mov    0x28(%r14),%rsi
    3a21:	49 c7 c3 00 00 00 00 	mov    $0x0,%r11
    3a28:	b9 02 00 00 00       	mov    $0x2,%ecx
    3a2d:	4c 89 df             	mov    %r11,%rdi
    3a30:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    3a32:	0f 85 5d 02 00 00    	jne    3c95 <dafs_remove_dentry+0x395>
        memcpy(buf,"/",1);
        buf[1]='\0';
    }else{
        //nova_dbg("%s root dentry",__func__);
        memcpy(ph, "/", 1);
    3a38:	41 c6 87 d8 01 00 00 	movb   $0x2f,0x1d8(%r15)
    3a3f:	2f 
        ph[1]='\0';
    3a40:	41 c6 87 d9 01 00 00 	movb   $0x0,0x1d9(%r15)
    3a47:	00 
    /*直接rm direntry就可以
    * 先找到相应的dir*/    
    ph = get_dentry_path(dentry,0);
    phname = &sbi->ph_name;
    phn = &sbi->ph_dzt;
    phname[0]='\0';
    3a48:	c6 83 d6 09 00 00 00 	movb   $0x0,0x9d6(%rbx)
    phn[0]='\0';
    3a4f:	c6 83 d7 05 00 00 00 	movb   $0x0,0x5d7(%rbx)
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    3a56:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    3a5d:	49 8b 84 24 b0 03 00 	mov    0x3b0(%r12),%rax
    3a64:	00 
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    3a65:	4c 8b 74 24 20       	mov    0x20(%rsp),%r14
    3a6a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi

    /*直接rm direntry就可以
    * 先找到相应的dir*/    
    ph = get_dentry_path(dentry,0);
    phname = &sbi->ph_name;
    phn = &sbi->ph_dzt;
    3a71:	4c 8d bb d7 05 00 00 	lea    0x5d7(%rbx),%r15
	dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;

    /*直接rm direntry就可以
    * 先找到相应的dir*/    
    ph = get_dentry_path(dentry,0);
    phname = &sbi->ph_name;
    3a78:	4c 8d ab d6 09 00 00 	lea    0x9d6(%rbx),%r13
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    3a7f:	48 8b 80 d8 0d 00 00 	mov    0xdd8(%rax),%rax
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    3a86:	4c 89 f2             	mov    %r14,%rdx
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    3a89:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    3a8e:	e8 00 00 00 00       	callq  3a93 <dafs_remove_dentry+0x193>
    tlen = strlen(phstr);
    3a93:	4c 89 f7             	mov    %r14,%rdi
    3a96:	4c 89 74 24 20       	mov    %r14,0x20(%rsp)
    3a9b:	e8 00 00 00 00       	callq  3aa0 <dafs_remove_dentry+0x1a0>
    nova_dbg("%s length is %llu", __func__, tlen);
    3aa0:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    3aa7:	48 89 c2             	mov    %rax,%rdx
    3aaa:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    tlen = strlen(phstr);
    3ab1:	49 89 c6             	mov    %rax,%r14
    nova_dbg("%s length is %llu", __func__, tlen);
    3ab4:	e8 00 00 00 00       	callq  3ab9 <dafs_remove_dentry+0x1b9>
    memcpy(phs, phstr, tlen);
    3ab9:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
    3abe:	4c 89 f2             	mov    %r14,%rdx
    3ac1:	4c 89 ff             	mov    %r15,%rdi
    3ac4:	e8 00 00 00 00       	callq  3ac9 <dafs_remove_dentry+0x1c9>
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    3ac9:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi

    nova_dbg("%s start %s",__func__,phstr);
    tlen = strlen(phstr);
    nova_dbg("%s length is %llu", __func__, tlen);
    memcpy(phs, phstr, tlen);
    phs[tlen]='\0';
    3ace:	42 c6 84 33 d7 05 00 	movb   $0x0,0x5d7(%rbx,%r14,1)
    3ad5:	00 00 
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    3ad7:	be 2f 00 00 00       	mov    $0x2f,%esi
            return dzt_ei;
        }
    }while(1);
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    3adc:	c6 83 d7 05 00 00 2f 	movb   $0x2f,0x5d7(%rbx)
    phs[1]='\0';
    3ae3:	c6 83 d8 05 00 00 00 	movb   $0x0,0x5d8(%rbx)
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    3aea:	e8 00 00 00 00       	callq  3aef <dafs_remove_dentry+0x1ef>
    if(!dzt_ei){
    3aef:	48 85 c0             	test   %rax,%rax
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    3af2:	49 89 c6             	mov    %rax,%r14
    if(!dzt_ei){
    3af5:	0f 84 13 03 00 00    	je     3e0e <dafs_remove_dentry+0x50e>
    phn[0]='\0';
    //phname = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph));
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    3afb:	48 8b 40 10          	mov    0x10(%rax),%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    3aff:	49 8b 94 24 b0 03 00 	mov    0x3b0(%r12),%rdx
    3b06:	00 
    phlen = strlen(phn);
    3b07:	4c 89 ff             	mov    %r15,%rdi
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    3b0a:	48 89 c1             	mov    %rax,%rcx
    3b0d:	48 03 4a 18          	add    0x18(%rdx),%rcx
    3b11:	48 85 c0             	test   %rax,%rax
    3b14:	b8 00 00 00 00       	mov    $0x0,%eax
    3b19:	48 0f 45 c1          	cmovne %rcx,%rax
    3b1d:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    3b22:	e8 00 00 00 00       	callq  3b27 <dafs_remove_dentry+0x227>
    if(phlen==1){
    3b27:	48 83 f8 01          	cmp    $0x1,%rax
    3b2b:	0f 84 f5 00 00 00    	je     3c26 <dafs_remove_dentry+0x326>
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    3b31:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    3b36:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    3b3b:	e8 00 00 00 00       	callq  3b40 <dafs_remove_dentry+0x240>
    3b40:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
        memcpy(phname, ph+phlen, flen);
    3b45:	4c 89 ef             	mov    %r13,%rdi
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    3b48:	48 29 f0             	sub    %rsi,%rax
        memcpy(phname, ph+phlen, flen);
    3b4b:	48 03 74 24 20       	add    0x20(%rsp),%rsi
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    3b50:	49 89 c7             	mov    %rax,%r15
        memcpy(phname, ph+phlen, flen);
    3b53:	48 89 c2             	mov    %rax,%rdx
    3b56:	e8 00 00 00 00       	callq  3b5b <dafs_remove_dentry+0x25b>
        phname[flen]='\0';
    3b5b:	42 c6 84 3b d6 09 00 	movb   $0x0,0x9d6(%rbx,%r15,1)
    3b62:	00 00 
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    3b64:	45 85 ff             	test   %r15d,%r15d
    3b67:	0f 8e 21 01 00 00    	jle    3c8e <dafs_remove_dentry+0x38e>
    3b6d:	41 8d 47 ff          	lea    -0x1(%r15),%eax
    3b71:	31 d2                	xor    %edx,%edx
    3b73:	49 8d 74 05 01       	lea    0x1(%r13,%rax,1),%rsi
		hash = hash * seed + (*str++);
    3b78:	48 89 d0             	mov    %rdx,%rax
    3b7b:	49 83 c5 01          	add    $0x1,%r13
    3b7f:	48 c1 e0 05          	shl    $0x5,%rax
    3b83:	48 29 d0             	sub    %rdx,%rax
    3b86:	48 89 c2             	mov    %rax,%rdx
    3b89:	49 0f be 45 ff       	movsbq -0x1(%r13),%rax
    3b8e:	48 01 c2             	add    %rax,%rdx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    3b91:	4c 39 ee             	cmp    %r13,%rsi
    3b94:	75 e2                	jne    3b78 <dafs_remove_dentry+0x278>
    dzt_eno = dzt_ei->dzt_eno;
    ph_hash = BKDRHash(phname, flen);

    /*lookup in hash table*/
    //nova_dbg("%s lookup for %s, hash value %llu",__func__,phname, ph_hash);
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    3b96:	49 8b 76 18          	mov    0x18(%r14),%rsi
    3b9a:	4c 8d 44 24 2c       	lea    0x2c(%rsp),%r8
    3b9f:	b9 01 00 00 00       	mov    $0x1,%ecx
    3ba4:	4c 89 e7             	mov    %r12,%rdi
    3ba7:	e8 00 00 00 00       	callq  3bac <dafs_remove_dentry+0x2ac>
    if(!ret){
    3bac:	85 c0                	test   %eax,%eax
    3bae:	0f 84 9d 00 00 00    	je     3c51 <dafs_remove_dentry+0x351>
        //nova_dbg("not find in hashtable");
        return -EINVAL;
    }

    dafs_de = &dafs_ze->dentry[de_pos];
    3bb4:	8b 74 24 2c          	mov    0x2c(%rsp),%esi
    3bb8:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    /*
    de_addr = le64_to_cpu(&dafs_de);
    record_dir_log(sb, de_addr, 0, DIR_RMDIR);*/

    
    ret = __remove_direntry(sb, dafs_de, dafs_ze, dzt_ei, de_pos);
    3bbd:	4c 89 f1             	mov    %r14,%rcx
    3bc0:	4c 89 e7             	mov    %r12,%rdi
    3bc3:	48 89 c2             	mov    %rax,%rdx
    if(!ret){
        //nova_dbg("not find in hashtable");
        return -EINVAL;
    }

    dafs_de = &dafs_ze->dentry[de_pos];
    3bc6:	49 89 f0             	mov    %rsi,%r8
    3bc9:	48 81 c6 81 00 00 00 	add    $0x81,%rsi
    3bd0:	48 c1 e6 07          	shl    $0x7,%rsi
    3bd4:	48 01 c6             	add    %rax,%rsi
    /*
    de_addr = le64_to_cpu(&dafs_de);
    record_dir_log(sb, de_addr, 0, DIR_RMDIR);*/

    
    ret = __remove_direntry(sb, dafs_de, dafs_ze, dzt_ei, de_pos);
    3bd7:	e8 44 e3 ff ff       	callq  1f20 <__remove_direntry>

    if(ret){
    3bdc:	85 c0                	test   %eax,%eax
    3bde:	75 14                	jne    3bf4 <dafs_remove_dentry+0x2f4>
    //kfree(phname);
    //kfree(phn);
    //kfree(ph);
    
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    3be0:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 3be6 <dafs_remove_dentry+0x2e6>
    3be6:	85 c0                	test   %eax,%eax
    3be8:	75 6e                	jne    3c58 <dafs_remove_dentry+0x358>
    //nova_dbg("%s end", __func__);
	return 0;
    3bea:	31 c0                	xor    %eax,%eax
    //kfree(phname);
    //kfree(phn);
    //kfree(ph);
    
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    3bec:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 3bf4 <dafs_remove_dentry+0x2f4>
    3bf3:	00 
    //nova_dbg("%s end", __func__);
	return 0;
}
    3bf4:	48 8b 4c 24 50       	mov    0x50(%rsp),%rcx
    3bf9:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
    3c00:	00 00 
    3c02:	0f 85 01 02 00 00    	jne    3e09 <dafs_remove_dentry+0x509>
    3c08:	48 83 c4 58          	add    $0x58,%rsp
    3c0c:	5b                   	pop    %rbx
    3c0d:	41 5c                	pop    %r12
    3c0f:	41 5d                	pop    %r13
    3c11:	41 5e                	pop    %r14
    3c13:	41 5f                	pop    %r15
    3c15:	5d                   	pop    %rbp
    3c16:	c3                   	retq   
    3c17:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
    3c1c:	e8 00 00 00 00       	callq  3c21 <dafs_remove_dentry+0x321>
    3c21:	e9 25 fd ff ff       	jmpq   394b <dafs_remove_dentry+0x4b>
    //memcpy(phname, ph, strlen(ph));
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
    3c26:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    3c2b:	e8 00 00 00 00       	callq  3c30 <dafs_remove_dentry+0x330>
        memcpy(phname, ph, flen);
    3c30:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
    //memcpy(phname, ph, strlen(ph));
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
    3c35:	49 89 c7             	mov    %rax,%r15
        memcpy(phname, ph, flen);
    3c38:	48 89 c2             	mov    %rax,%rdx
    3c3b:	4c 89 ef             	mov    %r13,%rdi
    3c3e:	e8 00 00 00 00       	callq  3c43 <dafs_remove_dentry+0x343>
        phname[flen]='\0';
    3c43:	42 c6 84 3b d6 09 00 	movb   $0x0,0x9d6(%rbx,%r15,1)
    3c4a:	00 00 
    3c4c:	e9 13 ff ff ff       	jmpq   3b64 <dafs_remove_dentry+0x264>

    //nova_dbg("%s start %s",__func__,dentry->d_name.name);
	NOVA_START_TIMING(remove_dentry_t, remove_dentry_time);

	if (!dentry->d_name.len)
		return -EINVAL;
    3c51:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    3c56:	eb 9c                	jmp    3bf4 <dafs_remove_dentry+0x2f4>
    3c58:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
    3c5d:	e8 00 00 00 00       	callq  3c62 <dafs_remove_dentry+0x362>
    //kfree(phname);
    //kfree(phn);
    //kfree(ph);
    
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    3c62:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
    3c67:	48 2b 44 24 30       	sub    0x30(%rsp),%rax
    3c6c:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    3c73:	48 2b 44 24 38       	sub    0x38(%rsp),%rax
    3c78:	48 03 44 24 48       	add    0x48(%rsp),%rax
    3c7d:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 3c85 <dafs_remove_dentry+0x385>
    3c84:	00 
    3c85:	e9 60 ff ff ff       	jmpq   3bea <dafs_remove_dentry+0x2ea>
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    3c8a:	0f 0b                	ud2    
    BUG_ON(sbi==NULL);
    3c8c:	0f 0b                	ud2    
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    3c8e:	31 d2                	xor    %edx,%edx
    3c90:	e9 01 ff ff ff       	jmpq   3b96 <dafs_remove_dentry+0x296>
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    3c95:	49 8d 87 d7 05 00 00 	lea    0x5d7(%r15),%rax
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
        memcpy(buf,"/",1);
    3c9c:	41 c6 87 d7 05 00 00 	movb   $0x2f,0x5d7(%r15)
    3ca3:	2f 
        buf[1]='\0';
    3ca4:	41 c6 87 d8 05 00 00 	movb   $0x0,0x5d8(%r15)
    3cab:	00 
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    3cac:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    3cb1:	4c 8b 6c 24 18       	mov    0x18(%rsp),%r13
    3cb6:	4c 89 5c 24 08       	mov    %r11,0x8(%rsp)
    3cbb:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
    3cc0:	4c 89 ef             	mov    %r13,%rdi
    3cc3:	e8 00 00 00 00       	callq  3cc8 <dafs_remove_dentry+0x3c8>
    3cc8:	ba 2f 00 00 00       	mov    $0x2f,%edx
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    3ccd:	49 8d 7c 05 01       	lea    0x1(%r13,%rax,1),%rdi
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    3cd2:	66 41 89 54 05 00    	mov    %dx,0x0(%r13,%rax,1)
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    3cd8:	49 8b 76 28          	mov    0x28(%r14),%rsi
    3cdc:	e8 00 00 00 00       	callq  3ce1 <dafs_remove_dentry+0x3e1>
        p_dentry = tem_dentry->d_parent;
    3ce1:	4d 8b 76 18          	mov    0x18(%r14),%r14
        //plen = strlen(buf);
        //buf[plen]='\0';
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
    3ce5:	4c 8b 5c 24 08       	mov    0x8(%rsp),%r11
    3cea:	b9 02 00 00 00       	mov    $0x2,%ecx
    3cef:	4c 8b 44 24 10       	mov    0x10(%rsp),%r8
    3cf4:	49 8b 76 28          	mov    0x28(%r14),%rsi
    3cf8:	4c 89 df             	mov    %r11,%rdi
    3cfb:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    3cfd:	75 b2                	jne    3cb1 <dafs_remove_dentry+0x3b1>
    3cff:	49 8b 46 30          	mov    0x30(%r14),%rax
    3d03:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
    3d08:	75 a7                	jne    3cb1 <dafs_remove_dentry+0x3b1>
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    3d0a:	4c 8b 74 24 18       	mov    0x18(%rsp),%r14

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    3d0f:	49 8d 87 d6 09 00 00 	lea    0x9d6(%r15),%rax
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    3d16:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    3d1d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    3d24:	4c 89 1c 24          	mov    %r11,(%rsp)
    3d28:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    3d2d:	49 89 c5             	mov    %rax,%r13
    3d30:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    3d35:	4c 89 f2             	mov    %r14,%rdx
    3d38:	e8 00 00 00 00       	callq  3d3d <dafs_remove_dentry+0x43d>
    tlen = strlen(buf);
    3d3d:	4c 89 74 24 18       	mov    %r14,0x18(%rsp)
    3d42:	4c 89 f7             	mov    %r14,%rdi
    3d45:	31 c0                	xor    %eax,%eax
    3d47:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    3d4b:	4c 89 f6             	mov    %r14,%rsi
    3d4e:	f2 ae                	repnz scas %es:(%rdi),%al
    memcpy(tem, buf, tlen);
    3d50:	4c 89 ef             	mov    %r13,%rdi
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    tlen = strlen(buf);
    3d53:	48 89 c8             	mov    %rcx,%rax
    3d56:	48 f7 d0             	not    %rax
    3d59:	4c 8d 70 ff          	lea    -0x1(%rax),%r14
    memcpy(tem, buf, tlen);
    3d5d:	4c 89 f2             	mov    %r14,%rdx
    3d60:	e8 00 00 00 00       	callq  3d65 <dafs_remove_dentry+0x465>
    tem[tlen]='\0';
    3d65:	4c 8b 1c 24          	mov    (%rsp),%r11
    3d69:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
    3d6e:	43 c6 84 37 d6 09 00 	movb   $0x0,0x9d6(%r15,%r14,1)
    3d75:	00 00 
    do{
        ppath = strrchr(tem, '/');
    3d77:	4c 8b 7c 24 10       	mov    0x10(%rsp),%r15
    3d7c:	be 2f 00 00 00       	mov    $0x2f,%esi
    3d81:	4c 89 1c 24          	mov    %r11,(%rsp)
    3d85:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
    3d8a:	4c 89 ff             	mov    %r15,%rdi
    3d8d:	e8 00 00 00 00       	callq  3d92 <dafs_remove_dentry+0x492>
        plen = strlen(ppath);
    3d92:	48 89 c7             	mov    %rax,%rdi
    nova_dbg("%s buf is %s",__func__, buf);
    tlen = strlen(buf);
    memcpy(tem, buf, tlen);
    tem[tlen]='\0';
    do{
        ppath = strrchr(tem, '/');
    3d95:	49 89 c5             	mov    %rax,%r13
        plen = strlen(ppath);
    3d98:	e8 00 00 00 00       	callq  3d9d <dafs_remove_dentry+0x49d>
        phlen = tlen - plen;
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    3d9d:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
    3da2:	4c 89 ee             	mov    %r13,%rsi
    memcpy(tem, buf, tlen);
    tem[tlen]='\0';
    do{
        ppath = strrchr(tem, '/');
        plen = strlen(ppath);
        phlen = tlen - plen;
    3da5:	49 29 c6             	sub    %rax,%r14
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    3da8:	e8 00 00 00 00       	callq  3dad <dafs_remove_dentry+0x4ad>
        memcpy(tem, buf, tlen);
    3dad:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
    3db2:	4c 89 ff             	mov    %r15,%rdi
    3db5:	4c 89 f2             	mov    %r14,%rdx
    3db8:	e8 00 00 00 00       	callq  3dbd <dafs_remove_dentry+0x4bd>
        tem[tlen]='\0';
        if(!strcmp(tem,"/"))
    3dbd:	4c 8b 1c 24          	mov    (%rsp),%r11
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
        memcpy(tem, buf, tlen);
        tem[tlen]='\0';
    3dc1:	4c 89 fe             	mov    %r15,%rsi
    3dc4:	43 c6 04 37 00       	movb   $0x0,(%r15,%r14,1)
        if(!strcmp(tem,"/"))
    3dc9:	b9 02 00 00 00       	mov    $0x2,%ecx
    3dce:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
    3dd3:	4c 89 df             	mov    %r11,%rdi
    3dd6:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    3dd8:	75 9d                	jne    3d77 <dafs_remove_dentry+0x477>
            break;
    }while(1);

    //BUG_ON(strlen(ph)==1023);
    nova_dbg("%s ful ph is %s sbi is %s",__func__,ph, sbi->ph_f);
    3dda:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
    3ddf:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    3de6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    3ded:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
    3df2:	48 89 d1             	mov    %rdx,%rcx
    3df5:	e8 00 00 00 00       	callq  3dfa <dafs_remove_dentry+0x4fa>
    //BUG_ON(ph==NULL);
    
    mntput(vfsmnt);
    3dfa:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
    3dff:	4c 89 c7             	mov    %r8,%rdi
    3e02:	e8 00 00 00 00       	callq  3e07 <dafs_remove_dentry+0x507>
    3e07:	eb 16                	jmp    3e1f <dafs_remove_dentry+0x51f>
    
    
    NOVA_END_TIMING(remove_dentry_t, remove_dentry_time);
    //nova_dbg("%s end", __func__);
	return 0;
}
    3e09:	e8 00 00 00 00       	callq  3e0e <dafs_remove_dentry+0x50e>
    3e0e:	e8 00 00 00 00       	callq  3e13 <dafs_remove_dentry+0x513>
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    if(!vfsmnt){
        nova_dbg("not find mnt");
    3e13:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    3e1a:	e8 00 00 00 00       	callq  3e1f <dafs_remove_dentry+0x51f>
    
    //kfree(buf);
    //kfree(tem);
    //nova_dbg("dafs finish get dentry path");
ERR:
    nova_dbg("%s ful ph is %s len %llu, sbi %s ",__func__,ph, strlen(ph), sbi->ph_f);
    3e1f:	4c 8b 7c 24 20       	mov    0x20(%rsp),%r15
    3e24:	4c 89 ff             	mov    %r15,%rdi
    3e27:	e8 00 00 00 00       	callq  3e2c <dafs_remove_dentry+0x52c>
    3e2c:	4d 89 f8             	mov    %r15,%r8
    3e2f:	48 89 c1             	mov    %rax,%rcx
    3e32:	4c 89 fa             	mov    %r15,%rdx
    3e35:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    3e3c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    3e43:	e8 00 00 00 00       	callq  3e48 <dafs_remove_dentry+0x548>
    3e48:	e9 fb fb ff ff       	jmpq   3a48 <dafs_remove_dentry+0x148>
    3e4d:	0f 1f 00             	nopl   (%rax)

0000000000003e50 <dafs_append_dir_init_entries>:
}

/*append . and .. entries*/
int dafs_append_dir_init_entries(struct super_block *sb, u32 par_pos, struct dzt_entry_info *dzt_ei,
                                 u64 self_ino, u64 parent_ino, const char *ful_name)
{
    3e50:	e8 00 00 00 00       	callq  3e55 <dafs_append_dir_init_entries+0x5>
    3e55:	55                   	push   %rbp
    3e56:	48 89 e5             	mov    %rsp,%rbp
    3e59:	41 57                	push   %r15
    3e5b:	41 56                	push   %r14
    3e5d:	41 55                	push   %r13
    3e5f:	41 54                	push   %r12
    3e61:	4d 89 cf             	mov    %r9,%r15
    3e64:	53                   	push   %rbx
    3e65:	48 83 ec 60          	sub    $0x60,%rsp
    3e69:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
    u32 cur_pos = 0;
    //int ret;
	

    //nova_dbg("%s start ino is %llu, par_ino is %llu", __func__, self_ino, parent_ino);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    3e6d:	48 8b 42 10          	mov    0x10(%rdx),%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    3e71:	48 8b 97 b0 03 00 00 	mov    0x3b0(%rdi),%rdx
}

/*append . and .. entries*/
int dafs_append_dir_init_entries(struct super_block *sb, u32 par_pos, struct dzt_entry_info *dzt_ei,
                                 u64 self_ino, u64 parent_ino, const char *ful_name)
{
    3e78:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)

    //nova_dbg("%s start ino is %llu, par_ino is %llu", __func__, self_ino, parent_ino);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    //nova_dbg("par ze addr is %llu", dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    3e7c:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
}

/*append . and .. entries*/
int dafs_append_dir_init_entries(struct super_block *sb, u32 par_pos, struct dzt_entry_info *dzt_ei,
                                 u64 self_ino, u64 parent_ino, const char *ful_name)
{
    3e80:	65 48 8b 1c 25 28 00 	mov    %gs:0x28,%rbx
    3e87:	00 00 
    3e89:	48 89 5d d0          	mov    %rbx,-0x30(%rbp)
    3e8d:	31 db                	xor    %ebx,%ebx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    3e8f:	49 89 c5             	mov    %rax,%r13
    3e92:	89 75 a8             	mov    %esi,-0x58(%rbp)
    3e95:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    3e99:	4c 03 6a 18          	add    0x18(%rdx),%r13
    3e9d:	48 85 c0             	test   %rax,%rax
    3ea0:	b8 00 00 00 00       	mov    $0x0,%eax
    3ea5:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
    3eac:	4c 0f 44 e8          	cmove  %rax,%r13
    //nova_dbg("%s start ino is %llu, par_ino is %llu", __func__, self_ino, parent_ino);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    //nova_dbg("par ze addr is %llu", dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    bitpos = 0;
    3eb0:	45 31 e4             	xor    %r12d,%r12d

    //nova_dbg("%s start ino is %llu, par_ino is %llu", __func__, self_ino, parent_ino);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    //nova_dbg("par ze addr is %llu", dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    3eb3:	4c 89 ee             	mov    %r13,%rsi
    3eb6:	e8 00 00 00 00       	callq  3ebb <dafs_append_dir_init_entries+0x6b>
    3ebb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3ebf:	48 8b 30             	mov    (%rax),%rsi
    3ec2:	31 c0                	xor    %eax,%eax
    3ec4:	eb 18                	jmp    3ede <dafs_append_dir_init_entries+0x8e>
    bitpos = 0;
    while(cur_pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
            bitpos+=2;
    3ec6:	41 83 c4 02          	add    $0x2,%r12d
            cur_pos++;
    3eca:	83 c3 01             	add    $0x1,%ebx
    3ecd:	48 83 c0 02          	add    $0x2,%rax
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    //nova_dbg("par ze addr is %llu", dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    bitpos = 0;
    while(cur_pos<NR_DENTRY_IN_ZONE){
    3ed1:	41 81 fc fe ff 01 00 	cmp    $0x1fffe,%r12d
    3ed8:	0f 84 a2 04 00 00    	je     4380 <dafs_append_dir_init_entries+0x530>

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    3ede:	48 0f a3 06          	bt     %rax,(%rsi)
    3ee2:	19 d2                	sbb    %edx,%edx
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
    3ee4:	85 d2                	test   %edx,%edx
    3ee6:	75 de                	jne    3ec6 <dafs_append_dir_init_entries+0x76>
    3ee8:	48 8d 48 01          	lea    0x1(%rax),%rcx
    3eec:	48 0f a3 0e          	bt     %rcx,(%rsi)
    3ef0:	19 d2                	sbb    %edx,%edx
    3ef2:	85 d2                	test   %edx,%edx
    3ef4:	75 d0                	jne    3ec6 <dafs_append_dir_init_entries+0x76>
    /* if not enough entries, negtive split*/
    if(cur_pos == NR_DENTRY_IN_ZONE){
        dafs_split_zone(sb, dzt_ei, 0, NEGTIVE_SPLIT);
    }

    p_len = strlen(ful_name);
    3ef6:	4c 89 ff             	mov    %r15,%rdi
    3ef9:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
    3efd:	e8 00 00 00 00       	callq  3f02 <dafs_append_dir_init_entries+0xb2>
    3f02:	48 8d 78 04          	lea    0x4(%rax),%rdi
    3f06:	be d0 80 00 00       	mov    $0x80d0,%esi
    3f0b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    3f0f:	e8 00 00 00 00       	callq  3f14 <dafs_append_dir_init_entries+0xc4>
    phn_f = kzalloc(sizeof(char)*(p_len+4), GFP_KERNEL);
    memcpy(phn_f, ful_name, p_len);
    3f14:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    3f18:	4c 89 fe             	mov    %r15,%rsi
    3f1b:	48 89 c7             	mov    %rax,%rdi
    phn_f[p_len]='\0';

    dafs_de = &dafs_ze->dentry[cur_pos];
    3f1e:	41 89 df             	mov    %ebx,%r15d
    3f21:	49 89 c6             	mov    %rax,%r14
        dafs_split_zone(sb, dzt_ei, 0, NEGTIVE_SPLIT);
    }

    p_len = strlen(ful_name);
    phn_f = kzalloc(sizeof(char)*(p_len+4), GFP_KERNEL);
    memcpy(phn_f, ful_name, p_len);
    3f24:	e8 00 00 00 00       	callq  3f29 <dafs_append_dir_init_entries+0xd9>
    3f29:	4c 89 fe             	mov    %r15,%rsi
    phn_f[p_len]='\0';
    3f2c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax

    dafs_de = &dafs_ze->dentry[cur_pos];
    3f30:	4d 8d 97 81 00 00 00 	lea    0x81(%r15),%r10
    3f37:	48 c1 e6 07          	shl    $0x7,%rsi
    3f3b:	49 8d 54 35 00       	lea    0x0(%r13,%rsi,1),%rdx
    3f40:	49 c1 e2 07          	shl    $0x7,%r10
    3f44:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 1;
    dafs_de->links_count = 1;
    3f48:	be 01 00 00 00       	mov    $0x1,%esi
    }

    p_len = strlen(ful_name);
    phn_f = kzalloc(sizeof(char)*(p_len+4), GFP_KERNEL);
    memcpy(phn_f, ful_name, p_len);
    phn_f[p_len]='\0';
    3f4d:	41 c6 04 06 00       	movb   $0x0,(%r14,%rax,1)

    dafs_de = &dafs_ze->dentry[cur_pos];
    3f52:	4d 01 ea             	add    %r13,%r10
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 1;
    dafs_de->links_count = 1;
    3f55:	66 89 b2 86 40 00 00 	mov    %si,0x4086(%rdx)
    phn_f = kzalloc(sizeof(char)*(p_len+4), GFP_KERNEL);
    memcpy(phn_f, ful_name, p_len);
    phn_f[p_len]='\0';

    dafs_de = &dafs_ze->dentry[cur_pos];
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    3f5c:	c6 82 80 40 00 00 06 	movb   $0x6,0x4080(%rdx)
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    3f63:	c6 82 82 40 00 00 00 	movb   $0x0,0x4082(%rdx)
    dafs_de->name_len = 1;
    3f6a:	c6 82 81 40 00 00 01 	movb   $0x1,0x4081(%rdx)
    p_len = strlen(ful_name);
    phn_f = kzalloc(sizeof(char)*(p_len+4), GFP_KERNEL);
    memcpy(phn_f, ful_name, p_len);
    phn_f[p_len]='\0';

    dafs_de = &dafs_ze->dentry[cur_pos];
    3f71:	4c 89 55 88          	mov    %r10,-0x78(%rbp)
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 1;
    dafs_de->links_count = 1;
    3f75:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    3f79:	e8 00 00 00 00       	callq  3f7e <dafs_append_dir_init_entries+0x12e>
    3f7e:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
    /*if not super root sub init file, then isr_sf = 0*/
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(self_ino);
    3f82:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    dafs_de->size = sb->s_blocksize;
    dafs_de->par_pos = cpu_to_le32(par_pos);
    
    memcpy(dafs_de->name, ".", 1);
    3f86:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
    dafs_de->name[1]='\0';

    /*set ful_name*/
    p_len += 2;
    dafs_de->fname_len = cpu_to_le64(p_len);
    if(p_len == 3)
    3f8a:	4c 8b 55 88          	mov    -0x78(%rbp),%r10
    3f8e:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
    dafs_de->name_len = 1;
    dafs_de->links_count = 1;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    /*if not super root sub init file, then isr_sf = 0*/
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(self_ino);
    3f92:	48 89 ba 98 40 00 00 	mov    %rdi,0x4098(%rdx)
    dafs_de->size = sb->s_blocksize;
    3f99:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 1;
    dafs_de->links_count = 1;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    3f9d:	89 82 88 40 00 00    	mov    %eax,0x4088(%rdx)
    /*if not super root sub init file, then isr_sf = 0*/
    dafs_de->isr_sf = 0;
    3fa3:	c6 82 83 40 00 00 00 	movb   $0x0,0x4083(%rdx)
    3faa:	48 89 4d 88          	mov    %rcx,-0x78(%rbp)
    3fae:	4c 89 55 98          	mov    %r10,-0x68(%rbp)
    dafs_de->ino = cpu_to_le64(self_ino);
    dafs_de->size = sb->s_blocksize;
    3fb2:	48 8b 47 18          	mov    0x18(%rdi),%rax
    dafs_de->par_pos = cpu_to_le32(par_pos);
    3fb6:	8b 7d a8             	mov    -0x58(%rbp),%edi
    3fb9:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
    dafs_de->links_count = 1;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    /*if not super root sub init file, then isr_sf = 0*/
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(self_ino);
    dafs_de->size = sb->s_blocksize;
    3fbd:	48 89 82 a0 40 00 00 	mov    %rax,0x40a0(%rdx)
    
    memcpy(dafs_de->name, ".", 1);
    dafs_de->name[1]='\0';

    /*set ful_name*/
    p_len += 2;
    3fc4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    /*if not super root sub init file, then isr_sf = 0*/
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(self_ino);
    dafs_de->size = sb->s_blocksize;
    dafs_de->par_pos = cpu_to_le32(par_pos);
    3fc8:	89 ba 8c 40 00 00    	mov    %edi,0x408c(%rdx)
    
    memcpy(dafs_de->name, ".", 1);
    3fce:	41 c6 84 35 b0 40 00 	movb   $0x2e,0x40b0(%r13,%rsi,1)
    3fd5:	00 2e 

    /*set ful_name*/
    p_len += 2;
    dafs_de->fname_len = cpu_to_le64(p_len);
    if(p_len == 3)
        strcat(phn_f, ".");
    3fd7:	4c 89 f7             	mov    %r14,%rdi
    dafs_de->ino = cpu_to_le64(self_ino);
    dafs_de->size = sb->s_blocksize;
    dafs_de->par_pos = cpu_to_le32(par_pos);
    
    memcpy(dafs_de->name, ".", 1);
    dafs_de->name[1]='\0';
    3fda:	c6 82 b1 40 00 00 00 	movb   $0x0,0x40b1(%rdx)

    /*set ful_name*/
    p_len += 2;
    3fe1:	48 8d 70 02          	lea    0x2(%rax),%rsi
    dafs_de->fname_len = cpu_to_le64(p_len);
    if(p_len == 3)
    3fe5:	48 83 fe 03          	cmp    $0x3,%rsi
    memcpy(dafs_de->name, ".", 1);
    dafs_de->name[1]='\0';

    /*set ful_name*/
    p_len += 2;
    dafs_de->fname_len = cpu_to_le64(p_len);
    3fe9:	48 89 b2 90 40 00 00 	mov    %rsi,0x4090(%rdx)
    3ff0:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
    if(p_len == 3)
    3ff4:	0f 84 a6 03 00 00    	je     43a0 <dafs_append_dir_init_entries+0x550>
        strcat(phn_f, ".");
    else
        strcat(phn_f, "/.");
    3ffa:	e8 00 00 00 00       	callq  3fff <dafs_append_dir_init_entries+0x1af>
    3fff:	ba 2f 2e 00 00       	mov    $0x2e2f,%edx
    4004:	4c 01 f0             	add    %r14,%rax
    4007:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
    400b:	66 89 10             	mov    %dx,(%rax)
    400e:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
    4012:	4c 8b 55 98          	mov    -0x68(%rbp),%r10
    4016:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
    401a:	c6 40 02 00          	movb   $0x0,0x2(%rax)
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    401e:	4c 89 f8             	mov    %r15,%rax
    dafs_de->ext_flag=0;
    4021:	45 31 db             	xor    %r11d,%r11d
    if(p_len == 3)
        strcat(phn_f, ".");
    else
        strcat(phn_f, "/.");
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    4024:	48 c1 e0 07          	shl    $0x7,%rax
    4028:	41 c6 84 05 d8 40 00 	movb   $0x0,0x40d8(%r13,%rax,1)
    402f:	00 00 
    dafs_de->ext_flag=0;
     
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    4031:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
        strcat(phn_f, ".");
    else
        strcat(phn_f, "/.");
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    dafs_de->ext_flag=0;
    4035:	66 44 89 9a 84 40 00 	mov    %r11w,0x4084(%rdx)
    403c:	00 
     
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    403d:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    4040:	f0 48 0f ab 08       	lock bts %rcx,(%rax)
    4045:	72 00                	jb     4047 <dafs_append_dir_init_entries+0x1f7>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    4047:	85 f6                	test   %esi,%esi
    bitpos++;
    4049:	45 8d 4c 24 02       	lea    0x2(%r12),%r9d
    404e:	0f 8e 70 03 00 00    	jle    43c4 <dafs_append_dir_init_entries+0x574>
    4054:	8d 46 ff             	lea    -0x1(%rsi),%eax
    4057:	4c 89 f1             	mov    %r14,%rcx
    405a:	31 d2                	xor    %edx,%edx
    405c:	49 8d 74 06 01       	lea    0x1(%r14,%rax,1),%rsi
		hash = hash * seed + (*str++);
    4061:	48 89 d0             	mov    %rdx,%rax
    4064:	48 83 c1 01          	add    $0x1,%rcx
    4068:	48 c1 e0 05          	shl    $0x5,%rax
    406c:	48 29 d0             	sub    %rdx,%rax
    406f:	48 89 c2             	mov    %rax,%rdx
    4072:	48 0f be 41 ff       	movsbq -0x1(%rcx),%rax
    4077:	48 01 c2             	add    %rax,%rdx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    407a:	48 39 f1             	cmp    %rsi,%rcx
    407d:	75 e2                	jne    4061 <dafs_append_dir_init_entries+0x211>
    //h_len = phlen + 2;
    hashname = BKDRHash(phn_f, p_len);
    //nova_dbg("%s init entry name %s",__func__,phn_f);
    dafs_de->hname = cpu_to_le64(hashname);
    407f:	49 c1 e7 07          	shl    $0x7,%r15
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    4083:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    4087:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    bitpos++;
    //h_len = phlen + 2;
    hashname = BKDRHash(phn_f, p_len);
    //nova_dbg("%s init entry name %s",__func__,phn_f);
    dafs_de->hname = cpu_to_le64(hashname);
    408d:	4b 89 94 3d a8 40 00 	mov    %rdx,0x40a8(%r13,%r15,1)
    4094:	00 
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    4095:	4c 8b 7d b0          	mov    -0x50(%rbp),%r15
    4099:	89 d9                	mov    %ebx,%ecx
    409b:	4c 89 55 98          	mov    %r10,-0x68(%rbp)
    409f:	44 89 4d a0          	mov    %r9d,-0x60(%rbp)
    40a3:	49 8b 77 18          	mov    0x18(%r15),%rsi
    40a7:	e8 00 00 00 00       	callq  40ac <dafs_append_dir_init_entries+0x25c>

    par_de = &dafs_ze->dentry[par_pos];
    //nova_dbg("par pos is %d, cur pos is %d", par_pos,cur_pos);
    par_hn = le64_to_cpu(par_de->hname);
    40ac:	8b 45 a8             	mov    -0x58(%rbp),%eax
    /*bugbugbugbugbug*/
    //nova_dbg("parent hashname is %llu", par_hn);
    /*update dir info entry */
    par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    40af:	49 8d 7f 38          	lea    0x38(%r15),%rdi
    dafs_de->hname = cpu_to_le64(hashname);
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);

    par_de = &dafs_ze->dentry[par_pos];
    //nova_dbg("par pos is %d, cur pos is %d", par_pos,cur_pos);
    par_hn = le64_to_cpu(par_de->hname);
    40b3:	48 c1 e0 07          	shl    $0x7,%rax
    /*bugbugbugbugbug*/
    //nova_dbg("parent hashname is %llu", par_hn);
    /*update dir info entry */
    par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    40b7:	49 8b b4 05 a8 40 00 	mov    0x40a8(%r13,%rax,1),%rsi
    40be:	00 
    40bf:	e8 00 00 00 00       	callq  40c4 <dafs_append_dir_init_entries+0x274>
    if(!par_dir){
    40c4:	48 85 c0             	test   %rax,%rax
    //nova_dbg("par pos is %d, cur pos is %d", par_pos,cur_pos);
    par_hn = le64_to_cpu(par_de->hname);
    /*bugbugbugbugbug*/
    //nova_dbg("parent hashname is %llu", par_hn);
    /*update dir info entry */
    par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    40c7:	49 89 c7             	mov    %rax,%r15
    if(!par_dir){
    40ca:	0f 84 0c 03 00 00    	je     43dc <dafs_append_dir_init_entries+0x58c>
        //nova_dbg("dafs not find dir entry");
        return -EINVAL;
    }
    par_dir->sub_num++;
    40d0:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    40d5:	ba 14 00 00 00       	mov    $0x14,%edx
    40da:	be d0 80 00 00       	mov    $0x80d0,%esi
    40df:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 40e6 <dafs_append_dir_init_entries+0x296>
    40e6:	e8 00 00 00 00       	callq  40eb <dafs_append_dir_init_entries+0x29b>
    new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
    new_sf->pos = cur_pos;
    40eb:	89 58 10             	mov    %ebx,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    40ee:	49 8b 57 20          	mov    0x20(%r15),%rdx
    list_add_tail(&new_sf->list, &par_dir->sub_file);
    40f2:	49 8d 7f 18          	lea    0x18(%r15),%rdi
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    40f6:	4c 8b 55 98          	mov    -0x68(%rbp),%r10
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    40fa:	49 89 47 20          	mov    %rax,0x20(%r15)
	new->next = next;
    40fe:	48 89 38             	mov    %rdi,(%rax)
    4101:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
	new->prev = prev;
    4105:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    4109:	48 89 02             	mov    %rax,(%rdx)
	if (support_clwb) {
    410c:	31 d2                	xor    %edx,%edx
    410e:	44 8b 0d 00 00 00 00 	mov    0x0(%rip),%r9d        # 4115 <dafs_append_dir_init_entries+0x2c5>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    4115:	44 89 d1             	mov    %r10d,%ecx
    4118:	83 e1 3f             	and    $0x3f,%ecx
    411b:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    411e:	45 85 c9             	test   %r9d,%r9d
    4121:	44 8b 4d a0          	mov    -0x60(%rbp),%r9d
    4125:	0f 84 30 02 00 00    	je     435b <dafs_append_dir_init_entries+0x50b>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    412b:	89 d0                	mov    %edx,%eax
    412d:	4c 01 d0             	add    %r10,%rax
    4130:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    4134:	83 c2 40             	add    $0x40,%edx
    4137:	39 d1                	cmp    %edx,%ecx
    4139:	77 f0                	ja     412b <dafs_append_dir_init_entries+0x2db>

    //nova_dbg("%s . pos is %d",__func__,cur_pos);
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    cur_pos++;
    413b:	83 c3 01             	add    $0x1,%ebx

    while(cur_pos<NR_DENTRY_IN_ZONE){
    413e:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
    4144:	0f 87 88 02 00 00    	ja     43d2 <dafs_append_dir_init_entries+0x582>
    414a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    414e:	48 8b 08             	mov    (%rax),%rcx
    4151:	eb 03                	jmp    4156 <dafs_append_dir_init_entries+0x306>
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
            bitpos+=2;
    4153:	41 89 c1             	mov    %eax,%r9d

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    4156:	49 63 c1             	movslq %r9d,%rax
    4159:	48 0f a3 01          	bt     %rax,(%rcx)
    415d:	19 c0                	sbb    %eax,%eax
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    cur_pos++;

    while(cur_pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
    415f:	85 c0                	test   %eax,%eax
    4161:	75 11                	jne    4174 <dafs_append_dir_init_entries+0x324>
#error "Please fix <asm/byteorder.h>"
#endif

static inline int test_bit_le(int nr, const void *addr)
{
	return test_bit(nr ^ BITOP_LE_SWIZZLE, addr);
    4163:	41 8d 51 01          	lea    0x1(%r9),%edx
    4167:	48 63 d2             	movslq %edx,%rdx
    416a:	48 0f a3 11          	bt     %rdx,(%rcx)
    416e:	19 c0                	sbb    %eax,%eax
    4170:	85 c0                	test   %eax,%eax
    4172:	74 16                	je     418a <dafs_append_dir_init_entries+0x33a>
            bitpos+=2;
            cur_pos++;
    4174:	83 c3 01             	add    $0x1,%ebx
    
    cur_pos++;

    while(cur_pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
            bitpos+=2;
    4177:	41 8d 41 02          	lea    0x2(%r9),%eax
    //nova_dbg("%s . pos is %d",__func__,cur_pos);
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    cur_pos++;

    while(cur_pos<NR_DENTRY_IN_ZONE){
    417b:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
    4181:	75 d0                	jne    4153 <dafs_append_dir_init_entries+0x303>
    4183:	41 83 c1 03          	add    $0x3,%r9d
    4187:	49 63 d1             	movslq %r9d,%rdx
            cur_pos++;
        }else{
            break;
        }
    }
    dafs_de = &dafs_ze->dentry[cur_pos];
    418a:	89 d9                	mov    %ebx,%ecx
    418c:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 2;
    dafs_de->links_count = 2;
    4190:	ba 02 00 00 00       	mov    $0x2,%edx
    4195:	48 89 cf             	mov    %rcx,%rdi
            cur_pos++;
        }else{
            break;
        }
    }
    dafs_de = &dafs_ze->dentry[cur_pos];
    4198:	4c 8d a1 81 00 00 00 	lea    0x81(%rcx),%r12
    419f:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
    41a3:	48 c1 e7 07          	shl    $0x7,%rdi
    41a7:	49 8d 74 3d 00       	lea    0x0(%r13,%rdi,1),%rsi
    41ac:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
    41b0:	49 c1 e4 07          	shl    $0x7,%r12
    41b4:	4d 01 ec             	add    %r13,%r12
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 2;
    dafs_de->links_count = 2;
    41b7:	66 89 96 86 40 00 00 	mov    %dx,0x4086(%rsi)
        }else{
            break;
        }
    }
    dafs_de = &dafs_ze->dentry[cur_pos];
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    41be:	c6 86 80 40 00 00 06 	movb   $0x6,0x4080(%rsi)
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    41c5:	c6 86 82 40 00 00 00 	movb   $0x0,0x4082(%rsi)
    dafs_de->name_len = 2;
    41cc:	c6 86 81 40 00 00 02 	movb   $0x2,0x4081(%rsi)
    dafs_de->links_count = 2;
    41d3:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    41d7:	e8 00 00 00 00       	callq  41dc <dafs_append_dir_init_entries+0x38c>
    41dc:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(parent_ino);
    dafs_de->size = sb->s_blocksize;
    memcpy(dafs_de->name, "..", 2);
    41e0:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
    41e4:	b9 2e 2e 00 00       	mov    $0x2e2e,%ecx
    dafs_de->name[2]='\0';
    p_len ++; 
    41e9:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 2;
    dafs_de->links_count = 2;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    41ed:	89 86 88 40 00 00    	mov    %eax,0x4088(%rsi)
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(parent_ino);
    41f3:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    /*标示. ..文件*/
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 2;
    dafs_de->links_count = 2;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    dafs_de->isr_sf = 0;
    41fa:	c6 86 83 40 00 00 00 	movb   $0x0,0x4083(%rsi)
    dafs_de->ino = cpu_to_le64(parent_ino);
    dafs_de->size = sb->s_blocksize;
    memcpy(dafs_de->name, "..", 2);
    dafs_de->name[2]='\0';
    p_len ++; 
    4201:	49 83 c0 03          	add    $0x3,%r8
    dafs_de->fname_len = cpu_to_le64(p_len);
    4205:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
    dafs_de->file_type = NORMAL_FILE;
    dafs_de->name_len = 2;
    dafs_de->links_count = 2;
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(parent_ino);
    4209:	48 89 86 98 40 00 00 	mov    %rax,0x4098(%rsi)
    dafs_de->size = sb->s_blocksize;
    4210:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    4214:	48 8b 40 18          	mov    0x18(%rax),%rax
    4218:	48 89 86 a0 40 00 00 	mov    %rax,0x40a0(%rsi)
    memcpy(dafs_de->name, "..", 2);
    421f:	66 41 89 8c 3d b0 40 	mov    %cx,0x40b0(%r13,%rdi,1)
    4226:	00 00 
    dafs_de->name[2]='\0';
    p_len ++; 
    dafs_de->fname_len = cpu_to_le64(p_len);
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    dafs_de->ext_flag=0;
    4228:	31 ff                	xor    %edi,%edi
    dafs_de->ino = cpu_to_le64(parent_ino);
    dafs_de->size = sb->s_blocksize;
    memcpy(dafs_de->name, "..", 2);
    dafs_de->name[2]='\0';
    p_len ++; 
    dafs_de->fname_len = cpu_to_le64(p_len);
    422a:	4c 89 86 90 40 00 00 	mov    %r8,0x4090(%rsi)
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    dafs_de->ext_flag=0;
    4231:	66 89 be 84 40 00 00 	mov    %di,0x4084(%rsi)
    strcat(phn_f, ".");
    4238:	4c 89 f7             	mov    %r14,%rdi
    dafs_de->mtime = CURRENT_TIME_SEC.tv_sec;
    dafs_de->isr_sf = 0;
    dafs_de->ino = cpu_to_le64(parent_ino);
    dafs_de->size = sb->s_blocksize;
    memcpy(dafs_de->name, "..", 2);
    dafs_de->name[2]='\0';
    423b:	c6 86 b2 40 00 00 00 	movb   $0x0,0x40b2(%rsi)
    p_len ++; 
    dafs_de->fname_len = cpu_to_le64(p_len);
    /*normal file*/
    dafs_de->ful_name.f_name[0]='\0';
    4242:	c6 86 d8 40 00 00 00 	movb   $0x0,0x40d8(%rsi)
    dafs_de->ext_flag=0;
    strcat(phn_f, ".");
    4249:	e8 00 00 00 00       	callq  424e <dafs_append_dir_init_entries+0x3fe>
    424e:	41 b8 2e 00 00 00    	mov    $0x2e,%r8d
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    4254:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
    4258:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
    425c:	66 45 89 04 06       	mov    %r8w,(%r14,%rax,1)
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    4261:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    4265:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
    4269:	48 8b 00             	mov    (%rax),%rax
    426c:	f0 48 0f ab 10       	lock bts %rdx,(%rax)
    4271:	72 00                	jb     4273 <dafs_append_dir_init_entries+0x423>
    4273:	45 85 c0             	test   %r8d,%r8d
    4276:	0f 8e 4f 01 00 00    	jle    43cb <dafs_append_dir_init_entries+0x57b>
    427c:	41 8d 40 ff          	lea    -0x1(%r8),%eax
    4280:	31 d2                	xor    %edx,%edx
    4282:	49 8d 7c 06 01       	lea    0x1(%r14,%rax,1),%rdi
    4287:	4c 89 f0             	mov    %r14,%rax
		hash = hash * seed + (*str++);
    428a:	48 89 d6             	mov    %rdx,%rsi
    428d:	48 83 c0 01          	add    $0x1,%rax
    4291:	48 c1 e6 05          	shl    $0x5,%rsi
    4295:	48 29 d6             	sub    %rdx,%rsi
    4298:	48 89 f2             	mov    %rsi,%rdx
    429b:	48 0f be 70 ff       	movsbq -0x1(%rax),%rsi
    42a0:	48 01 f2             	add    %rsi,%rdx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    42a3:	48 39 f8             	cmp    %rdi,%rax
    42a6:	75 e2                	jne    428a <dafs_append_dir_init_entries+0x43a>
    hashname = BKDRHash(phn_f, p_len);
    dafs_de->hname = cpu_to_le64(hashname);
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    42a8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    hashname = BKDRHash(phn_f, p_len);
    dafs_de->hname = cpu_to_le64(hashname);
    42ac:	48 c1 e1 07          	shl    $0x7,%rcx
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    42b0:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    hashname = BKDRHash(phn_f, p_len);
    dafs_de->hname = cpu_to_le64(hashname);
    42b4:	49 89 94 0d a8 40 00 	mov    %rdx,0x40a8(%r13,%rcx,1)
    42bb:	00 
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    42bc:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    42c2:	89 d9                	mov    %ebx,%ecx
    42c4:	48 8b 70 18          	mov    0x18(%rax),%rsi
    42c8:	e8 00 00 00 00       	callq  42cd <dafs_append_dir_init_entries+0x47d>
    
    /*update dir info entry */
    par_dir->sub_num++;
    42cd:	49 83 47 08 01       	addq   $0x1,0x8(%r15)
    42d2:	ba 14 00 00 00       	mov    $0x14,%edx
    42d7:	be d0 80 00 00       	mov    $0x80d0,%esi
    42dc:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 42e3 <dafs_append_dir_init_entries+0x493>
    42e3:	e8 00 00 00 00       	callq  42e8 <dafs_append_dir_init_entries+0x498>
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
    42e8:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
    new_sf->pos = cur_pos;
    42ec:	89 58 10             	mov    %ebx,0x10(%rax)
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    42ef:	44 89 e1             	mov    %r12d,%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    42f2:	49 8b 57 20          	mov    0x20(%r15),%rdx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    42f6:	49 89 47 20          	mov    %rax,0x20(%r15)
    42fa:	83 e1 3f             	and    $0x3f,%ecx
    42fd:	83 e9 80             	sub    $0xffffff80,%ecx
	new->next = next;
    4300:	48 89 38             	mov    %rdi,(%rax)
	new->prev = prev;
    4303:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    4307:	48 89 02             	mov    %rax,(%rdx)
	if (support_clwb) {
    430a:	31 d2                	xor    %edx,%edx
    430c:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 4312 <dafs_append_dir_init_entries+0x4c2>
    4312:	85 c0                	test   %eax,%eax
    4314:	74 59                	je     436f <dafs_append_dir_init_entries+0x51f>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    4316:	89 d0                	mov    %edx,%eax
    4318:	4c 01 e0             	add    %r12,%rax
    431b:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    431f:	83 c2 40             	add    $0x40,%edx
    4322:	39 d1                	cmp    %edx,%ecx
    4324:	77 f0                	ja     4316 <dafs_append_dir_init_entries+0x4c6>
    list_add_tail(&new_sf->list, &par_dir->sub_file);

    //nova_dbg("%s .. pos is %d",__func__,cur_pos);
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    //kfree(phname);
    kfree(phn_f);
    4326:	4c 89 f7             	mov    %r14,%rdi
    4329:	e8 00 00 00 00       	callq  432e <dafs_append_dir_init_entries+0x4de>
    kfree(zone_p);
    432e:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    4332:	e8 00 00 00 00       	callq  4337 <dafs_append_dir_init_entries+0x4e7>
    //nova_dbg("dafs finish add initial part in dir");
    return 0;
    4337:	31 c0                	xor    %eax,%eax
}
    4339:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    433d:	65 48 33 3c 25 28 00 	xor    %gs:0x28,%rdi
    4344:	00 00 
    4346:	0f 85 9a 00 00 00    	jne    43e6 <dafs_append_dir_init_entries+0x596>
    434c:	48 83 c4 60          	add    $0x60,%rsp
    4350:	5b                   	pop    %rbx
    4351:	41 5c                	pop    %r12
    4353:	41 5d                	pop    %r13
    4355:	41 5e                	pop    %r14
    4357:	41 5f                	pop    %r15
    4359:	5d                   	pop    %rbp
    435a:	c3                   	retq   
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    435b:	89 d0                	mov    %edx,%eax
    435d:	4c 01 d0             	add    %r10,%rax
    4360:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    4363:	83 c2 40             	add    $0x40,%edx
    4366:	39 d1                	cmp    %edx,%ecx
    4368:	77 f1                	ja     435b <dafs_append_dir_init_entries+0x50b>
    436a:	e9 cc fd ff ff       	jmpq   413b <dafs_append_dir_init_entries+0x2eb>
			_mm_clflush(buf + i);
    436f:	89 d0                	mov    %edx,%eax
    4371:	4c 01 e0             	add    %r12,%rax
    4374:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    4377:	83 c2 40             	add    $0x40,%edx
    437a:	39 d1                	cmp    %edx,%ecx
    437c:	77 f1                	ja     436f <dafs_append_dir_init_entries+0x51f>
    437e:	eb a6                	jmp    4326 <dafs_append_dir_init_entries+0x4d6>
        }
    }

    /* if not enough entries, negtive split*/
    if(cur_pos == NR_DENTRY_IN_ZONE){
        dafs_split_zone(sb, dzt_ei, 0, NEGTIVE_SPLIT);
    4380:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    4384:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    4388:	31 c9                	xor    %ecx,%ecx
    438a:	31 d2                	xor    %edx,%edx
    438c:	bb ff ff 00 00       	mov    $0xffff,%ebx
    4391:	e8 00 00 00 00       	callq  4396 <dafs_append_dir_init_entries+0x546>
    4396:	b9 ff ff 01 00       	mov    $0x1ffff,%ecx
    439b:	e9 56 fb ff ff       	jmpq   3ef6 <dafs_append_dir_init_entries+0xa6>

    /*set ful_name*/
    p_len += 2;
    dafs_de->fname_len = cpu_to_le64(p_len);
    if(p_len == 3)
        strcat(phn_f, ".");
    43a0:	e8 00 00 00 00       	callq  43a5 <dafs_append_dir_init_entries+0x555>
    43a5:	b9 2e 00 00 00       	mov    $0x2e,%ecx
    43aa:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
    43ae:	4c 8b 55 98          	mov    -0x68(%rbp),%r10
    43b2:	66 41 89 0c 06       	mov    %cx,(%r14,%rax,1)
    43b7:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
    43bb:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
    43bf:	e9 5a fc ff ff       	jmpq   401e <dafs_append_dir_init_entries+0x1ce>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    43c4:	31 d2                	xor    %edx,%edx
    43c6:	e9 b4 fc ff ff       	jmpq   407f <dafs_append_dir_init_entries+0x22f>
    43cb:	31 d2                	xor    %edx,%edx
    43cd:	e9 d6 fe ff ff       	jmpq   42a8 <dafs_append_dir_init_entries+0x458>
    43d2:	41 8d 54 24 03       	lea    0x3(%r12),%edx
    43d7:	e9 ae fd ff ff       	jmpq   418a <dafs_append_dir_init_entries+0x33a>
    //nova_dbg("parent hashname is %llu", par_hn);
    /*update dir info entry */
    par_dir = radix_tree_lookup(&dzt_ei->dir_tree, par_hn);
    if(!par_dir){
        //nova_dbg("dafs not find dir entry");
        return -EINVAL;
    43dc:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    43e1:	e9 53 ff ff ff       	jmpq   4339 <dafs_append_dir_init_entries+0x4e9>
    //kfree(phname);
    kfree(phn_f);
    kfree(zone_p);
    //nova_dbg("dafs finish add initial part in dir");
    return 0;
}
    43e6:	e8 00 00 00 00       	callq  43eb <dafs_append_dir_init_entries+0x59b>
    43eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000043f0 <dafs_empty_dir>:

/*bug 应该检验一下状态图是否有效*/
int dafs_empty_dir(struct inode *inode, struct dentry *dentry)
{
    43f0:	e8 00 00 00 00       	callq  43f5 <dafs_empty_dir+0x5>
    43f5:	55                   	push   %rbp
    43f6:	48 89 e5             	mov    %rsp,%rbp
    43f9:	41 57                	push   %r15
    43fb:	41 56                	push   %r14
    43fd:	41 55                	push   %r13
    43ff:	41 54                	push   %r12
    4401:	49 89 f7             	mov    %rsi,%r15
    4404:	53                   	push   %rbx
    4405:	48 83 ec 30          	sub    $0x30,%rsp
    struct super_block *sb = inode->i_sb;
    4409:	4c 8b 6f 28          	mov    0x28(%rdi),%r13
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    440d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    return 0;
}

/*bug 应该检验一下状态图是否有效*/
int dafs_empty_dir(struct inode *inode, struct dentry *dentry)
{
    4414:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    441b:	00 00 
    441d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    4421:	31 c0                	xor    %eax,%eax
}

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
    4423:	48 8b 46 18          	mov    0x18(%rsi),%rax
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    4427:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    442e:	49 8b 9d b0 03 00 00 	mov    0x3b0(%r13),%rbx

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
    4435:	48 8b 40 30          	mov    0x30(%rax),%rax
    4439:	4c 8b 60 28          	mov    0x28(%rax),%r12
    443d:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    4444:	00 00 
    struct nova_sb_info *sbi = NOVA_SB(sb);
    char *ph, *buf, *tem, *ppath;
    //char *buf = NULL, *ppath=NULL, *tem=NULL;
    struct fs_struct *fs = current->fs;
    4446:	4c 8b b0 30 06 00 00 	mov    0x630(%rax),%r14
    444d:	4d 8b 84 24 b0 03 00 	mov    0x3b0(%r12),%r8
    4454:	00 
    4455:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    4459:	e8 00 00 00 00       	callq  445e <dafs_empty_dir+0x6e>
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    445e:	4d 85 e4             	test   %r12,%r12
    4461:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
    4465:	0f 84 30 02 00 00    	je     469b <dafs_empty_dir+0x2ab>
    BUG_ON(sbi==NULL);
    446b:	4d 85 c0             	test   %r8,%r8
    446e:	0f 84 29 02 00 00    	je     469d <dafs_empty_dir+0x2ad>
    ph = &sbi->ph_f;
    4474:	49 8d 80 d8 01 00 00 	lea    0x1d8(%r8),%rax
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    447b:	49 8d 7e 04          	lea    0x4(%r14),%rdi
    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    447f:	41 c6 80 d8 01 00 00 	movb   $0x0,0x1d8(%r8)
    4486:	00 
    buf[0]='\0';
    4487:	41 c6 80 d7 05 00 00 	movb   $0x0,0x5d7(%r8)
    448e:	00 
    tem[0]='\0';
    448f:	41 c6 80 d6 09 00 00 	movb   $0x0,0x9d6(%r8)
    4496:	00 
    4497:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    449b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    449f:	e8 00 00 00 00       	callq  44a4 <dafs_empty_dir+0xb4>
    vfsmnt = mntget(fs->pwd.mnt);
    44a4:	49 8b 7e 28          	mov    0x28(%r14),%rdi
    44a8:	e8 00 00 00 00       	callq  44ad <dafs_empty_dir+0xbd>
    if(!vfsmnt){
    44ad:	48 85 c0             	test   %rax,%rax
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    44b0:	49 89 c4             	mov    %rax,%r12
    if(!vfsmnt){
    44b3:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
    44b7:	0f 84 e9 01 00 00    	je     46a6 <dafs_empty_dir+0x2b6>
    44bd:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
    44c2:	f0 41 0f c1 46 04    	lock xadd %eax,0x4(%r14)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
    44c8:	49 8b 77 28          	mov    0x28(%r15),%rsi
    44cc:	49 c7 c2 00 00 00 00 	mov    $0x0,%r10
    44d3:	b9 02 00 00 00       	mov    $0x2,%ecx
    44d8:	4c 89 d7             	mov    %r10,%rdi
    44db:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    44dd:	0f 85 06 02 00 00    	jne    46e9 <dafs_empty_dir+0x2f9>
        memcpy(buf,"/",1);
        buf[1]='\0';
    }else{
        //nova_dbg("%s root dentry",__func__);
        memcpy(ph, "/", 1);
    44e3:	41 c6 80 d8 01 00 00 	movb   $0x2f,0x1d8(%r8)
    44ea:	2f 
        ph[1]='\0';
    44eb:	41 c6 80 d9 01 00 00 	movb   $0x0,0x1d9(%r8)
    44f2:	00 
    //nova_dbg("%s dafs start test empty dir",__func__);
    ph = get_dentry_path(dentry,0);
    slen = strlen(ph)+1;
    phname = &sbi->ph_name;
    phn = &sbi->ph_dzt;
    phname[0]='\0';
    44f3:	c6 83 d6 09 00 00 00 	movb   $0x0,0x9d6(%rbx)
    phn[0]='\0';
    44fa:	c6 83 d7 05 00 00 00 	movb   $0x0,0x5d7(%rbx)
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    4501:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    4508:	49 8b 85 b0 03 00 00 	mov    0x3b0(%r13),%rax
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    450f:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
    4513:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi

    //nova_dbg("%s dafs start test empty dir",__func__);
    ph = get_dentry_path(dentry,0);
    slen = strlen(ph)+1;
    phname = &sbi->ph_name;
    phn = &sbi->ph_dzt;
    451a:	4c 8d bb d7 05 00 00 	lea    0x5d7(%rbx),%r15
    int i, ret;

    //nova_dbg("%s dafs start test empty dir",__func__);
    ph = get_dentry_path(dentry,0);
    slen = strlen(ph)+1;
    phname = &sbi->ph_name;
    4521:	4c 8d a3 d6 09 00 00 	lea    0x9d6(%rbx),%r12
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    4528:	48 8b 80 d8 0d 00 00 	mov    0xdd8(%rax),%rax
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    452f:	4c 89 f2             	mov    %r14,%rdx
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    4532:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    4536:	e8 00 00 00 00       	callq  453b <dafs_empty_dir+0x14b>
    tlen = strlen(phstr);
    453b:	4c 89 f7             	mov    %r14,%rdi
    453e:	4c 89 75 c0          	mov    %r14,-0x40(%rbp)
    4542:	e8 00 00 00 00       	callq  4547 <dafs_empty_dir+0x157>
    nova_dbg("%s length is %llu", __func__, tlen);
    4547:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    454e:	48 89 c2             	mov    %rax,%rdx
    4551:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    tlen = strlen(phstr);
    4558:	49 89 c6             	mov    %rax,%r14
    nova_dbg("%s length is %llu", __func__, tlen);
    455b:	e8 00 00 00 00       	callq  4560 <dafs_empty_dir+0x170>
    memcpy(phs, phstr, tlen);
    4560:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    4564:	4c 89 f2             	mov    %r14,%rdx
    4567:	4c 89 ff             	mov    %r15,%rdi
    456a:	e8 00 00 00 00       	callq  456f <dafs_empty_dir+0x17f>
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    456f:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi

    nova_dbg("%s start %s",__func__,phstr);
    tlen = strlen(phstr);
    nova_dbg("%s length is %llu", __func__, tlen);
    memcpy(phs, phstr, tlen);
    phs[tlen]='\0';
    4573:	42 c6 84 33 d7 05 00 	movb   $0x0,0x5d7(%rbx,%r14,1)
    457a:	00 00 
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    457c:	be 2f 00 00 00       	mov    $0x2f,%esi
            return dzt_ei;
        }
    }while(1);
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    4581:	c6 83 d7 05 00 00 2f 	movb   $0x2f,0x5d7(%rbx)
    phs[1]='\0';
    4588:	c6 83 d8 05 00 00 00 	movb   $0x0,0x5d8(%rbx)
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    458f:	e8 00 00 00 00       	callq  4594 <dafs_empty_dir+0x1a4>
    if(!dzt_ei){
    4594:	48 85 c0             	test   %rax,%rax
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    4597:	49 89 c6             	mov    %rax,%r14
    if(!dzt_ei){
    459a:	0f 84 3f 01 00 00    	je     46df <dafs_empty_dir+0x2ef>
    
    //phname = kzalloc(sizeof(char)*slen, GFP_KERNEL);
    //phn = kzalloc(sizeof(char)*slen, GFP_KERNEL);
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    45a0:	4c 89 ff             	mov    %r15,%rdi
    45a3:	e8 00 00 00 00       	callq  45a8 <dafs_empty_dir+0x1b8>
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
    45a8:	48 83 f8 01          	cmp    $0x1,%rax
    45ac:	0f 84 c0 00 00 00    	je     4672 <dafs_empty_dir+0x282>
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    45b2:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    45b6:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    45ba:	e8 00 00 00 00       	callq  45bf <dafs_empty_dir+0x1cf>
    45bf:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
        memcpy(phname, ph+phlen, flen);
    45c3:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    45c7:	4c 89 e7             	mov    %r12,%rdi
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    45ca:	48 29 d0             	sub    %rdx,%rax
        memcpy(phname, ph+phlen, flen);
    45cd:	48 01 d6             	add    %rdx,%rsi
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    45d0:	49 89 c7             	mov    %rax,%r15
        memcpy(phname, ph+phlen, flen);
    45d3:	48 89 c2             	mov    %rax,%rdx
    45d6:	e8 00 00 00 00       	callq  45db <dafs_empty_dir+0x1eb>
        phname[flen]='\0';
    45db:	42 c6 84 3b d6 09 00 	movb   $0x0,0x9d6(%rbx,%r15,1)
    45e2:	00 00 
	int i;

	for (i = 0; i < length; i++) {
    45e4:	45 85 ff             	test   %r15d,%r15d
    45e7:	0f 8e b2 00 00 00    	jle    469f <dafs_empty_dir+0x2af>
    45ed:	41 8d 47 ff          	lea    -0x1(%r15),%eax
    45f1:	31 db                	xor    %ebx,%ebx
    45f3:	49 8d 54 04 01       	lea    0x1(%r12,%rax,1),%rdx
		hash = hash * seed + (*str++);
    45f8:	48 89 d8             	mov    %rbx,%rax
    45fb:	49 83 c4 01          	add    $0x1,%r12
    45ff:	48 c1 e0 05          	shl    $0x5,%rax
    4603:	48 29 d8             	sub    %rbx,%rax
    4606:	48 89 c3             	mov    %rax,%rbx
    4609:	49 0f be 44 24 ff    	movsbq -0x1(%r12),%rax
    460f:	48 01 c3             	add    %rax,%rbx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    4612:	49 39 d4             	cmp    %rdx,%r12
    4615:	75 e1                	jne    45f8 <dafs_empty_dir+0x208>
    //kfree(phname);
    //kfree(ph);
    //kfree(phn);

    /*lookup in hash table, not decided*/
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    4617:	49 8b 76 18          	mov    0x18(%r14),%rsi
    461b:	4c 8d 45 cc          	lea    -0x34(%rbp),%r8
    461f:	48 89 da             	mov    %rbx,%rdx
    4622:	b9 01 00 00 00       	mov    $0x1,%ecx
    4627:	4c 89 ef             	mov    %r13,%rdi
    462a:	e8 00 00 00 00       	callq  462f <dafs_empty_dir+0x23f>
    if(!ret)
    462f:	85 c0                	test   %eax,%eax
        return -EINVAL;
    4631:	ba ea ff ff ff       	mov    $0xffffffea,%edx
    //kfree(ph);
    //kfree(phn);

    /*lookup in hash table, not decided*/
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    if(!ret)
    4636:	74 16                	je     464e <dafs_empty_dir+0x25e>
        return -EINVAL;

    //direntry = &dafs_ze->dentry[de_pos];
    
    par_dir = radix_tree_lookup(&dzt_ei->dir_tree, ph_hash);
    4638:	49 8d 7e 38          	lea    0x38(%r14),%rdi
    463c:	48 89 de             	mov    %rbx,%rsi
    463f:	e8 00 00 00 00       	callq  4644 <dafs_empty_dir+0x254>
    //kfree(phn);

    /*lookup in hash table, not decided*/
    ret = lookup_in_hashtable(sb, dzt_ei->ht_head, ph_hash, 1, &de_pos);
    if(!ret)
        return -EINVAL;
    4644:	31 d2                	xor    %edx,%edx
    4646:	48 83 78 08 00       	cmpq   $0x0,0x8(%rax)
    464b:	0f 94 c2             	sete   %dl

    
    //nova_dbg("%s dir is empty",__func__);
    return 1;

}
    464e:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
    4652:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
    4659:	00 00 
    465b:	89 d0                	mov    %edx,%eax
    465d:	0f 85 81 00 00 00    	jne    46e4 <dafs_empty_dir+0x2f4>
    4663:	48 83 c4 30          	add    $0x30,%rsp
    4667:	5b                   	pop    %rbx
    4668:	41 5c                	pop    %r12
    466a:	41 5d                	pop    %r13
    466c:	41 5e                	pop    %r14
    466e:	41 5f                	pop    %r15
    4670:	5d                   	pop    %rbp
    4671:	c3                   	retq   
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
        flen = strlen(ph);
    4672:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    4676:	e8 00 00 00 00       	callq  467b <dafs_empty_dir+0x28b>
        memcpy(phname, ph, flen);
    467b:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    dzt_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    phlen = strlen(phn);
    dzt_eno = dzt_ei->dzt_eno;
    if(phlen==1){
        flen = strlen(ph);
    467f:	49 89 c7             	mov    %rax,%r15
        memcpy(phname, ph, flen);
    4682:	48 89 c2             	mov    %rax,%rdx
    4685:	4c 89 e7             	mov    %r12,%rdi
    4688:	e8 00 00 00 00       	callq  468d <dafs_empty_dir+0x29d>
        phname[flen]='\0';
    468d:	42 c6 84 3b d6 09 00 	movb   $0x0,0x9d6(%rbx,%r15,1)
    4694:	00 00 
    4696:	e9 49 ff ff ff       	jmpq   45e4 <dafs_empty_dir+0x1f4>
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    469b:	0f 0b                	ud2    
    BUG_ON(sbi==NULL);
    469d:	0f 0b                	ud2    
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    469f:	31 db                	xor    %ebx,%ebx
    46a1:	e9 71 ff ff ff       	jmpq   4617 <dafs_empty_dir+0x227>
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    if(!vfsmnt){
        nova_dbg("not find mnt");
    46a6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    46ad:	e8 00 00 00 00       	callq  46b2 <dafs_empty_dir+0x2c2>
    
    //kfree(buf);
    //kfree(tem);
    //nova_dbg("dafs finish get dentry path");
ERR:
    nova_dbg("%s ful ph is %s len %llu, sbi %s ",__func__,ph, strlen(ph), sbi->ph_f);
    46b2:	4c 8b 7d c0          	mov    -0x40(%rbp),%r15
    46b6:	4c 89 ff             	mov    %r15,%rdi
    46b9:	e8 00 00 00 00       	callq  46be <dafs_empty_dir+0x2ce>
    46be:	4d 89 f8             	mov    %r15,%r8
    46c1:	48 89 c1             	mov    %rax,%rcx
    46c4:	4c 89 fa             	mov    %r15,%rdx
    46c7:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    46ce:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    46d5:	e8 00 00 00 00       	callq  46da <dafs_empty_dir+0x2ea>
    46da:	e9 14 fe ff ff       	jmpq   44f3 <dafs_empty_dir+0x103>
    46df:	e8 00 00 00 00       	callq  46e4 <dafs_empty_dir+0x2f4>

    
    //nova_dbg("%s dir is empty",__func__);
    return 1;

}
    46e4:	e8 00 00 00 00       	callq  46e9 <dafs_empty_dir+0x2f9>
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    46e9:	4d 8d b0 d7 05 00 00 	lea    0x5d7(%r8),%r14
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
        memcpy(buf,"/",1);
    46f0:	41 c6 80 d7 05 00 00 	movb   $0x2f,0x5d7(%r8)
    46f7:	2f 
        buf[1]='\0';
    46f8:	41 c6 80 d8 05 00 00 	movb   $0x0,0x5d8(%r8)
    46ff:	00 
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    4700:	4c 89 f7             	mov    %r14,%rdi
    4703:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
    4707:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
    470b:	e8 00 00 00 00       	callq  4710 <dafs_empty_dir+0x320>
    4710:	ba 2f 00 00 00       	mov    $0x2f,%edx
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    4715:	49 8d 7c 06 01       	lea    0x1(%r14,%rax,1),%rdi
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    471a:	66 41 89 14 06       	mov    %dx,(%r14,%rax,1)
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    471f:	49 8b 77 28          	mov    0x28(%r15),%rsi
    4723:	e8 00 00 00 00       	callq  4728 <dafs_empty_dir+0x338>
        p_dentry = tem_dentry->d_parent;
    4728:	4d 8b 7f 18          	mov    0x18(%r15),%r15
        //plen = strlen(buf);
        //buf[plen]='\0';
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
    472c:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    4730:	b9 02 00 00 00       	mov    $0x2,%ecx
    4735:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
    4739:	49 8b 77 28          	mov    0x28(%r15),%rsi
    473d:	4c 89 d7             	mov    %r10,%rdi
    4740:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    4742:	75 bc                	jne    4700 <dafs_empty_dir+0x310>
    4744:	49 8b 47 30          	mov    0x30(%r15),%rax
    4748:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
    474d:	75 b1                	jne    4700 <dafs_empty_dir+0x310>

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    474f:	49 8d 80 d6 09 00 00 	lea    0x9d6(%r8),%rax
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    4756:	4c 89 f2             	mov    %r14,%rdx
    4759:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    4760:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    4767:	4c 89 55 a8          	mov    %r10,-0x58(%rbp)

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    476b:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
    476f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    4773:	e8 00 00 00 00       	callq  4778 <dafs_empty_dir+0x388>
    tlen = strlen(buf);
    4778:	4c 89 f7             	mov    %r14,%rdi
    477b:	e8 00 00 00 00       	callq  4780 <dafs_empty_dir+0x390>
    memcpy(tem, buf, tlen);
    4780:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    4784:	48 89 c2             	mov    %rax,%rdx
    4787:	4c 89 f6             	mov    %r14,%rsi
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    tlen = strlen(buf);
    478a:	49 89 c7             	mov    %rax,%r15
    memcpy(tem, buf, tlen);
    478d:	e8 00 00 00 00       	callq  4792 <dafs_empty_dir+0x3a2>
    tem[tlen]='\0';
    4792:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
    4796:	4c 8b 55 a8          	mov    -0x58(%rbp),%r10
    479a:	43 c6 84 38 d6 09 00 	movb   $0x0,0x9d6(%r8,%r15,1)
    47a1:	00 00 
    do{
        ppath = strrchr(tem, '/');
    47a3:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    47a7:	be 2f 00 00 00       	mov    $0x2f,%esi
    47ac:	4c 89 55 a8          	mov    %r10,-0x58(%rbp)
    47b0:	e8 00 00 00 00       	callq  47b5 <dafs_empty_dir+0x3c5>
        plen = strlen(ppath);
    47b5:	48 89 c7             	mov    %rax,%rdi
    47b8:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    47bc:	e8 00 00 00 00       	callq  47c1 <dafs_empty_dir+0x3d1>
        phlen = tlen - plen;
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    47c1:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    47c5:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    memcpy(tem, buf, tlen);
    tem[tlen]='\0';
    do{
        ppath = strrchr(tem, '/');
        plen = strlen(ppath);
        phlen = tlen - plen;
    47c9:	49 29 c7             	sub    %rax,%r15
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    47cc:	e8 00 00 00 00       	callq  47d1 <dafs_empty_dir+0x3e1>
        memcpy(tem, buf, tlen);
    47d1:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    47d5:	4c 89 f6             	mov    %r14,%rsi
    47d8:	4c 89 fa             	mov    %r15,%rdx
    47db:	e8 00 00 00 00       	callq  47e0 <dafs_empty_dir+0x3f0>
        tem[tlen]='\0';
    47e0:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
        if(!strcmp(tem,"/"))
    47e4:	4c 8b 55 a8          	mov    -0x58(%rbp),%r10
    47e8:	b9 02 00 00 00       	mov    $0x2,%ecx
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
        memcpy(tem, buf, tlen);
        tem[tlen]='\0';
    47ed:	42 c6 04 3e 00       	movb   $0x0,(%rsi,%r15,1)
        if(!strcmp(tem,"/"))
    47f2:	4c 89 d7             	mov    %r10,%rdi
    47f5:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    47f7:	75 aa                	jne    47a3 <dafs_empty_dir+0x3b3>
            break;
    }while(1);

    //BUG_ON(strlen(ph)==1023);
    nova_dbg("%s ful ph is %s sbi is %s",__func__,ph, sbi->ph_f);
    47f9:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
    47fd:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    4804:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    480b:	48 89 d1             	mov    %rdx,%rcx
    480e:	e8 00 00 00 00       	callq  4813 <dafs_empty_dir+0x423>
    //BUG_ON(ph==NULL);
    
    mntput(vfsmnt);
    4813:	4c 89 e7             	mov    %r12,%rdi
    4816:	e8 00 00 00 00       	callq  481b <dafs_empty_dir+0x42b>
    481b:	e9 92 fe ff ff       	jmpq   46b2 <dafs_empty_dir+0x2c2>

0000000000004820 <add_rename_zone_dir>:

/*add rename zone root dentry
 * dentry 是新的dentry*/
int add_rename_zone_dir(struct dentry *dentry, struct dafs_dentry *old_de, struct dzt_entry_info *old_ei,
        u64 *new_hn, u64 *root_len)
{
    4820:	e8 00 00 00 00       	callq  4825 <add_rename_zone_dir+0x5>
    4825:	55                   	push   %rbp
    4826:	48 89 e5             	mov    %rsp,%rbp
    4829:	41 57                	push   %r15
    482b:	41 56                	push   %r14
    482d:	41 55                	push   %r13
    482f:	41 54                	push   %r12
    4831:	53                   	push   %rbx
    4832:	48 89 fb             	mov    %rdi,%rbx
    4835:	48 81 ec c0 00 00 00 	sub    $0xc0,%rsp
    
	/*nova_dbg_verbose("%s: dir %lu new inode %llu\n",
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
    483c:	44 8b 35 00 00 00 00 	mov    0x0(%rip),%r14d        # 4843 <add_rename_zone_dir+0x23>
{
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
    struct nova_inode *pidir;
    //const char *name = dentry->d_name.name;
    unsigned short namelen = dentry->d_name.len;
    4843:	44 8b 6f 24          	mov    0x24(%rdi),%r13d

/*add rename zone root dentry
 * dentry 是新的dentry*/
int add_rename_zone_dir(struct dentry *dentry, struct dafs_dentry *old_de, struct dzt_entry_info *old_ei,
        u64 *new_hn, u64 *root_len)
{
    4847:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    484e:	00 00 
    4850:	48 89 84 24 b8 00 00 	mov    %rax,0xb8(%rsp)
    4857:	00 
    4858:	31 c0                	xor    %eax,%eax
    struct inode *dir = dentry->d_parent->d_inode;
    485a:	48 8b 47 18          	mov    0x18(%rdi),%rax

/*add rename zone root dentry
 * dentry 是新的dentry*/
int add_rename_zone_dir(struct dentry *dentry, struct dafs_dentry *old_de, struct dzt_entry_info *old_ei,
        u64 *new_hn, u64 *root_len)
{
    485e:	48 89 74 24 58       	mov    %rsi,0x58(%rsp)
    
	/*nova_dbg_verbose("%s: dir %lu new inode %llu\n",
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
    4863:	45 85 f6             	test   %r14d,%r14d

/*add rename zone root dentry
 * dentry 是新的dentry*/
int add_rename_zone_dir(struct dentry *dentry, struct dafs_dentry *old_de, struct dzt_entry_info *old_ei,
        u64 *new_hn, u64 *root_len)
{
    4866:	48 89 54 24 50       	mov    %rdx,0x50(%rsp)
    486b:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
    4870:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
    struct inode *dir = dentry->d_parent->d_inode;
    4875:	4c 8b 60 30          	mov    0x30(%rax),%r12
    struct super_block *sb = dir->i_sb;
    4879:	49 8b 44 24 28       	mov    0x28(%r12),%rax
    487e:	48 89 84 24 80 00 00 	mov    %rax,0x80(%rsp)
    4885:	00 
    
	/*nova_dbg_verbose("%s: dir %lu new inode %llu\n",
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
    4886:	0f 85 9e 08 00 00    	jne    512a <add_rename_zone_dir+0x90a>
	if (namelen == 0)
    488c:	66 45 85 ed          	test   %r13w,%r13w
    4890:	0f 84 6d 09 00 00    	je     5203 <add_rename_zone_dir+0x9e3>
}

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
    4896:	48 8b 43 18          	mov    0x18(%rbx),%rax
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    489a:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    48a1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
    48a8:	48 8b 40 30          	mov    0x30(%rax),%rax
    48ac:	4c 8b 70 28          	mov    0x28(%rax),%r14
    48b0:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    48b7:	00 00 
    struct nova_sb_info *sbi = NOVA_SB(sb);
    char *ph, *buf, *tem, *ppath;
    //char *buf = NULL, *ppath=NULL, *tem=NULL;
    struct fs_struct *fs = current->fs;
    48b9:	4c 8b a8 30 06 00 00 	mov    0x630(%rax),%r13
    48c0:	4d 8b be b0 03 00 00 	mov    0x3b0(%r14),%r15
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    48c7:	e8 00 00 00 00       	callq  48cc <add_rename_zone_dir+0xac>
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    48cc:	4d 85 f6             	test   %r14,%r14
    48cf:	0f 84 38 09 00 00    	je     520d <add_rename_zone_dir+0x9ed>
    BUG_ON(sbi==NULL);
    48d5:	4d 85 ff             	test   %r15,%r15
    48d8:	0f 84 31 09 00 00    	je     520f <add_rename_zone_dir+0x9ef>
    ph = &sbi->ph_f;
    48de:	49 8d 87 d8 01 00 00 	lea    0x1d8(%r15),%rax
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    48e5:	49 8d 7d 04          	lea    0x4(%r13),%rdi
    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    48e9:	41 c6 87 d8 01 00 00 	movb   $0x0,0x1d8(%r15)
    48f0:	00 
    buf[0]='\0';
    48f1:	41 c6 87 d7 05 00 00 	movb   $0x0,0x5d7(%r15)
    48f8:	00 
    tem[0]='\0';
    48f9:	41 c6 87 d6 09 00 00 	movb   $0x0,0x9d6(%r15)
    4900:	00 
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    4901:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    4906:	e8 00 00 00 00       	callq  490b <add_rename_zone_dir+0xeb>
    vfsmnt = mntget(fs->pwd.mnt);
    490b:	49 8b 7d 28          	mov    0x28(%r13),%rdi
    490f:	e8 00 00 00 00       	callq  4914 <add_rename_zone_dir+0xf4>
    if(!vfsmnt){
    4914:	48 85 c0             	test   %rax,%rax
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    4917:	49 89 c0             	mov    %rax,%r8
    if(!vfsmnt){
    491a:	0f 84 c4 0a 00 00    	je     53e4 <add_rename_zone_dir+0xbc4>
    4920:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
    4925:	f0 41 0f c1 45 04    	lock xadd %eax,0x4(%r13)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
    492b:	48 8b 73 28          	mov    0x28(%rbx),%rsi
    492f:	49 c7 c2 00 00 00 00 	mov    $0x0,%r10
    4936:	b9 02 00 00 00       	mov    $0x2,%ecx
    493b:	4c 89 d7             	mov    %r10,%rdi
    493e:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    4940:	0f 85 41 09 00 00    	jne    5287 <add_rename_zone_dir+0xa67>
        memcpy(buf,"/",1);
        buf[1]='\0';
    }else{
        //nova_dbg("%s root dentry",__func__);
        memcpy(ph, "/", 1);
    4946:	41 c6 87 d8 01 00 00 	movb   $0x2f,0x1d8(%r15)
    494d:	2f 
        ph[1]='\0';
    494e:	41 c6 87 d9 01 00 00 	movb   $0x0,0x1d9(%r15)
    4955:	00 
	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
	if (namelen == 0)
		return -EINVAL;
   
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    4956:	4c 8b 74 24 38       	mov    0x38(%rsp),%r14
    495b:	4c 89 f7             	mov    %r14,%rdi
    495e:	e8 00 00 00 00       	callq  4963 <add_rename_zone_dir+0x143>
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    4963:	48 8d 78 01          	lea    0x1(%rax),%rdi
    4967:	be d0 80 00 00       	mov    $0x80d0,%esi
    496c:	e8 00 00 00 00       	callq  4971 <add_rename_zone_dir+0x151>
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    4971:	4c 89 f7             	mov    %r14,%rdi
    4974:	49 89 c7             	mov    %rax,%r15
    4977:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    497c:	e8 00 00 00 00       	callq  4981 <add_rename_zone_dir+0x161>
    4981:	48 8d 78 01          	lea    0x1(%rax),%rdi
    4985:	be d0 80 00 00       	mov    $0x80d0,%esi
    498a:	e8 00 00 00 00       	callq  498f <add_rename_zone_dir+0x16f>
    slen = strlen(ph);
    498f:	4c 89 f7             	mov    %r14,%rdi
    4992:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
    4997:	e8 00 00 00 00       	callq  499c <add_rename_zone_dir+0x17c>
    499c:	41 89 c5             	mov    %eax,%r13d
    memcpy(phname, ph, slen);
    499f:	4c 89 f6             	mov    %r14,%rsi
    49a2:	4c 89 ff             	mov    %r15,%rdi
    49a5:	4c 89 ea             	mov    %r13,%rdx
    49a8:	e8 00 00 00 00       	callq  49ad <add_rename_zone_dir+0x18d>
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    49ad:	48 8b bc 24 80 00 00 	mov    0x80(%rsp),%rdi
    49b4:	00 
    ph = get_dentry_path(dentry,0);
    phname = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    slen = strlen(ph);
    memcpy(phname, ph, slen);
    phname[slen]='\0';
    49b5:	43 c6 04 2f 00       	movb   $0x0,(%r15,%r13,1)
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    49ba:	4c 89 fa             	mov    %r15,%rdx
    49bd:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    49c4:	48 8b 87 b0 03 00 00 	mov    0x3b0(%rdi),%rax
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    49cb:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    49d2:	4c 8b b0 d8 0d 00 00 	mov    0xdd8(%rax),%r14
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    49d9:	e8 00 00 00 00       	callq  49de <add_rename_zone_dir+0x1be>
    tlen = strlen(phstr);
    49de:	4c 89 ff             	mov    %r15,%rdi
    49e1:	e8 00 00 00 00       	callq  49e6 <add_rename_zone_dir+0x1c6>
    nova_dbg("%s length is %llu", __func__, tlen);
    49e6:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    49ed:	48 89 c2             	mov    %rax,%rdx
    49f0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    tlen = strlen(phstr);
    49f7:	49 89 c5             	mov    %rax,%r13
    nova_dbg("%s length is %llu", __func__, tlen);
    49fa:	e8 00 00 00 00       	callq  49ff <add_rename_zone_dir+0x1df>
    memcpy(phs, phstr, tlen);
    49ff:	4c 89 fe             	mov    %r15,%rsi
    4a02:	4c 8b 7c 24 70       	mov    0x70(%rsp),%r15
    4a07:	4c 89 ea             	mov    %r13,%rdx
    4a0a:	4c 89 ff             	mov    %r15,%rdi
    4a0d:	e8 00 00 00 00       	callq  4a12 <add_rename_zone_dir+0x1f2>
    phs[tlen]='\0';
    4a12:	43 c6 04 2f 00       	movb   $0x0,(%r15,%r13,1)
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    4a17:	be 2f 00 00 00       	mov    $0x2f,%esi
            return dzt_ei;
        }
    }while(1);
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    4a1c:	41 c6 07 2f          	movb   $0x2f,(%r15)
    phs[1]='\0';
    4a20:	41 c6 47 01 00       	movb   $0x0,0x1(%r15)
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    4a25:	4c 89 f7             	mov    %r14,%rdi
    4a28:	e8 00 00 00 00       	callq  4a2d <add_rename_zone_dir+0x20d>
    if(!dzt_ei){
    4a2d:	48 85 c0             	test   %rax,%rax
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    4a30:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
    if(!dzt_ei){
    4a35:	0f 84 47 08 00 00    	je     5282 <add_rename_zone_dir+0xa62>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    4a3b:	48 8b bc 24 80 00 00 	mov    0x80(%rsp),%rdi
    4a42:	00 
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    slen = strlen(ph);
    memcpy(phname, ph, slen);
    phname[slen]='\0';
    dzt_ei = find_dzt(sb, phname, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    4a43:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
    4a48:	48 8b 97 b0 03 00 00 	mov    0x3b0(%rdi),%rdx
    4a4f:	48 8b 40 10          	mov    0x10(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    4a53:	48 89 c7             	mov    %rax,%rdi
    4a56:	48 03 7a 18          	add    0x18(%rdx),%rdi
    4a5a:	48 85 c0             	test   %rax,%rax
    4a5d:	b8 00 00 00 00       	mov    $0x0,%eax
    4a62:	48 0f 45 c7          	cmovne %rdi,%rax

    make_zone_ptr(&zone_p, dafs_ze);
    4a66:	48 8d bc 24 90 00 00 	lea    0x90(%rsp),%rdi
    4a6d:	00 
    struct file_p *tem_sf, *new_sf;
    struct list_head *this, *head, *next;
    char *new_pn, *ph, *par_ph, *tname, *phname, *phn;
    unsigned long phlen;
    //unsigned short delen;
    u32 bitpos = 0, cur_pos = 0, par_pos, slen;
    4a6e:	45 31 f6             	xor    %r14d,%r14d
    memcpy(phname, ph, slen);
    phname[slen]='\0';
    dzt_ei = find_dzt(sb, phname, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    4a71:	48 89 c6             	mov    %rax,%rsi
    4a74:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    4a79:	e8 00 00 00 00       	callq  4a7e <add_rename_zone_dir+0x25e>
    4a7e:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
    4a85:	00 
    struct file_p *tem_sf, *new_sf;
    struct list_head *this, *head, *next;
    char *new_pn, *ph, *par_ph, *tname, *phname, *phn;
    unsigned long phlen;
    //unsigned short delen;
    u32 bitpos = 0, cur_pos = 0, par_pos, slen;
    4a86:	31 d2                	xor    %edx,%edx
    4a88:	48 8b 30             	mov    (%rax),%rsi
    memcpy(phname, ph, slen);
    phname[slen]='\0';
    dzt_ei = find_dzt(sb, phname, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    4a8b:	31 c0                	xor    %eax,%eax
    4a8d:	eb 17                	jmp    4aa6 <add_rename_zone_dir+0x286>
    while(cur_pos<NR_DENTRY_IN_ZONE){
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
            bitpos+=2;
    4a8f:	83 c2 02             	add    $0x2,%edx
            cur_pos++;
    4a92:	41 83 c6 01          	add    $0x1,%r14d
    4a96:	48 83 c0 02          	add    $0x2,%rax
    phname[slen]='\0';
    dzt_ei = find_dzt(sb, phname, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);

    make_zone_ptr(&zone_p, dafs_ze);
    while(cur_pos<NR_DENTRY_IN_ZONE){
    4a9a:	81 fa fe ff 01 00    	cmp    $0x1fffe,%edx
    4aa0:	0f 84 96 06 00 00    	je     513c <add_rename_zone_dir+0x91c>

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    4aa6:	48 0f a3 06          	bt     %rax,(%rsi)
    4aaa:	19 c9                	sbb    %ecx,%ecx
        if(test_bit_le(bitpos, (void *)zone_p->statemap)||test_bit_le(bitpos+1, (void *)zone_p->statemap)){
    4aac:	85 c9                	test   %ecx,%ecx
    4aae:	75 df                	jne    4a8f <add_rename_zone_dir+0x26f>
    4ab0:	4c 8d 68 01          	lea    0x1(%rax),%r13
    4ab4:	4c 0f a3 2e          	bt     %r13,(%rsi)
    4ab8:	19 c9                	sbb    %ecx,%ecx
    4aba:	85 c9                	test   %ecx,%ecx
    4abc:	75 d1                	jne    4a8f <add_rename_zone_dir+0x26f>
        }else{
            break;
        }
    }

    phlen = strlen(phn);
    4abe:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    4ac3:	e8 00 00 00 00       	callq  4ac8 <add_rename_zone_dir+0x2a8>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    4ac8:	48 8b bc 24 80 00 00 	mov    0x80(%rsp),%rdi
    4acf:	00 
    4ad0:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
{
	struct nova_inode_info *si = NOVA_I(inode);
	struct nova_inode_info_header *sih = &si->header;

    //nova_dbg("inode addr is %llu", sih->pi_addr);
	return (struct nova_inode *)nova_get_block(sb, sih->pi_addr);
    4ad5:	49 8b 44 24 c8       	mov    -0x38(%r12),%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    4ada:	48 8b 97 b0 03 00 00 	mov    0x3b0(%rdi),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    4ae1:	48 89 c7             	mov    %rax,%rdi
    4ae4:	48 03 7a 18          	add    0x18(%rdx),%rdi
    4ae8:	48 85 c0             	test   %rax,%rax
    4aeb:	b8 00 00 00 00       	mov    $0x0,%eax
    4af0:	48 0f 45 c7          	cmovne %rdi,%rax
    4af4:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    pidir = nova_get_inode(sb, dir);
    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    4af9:	e8 00 00 00 00       	callq  4afe <add_rename_zone_dir+0x2de>
    4afe:	49 89 44 24 78       	mov    %rax,0x78(%r12)
    4b03:	49 8b 44 24 78       	mov    0x78(%r12),%rax
    //delen = DAFS_DIR_LEN(namelen + phlen);  

    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    4b08:	48 8b 74 24 68       	mov    0x68(%rsp),%rsi
        }
    }

    phlen = strlen(phn);
    pidir = nova_get_inode(sb, dir);
    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    4b0d:	49 c7 84 24 80 00 00 	movq   $0x0,0x80(%r12)
    4b14:	00 00 00 00 00 
    4b19:	49 8b 94 24 80 00 00 	mov    0x80(%r12),%rdx
    4b20:	00 
    4b21:	49 89 44 24 68       	mov    %rax,0x68(%r12)
    //delen = DAFS_DIR_LEN(namelen + phlen);  

    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    4b26:	44 89 f0             	mov    %r14d,%eax
    4b29:	48 89 c7             	mov    %rax,%rdi
    4b2c:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
    4b31:	48 05 81 00 00 00    	add    $0x81,%rax
    4b37:	48 c1 e0 07          	shl    $0x7,%rax
        }
    }

    phlen = strlen(phn);
    pidir = nova_get_inode(sb, dir);
    dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    4b3b:	49 89 54 24 70       	mov    %rdx,0x70(%r12)
    //delen = DAFS_DIR_LEN(namelen + phlen);  

    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    4b40:	48 01 f0             	add    %rsi,%rax
    4b43:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    4b48:	48 89 f8             	mov    %rdi,%rax
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = dentry->d_name.len;
    dafs_de->file_type = ROOT_DIRECTORY;       //file_type是啥？ not decided

	dafs_de->links_count = old_de->links_count;
    4b4b:	48 8b 7c 24 58       	mov    0x58(%rsp),%rdi
    4b50:	48 c1 e0 07          	shl    $0x7,%rax
    4b54:	4c 8d 3c 06          	lea    (%rsi,%rax,1),%r15

    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    //memset(dafs_de, 0, sizeof(dafs_de));
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    4b58:	41 c6 87 80 40 00 00 	movb   $0x6,0x4080(%r15)
    4b5f:	06 
    dafs_de->name_len = dentry->d_name.len;
    4b60:	8b 53 24             	mov    0x24(%rbx),%edx
    dafs_de->file_type = ROOT_DIRECTORY;       //file_type是啥？ not decided
    4b63:	41 c6 87 82 40 00 00 	movb   $0x2,0x4082(%r15)
    4b6a:	02 
    /*get dentry on nvm*/
    dafs_de = &dafs_ze->dentry[cur_pos];
    //memset(dafs_de, 0, sizeof(dafs_de));
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = dentry->d_name.len;
    4b6b:	41 88 97 81 40 00 00 	mov    %dl,0x4081(%r15)
    dafs_de->file_type = ROOT_DIRECTORY;       //file_type是啥？ not decided

	dafs_de->links_count = old_de->links_count;
    4b72:	0f b7 57 06          	movzwl 0x6(%rdi),%edx
    4b76:	66 41 89 97 86 40 00 	mov    %dx,0x4086(%r15)
    4b7d:	00 

    dafs_de->mtime = cpu_to_le32(dir->i_mtime.tv_sec);
    4b7e:	49 8b 54 24 68       	mov    0x68(%r12),%rdx
    4b83:	41 89 97 88 40 00 00 	mov    %edx,0x4088(%r15)
    /*not root at first*/
    //dafs_de->isr_sf = old_de->isr_sf;
    dafs_de->ino = old_de->ino;
    4b8a:	48 8b 57 18          	mov    0x18(%rdi),%rdx
    4b8e:	49 89 97 98 40 00 00 	mov    %rdx,0x4098(%r15)
    dafs_de->size = cpu_to_le64(dir->i_size);
    4b95:	49 8b 54 24 50       	mov    0x50(%r12),%rdx
    4b9a:	49 89 97 a0 40 00 00 	mov    %rdx,0x40a0(%r15)
    /*add dentry name*/
    if(dentry->d_name.len <= SMALL_NAME_LEN){
    4ba1:	83 7b 24 27          	cmpl   $0x27,0x24(%rbx)
    4ba5:	0f 86 02 04 00 00    	jbe    4fad <add_rename_zone_dir+0x78d>
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
        dafs_de->name[dentry->d_name.len] = '\0'; 

    } else {
        dafs_de->ext_flag = 1;
    4bab:	41 b9 01 00 00 00    	mov    $0x1,%r9d
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, cur_pos, dentry->d_name.len, dentry->d_name.name, 0);
    4bb1:	48 8b 8c 24 90 00 00 	mov    0x90(%rsp),%rcx
    4bb8:	00 
    4bb9:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
        dafs_de->name[dentry->d_name.len] = '\0'; 

    } else {
        dafs_de->ext_flag = 1;
    4bbe:	66 45 89 8f 84 40 00 	mov    %r9w,0x4084(%r15)
    4bc5:	00 
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, cur_pos, dentry->d_name.len, dentry->d_name.name, 0);
    4bc6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
    4bcd:	00 
    4bce:	45 89 f0             	mov    %r14d,%r8d
    4bd1:	48 8b 43 28          	mov    0x28(%rbx),%rax
    4bd5:	48 8b 74 24 78       	mov    0x78(%rsp),%rsi
    4bda:	48 8b bc 24 80 00 00 	mov    0x80(%rsp),%rdi
    4be1:	00 
    4be2:	48 89 04 24          	mov    %rax,(%rsp)
    4be6:	44 8b 4b 24          	mov    0x24(%rbx),%r9d
    4bea:	e8 00 00 00 00       	callq  4bef <add_rename_zone_dir+0x3cf>
    }

    dafs_de->fname_len = cpu_to_le64(phlen);
    4bef:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
    4bf4:	48 8b 7c 24 60       	mov    0x60(%rsp),%rdi
    4bf9:	48 8b 74 24 68       	mov    0x68(%rsp),%rsi
    4bfe:	48 c1 e0 07          	shl    $0x7,%rax
    4c02:	48 89 bc 06 90 40 00 	mov    %rdi,0x4090(%rsi,%rax,1)
    4c09:	00 

    /*set isr_sf, fulname*/
    temlen = phlen - dentry->d_name.len;
    4c0a:	8b 43 24             	mov    0x24(%rbx),%eax
    4c0d:	48 89 fb             	mov    %rdi,%rbx
    4c10:	48 29 c3             	sub    %rax,%rbx
    if(temlen == 1){
    4c13:	48 83 fb 01          	cmp    $0x1,%rbx
    4c17:	0f 85 10 04 00 00    	jne    502d <add_rename_zone_dir+0x80d>
        dafs_de->isr_sf = 1;
    4c1d:	41 c6 87 83 40 00 00 	movb   $0x1,0x4083(%r15)
    4c24:	01 
        dafs_de->par_pos = 0;
    4c25:	41 c7 87 8c 40 00 00 	movl   $0x0,0x408c(%r15)
    4c2c:	00 00 00 00 
        kfree(par_ph);
        
    }

    /*set root dir fulname*/
    if(dafs_de->ext_flag==0){
    4c30:	66 41 83 bf 84 40 00 	cmpw   $0x0,0x4084(%r15)
    4c37:	00 00 
        //re_len = SMALL_NAME_LEN - dentry->d_name.len;
        if(phlen<SMALL_NAME_LEN){
    4c39:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
        kfree(par_ph);
        
    }

    /*set root dir fulname*/
    if(dafs_de->ext_flag==0){
    4c3e:	0f 85 ac 03 00 00    	jne    4ff0 <add_rename_zone_dir+0x7d0>
        //re_len = SMALL_NAME_LEN - dentry->d_name.len;
        if(phlen<SMALL_NAME_LEN){
    4c44:	48 83 f8 26          	cmp    $0x26,%rax
    4c48:	0f 87 8f 03 00 00    	ja     4fdd <add_rename_zone_dir+0x7bd>
            memcpy(dafs_de->ful_name.f_name, phn, phlen);
    4c4e:	48 8b 5c 24 40       	mov    0x40(%rsp),%rbx
    4c53:	48 8b 7c 24 68       	mov    0x68(%rsp),%rdi
    4c58:	48 89 c2             	mov    %rax,%rdx
    4c5b:	48 8b 74 24 70       	mov    0x70(%rsp),%rsi
    4c60:	49 89 c7             	mov    %rax,%r15
    4c63:	48 c1 e3 07          	shl    $0x7,%rbx
    4c67:	48 8d bc 1f d8 40 00 	lea    0x40d8(%rdi,%rbx,1),%rdi
    4c6e:	00 
    4c6f:	e8 00 00 00 00       	callq  4c74 <add_rename_zone_dir+0x454>
            dafs_de->ful_name.f_name[phlen]='\0';
    4c74:	48 03 5c 24 68       	add    0x68(%rsp),%rbx
    4c79:	41 c6 84 1f d8 40 00 	movb   $0x0,0x40d8(%r15,%rbx,1)
    4c80:	00 00 
    4c82:	44 89 fb             	mov    %r15d,%ebx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    4c85:	85 db                	test   %ebx,%ebx
    4c87:	0f 8e 84 05 00 00    	jle    5211 <add_rename_zone_dir+0x9f1>
    4c8d:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    4c92:	8d 43 ff             	lea    -0x1(%rbx),%eax
    4c95:	45 31 ff             	xor    %r15d,%r15d
    4c98:	48 89 c3             	mov    %rax,%rbx
    4c9b:	48 8d 4c 07 01       	lea    0x1(%rdi,%rax,1),%rcx
    4ca0:	48 89 f8             	mov    %rdi,%rax
		hash = hash * seed + (*str++);
    4ca3:	4c 89 fa             	mov    %r15,%rdx
    4ca6:	48 83 c0 01          	add    $0x1,%rax
    4caa:	48 c1 e2 05          	shl    $0x5,%rdx
    4cae:	4c 29 fa             	sub    %r15,%rdx
    4cb1:	49 89 d7             	mov    %rdx,%r15
    4cb4:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    4cb9:	49 01 d7             	add    %rdx,%r15
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    4cbc:	48 39 c8             	cmp    %rcx,%rax
    4cbf:	75 e2                	jne    4ca3 <add_rename_zone_dir+0x483>
    /*get hash value*/
    hashname = BKDRHash(phn, phlen);


    /*get new ei path hashname*/
    if(dzt_ei->dzt_eno!=1){
    4cc1:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
    4cc6:	83 78 08 01          	cmpl   $0x1,0x8(%rax)
    4cca:	0f 84 be 04 00 00    	je     518e <add_rename_zone_dir+0x96e>
        newp_len =(u64)dzt_ei->root_len + phlen;
    4cd0:	48 8b 5c 24 60       	mov    0x60(%rsp),%rbx
    4cd5:	48 03 58 28          	add    0x28(%rax),%rbx
        new_pn = kzalloc(sizeof(char)*(newp_len+1), GFP_KERNEL);
    4cd9:	48 8d 7b 01          	lea    0x1(%rbx),%rdi
    4cdd:	be d0 80 00 00       	mov    $0x80d0,%esi
    4ce2:	e8 00 00 00 00       	callq  4ce7 <add_rename_zone_dir+0x4c7>
        get_zone_path(sb,dzt_ei, new_pn, phn);
    4ce7:	48 8b 4c 24 70       	mov    0x70(%rsp),%rcx
    4cec:	48 8b 74 24 78       	mov    0x78(%rsp),%rsi
    4cf1:	48 89 c2             	mov    %rax,%rdx
    4cf4:	48 8b bc 24 80 00 00 	mov    0x80(%rsp),%rdi
    4cfb:	00 
    4cfc:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
    4d01:	e8 00 00 00 00       	callq  4d06 <add_rename_zone_dir+0x4e6>
        *root_len = newp_len;
    4d06:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    4d0b:	85 db                	test   %ebx,%ebx
    4d0d:	4c 8b 44 24 60       	mov    0x60(%rsp),%r8
    4d12:	48 89 18             	mov    %rbx,(%rax)
    4d15:	0f 8e 1b 05 00 00    	jle    5236 <add_rename_zone_dir+0xa16>
    4d1b:	8d 43 ff             	lea    -0x1(%rbx),%eax
    4d1e:	4c 89 c1             	mov    %r8,%rcx
    4d21:	49 8d 74 00 01       	lea    0x1(%r8,%rax,1),%rsi
    4d26:	31 c0                	xor    %eax,%eax
		hash = hash * seed + (*str++);
    4d28:	48 89 c2             	mov    %rax,%rdx
    4d2b:	48 83 c1 01          	add    $0x1,%rcx
    4d2f:	48 c1 e2 05          	shl    $0x5,%rdx
    4d33:	48 29 c2             	sub    %rax,%rdx
    4d36:	48 89 d0             	mov    %rdx,%rax
    4d39:	48 0f be 51 ff       	movsbq -0x1(%rcx),%rdx
    4d3e:	48 01 d0             	add    %rdx,%rax
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    4d41:	48 39 f1             	cmp    %rsi,%rcx
    4d44:	75 e2                	jne    4d28 <add_rename_zone_dir+0x508>
        *new_hn = BKDRHash(new_pn, newp_len);
    4d46:	48 8b 5c 24 48       	mov    0x48(%rsp),%rbx
        kfree(new_pn);
    4d4b:	4c 89 c7             	mov    %r8,%rdi
    if(dzt_ei->dzt_eno!=1){
        newp_len =(u64)dzt_ei->root_len + phlen;
        new_pn = kzalloc(sizeof(char)*(newp_len+1), GFP_KERNEL);
        get_zone_path(sb,dzt_ei, new_pn, phn);
        *root_len = newp_len;
        *new_hn = BKDRHash(new_pn, newp_len);
    4d4e:	48 89 03             	mov    %rax,(%rbx)
        kfree(new_pn);
    4d51:	e8 00 00 00 00       	callq  4d56 <add_rename_zone_dir+0x536>
        *root_len = newp_len;
        *new_hn = BKDRHash(new_pn, newp_len);
        kfree(new_pn);
    }

    dafs_de->dzt_hn = cpu_to_le64(*new_hn);
    4d56:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    4d5b:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
    4d60:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
	if (support_clwb) {
    4d65:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # 4d6b <add_rename_zone_dir+0x54b>
    4d6b:	48 8b 10             	mov    (%rax),%rdx
    4d6e:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    4d73:	89 f1                	mov    %esi,%ecx
    4d75:	83 e1 3f             	and    $0x3f,%ecx
    4d78:	83 e9 80             	sub    $0xffffff80,%ecx
    4d7b:	48 c1 e0 07          	shl    $0x7,%rax
    4d7f:	48 89 94 03 a8 40 00 	mov    %rdx,0x40a8(%rbx,%rax,1)
    4d86:	00 
	if (support_clwb) {
    4d87:	31 d2                	xor    %edx,%edx
    4d89:	85 ff                	test   %edi,%edi
    4d8b:	0f 85 07 02 00 00    	jne    4f98 <add_rename_zone_dir+0x778>
    4d91:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    4d96:	89 d0                	mov    %edx,%eax
    4d98:	48 01 f0             	add    %rsi,%rax
    4d9b:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    4d9e:	83 c2 40             	add    $0x40,%edx
    4da1:	39 d1                	cmp    %edx,%ecx
    4da3:	77 f1                	ja     4d96 <add_rename_zone_dir+0x576>
    /*not decided是不是每次写到nvm都需要这个接口*/ 
    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    4da5:	48 8b 84 24 90 00 00 	mov    0x90(%rsp),%rax
    4dac:	00 
    4dad:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    4db0:	f0 4c 0f ab 28       	lock bts %r13,(%rax)
    4db5:	72 00                	jb     4db7 <add_rename_zone_dir+0x597>
    
    dir->i_blocks = pidir->i_blocks;
    4db7:	48 8b 44 24 20       	mov    0x20(%rsp),%rax

    /*cpy dir_info*/
    new_dir = add_dir_info(dzt_ei, hashname, cur_pos);
    4dbc:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    4dc1:	44 89 f2             	mov    %r14d,%edx
    4dc4:	4c 89 fe             	mov    %r15,%rsi
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    
    dir->i_blocks = pidir->i_blocks;
    4dc7:	48 8b 40 20          	mov    0x20(%rax),%rax
    4dcb:	49 89 84 24 98 00 00 	mov    %rax,0x98(%r12)
    4dd2:	00 

    /*cpy dir_info*/
    new_dir = add_dir_info(dzt_ei, hashname, cur_pos);
    4dd3:	e8 00 00 00 00       	callq  4dd8 <add_rename_zone_dir+0x5b8>
    phlen = le64_to_cpu(old_de->fname_len);
    4dd8:	4c 8b 6c 24 58       	mov    0x58(%rsp),%r13
    4ddd:	be d0 80 00 00       	mov    $0x80d0,%esi
    test_and_set_bit_le(bitpos, (void *)zone_p->statemap);
    
    dir->i_blocks = pidir->i_blocks;

    /*cpy dir_info*/
    new_dir = add_dir_info(dzt_ei, hashname, cur_pos);
    4de2:	48 89 c3             	mov    %rax,%rbx
    phlen = le64_to_cpu(old_de->fname_len);
    4de5:	4d 8b 65 10          	mov    0x10(%r13),%r12
    4de9:	4c 89 e7             	mov    %r12,%rdi
    4dec:	e8 00 00 00 00       	callq  4df1 <add_rename_zone_dir+0x5d1>
    tname = kzalloc(sizeof(char)*phlen,GFP_KERNEL);
    old_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    4df1:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
    4df6:	49 89 c3             	mov    %rax,%r11
    4df9:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    4dfe:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
    4e05:	00 
    get_de_name(old_de, old_ze, tname, 1);
    4e06:	b9 01 00 00 00       	mov    $0x1,%ecx

    /*cpy dir_info*/
    new_dir = add_dir_info(dzt_ei, hashname, cur_pos);
    phlen = le64_to_cpu(old_de->fname_len);
    tname = kzalloc(sizeof(char)*phlen,GFP_KERNEL);
    old_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    4e0b:	48 8b 57 10          	mov    0x10(%rdi),%rdx
    get_de_name(old_de, old_ze, tname, 1);
    4e0f:	4c 89 ef             	mov    %r13,%rdi
    4e12:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    4e19:	48 89 d6             	mov    %rdx,%rsi
    4e1c:	48 03 70 18          	add    0x18(%rax),%rsi
    4e20:	48 85 d2             	test   %rdx,%rdx
    4e23:	4c 89 da             	mov    %r11,%rdx
    4e26:	48 89 f0             	mov    %rsi,%rax
    4e29:	be 00 00 00 00       	mov    $0x0,%esi
    4e2e:	48 0f 45 f0          	cmovne %rax,%rsi
    4e32:	e8 00 00 00 00       	callq  4e37 <add_rename_zone_dir+0x617>
    old_hn = BKDRHash(tname, phlen); 
    old_dir = radix_tree_delete(&old_ei->dir_tree, phlen);
    4e37:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
    4e3c:	4c 89 e6             	mov    %r12,%rsi
    4e3f:	48 83 c7 38          	add    $0x38,%rdi
    4e43:	e8 00 00 00 00       	callq  4e48 <add_rename_zone_dir+0x628>
    head = &old_dir->sub_file;
    list_for_each_safe(this, next, head){
    4e48:	4c 8b 60 18          	mov    0x18(%rax),%r12
    tname = kzalloc(sizeof(char)*phlen,GFP_KERNEL);
    old_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    get_de_name(old_de, old_ze, tname, 1);
    old_hn = BKDRHash(tname, phlen); 
    old_dir = radix_tree_delete(&old_ei->dir_tree, phlen);
    head = &old_dir->sub_file;
    4e4c:	48 8d 78 18          	lea    0x18(%rax),%rdi
    phlen = le64_to_cpu(old_de->fname_len);
    tname = kzalloc(sizeof(char)*phlen,GFP_KERNEL);
    old_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    get_de_name(old_de, old_ze, tname, 1);
    old_hn = BKDRHash(tname, phlen); 
    old_dir = radix_tree_delete(&old_ei->dir_tree, phlen);
    4e50:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
    4e55:	48 8d 43 18          	lea    0x18(%rbx),%rax
    head = &old_dir->sub_file;
    list_for_each_safe(this, next, head){
    4e59:	4c 39 e7             	cmp    %r12,%rdi
    4e5c:	4d 8b 2c 24          	mov    (%r12),%r13
    4e60:	0f 84 90 00 00 00    	je     4ef6 <add_rename_zone_dir+0x6d6>
    4e66:	4c 89 7c 24 58       	mov    %r15,0x58(%rsp)
    4e6b:	44 89 74 24 50       	mov    %r14d,0x50(%rsp)
    4e70:	4d 89 e7             	mov    %r12,%r15
    4e73:	4d 89 ee             	mov    %r13,%r14
    4e76:	49 89 fc             	mov    %rdi,%r12
    4e79:	49 89 c5             	mov    %rax,%r13
    4e7c:	eb 03                	jmp    4e81 <add_rename_zone_dir+0x661>
    4e7e:	49 89 c6             	mov    %rax,%r14
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    4e81:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 4e88 <add_rename_zone_dir+0x668>
    4e88:	ba 14 00 00 00       	mov    $0x14,%edx
    4e8d:	be d0 80 00 00       	mov    $0x80d0,%esi
    4e92:	e8 00 00 00 00       	callq  4e97 <add_rename_zone_dir+0x677>
        tem_sf = list_entry(this, struct file_p, list);
        new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        new_sf->pos = tem_sf->pos;
    4e97:	41 8b 57 10          	mov    0x10(%r15),%edx
        list_add_tail(&new_sf->list, &new_dir->sub_file);
        list_del(&tem_sf->list);
        kfree(tem_sf);
    4e9b:	4c 89 ff             	mov    %r15,%rdi
    old_dir = radix_tree_delete(&old_ei->dir_tree, phlen);
    head = &old_dir->sub_file;
    list_for_each_safe(this, next, head){
        tem_sf = list_entry(this, struct file_p, list);
        new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        new_sf->pos = tem_sf->pos;
    4e9e:	89 50 10             	mov    %edx,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    4ea1:	48 8b 53 20          	mov    0x20(%rbx),%rdx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    4ea5:	48 89 43 20          	mov    %rax,0x20(%rbx)
	new->next = next;
    4ea9:	4c 89 28             	mov    %r13,(%rax)
	new->prev = prev;
    4eac:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    4eb0:	48 89 02             	mov    %rax,(%rdx)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    4eb3:	49 8b 47 08          	mov    0x8(%r15),%rax
    4eb7:	49 8b 17             	mov    (%r15),%rdx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    4eba:	48 89 42 08          	mov    %rax,0x8(%rdx)
	prev->next = next;
    4ebe:	48 89 10             	mov    %rdx,(%rax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    4ec1:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
    4ec8:	00 ad de 
    4ecb:	49 89 07             	mov    %rax,(%r15)
	entry->prev = LIST_POISON2;
    4ece:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
    4ed5:	00 ad de 
    4ed8:	49 89 47 08          	mov    %rax,0x8(%r15)
    4edc:	4d 89 f7             	mov    %r14,%r15
        list_add_tail(&new_sf->list, &new_dir->sub_file);
        list_del(&tem_sf->list);
        kfree(tem_sf);
    4edf:	e8 00 00 00 00       	callq  4ee4 <add_rename_zone_dir+0x6c4>
    old_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    get_de_name(old_de, old_ze, tname, 1);
    old_hn = BKDRHash(tname, phlen); 
    old_dir = radix_tree_delete(&old_ei->dir_tree, phlen);
    head = &old_dir->sub_file;
    list_for_each_safe(this, next, head){
    4ee4:	4d 39 f4             	cmp    %r14,%r12
    4ee7:	49 8b 06             	mov    (%r14),%rax
    4eea:	75 92                	jne    4e7e <add_rename_zone_dir+0x65e>
    4eec:	4c 8b 7c 24 58       	mov    0x58(%rsp),%r15
    4ef1:	44 8b 74 24 50       	mov    0x50(%rsp),%r14d
        new_sf->pos = tem_sf->pos;
        list_add_tail(&new_sf->list, &new_dir->sub_file);
        list_del(&tem_sf->list);
        kfree(tem_sf);
    }
    kfree(old_dir);
    4ef6:	48 8b 7c 24 68       	mov    0x68(%rsp),%rdi
    4efb:	e8 00 00 00 00       	callq  4f00 <add_rename_zone_dir+0x6e0>

    /*set pos in hash table for each zone*/
    //hashname = BKDRHash(phn, phlen);
    record_pos_htable(sb, dzt_ei->ht_head, hashname, cur_pos, 1);
    4f00:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
    4f05:	48 8b bc 24 80 00 00 	mov    0x80(%rsp),%rdi
    4f0c:	00 
    4f0d:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    4f13:	44 89 f1             	mov    %r14d,%ecx
    4f16:	4c 89 fa             	mov    %r15,%rdx
    4f19:	48 8b 70 18          	mov    0x18(%rax),%rsi
    4f1d:	e8 00 00 00 00       	callq  4f22 <add_rename_zone_dir+0x702>

    kfree(tname);
    4f22:	48 8b 7c 24 60       	mov    0x60(%rsp),%rdi
    4f27:	e8 00 00 00 00       	callq  4f2c <add_rename_zone_dir+0x70c>
    kfree(phname);
    4f2c:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
    4f31:	e8 00 00 00 00       	callq  4f36 <add_rename_zone_dir+0x716>
    kfree(ph);
    4f36:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
    4f3b:	e8 00 00 00 00       	callq  4f40 <add_rename_zone_dir+0x720>
    kfree(phn);
    4f40:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    4f45:	e8 00 00 00 00       	callq  4f4a <add_rename_zone_dir+0x72a>
    kfree(zone_p);
    4f4a:	48 8b bc 24 90 00 00 	mov    0x90(%rsp),%rdi
    4f51:	00 
    4f52:	e8 00 00 00 00       	callq  4f57 <add_rename_zone_dir+0x737>
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    4f57:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 4f5d <add_rename_zone_dir+0x73d>
    4f5d:	85 c0                	test   %eax,%eax
    4f5f:	0f 85 e8 01 00 00    	jne    514d <add_rename_zone_dir+0x92d>
    return ret;
    4f65:	31 c0                	xor    %eax,%eax
    kfree(tname);
    kfree(phname);
    kfree(ph);
    kfree(phn);
    kfree(zone_p);
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    4f67:	65 48 ff 05 00 00 00 	incq   %gs:0x0(%rip)        # 4f6f <add_rename_zone_dir+0x74f>
    4f6e:	00 
    return ret;
}
    4f6f:	48 8b 9c 24 b8 00 00 	mov    0xb8(%rsp),%rbx
    4f76:	00 
    4f77:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    4f7e:	00 00 
    4f80:	0f 85 98 04 00 00    	jne    541e <add_rename_zone_dir+0xbfe>
    4f86:	48 81 c4 c0 00 00 00 	add    $0xc0,%rsp
    4f8d:	5b                   	pop    %rbx
    4f8e:	41 5c                	pop    %r12
    4f90:	41 5d                	pop    %r13
    4f92:	41 5e                	pop    %r14
    4f94:	41 5f                	pop    %r15
    4f96:	5d                   	pop    %rbp
    4f97:	c3                   	retq   
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    4f98:	89 d0                	mov    %edx,%eax
    4f9a:	48 01 f0             	add    %rsi,%rax
    4f9d:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    4fa1:	83 c2 40             	add    $0x40,%edx
    4fa4:	39 d1                	cmp    %edx,%ecx
    4fa6:	77 f0                	ja     4f98 <add_rename_zone_dir+0x778>
    4fa8:	e9 f8 fd ff ff       	jmpq   4da5 <add_rename_zone_dir+0x585>
    //dafs_de->isr_sf = old_de->isr_sf;
    dafs_de->ino = old_de->ino;
    dafs_de->size = cpu_to_le64(dir->i_size);
    /*add dentry name*/
    if(dentry->d_name.len <= SMALL_NAME_LEN){
        dafs_de->ext_flag = 0;
    4fad:	45 31 d2             	xor    %r10d,%r10d
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
    4fb0:	48 8d bc 06 b0 40 00 	lea    0x40b0(%rsi,%rax,1),%rdi
    4fb7:	00 
    //dafs_de->isr_sf = old_de->isr_sf;
    dafs_de->ino = old_de->ino;
    dafs_de->size = cpu_to_le64(dir->i_size);
    /*add dentry name*/
    if(dentry->d_name.len <= SMALL_NAME_LEN){
        dafs_de->ext_flag = 0;
    4fb8:	66 45 89 97 84 40 00 	mov    %r10w,0x4084(%r15)
    4fbf:	00 
        memcpy(dafs_de->name,dentry->d_name.name,dentry->d_name.len);
    4fc0:	8b 53 24             	mov    0x24(%rbx),%edx
    4fc3:	48 8b 73 28          	mov    0x28(%rbx),%rsi
    4fc7:	e8 00 00 00 00       	callq  4fcc <add_rename_zone_dir+0x7ac>
        dafs_de->name[dentry->d_name.len] = '\0'; 
    4fcc:	8b 43 24             	mov    0x24(%rbx),%eax
    4fcf:	41 c6 84 07 b0 40 00 	movb   $0x0,0x40b0(%r15,%rax,1)
    4fd6:	00 00 
    4fd8:	e9 12 fc ff ff       	jmpq   4bef <add_rename_zone_dir+0x3cf>
        if(phlen<SMALL_NAME_LEN){
            memcpy(dafs_de->ful_name.f_name, phn, phlen);
            dafs_de->ful_name.f_name[phlen]='\0';
        } else {
            dafs_de->ext_flag = 2;
            ext_de_name(sb, dzt_ei, dafs_ze, zone_p, cur_pos, phlen, phn, 1);
    4fdd:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
        //re_len = SMALL_NAME_LEN - dentry->d_name.len;
        if(phlen<SMALL_NAME_LEN){
            memcpy(dafs_de->ful_name.f_name, phn, phlen);
            dafs_de->ful_name.f_name[phlen]='\0';
        } else {
            dafs_de->ext_flag = 2;
    4fe2:	41 b8 02 00 00 00    	mov    $0x2,%r8d
    4fe8:	66 45 89 87 84 40 00 	mov    %r8w,0x4084(%r15)
    4fef:	00 
            ext_de_name(sb, dzt_ei, dafs_ze, zone_p, cur_pos, phlen, phn, 1);
        }
    } else
        ext_de_name(sb, dzt_ei, dafs_ze, zone_p, cur_pos, phlen, phn, 1);
    4ff0:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    4ff5:	48 8b 8c 24 90 00 00 	mov    0x90(%rsp),%rcx
    4ffc:	00 
    4ffd:	41 89 c1             	mov    %eax,%r9d
    5000:	48 8b 54 24 68       	mov    0x68(%rsp),%rdx
    5005:	48 8b 74 24 78       	mov    0x78(%rsp),%rsi
    500a:	45 89 f0             	mov    %r14d,%r8d
    500d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    5014:	00 
    5015:	89 c3                	mov    %eax,%ebx
    5017:	48 89 3c 24          	mov    %rdi,(%rsp)
    501b:	48 8b bc 24 80 00 00 	mov    0x80(%rsp),%rdi
    5022:	00 
    5023:	e8 00 00 00 00       	callq  5028 <add_rename_zone_dir+0x808>
    5028:	e9 58 fc ff ff       	jmpq   4c85 <add_rename_zone_dir+0x465>
        dafs_de->isr_sf = 1;
        dafs_de->par_pos = 0;
    }else{
        dafs_de->isr_sf = 0;
        /*set par_pos*/
        par_ph = kzalloc(temlen*sizeof(char), GFP_KERNEL);
    502d:	48 89 df             	mov    %rbx,%rdi
    temlen = phlen - dentry->d_name.len;
    if(temlen == 1){
        dafs_de->isr_sf = 1;
        dafs_de->par_pos = 0;
    }else{
        dafs_de->isr_sf = 0;
    5030:	41 c6 87 83 40 00 00 	movb   $0x0,0x4083(%r15)
    5037:	00 
        /*set par_pos*/
        par_ph = kzalloc(temlen*sizeof(char), GFP_KERNEL);
    5038:	e8 93 b2 ff ff       	callq  2d0 <kzalloc.constprop.8>
        temlen--;
    503d:	48 8d 4b ff          	lea    -0x1(%rbx),%rcx
        memcpy(par_ph, phn, temlen);
    5041:	48 8b 74 24 70       	mov    0x70(%rsp),%rsi
    5046:	48 89 c7             	mov    %rax,%rdi
    5049:	48 89 ca             	mov    %rcx,%rdx
    504c:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
    5051:	e8 00 00 00 00       	callq  5056 <add_rename_zone_dir+0x836>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    5056:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
    505b:	49 89 c1             	mov    %rax,%r9
        par_ph[temlen] = '\0';
    505e:	c6 44 18 ff 00       	movb   $0x0,-0x1(%rax,%rbx,1)
    5063:	85 c9                	test   %ecx,%ecx
    5065:	0f 8e d2 01 00 00    	jle    523d <add_rename_zone_dir+0xa1d>
    506b:	8d 41 ff             	lea    -0x1(%rcx),%eax
    506e:	31 db                	xor    %ebx,%ebx
    5070:	49 8d 4c 01 01       	lea    0x1(%r9,%rax,1),%rcx
    5075:	4c 89 c8             	mov    %r9,%rax
		hash = hash * seed + (*str++);
    5078:	48 89 da             	mov    %rbx,%rdx
    507b:	48 83 c0 01          	add    $0x1,%rax
    507f:	48 c1 e2 05          	shl    $0x5,%rdx
    5083:	48 29 da             	sub    %rbx,%rdx
    5086:	48 89 d3             	mov    %rdx,%rbx
    5089:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    508e:	48 01 d3             	add    %rdx,%rbx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    5091:	48 39 c8             	cmp    %rcx,%rax
    5094:	75 e2                	jne    5078 <add_rename_zone_dir+0x858>
        par_hash = BKDRHash(par_ph, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
    5096:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
    509b:	48 8b bc 24 80 00 00 	mov    0x80(%rsp),%rdi
    50a2:	00 
    50a3:	4c 8d 84 24 8c 00 00 	lea    0x8c(%rsp),%r8
    50aa:	00 
    50ab:	b9 01 00 00 00       	mov    $0x1,%ecx
    50b0:	48 89 da             	mov    %rbx,%rdx
    50b3:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
    50b8:	48 8b 70 18          	mov    0x18(%rax),%rsi
    50bc:	e8 00 00 00 00       	callq  50c1 <add_rename_zone_dir+0x8a1>
        dafs_de->par_pos = cpu_to_le32(par_pos);
    50c1:	8b 84 24 8c 00 00 00 	mov    0x8c(%rsp),%eax

        /*set sub file pos*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    50c8:	48 89 de             	mov    %rbx,%rsi
        temlen--;
        memcpy(par_ph, phn, temlen);
        par_ph[temlen] = '\0';
        par_hash = BKDRHash(par_ph, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
        dafs_de->par_pos = cpu_to_le32(par_pos);
    50cb:	41 89 87 8c 40 00 00 	mov    %eax,0x408c(%r15)

        /*set sub file pos*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    50d2:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
    50d7:	48 8d 78 38          	lea    0x38(%rax),%rdi
    50db:	e8 00 00 00 00       	callq  50e0 <add_rename_zone_dir+0x8c0>
        pdir->sub_num++;
    50e0:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
        par_hash = BKDRHash(par_ph, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
        dafs_de->par_pos = cpu_to_le32(par_pos);

        /*set sub file pos*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    50e5:	48 89 c3             	mov    %rax,%rbx
    50e8:	ba 14 00 00 00       	mov    $0x14,%edx
    50ed:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 50f4 <add_rename_zone_dir+0x8d4>
    50f4:	be d0 80 00 00       	mov    $0x80d0,%esi
        pdir->sub_num++;
        tem_sf = (struct file_p *)kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = cur_pos;
        list_add_tail(&tem_sf->list, &pdir->sub_file);
    50f9:	48 83 c3 18          	add    $0x18,%rbx
    50fd:	e8 00 00 00 00       	callq  5102 <add_rename_zone_dir+0x8e2>
        kfree(par_ph);
    5102:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9

        /*set sub file pos*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        pdir->sub_num++;
        tem_sf = (struct file_p *)kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = cur_pos;
    5107:	44 89 70 10          	mov    %r14d,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    510b:	48 8b 53 08          	mov    0x8(%rbx),%rdx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    510f:	48 89 43 08          	mov    %rax,0x8(%rbx)
        list_add_tail(&tem_sf->list, &pdir->sub_file);
    5113:	48 89 18             	mov    %rbx,(%rax)
        kfree(par_ph);
    5116:	4c 89 cf             	mov    %r9,%rdi
	new->next = next;
	new->prev = prev;
    5119:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    511d:	48 89 02             	mov    %rax,(%rdx)
    5120:	e8 00 00 00 00       	callq  5125 <add_rename_zone_dir+0x905>
    5125:	e9 06 fb ff ff       	jmpq   4c30 <add_rename_zone_dir+0x410>
    512a:	48 8d bc 24 98 00 00 	lea    0x98(%rsp),%rdi
    5131:	00 
    5132:	e8 00 00 00 00       	callq  5137 <add_rename_zone_dir+0x917>
    5137:	e9 50 f7 ff ff       	jmpq   488c <add_rename_zone_dir+0x6c>
    513c:	41 bd ff ff 01 00    	mov    $0x1ffff,%r13d
    5142:	41 be ff ff 00 00    	mov    $0xffff,%r14d
    5148:	e9 71 f9 ff ff       	jmpq   4abe <add_rename_zone_dir+0x29e>
    514d:	48 8d bc 24 a8 00 00 	lea    0xa8(%rsp),%rdi
    5154:	00 
    5155:	e8 00 00 00 00       	callq  515a <add_rename_zone_dir+0x93a>
    kfree(tname);
    kfree(phname);
    kfree(ph);
    kfree(phn);
    kfree(zone_p);
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    515a:	48 8b 84 24 a8 00 00 	mov    0xa8(%rsp),%rax
    5161:	00 
    5162:	48 2b 84 24 98 00 00 	sub    0x98(%rsp),%rax
    5169:	00 
    516a:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    5171:	48 2b 84 24 a0 00 00 	sub    0xa0(%rsp),%rax
    5178:	00 
    5179:	48 03 84 24 b0 00 00 	add    0xb0(%rsp),%rax
    5180:	00 
    5181:	65 48 01 05 00 00 00 	add    %rax,%gs:0x0(%rip)        # 5189 <add_rename_zone_dir+0x969>
    5188:	00 
    5189:	e9 d7 fd ff ff       	jmpq   4f65 <add_rename_zone_dir+0x745>
        *root_len = newp_len;
        *new_hn = BKDRHash(new_pn, newp_len);
        kfree(new_pn);
    } else {
        newp_len = phlen;
        new_pn = kzalloc(sizeof(char *)*(newp_len+1), GFP_KERNEL);
    518e:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
    5193:	48 8d 3c c5 08 00 00 	lea    0x8(,%rax,8),%rdi
    519a:	00 
    519b:	e8 30 b1 ff ff       	callq  2d0 <kzalloc.constprop.8>
        memcpy(new_pn, phn, newp_len);
    51a0:	48 8b 74 24 70       	mov    0x70(%rsp),%rsi
    51a5:	48 8b 54 24 60       	mov    0x60(%rsp),%rdx
    51aa:	48 89 c7             	mov    %rax,%rdi
    51ad:	e8 00 00 00 00       	callq  51b2 <add_rename_zone_dir+0x992>
        new_pn[newp_len]='\0';
        *root_len = newp_len;
    51b2:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
        *new_hn = BKDRHash(new_pn, newp_len);
        kfree(new_pn);
    } else {
        newp_len = phlen;
        new_pn = kzalloc(sizeof(char *)*(newp_len+1), GFP_KERNEL);
        memcpy(new_pn, phn, newp_len);
    51b7:	48 89 c1             	mov    %rax,%rcx
        new_pn[newp_len]='\0';
    51ba:	48 8b 44 24 60       	mov    0x60(%rsp),%rax
        *root_len = newp_len;
        *new_hn = BKDRHash(new_pn, newp_len);
        kfree(new_pn);
    } else {
        newp_len = phlen;
        new_pn = kzalloc(sizeof(char *)*(newp_len+1), GFP_KERNEL);
    51bf:	48 89 ce             	mov    %rcx,%rsi
        memcpy(new_pn, phn, newp_len);
        new_pn[newp_len]='\0';
    51c2:	c6 04 01 00          	movb   $0x0,(%rcx,%rax,1)
        *root_len = newp_len;
    51c6:	48 89 07             	mov    %rax,(%rdi)
    51c9:	48 8d 7c 19 01       	lea    0x1(%rcx,%rbx,1),%rdi
    51ce:	31 c0                	xor    %eax,%eax
		hash = hash * seed + (*str++);
    51d0:	48 89 c2             	mov    %rax,%rdx
    51d3:	48 83 c6 01          	add    $0x1,%rsi
    51d7:	48 c1 e2 05          	shl    $0x5,%rdx
    51db:	48 29 c2             	sub    %rax,%rdx
    51de:	48 89 d0             	mov    %rdx,%rax
    51e1:	48 0f be 56 ff       	movsbq -0x1(%rsi),%rdx
    51e6:	48 01 d0             	add    %rdx,%rax
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    51e9:	48 39 fe             	cmp    %rdi,%rsi
    51ec:	75 e2                	jne    51d0 <add_rename_zone_dir+0x9b0>
        *new_hn = BKDRHash(new_pn, newp_len);
    51ee:	48 8b 5c 24 48       	mov    0x48(%rsp),%rbx
        kfree(new_pn);
    51f3:	48 89 cf             	mov    %rcx,%rdi
        newp_len = phlen;
        new_pn = kzalloc(sizeof(char *)*(newp_len+1), GFP_KERNEL);
        memcpy(new_pn, phn, newp_len);
        new_pn[newp_len]='\0';
        *root_len = newp_len;
        *new_hn = BKDRHash(new_pn, newp_len);
    51f6:	48 89 03             	mov    %rax,(%rbx)
        kfree(new_pn);
    51f9:	e8 00 00 00 00       	callq  51fe <add_rename_zone_dir+0x9de>
    51fe:	e9 53 fb ff ff       	jmpq   4d56 <add_rename_zone_dir+0x536>
				__func__, dir->i_ino, ino);
	nova_dbg_verbose("%s: %s %d\n", __func__, name, namelen);*/

	NOVA_START_TIMING(add_dentry_t, add_dentry_time);
	if (namelen == 0)
		return -EINVAL;
    5203:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    5208:	e9 62 fd ff ff       	jmpq   4f6f <add_rename_zone_dir+0x74f>
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    520d:	0f 0b                	ud2    
    BUG_ON(sbi==NULL);
    520f:	0f 0b                	ud2    
    /*get hash value*/
    hashname = BKDRHash(phn, phlen);


    /*get new ei path hashname*/
    if(dzt_ei->dzt_eno!=1){
    5211:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
    5216:	83 78 08 01          	cmpl   $0x1,0x8(%rax)
    521a:	74 28                	je     5244 <add_rename_zone_dir+0xa24>
        newp_len =(u64)dzt_ei->root_len + phlen;
    521c:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
    5221:	48 8b 5c 24 60       	mov    0x60(%rsp),%rbx
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    5226:	45 31 ff             	xor    %r15d,%r15d
    5229:	48 03 58 28          	add    0x28(%rax),%rbx
        new_pn = kzalloc(sizeof(char)*(newp_len+1), GFP_KERNEL);
    522d:	48 8d 7b 01          	lea    0x1(%rbx),%rdi
    5231:	e9 a7 fa ff ff       	jmpq   4cdd <add_rename_zone_dir+0x4bd>
    5236:	31 c0                	xor    %eax,%eax
    5238:	e9 09 fb ff ff       	jmpq   4d46 <add_rename_zone_dir+0x526>
    523d:	31 db                	xor    %ebx,%ebx
    523f:	e9 52 fe ff ff       	jmpq   5096 <add_rename_zone_dir+0x876>
        *root_len = newp_len;
        *new_hn = BKDRHash(new_pn, newp_len);
        kfree(new_pn);
    } else {
        newp_len = phlen;
        new_pn = kzalloc(sizeof(char *)*(newp_len+1), GFP_KERNEL);
    5244:	48 8b 5c 24 60       	mov    0x60(%rsp),%rbx
    5249:	45 31 ff             	xor    %r15d,%r15d
    524c:	48 8d 3c dd 08 00 00 	lea    0x8(,%rbx,8),%rdi
    5253:	00 
    5254:	e8 77 b0 ff ff       	callq  2d0 <kzalloc.constprop.8>
        memcpy(new_pn, phn, newp_len);
    5259:	48 8b 74 24 70       	mov    0x70(%rsp),%rsi
    525e:	48 89 da             	mov    %rbx,%rdx
    5261:	48 89 c7             	mov    %rax,%rdi
    5264:	e8 00 00 00 00       	callq  5269 <add_rename_zone_dir+0xa49>
    5269:	48 89 c1             	mov    %rax,%rcx
        new_pn[newp_len]='\0';
    526c:	48 89 d8             	mov    %rbx,%rax
    526f:	c6 04 19 00          	movb   $0x0,(%rcx,%rbx,1)
        *root_len = newp_len;
    5273:	48 8b 5c 24 28       	mov    0x28(%rsp),%rbx
    5278:	48 89 03             	mov    %rax,(%rbx)
    527b:	31 c0                	xor    %eax,%eax
    527d:	e9 6c ff ff ff       	jmpq   51ee <add_rename_zone_dir+0x9ce>
    5282:	e8 00 00 00 00       	callq  5287 <add_rename_zone_dir+0xa67>
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    5287:	4d 8d af d7 05 00 00 	lea    0x5d7(%r15),%r13
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
        memcpy(buf,"/",1);
    528e:	41 c6 87 d7 05 00 00 	movb   $0x2f,0x5d7(%r15)
    5295:	2f 
        buf[1]='\0';
    5296:	41 c6 87 d8 05 00 00 	movb   $0x0,0x5d8(%r15)
    529d:	00 
    }
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    529e:	49 89 de             	mov    %rbx,%r14
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    52a1:	4c 89 ef             	mov    %r13,%rdi
    52a4:	4c 89 44 24 70       	mov    %r8,0x70(%rsp)
    52a9:	4c 89 54 24 78       	mov    %r10,0x78(%rsp)
    52ae:	e8 00 00 00 00       	callq  52b3 <add_rename_zone_dir+0xa93>
    52b3:	41 bb 2f 00 00 00    	mov    $0x2f,%r11d
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    52b9:	49 8d 7c 05 01       	lea    0x1(%r13,%rax,1),%rdi
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    52be:	66 45 89 5c 05 00    	mov    %r11w,0x0(%r13,%rax,1)
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    52c4:	49 8b 76 28          	mov    0x28(%r14),%rsi
    52c8:	e8 00 00 00 00       	callq  52cd <add_rename_zone_dir+0xaad>
        p_dentry = tem_dentry->d_parent;
    52cd:	4d 8b 76 18          	mov    0x18(%r14),%r14
        //plen = strlen(buf);
        //buf[plen]='\0';
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
    52d1:	4c 8b 54 24 78       	mov    0x78(%rsp),%r10
    52d6:	b9 02 00 00 00       	mov    $0x2,%ecx
    52db:	4c 8b 44 24 70       	mov    0x70(%rsp),%r8
    52e0:	49 8b 76 28          	mov    0x28(%r14),%rsi
    52e4:	4c 89 d7             	mov    %r10,%rdi
    52e7:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    52e9:	75 b6                	jne    52a1 <add_rename_zone_dir+0xa81>
    52eb:	49 8b 46 30          	mov    0x30(%r14),%rax
    52ef:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
    52f4:	75 ab                	jne    52a1 <add_rename_zone_dir+0xa81>

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    52f6:	49 8d 87 d6 09 00 00 	lea    0x9d6(%r15),%rax
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    52fd:	4c 89 ea             	mov    %r13,%rdx
    5300:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    5307:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    530e:	4c 89 54 24 68       	mov    %r10,0x68(%rsp)

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    5313:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    5318:	e8 00 00 00 00       	callq  531d <add_rename_zone_dir+0xafd>
    tlen = strlen(buf);
    531d:	4c 89 ef             	mov    %r13,%rdi
    5320:	e8 00 00 00 00       	callq  5325 <add_rename_zone_dir+0xb05>
    memcpy(tem, buf, tlen);
    5325:	49 8d bf d6 09 00 00 	lea    0x9d6(%r15),%rdi
    532c:	48 89 c2             	mov    %rax,%rdx
    532f:	4c 89 ee             	mov    %r13,%rsi
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    tlen = strlen(buf);
    5332:	49 89 c6             	mov    %rax,%r14
    memcpy(tem, buf, tlen);
    5335:	e8 00 00 00 00       	callq  533a <add_rename_zone_dir+0xb1a>
    tem[tlen]='\0';
    533a:	4c 8b 44 24 70       	mov    0x70(%rsp),%r8
    533f:	4c 8b 54 24 68       	mov    0x68(%rsp),%r10
    5344:	43 c6 84 37 d6 09 00 	movb   $0x0,0x9d6(%r15,%r14,1)
    534b:	00 00 
    534d:	48 89 5c 24 70       	mov    %rbx,0x70(%rsp)
    5352:	4d 89 c7             	mov    %r8,%r15
    do{
        ppath = strrchr(tem, '/');
    5355:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
    535a:	be 2f 00 00 00       	mov    $0x2f,%esi
    535f:	4c 89 54 24 68       	mov    %r10,0x68(%rsp)
    5364:	e8 00 00 00 00       	callq  5369 <add_rename_zone_dir+0xb49>
        plen = strlen(ppath);
    5369:	48 89 c7             	mov    %rax,%rdi
    nova_dbg("%s buf is %s",__func__, buf);
    tlen = strlen(buf);
    memcpy(tem, buf, tlen);
    tem[tlen]='\0';
    do{
        ppath = strrchr(tem, '/');
    536c:	48 89 c3             	mov    %rax,%rbx
        plen = strlen(ppath);
    536f:	e8 00 00 00 00       	callq  5374 <add_rename_zone_dir+0xb54>
        phlen = tlen - plen;
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    5374:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
    5379:	48 89 de             	mov    %rbx,%rsi
    memcpy(tem, buf, tlen);
    tem[tlen]='\0';
    do{
        ppath = strrchr(tem, '/');
        plen = strlen(ppath);
        phlen = tlen - plen;
    537c:	49 29 c6             	sub    %rax,%r14
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    537f:	e8 00 00 00 00       	callq  5384 <add_rename_zone_dir+0xb64>
        memcpy(tem, buf, tlen);
    5384:	48 8b 5c 24 78       	mov    0x78(%rsp),%rbx
    5389:	4c 89 ee             	mov    %r13,%rsi
    538c:	4c 89 f2             	mov    %r14,%rdx
    538f:	48 89 df             	mov    %rbx,%rdi
    5392:	e8 00 00 00 00       	callq  5397 <add_rename_zone_dir+0xb77>
        tem[tlen]='\0';
        if(!strcmp(tem,"/"))
    5397:	4c 8b 54 24 68       	mov    0x68(%rsp),%r10
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
        memcpy(tem, buf, tlen);
        tem[tlen]='\0';
    539c:	48 89 de             	mov    %rbx,%rsi
    539f:	42 c6 04 33 00       	movb   $0x0,(%rbx,%r14,1)
        if(!strcmp(tem,"/"))
    53a4:	b9 02 00 00 00       	mov    $0x2,%ecx
    53a9:	4c 89 d7             	mov    %r10,%rdi
    53ac:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    53ae:	75 a5                	jne    5355 <add_rename_zone_dir+0xb35>
            break;
    }while(1);

    //BUG_ON(strlen(ph)==1023);
    nova_dbg("%s ful ph is %s sbi is %s",__func__,ph, sbi->ph_f);
    53b0:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    53b5:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    53bc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    53c3:	4c 89 7c 24 78       	mov    %r15,0x78(%rsp)
    53c8:	48 8b 5c 24 70       	mov    0x70(%rsp),%rbx
    53cd:	48 89 d1             	mov    %rdx,%rcx
    53d0:	e8 00 00 00 00       	callq  53d5 <add_rename_zone_dir+0xbb5>
    //BUG_ON(ph==NULL);
    
    mntput(vfsmnt);
    53d5:	4c 8b 44 24 78       	mov    0x78(%rsp),%r8
    53da:	4c 89 c7             	mov    %r8,%rdi
    53dd:	e8 00 00 00 00       	callq  53e2 <add_rename_zone_dir+0xbc2>
    53e2:	eb 0c                	jmp    53f0 <add_rename_zone_dir+0xbd0>
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    if(!vfsmnt){
        nova_dbg("not find mnt");
    53e4:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    53eb:	e8 00 00 00 00       	callq  53f0 <add_rename_zone_dir+0xbd0>
    
    //kfree(buf);
    //kfree(tem);
    //nova_dbg("dafs finish get dentry path");
ERR:
    nova_dbg("%s ful ph is %s len %llu, sbi %s ",__func__,ph, strlen(ph), sbi->ph_f);
    53f0:	4c 8b 74 24 38       	mov    0x38(%rsp),%r14
    53f5:	4c 89 f7             	mov    %r14,%rdi
    53f8:	e8 00 00 00 00       	callq  53fd <add_rename_zone_dir+0xbdd>
    53fd:	4d 89 f0             	mov    %r14,%r8
    5400:	48 89 c1             	mov    %rax,%rcx
    5403:	4c 89 f2             	mov    %r14,%rdx
    5406:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    540d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    5414:	e8 00 00 00 00       	callq  5419 <add_rename_zone_dir+0xbf9>
    5419:	e9 38 f5 ff ff       	jmpq   4956 <add_rename_zone_dir+0x136>
    kfree(ph);
    kfree(phn);
    kfree(zone_p);
    NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    return ret;
}
    541e:	e8 00 00 00 00       	callq  5423 <add_rename_zone_dir+0xc03>
    5423:	0f 1f 00             	nopl   (%rax)
    5426:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    542d:	00 00 00 

0000000000005430 <__rename_dir>:
 * n_ze是new_dentry所在的zone
 * path是新的目录的字符串
 * name纯的文件名*/
int __rename_dir(struct super_block *sb, struct dafs_dentry *src_de, \
        struct dzt_entry_info *dzt_ei, struct dzt_entry_info *old_ei, const char *path, char *name)
{
    5430:	e8 00 00 00 00       	callq  5435 <__rename_dir+0x5>
    5435:	55                   	push   %rbp
    5436:	48 89 f8             	mov    %rdi,%rax
    5439:	48 89 e5             	mov    %rsp,%rbp
    543c:	41 57                	push   %r15
    543e:	41 56                	push   %r14
    5440:	41 55                	push   %r13
    5442:	41 54                	push   %r12
    5444:	4d 89 c4             	mov    %r8,%r12
    5447:	53                   	push   %rbx
    5448:	48 89 d3             	mov    %rdx,%rbx
    544b:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    5452:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
    5456:	48 8b 90 b0 03 00 00 	mov    0x3b0(%rax),%rdx
    545d:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
    5464:	48 89 b5 30 ff ff ff 	mov    %rsi,-0xd0(%rbp)
    546b:	65 48 8b 3c 25 28 00 	mov    %gs:0x28,%rdi
    5472:	00 00 
    5474:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
    5478:	31 ff                	xor    %edi,%edi
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct zone_ptr *z_p;
    struct dafs_dentry *new_de, *sub_de, *par_de;
    struct dafs_zone_entry *ze, *o_ze;
    struct dzt_entry_info *ch_ei;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    547a:	48 8b 82 d8 0d 00 00 	mov    0xdd8(%rdx),%rax
 * n_ze是new_dentry所在的zone
 * path是新的目录的字符串
 * name纯的文件名*/
int __rename_dir(struct super_block *sb, struct dafs_dentry *src_de, \
        struct dzt_entry_info *dzt_ei, struct dzt_entry_info *old_ei, const char *path, char *name)
{
    5481:	48 89 8d 20 ff ff ff 	mov    %rcx,-0xe0(%rbp)
    5488:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct zone_ptr *z_p;
    struct dafs_dentry *new_de, *sub_de, *par_de;
    struct dafs_zone_entry *ze, *o_ze;
    struct dzt_entry_info *ch_ei;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    548c:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
    //u8 isr_sf;
    char *new_ph, *s_name, *sub_ph, *ch_ph, *tem, *r_name;
    u64 hashname, dzt_hn, ch_len, sub_len, old_hn, par_hash, rn_len;

    //nova_dbg("%s start",__func__);
    ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    5493:	48 8b 43 10          	mov    0x10(%rbx),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    5497:	48 85 c0             	test   %rax,%rax
    549a:	0f 84 1f 09 00 00    	je     5dbf <__rename_dir+0x98f>
    54a0:	48 03 42 18          	add    0x18(%rdx),%rax
    make_zone_ptr(&z_p, ze);
    54a4:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
    54a8:	4d 89 cf             	mov    %r9,%r15
    54ab:	48 89 c6             	mov    %rax,%rsi
    54ae:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    54b2:	e8 00 00 00 00       	callq  54b7 <__rename_dir+0x87>

    nlen = strlen(name);
    54b7:	4c 89 ff             	mov    %r15,%rdi
    54ba:	e8 00 00 00 00       	callq  54bf <__rename_dir+0x8f>
    flen = strlen(path);
    54bf:	4c 89 e7             	mov    %r12,%rdi

    //nova_dbg("%s start",__func__);
    ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    make_zone_ptr(&z_p, ze);

    nlen = strlen(name);
    54c2:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    flen = strlen(path);
    54c6:	e8 00 00 00 00       	callq  54cb <__rename_dir+0x9b>
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    54cb:	48 8d 78 01          	lea    0x1(%rax),%rdi
    //nova_dbg("%s start",__func__);
    ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    make_zone_ptr(&z_p, ze);

    nlen = strlen(name);
    flen = strlen(path);
    54cf:	48 89 c3             	mov    %rax,%rbx
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    54d2:	be d0 80 00 00       	mov    $0x80d0,%esi
    54d7:	e8 00 00 00 00       	callq  54dc <__rename_dir+0xac>
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    memcpy(new_ph, path, flen);
    54dc:	48 89 da             	mov    %rbx,%rdx
    54df:	49 89 c7             	mov    %rax,%r15
    54e2:	4c 89 e6             	mov    %r12,%rsi
    54e5:	48 89 c7             	mov    %rax,%rdi
    54e8:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    54ec:	e8 00 00 00 00       	callq  54f1 <__rename_dir+0xc1>
    new_ph[flen]='\0';
    54f1:	41 c6 04 1f 00       	movb   $0x0,(%r15,%rbx,1)
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
    54f6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    54fa:	4c 8b 40 08          	mov    0x8(%rax),%r8
    54fe:	4d 85 c0             	test   %r8,%r8
    5501:	0f 84 1f 0f 00 00    	je     6426 <__rename_dir+0xff6>
    5507:	48 8b 38             	mov    (%rax),%rdi
    550a:	31 c9                	xor    %ecx,%ecx
    550c:	31 d2                	xor    %edx,%edx
    550e:	eb 05                	jmp    5515 <__rename_dir+0xe5>
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
            bitpos+=2;
            dir_pos++;
    5510:	44 89 c9             	mov    %r9d,%ecx
    memcpy(new_ph, path, flen);
    new_ph[flen]='\0';
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
            bitpos+=2;
    5513:	89 c2                	mov    %eax,%edx

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    5515:	48 63 c2             	movslq %edx,%rax
    5518:	48 0f a3 07          	bt     %rax,(%rdi)
    551c:	19 c0                	sbb    %eax,%eax
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    memcpy(new_ph, path, flen);
    new_ph[flen]='\0';
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
    551e:	85 c0                	test   %eax,%eax
    5520:	75 15                	jne    5537 <__rename_dir+0x107>
    5522:	44 8d 62 01          	lea    0x1(%rdx),%r12d
    5526:	4d 63 e4             	movslq %r12d,%r12
    5529:	4c 0f a3 27          	bt     %r12,(%rdi)
    552d:	19 c0                	sbb    %eax,%eax
    552f:	85 c0                	test   %eax,%eax
    5531:	0f 84 f6 0d 00 00    	je     632d <__rename_dir+0xefd>
            bitpos+=2;
    5537:	8d 72 02             	lea    0x2(%rdx),%esi
            dir_pos++;
    553a:	44 8d 49 01          	lea    0x1(%rcx),%r9d
    flen = strlen(path);
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    memcpy(new_ph, path, flen);
    new_ph[flen]='\0';
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
    553e:	4c 39 c6             	cmp    %r8,%rsi
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
            bitpos+=2;
    5541:	48 89 f0             	mov    %rsi,%rax
    flen = strlen(path);
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    memcpy(new_ph, path, flen);
    new_ph[flen]='\0';
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
    5544:	72 ca                	jb     5510 <__rename_dir+0xe0>
    5546:	44 8d 62 03          	lea    0x3(%rdx),%r12d
    554a:	44 8d 69 02          	lea    0x2(%rcx),%r13d
    554e:	44 8d 7a 04          	lea    0x4(%rdx),%r15d
    5552:	44 89 8d 54 ff ff ff 	mov    %r9d,-0xac(%rbp)
    5559:	4d 63 e4             	movslq %r12d,%r12
            dir_pos++;
        }else{
            break;
        }
    }
    new_de = &ze->dentry[dir_pos];
    555c:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
    par_id = dir_pos;
    //memset(new_de, 0, sizeof(new_de));    
    new_de->entry_type = src_de->entry_type;
    5562:	48 8b b5 30 ff ff ff 	mov    -0xd0(%rbp),%rsi
            dir_pos++;
        }else{
            break;
        }
    }
    new_de = &ze->dentry[dir_pos];
    5569:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    par_id = dir_pos;
    //memset(new_de, 0, sizeof(new_de));    
    new_de->entry_type = src_de->entry_type;
    new_de->name_len = nlen;
    556d:	0f b6 4d b0          	movzbl -0x50(%rbp),%ecx
            dir_pos++;
        }else{
            break;
        }
    }
    new_de = &ze->dentry[dir_pos];
    5571:	4c 8d b0 81 00 00 00 	lea    0x81(%rax),%r14
    5578:	48 89 c2             	mov    %rax,%rdx
    557b:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    par_id = dir_pos;
    //memset(new_de, 0, sizeof(new_de));    
    new_de->entry_type = src_de->entry_type;
    557f:	0f b6 06             	movzbl (%rsi),%eax
    5582:	48 c1 e2 07          	shl    $0x7,%rdx
            dir_pos++;
        }else{
            break;
        }
    }
    new_de = &ze->dentry[dir_pos];
    5586:	49 c1 e6 07          	shl    $0x7,%r14
    558a:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
    558e:	49 01 fe             	add    %rdi,%r14
    5591:	4c 89 75 a0          	mov    %r14,-0x60(%rbp)
    5595:	4c 8d 34 17          	lea    (%rdi,%rdx,1),%r14
    par_id = dir_pos;
    //memset(new_de, 0, sizeof(new_de));    
    new_de->entry_type = src_de->entry_type;
    5599:	41 88 86 80 40 00 00 	mov    %al,0x4080(%r14)
    new_de->name_len = nlen;
    55a0:	41 88 8e 81 40 00 00 	mov    %cl,0x4081(%r14)
    new_de->file_type = src_de->file_type;       //file_type是啥？ not decided
    55a7:	0f b6 46 02          	movzbl 0x2(%rsi),%eax
    55ab:	41 88 86 82 40 00 00 	mov    %al,0x4082(%r14)
	new_de->links_count = src_de->links_count;
    55b2:	0f b7 46 06          	movzwl 0x6(%rsi),%eax
    55b6:	66 41 89 86 86 40 00 	mov    %ax,0x4086(%r14)
    55bd:	00 
    //new_de->de_len = cpu_to_le16(delen);  
    new_de->mtime = cpu_to_le32(CURRENT_TIME_SEC.tv_sec);
    55be:	e8 00 00 00 00       	callq  55c3 <__rename_dir+0x193>
    //new_de->isr_sf = src_de->isr_sf;
    new_de->ino = src_de->ino;
    55c3:	48 8b b5 30 ff ff ff 	mov    -0xd0(%rbp),%rsi
    new_de->entry_type = src_de->entry_type;
    new_de->name_len = nlen;
    new_de->file_type = src_de->file_type;       //file_type是啥？ not decided
	new_de->links_count = src_de->links_count;
    //new_de->de_len = cpu_to_le16(delen);  
    new_de->mtime = cpu_to_le32(CURRENT_TIME_SEC.tv_sec);
    55ca:	41 89 86 88 40 00 00 	mov    %eax,0x4088(%r14)
    //new_de->isr_sf = src_de->isr_sf;
    new_de->ino = src_de->ino;
    55d1:	48 8b 46 18          	mov    0x18(%rsi),%rax
    55d5:	49 89 86 98 40 00 00 	mov    %rax,0x4098(%r14)
    
    new_de->size = src_de->size;
    55dc:	48 8b 46 20          	mov    0x20(%rsi),%rax
    55e0:	49 89 86 a0 40 00 00 	mov    %rax,0x40a0(%r14)
    /*set name*/
    if(nlen<=SMALL_NAME_LEN){
    55e7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    55eb:	48 83 f8 27          	cmp    $0x27,%rax
    55ef:	0f 87 84 07 00 00    	ja     5d79 <__rename_dir+0x949>
        new_de->ext_flag = 0;
        memcpy(new_de->name, name, nlen);
    55f5:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
    55f9:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    new_de->ino = src_de->ino;
    
    new_de->size = src_de->size;
    /*set name*/
    if(nlen<=SMALL_NAME_LEN){
        new_de->ext_flag = 0;
    55fd:	45 31 d2             	xor    %r10d,%r10d
        memcpy(new_de->name, name, nlen);
    5600:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
    new_de->ino = src_de->ino;
    
    new_de->size = src_de->size;
    /*set name*/
    if(nlen<=SMALL_NAME_LEN){
        new_de->ext_flag = 0;
    5604:	66 45 89 96 84 40 00 	mov    %r10w,0x4084(%r14)
    560b:	00 
        memcpy(new_de->name, name, nlen);
    560c:	48 8d bc 17 b0 40 00 	lea    0x40b0(%rdi,%rdx,1),%rdi
    5613:	00 
    5614:	48 89 c2             	mov    %rax,%rdx
    5617:	e8 00 00 00 00       	callq  561c <__rename_dir+0x1ec>
        new_de->name[nlen] = '\0';
    561c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    5620:	41 c6 84 06 b0 40 00 	movb   $0x0,0x40b0(%r14,%rax,1)
    5627:	00 00 
    } else {
        new_de->ext_flag = 1;
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, nlen, name, 0);
    }
    new_de->fname_len = cpu_to_le64(flen);
    5629:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    562d:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    5631:	48 c1 e0 07          	shl    $0x7,%rax
    5635:	48 8d 0c 07          	lea    (%rdi,%rax,1),%rcx
    5639:	48 89 99 90 40 00 00 	mov    %rbx,0x4090(%rcx)
    
    /*set dir fulname*/
    if(new_de->ext_flag==0){
    5640:	66 41 83 be 84 40 00 	cmpw   $0x0,0x4084(%r14)
    5647:	00 00 
        new_de->name[nlen] = '\0';
    } else {
        new_de->ext_flag = 1;
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, nlen, name, 0);
    }
    new_de->fname_len = cpu_to_le64(flen);
    5649:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
    
    /*set dir fulname*/
    if(new_de->ext_flag==0){
    564d:	75 78                	jne    56c7 <__rename_dir+0x297>
        if(flen<SMALL_NAME_LEN){
    564f:	48 83 fb 26          	cmp    $0x26,%rbx
    5653:	77 64                	ja     56b9 <__rename_dir+0x289>
            memcpy(new_de->ful_name.f_name, new_ph, flen);
    5655:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
    5659:	48 8d bc 07 d8 40 00 	lea    0x40d8(%rdi,%rax,1),%rdi
    5660:	00 
    5661:	48 89 da             	mov    %rbx,%rdx
    5664:	e8 00 00 00 00       	callq  5669 <__rename_dir+0x239>
            new_de->ful_name.f_name[flen]='\0';
    5669:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
    566d:	c6 84 0b d8 40 00 00 	movb   $0x0,0x40d8(%rbx,%rcx,1)
    5674:	00 
    } else
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, flen, new_ph, 1);

    /*set par_pos and subpos in par
     * set isr_sf*/
    temlen = flen - nlen;
    5675:	48 2b 5d b0          	sub    -0x50(%rbp),%rbx
    if(temlen == 1){
    5679:	48 83 fb 01          	cmp    $0x1,%rbx
    567d:	0f 85 80 00 00 00    	jne    5703 <__rename_dir+0x2d3>
        new_de->isr_sf = 1;
        new_de->par_pos = 0;
        par_de = &ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
    5683:	48 8b 45 b8          	mov    -0x48(%rbp),%rax

    /*set par_pos and subpos in par
     * set isr_sf*/
    temlen = flen - nlen;
    if(temlen == 1){
        new_de->isr_sf = 1;
    5687:	41 c6 86 83 40 00 00 	movb   $0x1,0x4083(%r14)
    568e:	01 
        new_de->par_pos = 0;
    568f:	41 c7 86 8c 40 00 00 	movl   $0x0,0x408c(%r14)
    5696:	00 00 00 00 
        par_de = &ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
    569a:	48 83 b8 98 40 00 00 	cmpq   $0x1,0x4098(%rax)
    56a1:	01 
    56a2:	0f 84 fb 0c 00 00    	je     63a3 <__rename_dir+0xf73>
    56a8:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    56ac:	48 83 c0 38          	add    $0x38,%rax
    56b0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    56b4:	e9 3e 01 00 00       	jmpq   57f7 <__rename_dir+0x3c7>
    if(new_de->ext_flag==0){
        if(flen<SMALL_NAME_LEN){
            memcpy(new_de->ful_name.f_name, new_ph, flen);
            new_de->ful_name.f_name[flen]='\0';
        } else {
            new_de->ext_flag = 2;
    56b9:	41 b8 02 00 00 00    	mov    $0x2,%r8d
    56bf:	66 45 89 86 84 40 00 	mov    %r8w,0x4084(%r14)
    56c6:	00 
            ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, flen, new_ph, 1);
        }
    } else
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, flen, new_ph, 1);
    56c7:	48 8b 45 80          	mov    -0x80(%rbp),%rax
    56cb:	44 8b 85 54 ff ff ff 	mov    -0xac(%rbp),%r8d
    56d2:	41 89 d9             	mov    %ebx,%r9d
    56d5:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    56d9:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    56dd:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    56e1:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
    56e8:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    56ef:	00 
    56f0:	48 89 04 24          	mov    %rax,(%rsp)
    56f4:	e8 00 00 00 00       	callq  56f9 <__rename_dir+0x2c9>

    /*set par_pos and subpos in par
     * set isr_sf*/
    temlen = flen - nlen;
    56f9:	48 2b 5d b0          	sub    -0x50(%rbp),%rbx
    if(temlen == 1){
    56fd:	48 83 fb 01          	cmp    $0x1,%rbx
    5701:	74 80                	je     5683 <__rename_dir+0x253>
            list_add_tail(&tem_sf->list, &pdir->sub_file);
            pdir->sub_num++;
        }
    } else {
        new_de->isr_sf = 0;
        tem = kzalloc(sizeof(char)*temlen, GFP_KERNEL);
    5703:	48 89 df             	mov    %rbx,%rdi
            tem_sf->pos = cpu_to_le32(dir_pos);
            list_add_tail(&tem_sf->list, &pdir->sub_file);
            pdir->sub_num++;
        }
    } else {
        new_de->isr_sf = 0;
    5706:	41 c6 86 83 40 00 00 	movb   $0x0,0x4083(%r14)
    570d:	00 
        tem = kzalloc(sizeof(char)*temlen, GFP_KERNEL);
    570e:	e8 bd ab ff ff       	callq  2d0 <kzalloc.constprop.8>
        temlen--;
    5713:	48 8d 4b ff          	lea    -0x1(%rbx),%rcx
        memcpy(tem, new_ph, temlen);
    5717:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
    571b:	48 89 c7             	mov    %rax,%rdi
    571e:	48 89 ca             	mov    %rcx,%rdx
    5721:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    5725:	e8 00 00 00 00       	callq  572a <__rename_dir+0x2fa>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    572a:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
    572e:	49 89 c1             	mov    %rax,%r9
        tem[temlen]='\0';
    5731:	c6 44 18 ff 00       	movb   $0x0,-0x1(%rax,%rbx,1)
    5736:	85 c9                	test   %ecx,%ecx
    5738:	0f 8e 1a 0c 00 00    	jle    6358 <__rename_dir+0xf28>
    573e:	8d 41 ff             	lea    -0x1(%rcx),%eax
    5741:	31 db                	xor    %ebx,%ebx
    5743:	49 8d 4c 01 01       	lea    0x1(%r9,%rax,1),%rcx
    5748:	4c 89 c8             	mov    %r9,%rax
		hash = hash * seed + (*str++);
    574b:	48 89 da             	mov    %rbx,%rdx
    574e:	48 83 c0 01          	add    $0x1,%rax
    5752:	48 c1 e2 05          	shl    $0x5,%rdx
    5756:	48 29 da             	sub    %rbx,%rdx
    5759:	48 89 d3             	mov    %rdx,%rbx
    575c:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    5761:	48 01 d3             	add    %rdx,%rbx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    5764:	48 39 c8             	cmp    %rcx,%rax
    5767:	75 e2                	jne    574b <__rename_dir+0x31b>
        par_hash = BKDRHash(tem, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
    5769:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    576d:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
    5774:	4c 8d 45 c4          	lea    -0x3c(%rbp),%r8
    5778:	48 89 da             	mov    %rbx,%rdx
    577b:	b9 01 00 00 00       	mov    $0x1,%ecx
    5780:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
    5784:	48 8b 70 18          	mov    0x18(%rax),%rsi
    5788:	e8 00 00 00 00       	callq  578d <__rename_dir+0x35d>
        new_de->par_pos = cpu_to_le64(par_pos);
    578d:	8b 45 c4             	mov    -0x3c(%rbp),%eax

        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    5790:	48 89 de             	mov    %rbx,%rsi
        temlen--;
        memcpy(tem, new_ph, temlen);
        tem[temlen]='\0';
        par_hash = BKDRHash(tem, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
        new_de->par_pos = cpu_to_le64(par_pos);
    5793:	41 89 86 8c 40 00 00 	mov    %eax,0x408c(%r14)

        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    579a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    579e:	48 83 c0 38          	add    $0x38,%rax
    57a2:	48 89 c7             	mov    %rax,%rdi
    57a5:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    57a9:	e8 00 00 00 00       	callq  57ae <__rename_dir+0x37e>
        pdir->sub_num++;
    57ae:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    57b3:	ba 14 00 00 00       	mov    $0x14,%edx
    57b8:	be d0 80 00 00       	mov    $0x80d0,%esi
    57bd:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 57c4 <__rename_dir+0x394>
        par_hash = BKDRHash(tem, temlen);
        lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
        new_de->par_pos = cpu_to_le64(par_pos);

        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    57c4:	48 89 c3             	mov    %rax,%rbx
        pdir->sub_num++;
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = dir_pos;
        list_add_tail(&tem_sf->list, &pdir->sub_file);
    57c7:	48 83 c3 18          	add    $0x18,%rbx
    57cb:	e8 00 00 00 00       	callq  57d0 <__rename_dir+0x3a0>

        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        pdir->sub_num++;
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = dir_pos;
    57d0:	8b b5 54 ff ff ff    	mov    -0xac(%rbp),%esi
        list_add_tail(&tem_sf->list, &pdir->sub_file);
        kfree(tem);
    57d6:	4c 8b 4d 98          	mov    -0x68(%rbp),%r9

        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        pdir->sub_num++;
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = dir_pos;
    57da:	89 70 10             	mov    %esi,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    57dd:	48 8b 53 08          	mov    0x8(%rbx),%rdx
        list_add_tail(&tem_sf->list, &pdir->sub_file);
        kfree(tem);
    57e1:	4c 89 cf             	mov    %r9,%rdi
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    57e4:	48 89 43 08          	mov    %rax,0x8(%rbx)
        /*add list entry*/
        pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
        pdir->sub_num++;
        tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        tem_sf->pos = dir_pos;
        list_add_tail(&tem_sf->list, &pdir->sub_file);
    57e8:	48 89 18             	mov    %rbx,(%rax)
	new->next = next;
	new->prev = prev;
    57eb:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    57ef:	48 89 02             	mov    %rax,(%rdx)
        kfree(tem);
    57f2:	e8 00 00 00 00       	callq  57f7 <__rename_dir+0x3c7>
    }

    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)z_p->statemap);
    57f7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    57fb:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    57fe:	f0 4c 0f ab 20       	lock bts %r12,(%rax)
    5803:	72 00                	jb     5805 <__rename_dir+0x3d5>
    bitpos++;
    hashname = BKDRHash(new_ph, strlen(new_ph));
    5805:	48 8b 5d 80          	mov    -0x80(%rbp),%rbx
    5809:	48 89 df             	mov    %rbx,%rdi
    580c:	e8 00 00 00 00       	callq  5811 <__rename_dir+0x3e1>
    5811:	85 c0                	test   %eax,%eax
    5813:	0f 8e 82 0b 00 00    	jle    639b <__rename_dir+0xf6b>
    5819:	83 e8 01             	sub    $0x1,%eax
    581c:	45 31 f6             	xor    %r14d,%r14d
    581f:	48 8d 74 03 01       	lea    0x1(%rbx,%rax,1),%rsi
    5824:	48 89 d8             	mov    %rbx,%rax
		hash = hash * seed + (*str++);
    5827:	4c 89 f2             	mov    %r14,%rdx
    582a:	48 83 c0 01          	add    $0x1,%rax
    582e:	48 c1 e2 05          	shl    $0x5,%rdx
    5832:	4c 29 f2             	sub    %r14,%rdx
    5835:	49 89 d6             	mov    %rdx,%r14
    5838:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    583d:	49 01 d6             	add    %rdx,%r14
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    5840:	48 39 f0             	cmp    %rsi,%rax
    5843:	75 e2                	jne    5827 <__rename_dir+0x3f7>
    record_pos_htable(sb, dzt_ei->ht_head, hashname, dir_pos, 1);
    5845:	48 8b 5d 88          	mov    -0x78(%rbp),%rbx
    5849:	8b 8d 54 ff ff ff    	mov    -0xac(%rbp),%ecx
    584f:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    5855:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
    585c:	4c 89 f2             	mov    %r14,%rdx
    585f:	48 8b 73 18          	mov    0x18(%rbx),%rsi
    5863:	e8 00 00 00 00       	callq  5868 <__rename_dir+0x438>
    new_de->hname = cpu_to_le64(hashname);
    5868:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    586c:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi

    dir_pos++;

    /*new dir_info_entry*/
    new_dir = add_dir_info(dzt_ei, hashname, dir_pos);
    5870:	44 89 ea             	mov    %r13d,%edx
    5873:	4c 89 f6             	mov    %r14,%rsi
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)z_p->statemap);
    bitpos++;
    hashname = BKDRHash(new_ph, strlen(new_ph));
    record_pos_htable(sb, dzt_ei->ht_head, hashname, dir_pos, 1);
    new_de->hname = cpu_to_le64(hashname);
    5876:	48 c1 e0 07          	shl    $0x7,%rax
    587a:	4c 89 b4 07 a8 40 00 	mov    %r14,0x40a8(%rdi,%rax,1)
    5881:	00 

    dir_pos++;

    /*new dir_info_entry*/
    new_dir = add_dir_info(dzt_ei, hashname, dir_pos);
    5882:	48 89 df             	mov    %rbx,%rdi
    5885:	e8 00 00 00 00       	callq  588a <__rename_dir+0x45a>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    588a:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
    new_dir->f_s = DENTRY_FREQUENCY_WRITE;
    588e:	c6 40 02 02          	movb   $0x2,0x2(%rax)
	if (support_clwb) {
    5892:	31 d2                	xor    %edx,%edx
    5894:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # 589a <__rename_dir+0x46a>
    new_de->hname = cpu_to_le64(hashname);

    dir_pos++;

    /*new dir_info_entry*/
    new_dir = add_dir_info(dzt_ei, hashname, dir_pos);
    589a:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    58a1:	89 f1                	mov    %esi,%ecx
    58a3:	83 e1 3f             	and    $0x3f,%ecx
    58a6:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    58a9:	85 ff                	test   %edi,%edi
    58ab:	0f 85 42 05 00 00    	jne    5df3 <__rename_dir+0x9c3>
    58b1:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    58b5:	89 d0                	mov    %edx,%eax
    58b7:	48 01 f0             	add    %rsi,%rax
    58ba:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    58bd:	83 c2 40             	add    $0x40,%edx
    58c0:	39 d1                	cmp    %edx,%ecx
    58c2:	77 f1                	ja     58b5 <__rename_dir+0x485>
        return -EINVAL;
    
    nova_flush_buffer(new_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    old_hn = le64_to_cpu(src_de->hname);
    old_dir = radix_tree_lookup(&dzt_ei->dir_tree, old_hn);
    58c4:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
    58cb:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    58cf:	48 8b 70 28          	mov    0x28(%rax),%rsi
    58d3:	e8 00 00 00 00       	callq  58d8 <__rename_dir+0x4a8>
    head = &old_dir->sub_file;
    58d8:	48 8d 58 18          	lea    0x18(%rax),%rbx
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
    58dc:	c7 85 1c ff ff ff 00 	movl   $0x0,-0xe4(%rbp)
    58e3:	00 00 00 
    
    nova_flush_buffer(new_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    old_hn = le64_to_cpu(src_de->hname);
    old_dir = radix_tree_lookup(&dzt_ei->dir_tree, old_hn);
    head = &old_dir->sub_file;
    58e6:	48 89 df             	mov    %rbx,%rdi
    58e9:	48 89 9d 48 ff ff ff 	mov    %rbx,-0xb8(%rbp)
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
    58f0:	48 8b 58 18          	mov    0x18(%rax),%rbx
    58f4:	48 8b 03             	mov    (%rbx),%rax
    58f7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
            
            /*add in dir subpos*/
            new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            new_sf->pos = dir_pos;
            new_dir->sub_num++;
            list_add_tail(&new_sf->list, &new_dir->sub_file);
    58fb:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
    5902:	48 83 c0 18          	add    $0x18,%rax
    5906:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
                o_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
                rn_len = le64_to_cpu(src_de->fname_len); 
                r_name = kzalloc(sizeof(char)*(rn_len+1),GFP_KERNEL);
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
    590d:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
    5914:	48 83 c0 38          	add    $0x38,%rax
    old_hn = le64_to_cpu(src_de->hname);
    old_dir = radix_tree_lookup(&dzt_ei->dir_tree, old_hn);
    head = &old_dir->sub_file;
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
    5918:	48 39 df             	cmp    %rbx,%rdi
                o_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
                rn_len = le64_to_cpu(src_de->fname_len); 
                r_name = kzalloc(sizeof(char)*(rn_len+1),GFP_KERNEL);
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
    591b:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
    old_hn = le64_to_cpu(src_de->hname);
    old_dir = radix_tree_lookup(&dzt_ei->dir_tree, old_hn);
    head = &old_dir->sub_file;
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
    5922:	0f 84 14 04 00 00    	je     5d3c <__rename_dir+0x90c>
        tem_sf = list_entry(this, struct file_p, list);
        s_pos = tem_sf->pos;
    5928:	8b 5b 10             	mov    0x10(%rbx),%ebx
    592b:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 5932 <__rename_dir+0x502>
    5932:	ba 70 00 00 00       	mov    $0x70,%edx
    5937:	be d0 80 00 00       	mov    $0x80d0,%esi
    593c:	e8 00 00 00 00       	callq  5941 <__rename_dir+0x511>
    5941:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    5945:	89 d8                	mov    %ebx,%eax
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    5947:	be d0 80 00 00       	mov    $0x80d0,%esi
    594c:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    5953:	48 89 c3             	mov    %rax,%rbx
    5956:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    595a:	48 c1 e3 07          	shl    $0x7,%rbx
    595e:	4c 8d 24 18          	lea    (%rax,%rbx,1),%r12
        sub_de = &ze->dentry[s_pos];
        sub_ph = kzalloc(sizeof(char )*LARGE_NAME_LEN, GFP_KERNEL);
        sub_len = le64_to_cpu(sub_de->name_len);
    5962:	41 0f b6 84 24 81 40 	movzbl 0x4081(%r12),%eax
    5969:	00 00 
    596b:	48 8d 78 01          	lea    0x1(%rax),%rdi
    596f:	88 85 53 ff ff ff    	mov    %al,-0xad(%rbp)
    5975:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    5979:	e8 00 00 00 00       	callq  597e <__rename_dir+0x54e>
        s_name = kzalloc(sizeof(char )*(sub_len+1), GFP_KERNEL);
        if(sub_de->ext_flag==1)
    597e:	66 41 83 bc 24 84 40 	cmpw   $0x1,0x4084(%r12)
    5985:	00 00 01 
    5988:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    598c:	0f 84 01 05 00 00    	je     5e93 <__rename_dir+0xa63>
            get_ext_name(sub_de->next, s_name);
        else{
            memcpy(s_name, sub_de->name, sub_len);
    5992:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    5996:	48 8d b4 18 b0 40 00 	lea    0x40b0(%rax,%rbx,1),%rsi
    599d:	00 
    599e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
    59a2:	83 f8 08             	cmp    $0x8,%eax
    59a5:	0f 83 72 04 00 00    	jae    5e1d <__rename_dir+0x9ed>
    59ab:	a8 04                	test   $0x4,%al
    59ad:	0f 85 62 09 00 00    	jne    6315 <__rename_dir+0xee5>
    59b3:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
    59b7:	85 db                	test   %ebx,%ebx
    59b9:	74 14                	je     59cf <__rename_dir+0x59f>
    59bb:	0f b6 06             	movzbl (%rsi),%eax
    59be:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    59c2:	88 07                	mov    %al,(%rdi)
    59c4:	48 89 d8             	mov    %rbx,%rax
    59c7:	a8 02                	test   $0x2,%al
    59c9:	0f 85 90 09 00 00    	jne    635f <__rename_dir+0xf2f>
            s_name[sub_len] = '\0';
    59cf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    59d3:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
    59d7:	c6 04 18 00          	movb   $0x0,(%rax,%rbx,1)
        }
        slen = strlen(new_ph);
    59db:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
    59df:	e8 00 00 00 00       	callq  59e4 <__rename_dir+0x5b4>
        memcpy(sub_ph, new_ph, slen);
    59e4:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
    59e8:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    59ec:	48 89 c2             	mov    %rax,%rdx
            get_ext_name(sub_de->next, s_name);
        else{
            memcpy(s_name, sub_de->name, sub_len);
            s_name[sub_len] = '\0';
        }
        slen = strlen(new_ph);
    59ef:	48 89 c3             	mov    %rax,%rbx
        memcpy(sub_ph, new_ph, slen);
    59f2:	e8 00 00 00 00       	callq  59f7 <__rename_dir+0x5c7>
        sub_ph[slen] = '\0';
    59f7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    59fb:	c6 04 18 00          	movb   $0x0,(%rax,%rbx,1)
        strcat(sub_ph, "/");
    59ff:	48 89 c7             	mov    %rax,%rdi
    5a02:	48 89 c3             	mov    %rax,%rbx
    5a05:	e8 00 00 00 00       	callq  5a0a <__rename_dir+0x5da>
        strcat(sub_ph, s_name);
    5a0a:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    5a0e:	48 8d 7c 03 01       	lea    0x1(%rbx,%rax,1),%rdi
            s_name[sub_len] = '\0';
        }
        slen = strlen(new_ph);
        memcpy(sub_ph, new_ph, slen);
        sub_ph[slen] = '\0';
        strcat(sub_ph, "/");
    5a13:	c6 04 03 2f          	movb   $0x2f,(%rbx,%rax,1)
        strcat(sub_ph, s_name);
    5a17:	e8 00 00 00 00       	callq  5a1c <__rename_dir+0x5ec>

        if(sub_de->file_type == NORMAL_DIRECTORY){
    5a1c:	41 80 bc 24 82 40 00 	cmpb   $0x1,0x4082(%r12)
    5a23:	00 01 
    5a25:	0f 84 50 06 00 00    	je     607b <__rename_dir+0xc4b>
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);

        } else {
            //delen = DAFS_DIR_LEN(str(s_name)+str(sub_ph));
            /*set dir entry*/
            while(bitpos<z_p->zone_max){
    5a2b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    5a2f:	44 89 fa             	mov    %r15d,%edx
    5a32:	41 8d 5f 01          	lea    0x1(%r15),%ebx
    5a36:	48 63 db             	movslq %ebx,%rbx
    5a39:	48 8b 70 08          	mov    0x8(%rax),%rsi
    5a3d:	48 39 d6             	cmp    %rdx,%rsi
    5a40:	76 40                	jbe    5a82 <__rename_dir+0x652>
    5a42:	48 8b 08             	mov    (%rax),%rcx
    5a45:	eb 03                	jmp    5a4a <__rename_dir+0x61a>
                if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
                    bitpos+=2;
    5a47:	41 89 c7             	mov    %eax,%r15d

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    5a4a:	49 63 c7             	movslq %r15d,%rax
    5a4d:	48 0f a3 01          	bt     %rax,(%rcx)
    5a51:	19 c0                	sbb    %eax,%eax

        } else {
            //delen = DAFS_DIR_LEN(str(s_name)+str(sub_ph));
            /*set dir entry*/
            while(bitpos<z_p->zone_max){
                if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
    5a53:	85 c0                	test   %eax,%eax
    5a55:	75 11                	jne    5a68 <__rename_dir+0x638>
    5a57:	41 8d 5f 01          	lea    0x1(%r15),%ebx
    5a5b:	48 63 db             	movslq %ebx,%rbx
    5a5e:	48 0f a3 19          	bt     %rbx,(%rcx)
    5a62:	19 c0                	sbb    %eax,%eax
    5a64:	85 c0                	test   %eax,%eax
    5a66:	74 1a                	je     5a82 <__rename_dir+0x652>
                    bitpos+=2;
    5a68:	41 8d 57 02          	lea    0x2(%r15),%edx
                    dir_pos++;
    5a6c:	41 83 c5 01          	add    $0x1,%r13d
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);

        } else {
            //delen = DAFS_DIR_LEN(str(s_name)+str(sub_ph));
            /*set dir entry*/
            while(bitpos<z_p->zone_max){
    5a70:	48 39 f2             	cmp    %rsi,%rdx
                if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
                    bitpos+=2;
    5a73:	48 89 d0             	mov    %rdx,%rax
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);

        } else {
            //delen = DAFS_DIR_LEN(str(s_name)+str(sub_ph));
            /*set dir entry*/
            while(bitpos<z_p->zone_max){
    5a76:	72 cf                	jb     5a47 <__rename_dir+0x617>
    5a78:	41 83 c7 03          	add    $0x3,%r15d
    5a7c:	49 63 df             	movslq %r15d,%rbx
                if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
                    bitpos+=2;
    5a7f:	41 89 d7             	mov    %edx,%r15d
                    dir_pos++;
                }else{
                    break;
                }
            }
            new_de = &ze->dentry[dir_pos]; 
    5a82:	44 89 e8             	mov    %r13d,%eax
    5a85:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    5a89:	48 89 c2             	mov    %rax,%rdx
    5a8c:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    5a90:	48 05 81 00 00 00    	add    $0x81,%rax
    5a96:	48 c1 e0 07          	shl    $0x7,%rax
    5a9a:	48 c1 e2 07          	shl    $0x7,%rdx
    5a9e:	48 01 f8             	add    %rdi,%rax
    5aa1:	4c 8d 14 17          	lea    (%rdi,%rdx,1),%r10
    5aa5:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
    5aac:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
            //memset(new_de, 0, sizeof(new_de));    
            new_de->entry_type = sub_de->entry_type;
    5ab3:	41 0f b6 84 24 80 40 	movzbl 0x4080(%r12),%eax
    5aba:	00 00 
            new_de->name_len = sub_de->name_len;
            new_de->file_type = sub_de->file_type;       //file_type是啥？ not decided
	        new_de->links_count = sub_de->links_count;
    5abc:	4c 89 95 60 ff ff ff 	mov    %r10,-0xa0(%rbp)
                    break;
                }
            }
            new_de = &ze->dentry[dir_pos]; 
            //memset(new_de, 0, sizeof(new_de));    
            new_de->entry_type = sub_de->entry_type;
    5ac3:	41 88 82 80 40 00 00 	mov    %al,0x4080(%r10)
            new_de->name_len = sub_de->name_len;
    5aca:	41 0f b6 84 24 81 40 	movzbl 0x4081(%r12),%eax
    5ad1:	00 00 
    5ad3:	41 88 82 81 40 00 00 	mov    %al,0x4081(%r10)
            new_de->file_type = sub_de->file_type;       //file_type是啥？ not decided
    5ada:	41 0f b6 84 24 82 40 	movzbl 0x4082(%r12),%eax
    5ae1:	00 00 
    5ae3:	41 88 82 82 40 00 00 	mov    %al,0x4082(%r10)
	        new_de->links_count = sub_de->links_count;
    5aea:	41 0f b7 84 24 86 40 	movzwl 0x4086(%r12),%eax
    5af1:	00 00 
    5af3:	66 41 89 82 86 40 00 	mov    %ax,0x4086(%r10)
    5afa:	00 
            //new_de->de_len = cpu_to_le16(delen);  
            new_de->mtime = cpu_to_le32(CURRENT_TIME_SEC.tv_sec);
    5afb:	e8 00 00 00 00       	callq  5b00 <__rename_dir+0x6d0>
    5b00:	4c 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%r10
            //new_de->isr_sf = sub_de->isr_sf;
            new_de->ino = sub_de->ino;
              
            new_de->size = sub_de->size;
            if(sub_de->ext_flag==1){
    5b07:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
            new_de->entry_type = sub_de->entry_type;
            new_de->name_len = sub_de->name_len;
            new_de->file_type = sub_de->file_type;       //file_type是啥？ not decided
	        new_de->links_count = sub_de->links_count;
            //new_de->de_len = cpu_to_le16(delen);  
            new_de->mtime = cpu_to_le32(CURRENT_TIME_SEC.tv_sec);
    5b0e:	41 89 82 88 40 00 00 	mov    %eax,0x4088(%r10)
            //new_de->isr_sf = sub_de->isr_sf;
            new_de->ino = sub_de->ino;
    5b15:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    5b1c:	48 c1 e0 07          	shl    $0x7,%rax
    5b20:	48 03 45 b8          	add    -0x48(%rbp),%rax
    5b24:	48 8b 88 98 40 00 00 	mov    0x4098(%rax),%rcx
    5b2b:	49 89 8a 98 40 00 00 	mov    %rcx,0x4098(%r10)
              
            new_de->size = sub_de->size;
    5b32:	48 8b 80 a0 40 00 00 	mov    0x40a0(%rax),%rax
    5b39:	49 89 82 a0 40 00 00 	mov    %rax,0x40a0(%r10)
            if(sub_de->ext_flag==1){
    5b40:	41 0f b7 84 24 84 40 	movzwl 0x4084(%r12),%eax
    5b47:	00 00 
    5b49:	66 83 f8 01          	cmp    $0x1,%ax
    5b4d:	0f 84 dc 04 00 00    	je     602f <__rename_dir+0xbff>
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);

            }else{

                new_de->ext_flag = sub_de->ext_flag;
                memcpy(new_de->name, s_name, sub_len);
    5b53:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
                new_de->ext_flag=1;
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);

            }else{

                new_de->ext_flag = sub_de->ext_flag;
    5b57:	66 41 89 82 84 40 00 	mov    %ax,0x4084(%r10)
    5b5e:	00 
                memcpy(new_de->name, s_name, sub_len);
    5b5f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    5b63:	83 ff 08             	cmp    $0x8,%edi
    5b66:	48 8d 84 10 b0 40 00 	lea    0x40b0(%rax,%rdx,1),%rax
    5b6d:	00 
    5b6e:	0f 83 e6 02 00 00    	jae    5e5a <__rename_dir+0xa2a>
    5b74:	83 e7 04             	and    $0x4,%edi
    5b77:	0f 85 c3 07 00 00    	jne    6340 <__rename_dir+0xf10>
    5b7d:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    5b81:	85 ff                	test   %edi,%edi
    5b83:	74 12                	je     5b97 <__rename_dir+0x767>
    5b85:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    5b89:	83 e7 02             	and    $0x2,%edi
    5b8c:	0f b6 16             	movzbl (%rsi),%edx
    5b8f:	88 10                	mov    %dl,(%rax)
    5b91:	0f 85 de 07 00 00    	jne    6375 <__rename_dir+0xf45>
                new_de->name[sub_len] = '\0';
    5b97:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    5b9b:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
    5b9f:	48 c1 e0 07          	shl    $0x7,%rax
    5ba3:	48 03 45 b8          	add    -0x48(%rbp),%rax
    5ba7:	c6 84 06 b0 40 00 00 	movb   $0x0,0x40b0(%rsi,%rax,1)
    5bae:	00 
            }

            sub_plen = strlen(sub_ph);
    5baf:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    5bb3:	4c 89 95 60 ff ff ff 	mov    %r10,-0xa0(%rbp)
    5bba:	e8 00 00 00 00       	callq  5bbf <__rename_dir+0x78f>
            new_de->fname_len = cpu_to_le64(sub_plen);
    5bbf:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
    5bc3:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
            //new_de->par_pos = sub_de->par_pos;
            /*set isr_sf, new_de is not root*/
            new_de->isr_sf = 0;
    5bc7:	4c 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%r10
            new_de->par_pos = cpu_to_le32(par_id);
    5bce:	8b b5 54 ff ff ff    	mov    -0xac(%rbp),%esi
                memcpy(new_de->name, s_name, sub_len);
                new_de->name[sub_len] = '\0';
            }

            sub_plen = strlen(sub_ph);
            new_de->fname_len = cpu_to_le64(sub_plen);
    5bd4:	48 c1 e2 07          	shl    $0x7,%rdx
    5bd8:	48 8d 0c 17          	lea    (%rdi,%rdx,1),%rcx
    5bdc:	48 89 81 90 40 00 00 	mov    %rax,0x4090(%rcx)
            new_de->isr_sf = 0;
            new_de->par_pos = cpu_to_le32(par_id);

            /*set fulname*/
            /*ROOT_DIRECTORY set fulname and update ei*/
            if(new_de->file_type==ROOT_DIRECTORY) {
    5be3:	41 80 ba 82 40 00 00 	cmpb   $0x2,0x4082(%r10)
    5bea:	02 

            sub_plen = strlen(sub_ph);
            new_de->fname_len = cpu_to_le64(sub_plen);
            //new_de->par_pos = sub_de->par_pos;
            /*set isr_sf, new_de is not root*/
            new_de->isr_sf = 0;
    5beb:	41 c6 82 83 40 00 00 	movb   $0x0,0x4083(%r10)
    5bf2:	00 
            new_de->par_pos = cpu_to_le32(par_id);
    5bf3:	41 89 b2 8c 40 00 00 	mov    %esi,0x408c(%r10)

            /*set fulname*/
            /*ROOT_DIRECTORY set fulname and update ei*/
            if(new_de->file_type==ROOT_DIRECTORY) {
    5bfa:	0f 84 a8 02 00 00    	je     5ea8 <__rename_dir+0xa78>
                radix_tree_insert(&dzt_m->dzt_root, dzt_hn, ch_ei);
                radix_tree_tag_set(&dzt_m->dzt_root, dzt_hn, 1);
                kfree(ch_ph);
                new_de->dzt_hn = cpu_to_le64(dzt_hn);
            } else {
                new_de->ful_name.f_name[0]='\0';
    5c00:	c6 81 d8 40 00 00 00 	movb   $0x0,0x40d8(%rcx)
                new_de->hname = cpu_to_le64(hashname);
    5c07:	4c 89 b1 a8 40 00 00 	mov    %r14,0x40a8(%rcx)
                //new_de->dzt_hn = sub_de->dzt_hn;
            }

            /*make valid*/
            bitpos++;
            test_and_set_bit_le(bitpos, (void *)z_p->statemap);
    5c0e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    5c12:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    5c15:	f0 48 0f ab 18       	lock bts %rbx,(%rax)
    5c1a:	72 00                	jb     5c1c <__rename_dir+0x7ec>
            hashname = BKDRHash(sub_ph, strlen(sub_ph));
    5c1c:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
    5c20:	4c 89 55 a0          	mov    %r10,-0x60(%rbp)
    5c24:	48 89 df             	mov    %rbx,%rdi
    5c27:	e8 00 00 00 00       	callq  5c2c <__rename_dir+0x7fc>
    5c2c:	85 c0                	test   %eax,%eax
    5c2e:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
    5c32:	0f 8e 5b 06 00 00    	jle    6293 <__rename_dir+0xe63>
    5c38:	83 e8 01             	sub    $0x1,%eax
    5c3b:	45 31 f6             	xor    %r14d,%r14d
    5c3e:	48 8d 4c 03 01       	lea    0x1(%rbx,%rax,1),%rcx
    5c43:	48 89 d8             	mov    %rbx,%rax
		hash = hash * seed + (*str++);
    5c46:	4c 89 f2             	mov    %r14,%rdx
    5c49:	48 83 c0 01          	add    $0x1,%rax
    5c4d:	48 c1 e2 05          	shl    $0x5,%rdx
    5c51:	4c 29 f2             	sub    %r14,%rdx
    5c54:	49 89 d6             	mov    %rdx,%r14
    5c57:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    5c5c:	49 01 d6             	add    %rdx,%r14
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    5c5f:	48 39 c8             	cmp    %rcx,%rax
    5c62:	75 e2                	jne    5c46 <__rename_dir+0x816>
           
            /*rename dir_info*/
            if(new_de->file_type==ROOT_DIRECTORY){
    5c64:	41 80 ba 82 40 00 00 	cmpb   $0x2,0x4082(%r10)
    5c6b:	02 
    5c6c:	0f 84 54 04 00 00    	je     60c6 <__rename_dir+0xc96>
            if(new_de->file_type==NORMAL_DIRECTORY){
                new_de->ful_name->f_name[0]="/0";
                new_de->hname = cpu_to_le64(hashname);
            } */

            record_pos_htable(sb, dzt_ei->ht_head, hashname,  dir_pos, 1);
    5c72:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    5c76:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
    5c7d:	44 89 e9             	mov    %r13d,%ecx
    5c80:	4c 89 f2             	mov    %r14,%rdx
    5c83:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    5c89:	48 8b 70 18          	mov    0x18(%rax),%rsi
    5c8d:	e8 00 00 00 00       	callq  5c92 <__rename_dir+0x862>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    5c92:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
	if (support_clwb) {
    5c99:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 5c9f <__rename_dir+0x86f>
    5c9f:	31 d2                	xor    %edx,%edx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    5ca1:	89 f1                	mov    %esi,%ecx
    5ca3:	83 e1 3f             	and    $0x3f,%ecx
    5ca6:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    5ca9:	85 c0                	test   %eax,%eax
    5cab:	0f 85 57 01 00 00    	jne    5e08 <__rename_dir+0x9d8>
    5cb1:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    5cb8:	89 d0                	mov    %edx,%eax
    5cba:	48 01 f0             	add    %rsi,%rax
    5cbd:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    5cc0:	83 c2 40             	add    $0x40,%edx
    5cc3:	39 d1                	cmp    %edx,%ecx
    5cc5:	77 f1                	ja     5cb8 <__rename_dir+0x888>
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    5cc7:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 5cce <__rename_dir+0x89e>
    5cce:	ba 14 00 00 00       	mov    $0x14,%edx
    5cd3:	be d0 80 00 00       	mov    $0x80d0,%esi
            new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            new_sf->pos = dir_pos;
            new_dir->sub_num++;
            list_add_tail(&new_sf->list, &new_dir->sub_file);

            bitpos++;
    5cd8:	41 83 c7 02          	add    $0x2,%r15d
    5cdc:	e8 00 00 00 00       	callq  5ce1 <__rename_dir+0x8b1>
            nova_flush_buffer(new_de, DAFS_DEF_DENTRY_SIZE, 0);
            
            /*add in dir subpos*/
            new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            new_sf->pos = dir_pos;
            new_dir->sub_num++;
    5ce1:	48 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%rdi
            list_add_tail(&new_sf->list, &new_dir->sub_file);
    5ce8:	48 8b 9d 38 ff ff ff 	mov    -0xc8(%rbp),%rbx
            record_pos_htable(sb, dzt_ei->ht_head, hashname,  dir_pos, 1);
            nova_flush_buffer(new_de, DAFS_DEF_DENTRY_SIZE, 0);
            
            /*add in dir subpos*/
            new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            new_sf->pos = dir_pos;
    5cef:	44 89 68 10          	mov    %r13d,0x10(%rax)
            new_dir->sub_num++;
            list_add_tail(&new_sf->list, &new_dir->sub_file);

            bitpos++;
            dir_pos++;
    5cf3:	41 83 c5 01          	add    $0x1,%r13d
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    5cf7:	48 8b 57 20          	mov    0x20(%rdi),%rdx
            nova_flush_buffer(new_de, DAFS_DEF_DENTRY_SIZE, 0);
            
            /*add in dir subpos*/
            new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            new_sf->pos = dir_pos;
            new_dir->sub_num++;
    5cfb:	48 83 47 08 01       	addq   $0x1,0x8(%rdi)
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    5d00:	48 89 47 20          	mov    %rax,0x20(%rdi)
            list_add_tail(&new_sf->list, &new_dir->sub_file);
    5d04:	48 89 18             	mov    %rbx,(%rax)

            bitpos++;
            dir_pos++;
    5d07:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
	new->next = next;
	new->prev = prev;
    5d0b:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    5d0f:	48 89 02             	mov    %rax,(%rdx)
            
        }
        //list_del(&tem_sf->list);
        //old_dir->sub_num--;
        //kfree(tem_sf);
        kfree(s_name);
    5d12:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    5d16:	e8 00 00 00 00       	callq  5d1b <__rename_dir+0x8eb>
        kfree(sub_ph);
    5d1b:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    5d1f:	e8 00 00 00 00       	callq  5d24 <__rename_dir+0x8f4>
    old_hn = le64_to_cpu(src_de->hname);
    old_dir = radix_tree_lookup(&dzt_ei->dir_tree, old_hn);
    head = &old_dir->sub_file;
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
    5d24:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    5d28:	48 39 9d 48 ff ff ff 	cmp    %rbx,-0xb8(%rbp)
    5d2f:	48 8b 00             	mov    (%rax),%rax
    5d32:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    5d36:	0f 85 ec fb ff ff    	jne    5928 <__rename_dir+0x4f8>
        //old_dir->sub_num--;
        //kfree(tem_sf);
        kfree(s_name);
        kfree(sub_ph);
    }
    kfree(z_p);
    5d3c:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    5d40:	e8 00 00 00 00       	callq  5d45 <__rename_dir+0x915>
    kfree(new_ph);
    5d45:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
    5d49:	e8 00 00 00 00       	callq  5d4e <__rename_dir+0x91e>
    //nova_dbg("%s end",__func__);
    return ret;

}
    5d4e:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    5d52:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    5d59:	00 00 
    5d5b:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
    5d61:	0f 85 e0 06 00 00    	jne    6447 <__rename_dir+0x1017>
    5d67:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    5d6e:	5b                   	pop    %rbx
    5d6f:	41 5c                	pop    %r12
    5d71:	41 5d                	pop    %r13
    5d73:	41 5e                	pop    %r14
    5d75:	41 5f                	pop    %r15
    5d77:	5d                   	pop    %rbp
    5d78:	c3                   	retq   
    if(nlen<=SMALL_NAME_LEN){
        new_de->ext_flag = 0;
        memcpy(new_de->name, name, nlen);
        new_de->name[nlen] = '\0';
    } else {
        new_de->ext_flag = 1;
    5d79:	41 b9 01 00 00 00    	mov    $0x1,%r9d
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, nlen, name, 0);
    5d7f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    5d83:	44 8b 85 54 ff ff ff 	mov    -0xac(%rbp),%r8d
    if(nlen<=SMALL_NAME_LEN){
        new_de->ext_flag = 0;
        memcpy(new_de->name, name, nlen);
        new_de->name[nlen] = '\0';
    } else {
        new_de->ext_flag = 1;
    5d8a:	66 45 89 8e 84 40 00 	mov    %r9w,0x4084(%r14)
    5d91:	00 
        ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, nlen, name, 0);
    5d92:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    5d96:	44 8b 4d b0          	mov    -0x50(%rbp),%r9d
    5d9a:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    5d9e:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    5da2:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
    5da9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
    5db0:	00 
    5db1:	48 89 04 24          	mov    %rax,(%rsp)
    5db5:	e8 00 00 00 00       	callq  5dba <__rename_dir+0x98a>
    5dba:	e9 6a f8 ff ff       	jmpq   5629 <__rename_dir+0x1f9>
    char *new_ph, *s_name, *sub_ph, *ch_ph, *tem, *r_name;
    u64 hashname, dzt_hn, ch_len, sub_len, old_hn, par_hash, rn_len;

    //nova_dbg("%s start",__func__);
    ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    make_zone_ptr(&z_p, ze);
    5dbf:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
    5dc3:	31 f6                	xor    %esi,%esi
    5dc5:	e8 00 00 00 00       	callq  5dca <__rename_dir+0x99a>

    nlen = strlen(name);
    5dca:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
    5dce:	e8 00 00 00 00       	callq  5dd3 <__rename_dir+0x9a3>
    flen = strlen(path);
    5dd3:	4c 89 e7             	mov    %r12,%rdi

    //nova_dbg("%s start",__func__);
    ze = (struct dafs_zone_entry *)nova_get_block(sb, dzt_ei->dz_addr);
    make_zone_ptr(&z_p, ze);

    nlen = strlen(name);
    5dd6:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    flen = strlen(path);
    5dda:	e8 00 00 00 00       	callq  5ddf <__rename_dir+0x9af>
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    5ddf:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
    5de6:	00 
    5de7:	48 89 c3             	mov    %rax,%rbx
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    5dea:	48 8d 78 01          	lea    0x1(%rax),%rdi
    5dee:	e9 df f6 ff ff       	jmpq   54d2 <__rename_dir+0xa2>
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    5df3:	89 d0                	mov    %edx,%eax
    5df5:	48 01 f0             	add    %rsi,%rax
    5df8:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    5dfc:	83 c2 40             	add    $0x40,%edx
    5dff:	39 d1                	cmp    %edx,%ecx
    5e01:	77 f0                	ja     5df3 <__rename_dir+0x9c3>
    5e03:	e9 bc fa ff ff       	jmpq   58c4 <__rename_dir+0x494>
			_mm_clwb(buf + i);
    5e08:	89 d0                	mov    %edx,%eax
    5e0a:	48 01 f0             	add    %rsi,%rax
    5e0d:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    5e11:	83 c2 40             	add    $0x40,%edx
    5e14:	39 d1                	cmp    %edx,%ecx
    5e16:	77 f0                	ja     5e08 <__rename_dir+0x9d8>
    5e18:	e9 aa fe ff ff       	jmpq   5cc7 <__rename_dir+0x897>
        sub_len = le64_to_cpu(sub_de->name_len);
        s_name = kzalloc(sizeof(char )*(sub_len+1), GFP_KERNEL);
        if(sub_de->ext_flag==1)
            get_ext_name(sub_de->next, s_name);
        else{
            memcpy(s_name, sub_de->name, sub_len);
    5e1d:	48 8b 06             	mov    (%rsi),%rax
    5e20:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    5e24:	48 89 07             	mov    %rax,(%rdi)
    5e27:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx
    5e2b:	89 d8                	mov    %ebx,%eax
    5e2d:	48 8b 54 06 f8       	mov    -0x8(%rsi,%rax,1),%rdx
    5e32:	48 89 54 07 f8       	mov    %rdx,-0x8(%rdi,%rax,1)
    5e37:	48 89 f8             	mov    %rdi,%rax
    5e3a:	48 83 c7 08          	add    $0x8,%rdi
    5e3e:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    5e42:	48 29 f8             	sub    %rdi,%rax
    5e45:	8d 0c 03             	lea    (%rbx,%rax,1),%ecx
    5e48:	48 29 c6             	sub    %rax,%rsi
    5e4b:	89 c8                	mov    %ecx,%eax
    5e4d:	c1 e8 03             	shr    $0x3,%eax
    5e50:	89 c1                	mov    %eax,%ecx
    5e52:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    5e55:	e9 75 fb ff ff       	jmpq   59cf <__rename_dir+0x59f>
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);

            }else{

                new_de->ext_flag = sub_de->ext_flag;
                memcpy(new_de->name, s_name, sub_len);
    5e5a:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    5e5e:	48 8d 78 08          	lea    0x8(%rax),%rdi
    5e62:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    5e66:	48 8b 16             	mov    (%rsi),%rdx
    5e69:	48 89 10             	mov    %rdx,(%rax)
    5e6c:	4c 8b 5d a0          	mov    -0x60(%rbp),%r11
    5e70:	44 89 da             	mov    %r11d,%edx
    5e73:	48 8b 4c 16 f8       	mov    -0x8(%rsi,%rdx,1),%rcx
    5e78:	48 89 4c 10 f8       	mov    %rcx,-0x8(%rax,%rdx,1)
    5e7d:	48 29 f8             	sub    %rdi,%rax
    5e80:	48 29 c6             	sub    %rax,%rsi
    5e83:	44 01 d8             	add    %r11d,%eax
    5e86:	c1 e8 03             	shr    $0x3,%eax
    5e89:	89 c1                	mov    %eax,%ecx
    5e8b:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    5e8e:	e9 04 fd ff ff       	jmpq   5b97 <__rename_dir+0x767>
        sub_de = &ze->dentry[s_pos];
        sub_ph = kzalloc(sizeof(char )*LARGE_NAME_LEN, GFP_KERNEL);
        sub_len = le64_to_cpu(sub_de->name_len);
        s_name = kzalloc(sizeof(char )*(sub_len+1), GFP_KERNEL);
        if(sub_de->ext_flag==1)
            get_ext_name(sub_de->next, s_name);
    5e93:	49 8b bc 24 b0 40 00 	mov    0x40b0(%r12),%rdi
    5e9a:	00 
    5e9b:	48 89 c6             	mov    %rax,%rsi
    5e9e:	e8 00 00 00 00       	callq  5ea3 <__rename_dir+0xa73>
    5ea3:	e9 33 fb ff ff       	jmpq   59db <__rename_dir+0x5ab>

            /*set fulname*/
            /*ROOT_DIRECTORY set fulname and update ei*/
            if(new_de->file_type==ROOT_DIRECTORY) {
                /*set_ful name*/
                if(sub_de->ext_flag==0){
    5ea8:	66 41 83 bc 24 84 40 	cmpw   $0x0,0x4084(%r12)
    5eaf:	00 00 00 
    5eb2:	48 89 8d 60 ff ff ff 	mov    %rcx,-0xa0(%rbp)
    5eb9:	0f 85 dc 03 00 00    	jne    629b <__rename_dir+0xe6b>
                    if(sub_plen<SMALL_NAME_LEN){
    5ebf:	48 83 f8 26          	cmp    $0x26,%rax
    5ec3:	0f 87 82 03 00 00    	ja     624b <__rename_dir+0xe1b>
                        memcpy(new_de->ful_name.f_name, sub_ph, sub_plen);
    5ec9:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    5ecd:	48 8d bc 17 d8 40 00 	lea    0x40d8(%rdi,%rdx,1),%rdi
    5ed4:	00 
    5ed5:	48 89 c2             	mov    %rax,%rdx
    5ed8:	4c 89 95 58 ff ff ff 	mov    %r10,-0xa8(%rbp)
    5edf:	e8 00 00 00 00       	callq  5ee4 <__rename_dir+0xab4>
                        new_de->ful_name.f_name[sub_len]='\0';
    5ee4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
    5ee8:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
    5eef:	4c 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%r10
    5ef6:	c6 84 08 d8 40 00 00 	movb   $0x0,0x40d8(%rax,%rcx,1)
    5efd:	00 
                        ext_de_name(sb ,dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);
                    }
                } else
                    ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);

                dzt_hn = le64_to_cpu(sub_de->dzt_hn);
    5efe:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
                ch_ei = radix_tree_delete(&dzt_m->dzt_root, dzt_hn);
    5f05:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    5f09:	4c 89 55 a0          	mov    %r10,-0x60(%rbp)
                        ext_de_name(sb ,dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);
                    }
                } else
                    ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);

                dzt_hn = le64_to_cpu(sub_de->dzt_hn);
    5f0d:	48 c1 e0 07          	shl    $0x7,%rax
                ch_ei = radix_tree_delete(&dzt_m->dzt_root, dzt_hn);
    5f11:	48 8b b4 07 a8 40 00 	mov    0x40a8(%rdi,%rax,1),%rsi
    5f18:	00 
    5f19:	48 8b bd 28 ff ff ff 	mov    -0xd8(%rbp),%rdi
    5f20:	e8 00 00 00 00       	callq  5f25 <__rename_dir+0xaf5>
                if(dzt_ei->dzt_eno!=1) {
    5f25:	4c 8b 75 88          	mov    -0x78(%rbp),%r14
    5f29:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
                    }
                } else
                    ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);

                dzt_hn = le64_to_cpu(sub_de->dzt_hn);
                ch_ei = radix_tree_delete(&dzt_m->dzt_root, dzt_hn);
    5f2d:	49 89 c0             	mov    %rax,%r8
    5f30:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
                if(dzt_ei->dzt_eno!=1) {
                    ch_len =(u64)dzt_ei->root_len + strlen(sub_ph);
    5f34:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
                } else
                    ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);

                dzt_hn = le64_to_cpu(sub_de->dzt_hn);
                ch_ei = radix_tree_delete(&dzt_m->dzt_root, dzt_hn);
                if(dzt_ei->dzt_eno!=1) {
    5f38:	41 83 7e 08 01       	cmpl   $0x1,0x8(%r14)
    5f3d:	4c 89 95 78 ff ff ff 	mov    %r10,-0x88(%rbp)
    5f44:	0f 84 67 03 00 00    	je     62b1 <__rename_dir+0xe81>
                    ch_len =(u64)dzt_ei->root_len + strlen(sub_ph);
    5f4a:	e8 00 00 00 00       	callq  5f4f <__rename_dir+0xb1f>
    5f4f:	49 03 46 28          	add    0x28(%r14),%rax
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    5f53:	be d0 80 00 00       	mov    $0x80d0,%esi
    5f58:	48 8d 3c c5 08 00 00 	lea    0x8(,%rax,8),%rdi
    5f5f:	00 
    5f60:	49 89 c4             	mov    %rax,%r12
    5f63:	e8 00 00 00 00       	callq  5f68 <__rename_dir+0xb38>
                    ch_ph = kzalloc(sizeof(char *)*(ch_len+1), GFP_KERNEL);
                    get_zone_path(sb, dzt_ei, ch_ph, sub_ph);
    5f68:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
    5f6c:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    5f70:	48 89 c2             	mov    %rax,%rdx
    5f73:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
    5f7a:	49 89 c6             	mov    %rax,%r14
    5f7d:	e8 00 00 00 00       	callq  5f82 <__rename_dir+0xb52>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    5f82:	45 85 e4             	test   %r12d,%r12d
    5f85:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
    5f89:	4c 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10
    5f90:	0f 8e 5b 03 00 00    	jle    62f1 <__rename_dir+0xec1>
    5f96:	41 8d 44 24 ff       	lea    -0x1(%r12),%eax
    5f9b:	31 c9                	xor    %ecx,%ecx
    5f9d:	49 8d 74 06 01       	lea    0x1(%r14,%rax,1),%rsi
    5fa2:	4c 89 f0             	mov    %r14,%rax
		hash = hash * seed + (*str++);
    5fa5:	48 89 ca             	mov    %rcx,%rdx
    5fa8:	48 83 c0 01          	add    $0x1,%rax
    5fac:	48 c1 e2 05          	shl    $0x5,%rdx
    5fb0:	48 29 ca             	sub    %rcx,%rdx
    5fb3:	48 89 d1             	mov    %rdx,%rcx
    5fb6:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    5fbb:	48 01 d1             	add    %rdx,%rcx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    5fbe:	48 39 f0             	cmp    %rsi,%rax
    5fc1:	75 e2                	jne    5fa5 <__rename_dir+0xb75>
                    ch_ph = kzalloc(sizeof(char *)*(ch_len+1), GFP_KERNEL);
                    memcpy(ch_ph, sub_ph, ch_len);
                    ch_ph[ch_len]='\0';
                }
                dzt_hn = BKDRHash(ch_ph, ch_len);
                ch_ei->root_len = (u32)ch_len;
    5fc3:	41 83 e4 ff          	and    $0xffffffff,%r12d
                ch_ei->hash_name = dzt_hn;
    5fc7:	49 89 48 30          	mov    %rcx,0x30(%r8)
                radix_tree_insert(&dzt_m->dzt_root, dzt_hn, ch_ei);
    5fcb:	4c 89 c2             	mov    %r8,%rdx
                    ch_ph = kzalloc(sizeof(char *)*(ch_len+1), GFP_KERNEL);
                    memcpy(ch_ph, sub_ph, ch_len);
                    ch_ph[ch_len]='\0';
                }
                dzt_hn = BKDRHash(ch_ph, ch_len);
                ch_ei->root_len = (u32)ch_len;
    5fce:	4d 89 60 28          	mov    %r12,0x28(%r8)
                ch_ei->hash_name = dzt_hn;
                radix_tree_insert(&dzt_m->dzt_root, dzt_hn, ch_ei);
    5fd2:	4c 8b a5 28 ff ff ff 	mov    -0xd8(%rbp),%r12
    5fd9:	48 89 ce             	mov    %rcx,%rsi
    5fdc:	4c 89 95 78 ff ff ff 	mov    %r10,-0x88(%rbp)
    5fe3:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    5fe7:	4c 89 e7             	mov    %r12,%rdi
    5fea:	e8 00 00 00 00       	callq  5fef <__rename_dir+0xbbf>
                radix_tree_tag_set(&dzt_m->dzt_root, dzt_hn, 1);
    5fef:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
    5ff3:	ba 01 00 00 00       	mov    $0x1,%edx
    5ff8:	4c 89 e7             	mov    %r12,%rdi
    5ffb:	48 89 ce             	mov    %rcx,%rsi
    5ffe:	e8 00 00 00 00       	callq  6003 <__rename_dir+0xbd3>
                kfree(ch_ph);
    6003:	4c 89 f7             	mov    %r14,%rdi
    6006:	e8 00 00 00 00       	callq  600b <__rename_dir+0xbdb>
                new_de->dzt_hn = cpu_to_le64(dzt_hn);
    600b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    600f:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    6013:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
    6017:	4c 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10
    601e:	48 c1 e0 07          	shl    $0x7,%rax
    6022:	48 89 8c 07 a8 40 00 	mov    %rcx,0x40a8(%rdi,%rax,1)
    6029:	00 
    602a:	e9 df fb ff ff       	jmpq   5c0e <__rename_dir+0x7de>
            //new_de->isr_sf = sub_de->isr_sf;
            new_de->ino = sub_de->ino;
              
            new_de->size = sub_de->size;
            if(sub_de->ext_flag==1){
                new_de->ext_flag=1;
    602f:	b9 01 00 00 00       	mov    $0x1,%ecx
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);
    6034:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    6038:	44 0f b6 8d 53 ff ff 	movzbl -0xad(%rbp),%r9d
    603f:	ff 
            //new_de->isr_sf = sub_de->isr_sf;
            new_de->ino = sub_de->ino;
              
            new_de->size = sub_de->size;
            if(sub_de->ext_flag==1){
                new_de->ext_flag=1;
    6040:	66 41 89 8a 84 40 00 	mov    %cx,0x4084(%r10)
    6047:	00 
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);
    6048:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    604c:	45 89 e8             	mov    %r13d,%r8d
    604f:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    6053:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    6057:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
    605e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
    6065:	00 
    6066:	48 89 04 24          	mov    %rax,(%rsp)
    606a:	e8 00 00 00 00       	callq  606f <__rename_dir+0xc3f>
    606f:	4c 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%r10
    6076:	e9 34 fb ff ff       	jmpq   5baf <__rename_dir+0x77f>
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
        tem_sf = list_entry(this, struct file_p, list);
        s_pos = tem_sf->pos;
        sub_de = &ze->dentry[s_pos];
    607b:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
    6082:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
        sub_ph[slen] = '\0';
        strcat(sub_ph, "/");
        strcat(sub_ph, s_name);

        if(sub_de->file_type == NORMAL_DIRECTORY){
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);
    6086:	4c 8b 4d a8          	mov    -0x58(%rbp),%r9
    608a:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
    608e:	48 8b 8d 20 ff ff ff 	mov    -0xe0(%rbp),%rcx
    6095:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
        tem_sf = list_entry(this, struct file_p, list);
        s_pos = tem_sf->pos;
        sub_de = &ze->dentry[s_pos];
    6099:	48 81 c6 81 00 00 00 	add    $0x81,%rsi
        sub_ph[slen] = '\0';
        strcat(sub_ph, "/");
        strcat(sub_ph, s_name);

        if(sub_de->file_type == NORMAL_DIRECTORY){
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);
    60a0:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
    
    /*rename 子文件*/
    list_for_each_safe(this, next, head) {
        tem_sf = list_entry(this, struct file_p, list);
        s_pos = tem_sf->pos;
        sub_de = &ze->dentry[s_pos];
    60a7:	48 89 f3             	mov    %rsi,%rbx
    60aa:	48 c1 e3 07          	shl    $0x7,%rbx
    60ae:	48 8d 34 18          	lea    (%rax,%rbx,1),%rsi
        sub_ph[slen] = '\0';
        strcat(sub_ph, "/");
        strcat(sub_ph, s_name);

        if(sub_de->file_type == NORMAL_DIRECTORY){
            ret = __rename_dir(sb, sub_de, dzt_ei,old_ei, sub_ph, s_name);
    60b2:	e8 00 00 00 00       	callq  60b7 <__rename_dir+0xc87>
    60b7:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
    60bb:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
    60c1:	e9 4c fc ff ff       	jmpq   5d12 <__rename_dir+0x8e2>
            test_and_set_bit_le(bitpos, (void *)z_p->statemap);
            hashname = BKDRHash(sub_ph, strlen(sub_ph));
           
            /*rename dir_info*/
            if(new_de->file_type==ROOT_DIRECTORY){
                nr_dir = add_dir_info(dzt_ei, hashname, dir_pos);
    60c6:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
    60ca:	44 89 ea             	mov    %r13d,%edx
    60cd:	4c 89 f6             	mov    %r14,%rsi
    60d0:	e8 00 00 00 00       	callq  60d5 <__rename_dir+0xca5>
    60d5:	48 89 c3             	mov    %rax,%rbx
                o_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    60d8:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
    60df:	4c 8b 60 10          	mov    0x10(%rax),%r12
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    60e3:	4d 85 e4             	test   %r12,%r12
    60e6:	0f 84 0c 02 00 00    	je     62f8 <__rename_dir+0xec8>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    60ec:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
    60f3:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    60fa:	4c 03 60 18          	add    0x18(%rax),%r12
                rn_len = le64_to_cpu(src_de->fname_len); 
    60fe:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
    6105:	4c 89 65 a0          	mov    %r12,-0x60(%rbp)
    6109:	4c 8b 60 10          	mov    0x10(%rax),%r12
                r_name = kzalloc(sizeof(char)*(rn_len+1),GFP_KERNEL);
    610d:	49 8d 7c 24 01       	lea    0x1(%r12),%rdi
    6112:	be d0 80 00 00       	mov    $0x80d0,%esi
    6117:	e8 00 00 00 00       	callq  611c <__rename_dir+0xcec>
                get_de_name(src_de, o_ze, r_name, 1);
    611c:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
    6120:	48 8b bd 30 ff ff ff 	mov    -0xd0(%rbp),%rdi
    6127:	b9 01 00 00 00       	mov    $0x1,%ecx
    612c:	48 89 c2             	mov    %rax,%rdx
    612f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    6133:	e8 00 00 00 00       	callq  6138 <__rename_dir+0xd08>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    6138:	45 85 e4             	test   %r12d,%r12d
    613b:	0f 8e 53 02 00 00    	jle    6394 <__rename_dir+0xf64>
    6141:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    6145:	41 8d 54 24 ff       	lea    -0x1(%r12),%edx
    614a:	31 f6                	xor    %esi,%esi
    614c:	48 8d 4c 10 01       	lea    0x1(%rax,%rdx,1),%rcx
		hash = hash * seed + (*str++);
    6151:	48 89 f2             	mov    %rsi,%rdx
    6154:	48 83 c0 01          	add    $0x1,%rax
    6158:	48 c1 e2 05          	shl    $0x5,%rdx
    615c:	48 29 f2             	sub    %rsi,%rdx
    615f:	48 89 d6             	mov    %rdx,%rsi
    6162:	48 0f be 50 ff       	movsbq -0x1(%rax),%rdx
    6167:	48 01 d6             	add    %rdx,%rsi
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    616a:	48 39 c8             	cmp    %rcx,%rax
    616d:	75 e2                	jne    6151 <__rename_dir+0xd21>
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
    616f:	48 8b bd 10 ff ff ff 	mov    -0xf0(%rbp),%rdi
    6176:	e8 00 00 00 00       	callq  617b <__rename_dir+0xd4b>
                this = head = next =NULL;
                head = &old_dir->sub_file;
                list_for_each_safe(this, next, head){
    617b:	48 8b 48 18          	mov    0x18(%rax),%rcx
                r_name = kzalloc(sizeof(char)*(rn_len+1),GFP_KERNEL);
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
                this = head = next =NULL;
                head = &old_dir->sub_file;
    617f:	48 8d 70 18          	lea    0x18(%rax),%rsi
                o_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
                rn_len = le64_to_cpu(src_de->fname_len); 
                r_name = kzalloc(sizeof(char)*(rn_len+1),GFP_KERNEL);
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
    6183:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                this = head = next =NULL;
                head = &old_dir->sub_file;
    6187:	48 89 b5 48 ff ff ff 	mov    %rsi,-0xb8(%rbp)
                list_for_each_safe(this, next, head){
    618e:	48 39 ce             	cmp    %rcx,%rsi
    6191:	4c 8b 21             	mov    (%rcx),%r12
    6194:	0f 84 f1 01 00 00    	je     638b <__rename_dir+0xf5b>
    619a:	48 8d 43 18          	lea    0x18(%rbx),%rax
    619e:	44 89 7d 98          	mov    %r15d,-0x68(%rbp)
    61a2:	44 89 6d 90          	mov    %r13d,-0x70(%rbp)
    61a6:	4c 89 b5 78 ff ff ff 	mov    %r14,-0x88(%rbp)
    61ad:	4d 89 e5             	mov    %r12,%r13
    61b0:	49 89 f7             	mov    %rsi,%r15
    61b3:	49 89 ce             	mov    %rcx,%r14
    61b6:	49 89 c4             	mov    %rax,%r12
    61b9:	eb 03                	jmp    61be <__rename_dir+0xd8e>
    61bb:	49 89 c5             	mov    %rax,%r13
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    61be:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 61c5 <__rename_dir+0xd95>
    61c5:	ba 14 00 00 00       	mov    $0x14,%edx
    61ca:	be d0 80 00 00       	mov    $0x80d0,%esi
    61cf:	e8 00 00 00 00       	callq  61d4 <__rename_dir+0xda4>
                    tem_sf = list_entry(this, struct file_p, list);
                    new_sf = kzalloc(sizeof(struct file_p),GFP_KERNEL);
                    new_sf->pos = tem_sf->pos;
    61d4:	41 8b 56 10          	mov    0x10(%r14),%edx
                    list_add_tail(&new_sf->list, &nr_dir->sub_file);
                    list_del(&tem_sf->list);
                    kfree(tem_sf);
    61d8:	4c 89 f7             	mov    %r14,%rdi
                this = head = next =NULL;
                head = &old_dir->sub_file;
                list_for_each_safe(this, next, head){
                    tem_sf = list_entry(this, struct file_p, list);
                    new_sf = kzalloc(sizeof(struct file_p),GFP_KERNEL);
                    new_sf->pos = tem_sf->pos;
    61db:	89 50 10             	mov    %edx,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    61de:	48 8b 53 20          	mov    0x20(%rbx),%rdx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    61e2:	48 89 43 20          	mov    %rax,0x20(%rbx)
	new->next = next;
    61e6:	4c 89 20             	mov    %r12,(%rax)
	new->prev = prev;
    61e9:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    61ed:	48 89 02             	mov    %rax,(%rdx)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    61f0:	49 8b 46 08          	mov    0x8(%r14),%rax
    61f4:	49 8b 16             	mov    (%r14),%rdx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    61f7:	48 89 42 08          	mov    %rax,0x8(%rdx)
	prev->next = next;
    61fb:	48 89 10             	mov    %rdx,(%rax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    61fe:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
    6205:	00 ad de 
    6208:	49 89 06             	mov    %rax,(%r14)
	entry->prev = LIST_POISON2;
    620b:	48 b8 00 02 00 00 00 	movabs $0xdead000000000200,%rax
    6212:	00 ad de 
    6215:	49 89 46 08          	mov    %rax,0x8(%r14)
    6219:	4d 89 ee             	mov    %r13,%r14
                    list_add_tail(&new_sf->list, &nr_dir->sub_file);
                    list_del(&tem_sf->list);
                    kfree(tem_sf);
    621c:	e8 00 00 00 00       	callq  6221 <__rename_dir+0xdf1>
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
                this = head = next =NULL;
                head = &old_dir->sub_file;
                list_for_each_safe(this, next, head){
    6221:	4d 39 ef             	cmp    %r13,%r15
    6224:	49 8b 45 00          	mov    0x0(%r13),%rax
    6228:	75 91                	jne    61bb <__rename_dir+0xd8b>
    622a:	44 8b 6d 90          	mov    -0x70(%rbp),%r13d
    622e:	4c 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%r14
    6235:	44 8b 7d 98          	mov    -0x68(%rbp),%r15d
    6239:	48 89 45 98          	mov    %rax,-0x68(%rbp)
                    new_sf->pos = tem_sf->pos;
                    list_add_tail(&new_sf->list, &nr_dir->sub_file);
                    list_del(&tem_sf->list);
                    kfree(tem_sf);
                }
                kfree(old_dir);
    623d:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    6241:	e8 00 00 00 00       	callq  6246 <__rename_dir+0xe16>
    6246:	e9 27 fa ff ff       	jmpq   5c72 <__rename_dir+0x842>
                    if(sub_plen<SMALL_NAME_LEN){
                        memcpy(new_de->ful_name.f_name, sub_ph, sub_plen);
                        new_de->ful_name.f_name[sub_len]='\0';
                    } else {
                        new_de->ext_flag = 2;
                        ext_de_name(sb ,dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);
    624b:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
                if(sub_de->ext_flag==0){
                    if(sub_plen<SMALL_NAME_LEN){
                        memcpy(new_de->ful_name.f_name, sub_ph, sub_plen);
                        new_de->ful_name.f_name[sub_len]='\0';
                    } else {
                        new_de->ext_flag = 2;
    624f:	ba 02 00 00 00       	mov    $0x2,%edx
    6254:	4c 89 55 a0          	mov    %r10,-0x60(%rbp)
    6258:	66 41 89 92 84 40 00 	mov    %dx,0x4084(%r10)
    625f:	00 
                        ext_de_name(sb ,dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);
    6260:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    6267:	00 
    6268:	48 89 3c 24          	mov    %rdi,(%rsp)
                    }
                } else
                    ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_plen, sub_ph, 1);
    626c:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    6270:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    6274:	41 89 c1             	mov    %eax,%r9d
    6277:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
    627b:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
    6282:	45 89 e8             	mov    %r13d,%r8d
    6285:	e8 00 00 00 00       	callq  628a <__rename_dir+0xe5a>
    628a:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
    628e:	e9 6b fc ff ff       	jmpq   5efe <__rename_dir+0xace>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    6293:	45 31 f6             	xor    %r14d,%r14d
    6296:	e9 c9 f9 ff ff       	jmpq   5c64 <__rename_dir+0x834>
    629b:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    629f:	4c 89 55 a0          	mov    %r10,-0x60(%rbp)
    62a3:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
    62aa:	00 
    62ab:	48 89 34 24          	mov    %rsi,(%rsp)
    62af:	eb bb                	jmp    626c <__rename_dir+0xe3c>
                if(dzt_ei->dzt_eno!=1) {
                    ch_len =(u64)dzt_ei->root_len + strlen(sub_ph);
                    ch_ph = kzalloc(sizeof(char *)*(ch_len+1), GFP_KERNEL);
                    get_zone_path(sb, dzt_ei, ch_ph, sub_ph);
                } else {
                    ch_len = strlen(sub_ph);
    62b1:	e8 00 00 00 00       	callq  62b6 <__rename_dir+0xe86>
                    ch_ph = kzalloc(sizeof(char *)*(ch_len+1), GFP_KERNEL);
    62b6:	48 8d 3c c5 08 00 00 	lea    0x8(,%rax,8),%rdi
    62bd:	00 
                if(dzt_ei->dzt_eno!=1) {
                    ch_len =(u64)dzt_ei->root_len + strlen(sub_ph);
                    ch_ph = kzalloc(sizeof(char *)*(ch_len+1), GFP_KERNEL);
                    get_zone_path(sb, dzt_ei, ch_ph, sub_ph);
                } else {
                    ch_len = strlen(sub_ph);
    62be:	49 89 c4             	mov    %rax,%r12
                    ch_ph = kzalloc(sizeof(char *)*(ch_len+1), GFP_KERNEL);
    62c1:	e8 0a a0 ff ff       	callq  2d0 <kzalloc.constprop.8>
                    memcpy(ch_ph, sub_ph, ch_len);
    62c6:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    62ca:	4c 89 e2             	mov    %r12,%rdx
    62cd:	48 89 c7             	mov    %rax,%rdi
                    ch_len =(u64)dzt_ei->root_len + strlen(sub_ph);
                    ch_ph = kzalloc(sizeof(char *)*(ch_len+1), GFP_KERNEL);
                    get_zone_path(sb, dzt_ei, ch_ph, sub_ph);
                } else {
                    ch_len = strlen(sub_ph);
                    ch_ph = kzalloc(sizeof(char *)*(ch_len+1), GFP_KERNEL);
    62d0:	49 89 c6             	mov    %rax,%r14
                    memcpy(ch_ph, sub_ph, ch_len);
    62d3:	e8 00 00 00 00       	callq  62d8 <__rename_dir+0xea8>
	int i;

	for (i = 0; i < length; i++) {
    62d8:	45 85 e4             	test   %r12d,%r12d
                    ch_ph[ch_len]='\0';
    62db:	43 c6 04 26 00       	movb   $0x0,(%r14,%r12,1)
    62e0:	4c 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10
    62e7:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
    62eb:	0f 8f a5 fc ff ff    	jg     5f96 <__rename_dir+0xb66>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    62f1:	31 c9                	xor    %ecx,%ecx
    62f3:	e9 cb fc ff ff       	jmpq   5fc3 <__rename_dir+0xb93>
           
            /*rename dir_info*/
            if(new_de->file_type==ROOT_DIRECTORY){
                nr_dir = add_dir_info(dzt_ei, hashname, dir_pos);
                o_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
                rn_len = le64_to_cpu(src_de->fname_len); 
    62f8:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    62ff:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
    6306:	00 
    6307:	4c 8b 60 10          	mov    0x10(%rax),%r12
                r_name = kzalloc(sizeof(char)*(rn_len+1),GFP_KERNEL);
    630b:	49 8d 7c 24 01       	lea    0x1(%r12),%rdi
    6310:	e9 fd fd ff ff       	jmpq   6112 <__rename_dir+0xce2>
        sub_len = le64_to_cpu(sub_de->name_len);
        s_name = kzalloc(sizeof(char )*(sub_len+1), GFP_KERNEL);
        if(sub_de->ext_flag==1)
            get_ext_name(sub_de->next, s_name);
        else{
            memcpy(s_name, sub_de->name, sub_len);
    6315:	8b 06                	mov    (%rsi),%eax
    6317:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
    631b:	89 03                	mov    %eax,(%rbx)
    631d:	8b 45 a0             	mov    -0x60(%rbp),%eax
    6320:	8b 54 06 fc          	mov    -0x4(%rsi,%rax,1),%edx
    6324:	89 54 03 fc          	mov    %edx,-0x4(%rbx,%rax,1)
    6328:	e9 a2 f6 ff ff       	jmpq   59cf <__rename_dir+0x59f>
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    memcpy(new_ph, path, flen);
    new_ph[flen]='\0';
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
    632d:	44 8d 69 01          	lea    0x1(%rcx),%r13d
    6331:	44 8d 7a 02          	lea    0x2(%rdx),%r15d
    6335:	89 8d 54 ff ff ff    	mov    %ecx,-0xac(%rbp)
    633b:	e9 1c f2 ff ff       	jmpq   555c <__rename_dir+0x12c>
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);

            }else{

                new_de->ext_flag = sub_de->ext_flag;
                memcpy(new_de->name, s_name, sub_len);
    6340:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    6344:	8b 17                	mov    (%rdi),%edx
    6346:	89 10                	mov    %edx,(%rax)
    6348:	8b 55 a0             	mov    -0x60(%rbp),%edx
    634b:	8b 4c 17 fc          	mov    -0x4(%rdi,%rdx,1),%ecx
    634f:	89 4c 10 fc          	mov    %ecx,-0x4(%rax,%rdx,1)
    6353:	e9 3f f8 ff ff       	jmpq   5b97 <__rename_dir+0x767>
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    6358:	31 db                	xor    %ebx,%ebx
    635a:	e9 0a f4 ff ff       	jmpq   5769 <__rename_dir+0x339>
        sub_len = le64_to_cpu(sub_de->name_len);
        s_name = kzalloc(sizeof(char )*(sub_len+1), GFP_KERNEL);
        if(sub_de->ext_flag==1)
            get_ext_name(sub_de->next, s_name);
        else{
            memcpy(s_name, sub_de->name, sub_len);
    635f:	8b 45 a0             	mov    -0x60(%rbp),%eax
    6362:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
    6366:	0f b7 54 06 fe       	movzwl -0x2(%rsi,%rax,1),%edx
    636b:	66 89 54 03 fe       	mov    %dx,-0x2(%rbx,%rax,1)
    6370:	e9 5a f6 ff ff       	jmpq   59cf <__rename_dir+0x59f>
                ext_de_name(sb, dzt_ei, ze, z_p, dir_pos, sub_len, s_name, 0);

            }else{

                new_de->ext_flag = sub_de->ext_flag;
                memcpy(new_de->name, s_name, sub_len);
    6375:	8b 55 a0             	mov    -0x60(%rbp),%edx
    6378:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    637c:	0f b7 4c 16 fe       	movzwl -0x2(%rsi,%rdx,1),%ecx
    6381:	66 89 4c 10 fe       	mov    %cx,-0x2(%rax,%rdx,1)
    6386:	e9 0c f8 ff ff       	jmpq   5b97 <__rename_dir+0x767>
                get_de_name(src_de, o_ze, r_name, 1);
                old_hn = BKDRHash(r_name, rn_len);
                old_dir = radix_tree_delete(&old_ei->dir_tree, old_hn);
                this = head = next =NULL;
                head = &old_dir->sub_file;
                list_for_each_safe(this, next, head){
    638b:	4c 89 65 98          	mov    %r12,-0x68(%rbp)
    638f:	e9 a9 fe ff ff       	jmpq   623d <__rename_dir+0xe0d>
    6394:	31 f6                	xor    %esi,%esi
    6396:	e9 d4 fd ff ff       	jmpq   616f <__rename_dir+0xd3f>
    639b:	45 31 f6             	xor    %r14d,%r14d
    639e:	e9 a2 f4 ff ff       	jmpq   5845 <__rename_dir+0x415>
        new_de->par_pos = 0;
        par_de = &ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
            //nova_dbg("new par is root");
            par_hash = le64_to_cpu(par_de->hname);
    63a3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
            lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
    63a7:	4c 8b 75 88          	mov    -0x78(%rbp),%r14
    63ab:	4c 8d 45 c4          	lea    -0x3c(%rbp),%r8
    63af:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
    63b6:	b9 01 00 00 00       	mov    $0x1,%ecx
        new_de->par_pos = 0;
        par_de = &ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
            //nova_dbg("new par is root");
            par_hash = le64_to_cpu(par_de->hname);
    63bb:	48 8b 98 a8 40 00 00 	mov    0x40a8(%rax),%rbx
            lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
    63c2:	49 8b 76 18          	mov    0x18(%r14),%rsi
    63c6:	48 89 da             	mov    %rbx,%rdx
    63c9:	e8 00 00 00 00       	callq  63ce <__rename_dir+0xf9e>
            pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
    63ce:	4c 89 f0             	mov    %r14,%rax
    63d1:	48 89 de             	mov    %rbx,%rsi
    63d4:	48 83 c0 38          	add    $0x38,%rax
    63d8:	48 89 c7             	mov    %rax,%rdi
    63db:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    63df:	e8 00 00 00 00       	callq  63e4 <__rename_dir+0xfb4>
    63e4:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 63eb <__rename_dir+0xfbb>
    63eb:	ba 14 00 00 00       	mov    $0x14,%edx
    63f0:	be d0 80 00 00       	mov    $0x80d0,%esi
    63f5:	48 89 c3             	mov    %rax,%rbx
    63f8:	e8 00 00 00 00       	callq  63fd <__rename_dir+0xfcd>
            tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            tem_sf->pos = cpu_to_le32(dir_pos);
    63fd:	8b b5 54 ff ff ff    	mov    -0xac(%rbp),%esi
            list_add_tail(&tem_sf->list, &pdir->sub_file);
    6403:	48 8d 4b 18          	lea    0x18(%rbx),%rcx
            //nova_dbg("new par is root");
            par_hash = le64_to_cpu(par_de->hname);
            lookup_in_hashtable(sb, dzt_ei->ht_head, par_hash, 1, &par_pos);
            pdir = radix_tree_lookup(&dzt_ei->dir_tree, par_hash);
            tem_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
            tem_sf->pos = cpu_to_le32(dir_pos);
    6407:	89 70 10             	mov    %esi,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    640a:	48 8b 53 20          	mov    0x20(%rbx),%rdx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    640e:	48 89 43 20          	mov    %rax,0x20(%rbx)
            list_add_tail(&tem_sf->list, &pdir->sub_file);
    6412:	48 89 08             	mov    %rcx,(%rax)
	new->next = next;
	new->prev = prev;
    6415:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    6419:	48 89 02             	mov    %rax,(%rdx)
            pdir->sub_num++;
    641c:	48 83 43 08 01       	addq   $0x1,0x8(%rbx)
    6421:	e9 d1 f3 ff ff       	jmpq   57f7 <__rename_dir+0x3c7>
    flen = strlen(path);
    new_ph = kzalloc(sizeof(char )*(flen+1), GFP_KERNEL);
    memcpy(new_ph, path, flen);
    new_ph[flen]='\0';
    /*set dir entry*/
    while(bitpos<z_p->zone_max){
    6426:	41 bc 01 00 00 00    	mov    $0x1,%r12d
    642c:	41 bd 01 00 00 00    	mov    $0x1,%r13d
    6432:	41 bf 02 00 00 00    	mov    $0x2,%r15d
    struct dzt_entry_info *ch_ei;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    struct dir_info *new_dir, *old_dir, *pdir, *nr_dir;
    struct list_head *this, *head, *next;
    struct file_p *tem_sf, *new_sf;
    u32 bitpos = 0, dir_pos = 0, s_pos, par_pos, par_id;
    6438:	c7 85 54 ff ff ff 00 	movl   $0x0,-0xac(%rbp)
    643f:	00 00 00 
    6442:	e9 15 f1 ff ff       	jmpq   555c <__rename_dir+0x12c>
    kfree(z_p);
    kfree(new_ph);
    //nova_dbg("%s end",__func__);
    return ret;

}
    6447:	e8 00 00 00 00       	callq  644c <__rename_dir+0x101c>
    644c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000006450 <add_rename_dir>:

/*rename directories*/
int add_rename_dir(struct dentry *o_dentry, struct dentry *n_dentry, struct dafs_dentry *old_de,
                   struct dzt_entry_info *old_ei)
{
    6450:	e8 00 00 00 00       	callq  6455 <add_rename_dir+0x5>
    6455:	55                   	push   %rbp
    6456:	48 89 e5             	mov    %rsp,%rbp
    6459:	41 57                	push   %r15
    645b:	41 56                	push   %r14
    645d:	41 55                	push   %r13
    645f:	41 54                	push   %r12
    6461:	49 89 f5             	mov    %rsi,%r13
    6464:	53                   	push   %rbx
    6465:	48 83 ec 40          	sub    $0x40,%rsp
    struct super_block *sb = o_dentry->d_sb;
    6469:	48 8b 47 68          	mov    0x68(%rdi),%rax
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    646d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
}

/*rename directories*/
int add_rename_dir(struct dentry *o_dentry, struct dentry *n_dentry, struct dafs_dentry *old_de,
                   struct dzt_entry_info *old_ei)
{
    6474:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
    6478:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
    struct super_block *sb = o_dentry->d_sb;
    647c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    //struct dafs_dentry *new_de;
    struct dzt_entry_info *n_ei;
    struct dafs_zone_entry *n_ze;
    char *n_phname, *ph, *n_name, *phn;
    u32 namelen = n_dentry->d_name.len;
    6480:	8b 46 24             	mov    0x24(%rsi),%eax
    6483:	89 45 c8             	mov    %eax,-0x38(%rbp)
}

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
    6486:	48 8b 46 18          	mov    0x18(%rsi),%rax
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    648a:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
    6491:	48 8b 40 30          	mov    0x30(%rax),%rax
    6495:	48 8b 58 28          	mov    0x28(%rax),%rbx
    6499:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    64a0:	00 00 
    struct nova_sb_info *sbi = NOVA_SB(sb);
    char *ph, *buf, *tem, *ppath;
    //char *buf = NULL, *ppath=NULL, *tem=NULL;
    struct fs_struct *fs = current->fs;
    64a2:	4c 8b a0 30 06 00 00 	mov    0x630(%rax),%r12
    64a9:	4c 8b b3 b0 03 00 00 	mov    0x3b0(%rbx),%r14
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    64b0:	e8 00 00 00 00       	callq  64b5 <add_rename_dir+0x65>
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    64b5:	48 85 db             	test   %rbx,%rbx
    64b8:	0f 84 17 02 00 00    	je     66d5 <add_rename_dir+0x285>
    BUG_ON(sbi==NULL);
    64be:	4d 85 f6             	test   %r14,%r14
    64c1:	0f 84 10 02 00 00    	je     66d7 <add_rename_dir+0x287>
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    64c7:	49 8d 7c 24 04       	lea    0x4(%r12),%rdi
    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    64cc:	41 c6 86 d8 01 00 00 	movb   $0x0,0x1d8(%r14)
    64d3:	00 
    buf[0]='\0';
    64d4:	41 c6 86 d7 05 00 00 	movb   $0x0,0x5d7(%r14)
    64db:	00 
    tem[0]='\0';
    64dc:	41 c6 86 d6 09 00 00 	movb   $0x0,0x9d6(%r14)
    64e3:	00 
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    64e4:	49 8d 9e d8 01 00 00 	lea    0x1d8(%r14),%rbx
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    64eb:	e8 00 00 00 00       	callq  64f0 <add_rename_dir+0xa0>
    vfsmnt = mntget(fs->pwd.mnt);
    64f0:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
    64f5:	e8 00 00 00 00       	callq  64fa <add_rename_dir+0xaa>
    if(!vfsmnt){
    64fa:	48 85 c0             	test   %rax,%rax
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    64fd:	49 89 c7             	mov    %rax,%r15
    if(!vfsmnt){
    6500:	0f 84 d3 01 00 00    	je     66d9 <add_rename_dir+0x289>
    6506:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
    650b:	f0 41 0f c1 44 24 04 	lock xadd %eax,0x4(%r12)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
    6512:	49 8b 75 28          	mov    0x28(%r13),%rsi
    6516:	49 c7 c2 00 00 00 00 	mov    $0x0,%r10
    651d:	b9 02 00 00 00       	mov    $0x2,%ecx
    6522:	4c 89 d7             	mov    %r10,%rdi
    6525:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    6527:	0f 85 f0 01 00 00    	jne    671d <add_rename_dir+0x2cd>
        memcpy(buf,"/",1);
        buf[1]='\0';
    }else{
        //nova_dbg("%s root dentry",__func__);
        memcpy(ph, "/", 1);
    652d:	41 c6 86 d8 01 00 00 	movb   $0x2f,0x1d8(%r14)
    6534:	2f 
        ph[1]='\0';
    6535:	41 c6 86 d9 01 00 00 	movb   $0x0,0x1d9(%r14)
    653c:	00 
    //int i;
    int ret= 0;

    //nova_dbg("%s start",__func__); 
    ph = get_dentry_path(n_dentry,0);
    n_phname = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    653d:	48 89 df             	mov    %rbx,%rdi
    6540:	e8 00 00 00 00       	callq  6545 <add_rename_dir+0xf5>
					flags, size);
		}
#endif
	}
	return __kmalloc(size, flags);
    6545:	48 8d 78 01          	lea    0x1(%rax),%rdi
    6549:	be d0 80 00 00       	mov    $0x80d0,%esi
    654e:	e8 00 00 00 00       	callq  6553 <add_rename_dir+0x103>
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    6553:	48 89 df             	mov    %rbx,%rdi
    6556:	49 89 c6             	mov    %rax,%r14
    6559:	e8 00 00 00 00       	callq  655e <add_rename_dir+0x10e>
    655e:	48 8d 78 01          	lea    0x1(%rax),%rdi
    6562:	be d0 80 00 00       	mov    $0x80d0,%esi
    6567:	e8 00 00 00 00       	callq  656c <add_rename_dir+0x11c>
    656c:	49 89 c4             	mov    %rax,%r12
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    656f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    6573:	48 89 da             	mov    %rbx,%rdx
    6576:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    657d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    6584:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
    658b:	48 8b 80 d8 0d 00 00 	mov    0xdd8(%rax),%rax
    6592:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    6596:	e8 00 00 00 00       	callq  659b <add_rename_dir+0x14b>
    tlen = strlen(phstr);
    659b:	48 89 df             	mov    %rbx,%rdi
    659e:	e8 00 00 00 00       	callq  65a3 <add_rename_dir+0x153>
    nova_dbg("%s length is %llu", __func__, tlen);
    65a3:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    tlen = strlen(phstr);
    65aa:	49 89 c7             	mov    %rax,%r15
    nova_dbg("%s length is %llu", __func__, tlen);
    65ad:	48 89 c2             	mov    %rax,%rdx
    65b0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    65b7:	e8 00 00 00 00       	callq  65bc <add_rename_dir+0x16c>
    memcpy(phs, phstr, tlen);
    65bc:	4c 89 fa             	mov    %r15,%rdx
    65bf:	48 89 de             	mov    %rbx,%rsi
    65c2:	4c 89 e7             	mov    %r12,%rdi
    65c5:	e8 00 00 00 00       	callq  65ca <add_rename_dir+0x17a>
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    65ca:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi

    nova_dbg("%s start %s",__func__,phstr);
    tlen = strlen(phstr);
    nova_dbg("%s length is %llu", __func__, tlen);
    memcpy(phs, phstr, tlen);
    phs[tlen]='\0';
    65ce:	43 c6 04 3c 00       	movb   $0x0,(%r12,%r15,1)
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    65d3:	be 2f 00 00 00       	mov    $0x2f,%esi
            return dzt_ei;
        }
    }while(1);
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    65d8:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    phs[1]='\0';
    65dd:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    65e3:	e8 00 00 00 00       	callq  65e8 <add_rename_dir+0x198>
    if(!dzt_ei){
    65e8:	48 85 c0             	test   %rax,%rax
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    65eb:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    if(!dzt_ei){
    65ef:	0f 84 23 01 00 00    	je     6718 <add_rename_dir+0x2c8>
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    //memcpy(n_phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    
    phlen = strlen(phn);
    65f5:	4c 89 e7             	mov    %r12,%rdi
    65f8:	e8 00 00 00 00       	callq  65fd <add_rename_dir+0x1ad>
    if(phlen==1){
    65fd:	48 83 f8 01          	cmp    $0x1,%rax
    6601:	0f 84 ab 00 00 00    	je     66b2 <add_rename_dir+0x262>
        flen = strlen(ph);
        memcpy(n_phname, ph, flen);
        n_phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    6607:	48 89 df             	mov    %rbx,%rdi
    660a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    660e:	e8 00 00 00 00       	callq  6613 <add_rename_dir+0x1c3>
    6613:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
        memcpy(n_phname, ph+phlen, flen);
    6617:	4c 89 f7             	mov    %r14,%rdi
    if(phlen==1){
        flen = strlen(ph);
        memcpy(n_phname, ph, flen);
        n_phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    661a:	48 29 f0             	sub    %rsi,%rax
        memcpy(n_phname, ph+phlen, flen);
    661d:	48 01 de             	add    %rbx,%rsi
    if(phlen==1){
        flen = strlen(ph);
        memcpy(n_phname, ph, flen);
        n_phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    6620:	49 89 c7             	mov    %rax,%r15
        memcpy(n_phname, ph+phlen, flen);
    6623:	48 89 c2             	mov    %rax,%rdx
    6626:	e8 00 00 00 00       	callq  662b <add_rename_dir+0x1db>
        n_phname[flen]='\0';
    662b:	43 c6 04 3e 00       	movb   $0x0,(%r14,%r15,1)
    6630:	8b 45 c8             	mov    -0x38(%rbp),%eax
    6633:	be d0 80 00 00       	mov    $0x80d0,%esi
    6638:	8d 78 01             	lea    0x1(%rax),%edi
    663b:	e8 00 00 00 00       	callq  6640 <add_rename_dir+0x1f0>
    }

    n_name = kzalloc(sizeof(char)*(namelen+1), GFP_KERNEL);
    memcpy(n_name, n_dentry->d_name.name, namelen);
    6640:	8b 4d c8             	mov    -0x38(%rbp),%ecx
    6643:	49 8b 75 28          	mov    0x28(%r13),%rsi
    6647:	48 89 c7             	mov    %rax,%rdi
    664a:	49 89 c7             	mov    %rax,%r15
    664d:	48 89 ca             	mov    %rcx,%rdx
    6650:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
    6654:	e8 00 00 00 00       	callq  6659 <add_rename_dir+0x209>
    n_name[namelen] = '\0';
    6659:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx

    ret = __rename_dir(sb, old_de, n_ei, old_ei,n_phname, n_name);
    665d:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    6661:	4d 89 f9             	mov    %r15,%r9
    6664:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    6668:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    666c:	4d 89 f0             	mov    %r14,%r8
        n_phname[flen]='\0';
    }

    n_name = kzalloc(sizeof(char)*(namelen+1), GFP_KERNEL);
    memcpy(n_name, n_dentry->d_name.name, namelen);
    n_name[namelen] = '\0';
    666f:	41 c6 04 0f 00       	movb   $0x0,(%r15,%rcx,1)

    ret = __rename_dir(sb, old_de, n_ei, old_ei,n_phname, n_name);
    6674:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
    6678:	e8 00 00 00 00       	callq  667d <add_rename_dir+0x22d>
    
    kfree(n_phname);
    667d:	4c 89 f7             	mov    %r14,%rdi

    n_name = kzalloc(sizeof(char)*(namelen+1), GFP_KERNEL);
    memcpy(n_name, n_dentry->d_name.name, namelen);
    n_name[namelen] = '\0';

    ret = __rename_dir(sb, old_de, n_ei, old_ei,n_phname, n_name);
    6680:	41 89 c5             	mov    %eax,%r13d
    
    kfree(n_phname);
    6683:	e8 00 00 00 00       	callq  6688 <add_rename_dir+0x238>
    kfree(phn);
    6688:	4c 89 e7             	mov    %r12,%rdi
    668b:	e8 00 00 00 00       	callq  6690 <add_rename_dir+0x240>
    kfree(ph);
    6690:	48 89 df             	mov    %rbx,%rdi
    6693:	e8 00 00 00 00       	callq  6698 <add_rename_dir+0x248>
    kfree(n_name);
    6698:	4c 89 ff             	mov    %r15,%rdi
    669b:	e8 00 00 00 00       	callq  66a0 <add_rename_dir+0x250>
    //nova_dbg("%s end",__func__);
    return ret;
}
    66a0:	48 83 c4 40          	add    $0x40,%rsp
    66a4:	44 89 e8             	mov    %r13d,%eax
    66a7:	5b                   	pop    %rbx
    66a8:	41 5c                	pop    %r12
    66aa:	41 5d                	pop    %r13
    66ac:	41 5e                	pop    %r14
    66ae:	41 5f                	pop    %r15
    66b0:	5d                   	pop    %rbp
    66b1:	c3                   	retq   
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
    66b2:	48 89 df             	mov    %rbx,%rdi
    66b5:	e8 00 00 00 00       	callq  66ba <add_rename_dir+0x26a>
        memcpy(n_phname, ph, flen);
    66ba:	48 89 de             	mov    %rbx,%rsi
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
    66bd:	49 89 c7             	mov    %rax,%r15
        memcpy(n_phname, ph, flen);
    66c0:	48 89 c2             	mov    %rax,%rdx
    66c3:	4c 89 f7             	mov    %r14,%rdi
    66c6:	e8 00 00 00 00       	callq  66cb <add_rename_dir+0x27b>
        n_phname[flen]='\0';
    66cb:	43 c6 04 3e 00       	movb   $0x0,(%r14,%r15,1)
    66d0:	e9 5b ff ff ff       	jmpq   6630 <add_rename_dir+0x1e0>
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    66d5:	0f 0b                	ud2    
    BUG_ON(sbi==NULL);
    66d7:	0f 0b                	ud2    
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    if(!vfsmnt){
        nova_dbg("not find mnt");
    66d9:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    66e0:	e8 00 00 00 00       	callq  66e5 <add_rename_dir+0x295>
    
    //kfree(buf);
    //kfree(tem);
    //nova_dbg("dafs finish get dentry path");
ERR:
    nova_dbg("%s ful ph is %s len %llu, sbi %s ",__func__,ph, strlen(ph), sbi->ph_f);
    66e5:	31 c0                	xor    %eax,%eax
    66e7:	48 89 df             	mov    %rbx,%rdi
    66ea:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    66ee:	f2 ae                	repnz scas %es:(%rdi),%al
    66f0:	49 89 d8             	mov    %rbx,%r8
    66f3:	48 89 da             	mov    %rbx,%rdx
    66f6:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    66fd:	48 89 c8             	mov    %rcx,%rax
    6700:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    6707:	48 f7 d0             	not    %rax
    670a:	48 8d 48 ff          	lea    -0x1(%rax),%rcx
    670e:	e8 00 00 00 00       	callq  6713 <add_rename_dir+0x2c3>
    6713:	e9 25 fe ff ff       	jmpq   653d <add_rename_dir+0xed>
    6718:	e8 00 00 00 00       	callq  671d <add_rename_dir+0x2cd>
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    671d:	49 8d 86 d7 05 00 00 	lea    0x5d7(%r14),%rax
    6724:	48 89 5d a0          	mov    %rbx,-0x60(%rbp)
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
        memcpy(buf,"/",1);
    6728:	41 c6 86 d7 05 00 00 	movb   $0x2f,0x5d7(%r14)
    672f:	2f 
        buf[1]='\0';
    6730:	41 c6 86 d8 05 00 00 	movb   $0x0,0x5d8(%r14)
    6737:	00 
    }
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    6738:	4d 89 ec             	mov    %r13,%r12
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    673b:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    673f:	48 89 c3             	mov    %rax,%rbx
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    6742:	48 89 df             	mov    %rbx,%rdi
    6745:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
    6749:	e8 00 00 00 00       	callq  674e <add_rename_dir+0x2fe>
    674e:	ba 2f 00 00 00       	mov    $0x2f,%edx
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    6753:	48 8d 7c 03 01       	lea    0x1(%rbx,%rax,1),%rdi
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    6758:	66 89 14 03          	mov    %dx,(%rbx,%rax,1)
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    675c:	49 8b 74 24 28       	mov    0x28(%r12),%rsi
    6761:	e8 00 00 00 00       	callq  6766 <add_rename_dir+0x316>
        p_dentry = tem_dentry->d_parent;
    6766:	4d 8b 64 24 18       	mov    0x18(%r12),%r12
        //plen = strlen(buf);
        //buf[plen]='\0';
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
    676b:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    676f:	b9 02 00 00 00       	mov    $0x2,%ecx
    6774:	49 8b 74 24 28       	mov    0x28(%r12),%rsi
    6779:	4c 89 d7             	mov    %r10,%rdi
    677c:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    677e:	75 c2                	jne    6742 <add_rename_dir+0x2f2>
    6780:	49 8b 44 24 30       	mov    0x30(%r12),%rax
    6785:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
    678a:	75 b6                	jne    6742 <add_rename_dir+0x2f2>
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    678c:	4c 8b 65 a8          	mov    -0x58(%rbp),%r12

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    6790:	49 8d 86 d6 09 00 00 	lea    0x9d6(%r14),%rax
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    6797:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    679e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    67a5:	4c 89 55 98          	mov    %r10,-0x68(%rbp)
    67a9:	48 8b 5d a0          	mov    -0x60(%rbp),%rbx

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    67ad:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    67b1:	4c 89 e2             	mov    %r12,%rdx
    67b4:	e8 00 00 00 00       	callq  67b9 <add_rename_dir+0x369>
    tlen = strlen(buf);
    67b9:	4c 89 65 a8          	mov    %r12,-0x58(%rbp)
    67bd:	4c 89 e7             	mov    %r12,%rdi
    67c0:	31 c0                	xor    %eax,%eax
    67c2:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    67c6:	4c 89 e6             	mov    %r12,%rsi
    67c9:	f2 ae                	repnz scas %es:(%rdi),%al
    memcpy(tem, buf, tlen);
    67cb:	49 8d be d6 09 00 00 	lea    0x9d6(%r14),%rdi
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    tlen = strlen(buf);
    67d2:	48 f7 d1             	not    %rcx
    67d5:	48 89 c8             	mov    %rcx,%rax
    67d8:	48 83 e8 01          	sub    $0x1,%rax
    67dc:	49 89 c4             	mov    %rax,%r12
    memcpy(tem, buf, tlen);
    67df:	48 89 c2             	mov    %rax,%rdx
    67e2:	e8 00 00 00 00       	callq  67e7 <add_rename_dir+0x397>
    tem[tlen]='\0';
    67e7:	4c 89 e0             	mov    %r12,%rax
    67ea:	43 c6 84 26 d6 09 00 	movb   $0x0,0x9d6(%r14,%r12,1)
    67f1:	00 00 
    67f3:	4c 8b 55 98          	mov    -0x68(%rbp),%r10
    67f7:	4c 8b 65 b0          	mov    -0x50(%rbp),%r12
    67fb:	49 89 c6             	mov    %rax,%r14
    67fe:	4c 89 6d a0          	mov    %r13,-0x60(%rbp)
    do{
        ppath = strrchr(tem, '/');
    6802:	be 2f 00 00 00       	mov    $0x2f,%esi
    6807:	4c 89 e7             	mov    %r12,%rdi
    680a:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
    680e:	e8 00 00 00 00       	callq  6813 <add_rename_dir+0x3c3>
    6813:	49 89 c5             	mov    %rax,%r13
        plen = strlen(ppath);
    6816:	48 89 c7             	mov    %rax,%rdi
    6819:	e8 00 00 00 00       	callq  681e <add_rename_dir+0x3ce>
        phlen = tlen - plen;
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    681e:	4c 89 ee             	mov    %r13,%rsi
    6821:	48 89 df             	mov    %rbx,%rdi
    memcpy(tem, buf, tlen);
    tem[tlen]='\0';
    do{
        ppath = strrchr(tem, '/');
        plen = strlen(ppath);
        phlen = tlen - plen;
    6824:	49 29 c6             	sub    %rax,%r14
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    6827:	e8 00 00 00 00       	callq  682c <add_rename_dir+0x3dc>
        memcpy(tem, buf, tlen);
    682c:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    6830:	4c 89 e7             	mov    %r12,%rdi
    6833:	4c 89 f2             	mov    %r14,%rdx
    6836:	e8 00 00 00 00       	callq  683b <add_rename_dir+0x3eb>
        tem[tlen]='\0';
        if(!strcmp(tem,"/"))
    683b:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
        memcpy(tem, buf, tlen);
        tem[tlen]='\0';
    683f:	43 c6 04 34 00       	movb   $0x0,(%r12,%r14,1)
        if(!strcmp(tem,"/"))
    6844:	b9 02 00 00 00       	mov    $0x2,%ecx
    6849:	4c 89 e6             	mov    %r12,%rsi
    684c:	4c 89 d7             	mov    %r10,%rdi
    684f:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    6851:	75 af                	jne    6802 <add_rename_dir+0x3b2>
            break;
    }while(1);

    //BUG_ON(strlen(ph)==1023);
    nova_dbg("%s ful ph is %s sbi is %s",__func__,ph, sbi->ph_f);
    6853:	48 89 d9             	mov    %rbx,%rcx
    6856:	48 89 da             	mov    %rbx,%rdx
    6859:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    6860:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    6867:	4c 8b 6d a0          	mov    -0x60(%rbp),%r13
    686b:	e8 00 00 00 00       	callq  6870 <add_rename_dir+0x420>
    //BUG_ON(ph==NULL);
    
    mntput(vfsmnt);
    6870:	4c 89 ff             	mov    %r15,%rdi
    6873:	e8 00 00 00 00       	callq  6878 <add_rename_dir+0x428>
    6878:	e9 68 fe ff ff       	jmpq   66e5 <add_rename_dir+0x295>
    687d:	0f 1f 00             	nopl   (%rax)

0000000000006880 <__rename_dir_direntry>:
/*rename_s 是父文件夹是否变化的标志
 * 0不变化父文件夹
 * ch_link inc or dec links
 * not decided 标记log*/
int __rename_dir_direntry(struct dentry *old_dentry, struct dentry *new_dentry)
{ 
    6880:	e8 00 00 00 00       	callq  6885 <__rename_dir_direntry+0x5>
    6885:	55                   	push   %rbp
    6886:	48 89 e5             	mov    %rsp,%rbp
    6889:	41 57                	push   %r15
    688b:	41 56                	push   %r14
    688d:	41 55                	push   %r13
    688f:	41 54                	push   %r12
    6891:	49 89 fd             	mov    %rdi,%r13
    6894:	53                   	push   %rbx
    6895:	48 83 ec 50          	sub    $0x50,%rsp
    struct super_block *sb = old_dentry->d_sb;
    6899:	4c 8b 77 68          	mov    0x68(%rdi),%r14
/*rename_s 是父文件夹是否变化的标志
 * 0不变化父文件夹
 * ch_link inc or dec links
 * not decided 标记log*/
int __rename_dir_direntry(struct dentry *old_dentry, struct dentry *new_dentry)
{ 
    689d:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
    68a1:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    68a8:	00 00 
    68aa:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    68ae:	31 c0                	xor    %eax,%eax
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    68b0:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
{ 
    struct super_block *sb = old_dentry->d_sb;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dafs_dentry *old_de;
    struct dzt_entry_info *ch_ei, *old_ei;
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    68b7:	49 8b 86 b0 03 00 00 	mov    0x3b0(%r14),%rax
    68be:	48 8b 80 d8 0d 00 00 	mov    0xdd8(%rax),%rax
    68c5:	48 89 45 90          	mov    %rax,-0x70(%rbp)
}

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
    68c9:	48 8b 47 18          	mov    0x18(%rdi),%rax
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    68cd:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
    68d4:	48 8b 40 30          	mov    0x30(%rax),%rax
    68d8:	48 8b 58 28          	mov    0x28(%rax),%rbx
    68dc:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    68e3:	00 00 
    struct nova_sb_info *sbi = NOVA_SB(sb);
    char *ph, *buf, *tem, *ppath;
    //char *buf = NULL, *ppath=NULL, *tem=NULL;
    struct fs_struct *fs = current->fs;
    68e5:	4c 8b a0 30 06 00 00 	mov    0x630(%rax),%r12
    68ec:	4c 8b bb b0 03 00 00 	mov    0x3b0(%rbx),%r15
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    68f3:	e8 00 00 00 00       	callq  68f8 <__rename_dir_direntry+0x78>
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    68f8:	48 85 db             	test   %rbx,%rbx
    68fb:	0f 84 13 03 00 00    	je     6c14 <__rename_dir_direntry+0x394>
    BUG_ON(sbi==NULL);
    6901:	4d 85 ff             	test   %r15,%r15
    6904:	0f 84 0c 03 00 00    	je     6c16 <__rename_dir_direntry+0x396>
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    690a:	49 8d 7c 24 04       	lea    0x4(%r12),%rdi
    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    690f:	41 c6 87 d8 01 00 00 	movb   $0x0,0x1d8(%r15)
    6916:	00 
    buf[0]='\0';
    6917:	41 c6 87 d7 05 00 00 	movb   $0x0,0x5d7(%r15)
    691e:	00 
    tem[0]='\0';
    691f:	41 c6 87 d6 09 00 00 	movb   $0x0,0x9d6(%r15)
    6926:	00 
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    6927:	49 8d 9f d8 01 00 00 	lea    0x1d8(%r15),%rbx
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    692e:	e8 00 00 00 00       	callq  6933 <__rename_dir_direntry+0xb3>
    vfsmnt = mntget(fs->pwd.mnt);
    6933:	49 8b 7c 24 28       	mov    0x28(%r12),%rdi
    6938:	e8 00 00 00 00       	callq  693d <__rename_dir_direntry+0xbd>
    if(!vfsmnt){
    693d:	48 85 c0             	test   %rax,%rax
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    6940:	49 89 c1             	mov    %rax,%r9
    if(!vfsmnt){
    6943:	0f 84 49 04 00 00    	je     6d92 <__rename_dir_direntry+0x512>
    6949:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
    694e:	f0 41 0f c1 44 24 04 	lock xadd %eax,0x4(%r12)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
    6955:	49 8b 75 28          	mov    0x28(%r13),%rsi
    6959:	49 c7 c2 00 00 00 00 	mov    $0x0,%r10
    6960:	b9 02 00 00 00       	mov    $0x2,%ecx
    6965:	4c 89 d7             	mov    %r10,%rdi
    6968:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    696a:	0f 85 af 02 00 00    	jne    6c1f <__rename_dir_direntry+0x39f>
        memcpy(buf,"/",1);
        buf[1]='\0';
    }else{
        //nova_dbg("%s root dentry",__func__);
        memcpy(ph, "/", 1);
    6970:	41 c6 87 d8 01 00 00 	movb   $0x2f,0x1d8(%r15)
    6977:	2f 
        ph[1]='\0';
    6978:	41 c6 87 d9 01 00 00 	movb   $0x0,0x1d9(%r15)
    697f:	00 

    //nova_dbg("%s start",__func__);
    ph = get_dentry_path(old_dentry, 0);
    //nova_dbg("strictly full name is %s", ph);
    //nova_dbg("strictly full name length is %llu", strlen(ph));
    phname = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    6980:	48 89 df             	mov    %rbx,%rdi
    6983:	e8 00 00 00 00       	callq  6988 <__rename_dir_direntry+0x108>
    6988:	48 8d 78 01          	lea    0x1(%rax),%rdi
    698c:	be d0 80 00 00       	mov    $0x80d0,%esi
    6991:	e8 00 00 00 00       	callq  6996 <__rename_dir_direntry+0x116>
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    6996:	48 89 df             	mov    %rbx,%rdi
    6999:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    699d:	e8 00 00 00 00       	callq  69a2 <__rename_dir_direntry+0x122>
    69a2:	48 8d 78 01          	lea    0x1(%rax),%rdi
    69a6:	be d0 80 00 00       	mov    $0x80d0,%esi
    69ab:	e8 00 00 00 00       	callq  69b0 <__rename_dir_direntry+0x130>
    69b0:	49 89 c4             	mov    %rax,%r12
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    69b3:	49 8b 86 b0 03 00 00 	mov    0x3b0(%r14),%rax
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    69ba:	48 89 da             	mov    %rbx,%rdx
    69bd:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    69c4:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    69cb:	48 8b 80 d8 0d 00 00 	mov    0xdd8(%rax),%rax
    69d2:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    69d6:	e8 00 00 00 00       	callq  69db <__rename_dir_direntry+0x15b>
    tlen = strlen(phstr);
    69db:	48 89 df             	mov    %rbx,%rdi
    69de:	e8 00 00 00 00       	callq  69e3 <__rename_dir_direntry+0x163>
    nova_dbg("%s length is %llu", __func__, tlen);
    69e3:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    tlen = strlen(phstr);
    69ea:	49 89 c7             	mov    %rax,%r15
    nova_dbg("%s length is %llu", __func__, tlen);
    69ed:	48 89 c2             	mov    %rax,%rdx
    69f0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    69f7:	e8 00 00 00 00       	callq  69fc <__rename_dir_direntry+0x17c>
    memcpy(phs, phstr, tlen);
    69fc:	4c 89 fa             	mov    %r15,%rdx
    69ff:	48 89 de             	mov    %rbx,%rsi
    6a02:	4c 89 e7             	mov    %r12,%rdi
    6a05:	e8 00 00 00 00       	callq  6a0a <__rename_dir_direntry+0x18a>
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    6a0a:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi

    nova_dbg("%s start %s",__func__,phstr);
    tlen = strlen(phstr);
    nova_dbg("%s length is %llu", __func__, tlen);
    memcpy(phs, phstr, tlen);
    phs[tlen]='\0';
    6a0e:	43 c6 04 3c 00       	movb   $0x0,(%r12,%r15,1)
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    6a13:	be 2f 00 00 00       	mov    $0x2f,%esi
            return dzt_ei;
        }
    }while(1);
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    6a18:	41 c6 04 24 2f       	movb   $0x2f,(%r12)
    phs[1]='\0';
    6a1d:	41 c6 44 24 01 00    	movb   $0x0,0x1(%r12)
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    6a23:	e8 00 00 00 00       	callq  6a28 <__rename_dir_direntry+0x1a8>
    if(!dzt_ei){
    6a28:	48 85 c0             	test   %rax,%rax
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    6a2b:	49 89 c7             	mov    %rax,%r15
    if(!dzt_ei){
    6a2e:	0f 84 59 03 00 00    	je     6d8d <__rename_dir_direntry+0x50d>
    //nova_dbg("strictly full name is %s", ph);
    //nova_dbg("strictly full name length is %llu", strlen(ph));
    phname = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    old_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    6a34:	48 8b 40 10          	mov    0x10(%rax),%rax
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    6a38:	49 8b 96 b0 03 00 00 	mov    0x3b0(%r14),%rdx
    phlen = strlen(phn);
    6a3f:	4c 89 e7             	mov    %r12,%rdi
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    6a42:	48 89 c6             	mov    %rax,%rsi
    6a45:	48 03 72 18          	add    0x18(%rdx),%rsi
    6a49:	48 85 c0             	test   %rax,%rax
    6a4c:	b8 00 00 00 00       	mov    $0x0,%eax
    6a51:	48 0f 45 c6          	cmovne %rsi,%rax
    6a55:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    6a59:	e8 00 00 00 00       	callq  6a5e <__rename_dir_direntry+0x1de>
    dzt_eno = old_ei->dzt_eno;
    if(phlen==1){
    6a5e:	48 83 f8 01          	cmp    $0x1,%rax
    6a62:	0f 84 1e 01 00 00    	je     6b86 <__rename_dir_direntry+0x306>
        slen = strlen(ph);
        memcpy(phname, ph, slen);
        phname[slen] = '\0';
    } else {
        flen = strlen(ph)-phlen;
    6a68:	48 89 df             	mov    %rbx,%rdi
    6a6b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    6a6f:	e8 00 00 00 00       	callq  6a74 <__rename_dir_direntry+0x1f4>
    6a74:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
    6a78:	48 29 f0             	sub    %rsi,%rax
        memcpy(phname, ph+phlen, flen);
    6a7b:	48 01 de             	add    %rbx,%rsi
    6a7e:	48 89 c2             	mov    %rax,%rdx
    6a81:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    6a85:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    6a89:	e8 00 00 00 00       	callq  6a8e <__rename_dir_direntry+0x20e>
        phname[flen] = '\0';
    6a8e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    6a92:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
    6a96:	c6 04 08 00          	movb   $0x0,(%rax,%rcx,1)
    }
    ph_hash = BKDRHash(phname, strlen(phname));
    6a9a:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    6a9e:	e8 00 00 00 00       	callq  6aa3 <__rename_dir_direntry+0x223>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    6aa3:	85 c0                	test   %eax,%eax
    6aa5:	0f 8e 6d 01 00 00    	jle    6c18 <__rename_dir_direntry+0x398>
    6aab:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    6aaf:	83 e8 01             	sub    $0x1,%eax
    6ab2:	31 d2                	xor    %edx,%edx
    6ab4:	48 8d 74 07 01       	lea    0x1(%rdi,%rax,1),%rsi
    6ab9:	48 89 f9             	mov    %rdi,%rcx
		hash = hash * seed + (*str++);
    6abc:	48 89 d0             	mov    %rdx,%rax
    6abf:	48 83 c1 01          	add    $0x1,%rcx
    6ac3:	48 c1 e0 05          	shl    $0x5,%rax
    6ac7:	48 29 d0             	sub    %rdx,%rax
    6aca:	48 89 c2             	mov    %rax,%rdx
    6acd:	48 0f be 41 ff       	movsbq -0x1(%rcx),%rax
    6ad2:	48 01 c2             	add    %rax,%rdx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    6ad5:	48 39 f1             	cmp    %rsi,%rcx
    6ad8:	75 e2                	jne    6abc <__rename_dir_direntry+0x23c>
    ht_addr = old_ei->ht_head;
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    6ada:	49 8b 77 18          	mov    0x18(%r15),%rsi
    6ade:	4c 8d 45 bc          	lea    -0x44(%rbp),%r8
    6ae2:	b9 01 00 00 00       	mov    $0x1,%ecx
    6ae7:	4c 89 f7             	mov    %r14,%rdi
    6aea:	e8 00 00 00 00       	callq  6aef <__rename_dir_direntry+0x26f>
    6aef:	89 c2                	mov    %eax,%edx
    struct dafs_zone_entry *dafs_ze;
    char *ph, *phname, *phn;
    u32 dzt_eno, de_pos,slen;
    u64 old_hn, new_hn, root_len;
    u64 ph_hash, ht_addr, flen, phlen;
    int err = -ENOENT;
    6af1:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        phname[flen] = '\0';
    }
    ph_hash = BKDRHash(phname, strlen(phname));
    ht_addr = old_ei->ht_head;
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    if(!ret){
    6af6:	85 d2                	test   %edx,%edx
    6af8:	74 60                	je     6b5a <__rename_dir_direntry+0x2da>
        //nova_dbg("not found dentry in nvm");
        goto OUT;
    }
    old_de = &dafs_ze->dentry[de_pos];
    6afa:	8b 45 bc             	mov    -0x44(%rbp),%eax
    kfree(phname);
    6afd:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    ret = lookup_in_hashtable(sb, ht_addr, ph_hash, 1, &de_pos);
    if(!ret){
        //nova_dbg("not found dentry in nvm");
        goto OUT;
    }
    old_de = &dafs_ze->dentry[de_pos];
    6b01:	4c 8d b0 81 00 00 00 	lea    0x81(%rax),%r14
    6b08:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    6b0c:	49 c1 e6 07          	shl    $0x7,%r14
    6b10:	4c 03 75 a8          	add    -0x58(%rbp),%r14
    kfree(phname);
    6b14:	e8 00 00 00 00       	callq  6b19 <__rename_dir_direntry+0x299>
    kfree(ph);
    6b19:	48 89 df             	mov    %rbx,%rdi
    6b1c:	e8 00 00 00 00       	callq  6b21 <__rename_dir_direntry+0x2a1>
    kfree(phn);
    6b21:	4c 89 e7             	mov    %r12,%rdi
    6b24:	e8 00 00 00 00       	callq  6b29 <__rename_dir_direntry+0x2a9>
    6b29:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    6b2d:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
    6b31:	48 c1 e0 07          	shl    $0x7,%rax
    6b35:	4c 8d 24 03          	lea    (%rbx,%rax,1),%r12
    //old_de = dafs_find_direntry(sb, old_dentry,0,0);
    //dz_no = le64_to_cpu(old_de->zone_no);
    
    if(old_de->file_type == ROOT_DIRECTORY){
    6b39:	41 80 bc 24 82 40 00 	cmpb   $0x2,0x4082(%r12)
    6b40:	00 02 
    6b42:	74 5b                	je     6b9f <__rename_dir_direntry+0x31f>
        old_de->file_type = NORMAL_FILE;
        err = dafs_remove_dentry(old_dentry);

    } else {
        
        err = add_rename_dir(old_dentry, new_dentry, old_de, old_ei); 
    6b44:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
    6b48:	4c 89 f9             	mov    %r15,%rcx
    6b4b:	4c 89 f2             	mov    %r14,%rdx
    6b4e:	4c 89 ef             	mov    %r13,%rdi
    6b51:	e8 00 00 00 00       	callq  6b56 <__rename_dir_direntry+0x2d6>
        if(err)
    6b56:	85 c0                	test   %eax,%eax
    6b58:	74 22                	je     6b7c <__rename_dir_direntry+0x2fc>
            return err;
        err = dafs_remove_dentry(old_dentry);
    }
OUT:
   return err;
}
    6b5a:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    6b5e:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    6b65:	00 00 
    6b67:	0f 85 1b 02 00 00    	jne    6d88 <__rename_dir_direntry+0x508>
    6b6d:	48 83 c4 50          	add    $0x50,%rsp
    6b71:	5b                   	pop    %rbx
    6b72:	41 5c                	pop    %r12
    6b74:	41 5d                	pop    %r13
    6b76:	41 5e                	pop    %r14
    6b78:	41 5f                	pop    %r15
    6b7a:	5d                   	pop    %rbp
    6b7b:	c3                   	retq   
    } else {
        
        err = add_rename_dir(old_dentry, new_dentry, old_de, old_ei); 
        if(err)
            return err;
        err = dafs_remove_dentry(old_dentry);
    6b7c:	4c 89 ef             	mov    %r13,%rdi
    6b7f:	e8 00 00 00 00       	callq  6b84 <__rename_dir_direntry+0x304>
    6b84:	eb d4                	jmp    6b5a <__rename_dir_direntry+0x2da>
    old_ei = find_dzt(sb, ph, phn);
    dafs_ze = (struct dafs_zone_entry *)nova_get_block(sb, old_ei->dz_addr);
    phlen = strlen(phn);
    dzt_eno = old_ei->dzt_eno;
    if(phlen==1){
        slen = strlen(ph);
    6b86:	48 89 df             	mov    %rbx,%rdi
    6b89:	e8 00 00 00 00       	callq  6b8e <__rename_dir_direntry+0x30e>
    6b8e:	89 c1                	mov    %eax,%ecx
        memcpy(phname, ph, slen);
    6b90:	48 89 de             	mov    %rbx,%rsi
    6b93:	48 89 ca             	mov    %rcx,%rdx
    6b96:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
    6b9a:	e9 e6 fe ff ff       	jmpq   6a85 <__rename_dir_direntry+0x205>
    //old_de = dafs_find_direntry(sb, old_dentry,0,0);
    //dz_no = le64_to_cpu(old_de->zone_no);
    
    if(old_de->file_type == ROOT_DIRECTORY){
        old_hn = le64_to_cpu(old_de->hname);
        ch_ei = radix_tree_delete(&dzt_m->dzt_root, old_hn);
    6b9f:	49 8b b4 24 a8 40 00 	mov    0x40a8(%r12),%rsi
    6ba6:	00 
    6ba7:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
    6bab:	e8 00 00 00 00       	callq  6bb0 <__rename_dir_direntry+0x330>
        err = add_rename_zone_dir(new_dentry, old_de, old_ei, &new_hn, &root_len);
    6bb0:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    6bb4:	4c 8d 45 c8          	lea    -0x38(%rbp),%r8
    6bb8:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
    6bbc:	4c 89 fa             	mov    %r15,%rdx
    6bbf:	4c 89 f6             	mov    %r14,%rsi
    //old_de = dafs_find_direntry(sb, old_dentry,0,0);
    //dz_no = le64_to_cpu(old_de->zone_no);
    
    if(old_de->file_type == ROOT_DIRECTORY){
        old_hn = le64_to_cpu(old_de->hname);
        ch_ei = radix_tree_delete(&dzt_m->dzt_root, old_hn);
    6bc2:	48 89 c3             	mov    %rax,%rbx
        err = add_rename_zone_dir(new_dentry, old_de, old_ei, &new_hn, &root_len);
    6bc5:	e8 00 00 00 00       	callq  6bca <__rename_dir_direntry+0x34a>
        /*防止zone被删除*/
        if(err)
    6bca:	85 c0                	test   %eax,%eax
    6bcc:	75 8c                	jne    6b5a <__rename_dir_direntry+0x2da>
            return err;
        ch_ei->root_len = root_len;
        ch_ei->hash_name = new_hn;
    6bce:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
        ch_ei = radix_tree_delete(&dzt_m->dzt_root, old_hn);
        err = add_rename_zone_dir(new_dentry, old_de, old_ei, &new_hn, &root_len);
        /*防止zone被删除*/
        if(err)
            return err;
        ch_ei->root_len = root_len;
    6bd2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
        ch_ei->hash_name = new_hn;
        /*update ei hashname, root len and set dirty bit*/
        radix_tree_insert(&dzt_m->dzt_root, new_hn, ch_ei);
    6bd6:	48 89 da             	mov    %rbx,%rdx
        err = add_rename_zone_dir(new_dentry, old_de, old_ei, &new_hn, &root_len);
        /*防止zone被删除*/
        if(err)
            return err;
        ch_ei->root_len = root_len;
        ch_ei->hash_name = new_hn;
    6bd9:	48 89 73 30          	mov    %rsi,0x30(%rbx)
        ch_ei = radix_tree_delete(&dzt_m->dzt_root, old_hn);
        err = add_rename_zone_dir(new_dentry, old_de, old_ei, &new_hn, &root_len);
        /*防止zone被删除*/
        if(err)
            return err;
        ch_ei->root_len = root_len;
    6bdd:	48 89 43 28          	mov    %rax,0x28(%rbx)
        ch_ei->hash_name = new_hn;
        /*update ei hashname, root len and set dirty bit*/
        radix_tree_insert(&dzt_m->dzt_root, new_hn, ch_ei);
    6be1:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
    6be5:	48 89 df             	mov    %rbx,%rdi
    6be8:	e8 00 00 00 00       	callq  6bed <__rename_dir_direntry+0x36d>
        radix_tree_tag_set(&dzt_m->dzt_root, new_hn, 1);
    6bed:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    6bf1:	48 89 df             	mov    %rbx,%rdi
    6bf4:	ba 01 00 00 00       	mov    $0x1,%edx
    6bf9:	e8 00 00 00 00       	callq  6bfe <__rename_dir_direntry+0x37e>

        old_de->file_type = NORMAL_FILE;
    6bfe:	41 c6 84 24 82 40 00 	movb   $0x0,0x4082(%r12)
    6c05:	00 00 
        err = dafs_remove_dentry(old_dentry);
    6c07:	4c 89 ef             	mov    %r13,%rdi
    6c0a:	e8 00 00 00 00       	callq  6c0f <__rename_dir_direntry+0x38f>
    6c0f:	e9 46 ff ff ff       	jmpq   6b5a <__rename_dir_direntry+0x2da>
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    6c14:	0f 0b                	ud2    
    BUG_ON(sbi==NULL);
    6c16:	0f 0b                	ud2    
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    6c18:	31 d2                	xor    %edx,%edx
    6c1a:	e9 bb fe ff ff       	jmpq   6ada <__rename_dir_direntry+0x25a>
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    6c1f:	4d 8d a7 d7 05 00 00 	lea    0x5d7(%r15),%r12
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
        memcpy(buf,"/",1);
    6c26:	41 c6 87 d7 05 00 00 	movb   $0x2f,0x5d7(%r15)
    6c2d:	2f 
        buf[1]='\0';
    6c2e:	41 c6 87 d8 05 00 00 	movb   $0x0,0x5d8(%r15)
    6c35:	00 
    }
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    6c36:	4d 89 e8             	mov    %r13,%r8
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    6c39:	4c 89 e7             	mov    %r12,%rdi
    6c3c:	4c 89 55 98          	mov    %r10,-0x68(%rbp)
    6c40:	4c 89 4d a8          	mov    %r9,-0x58(%rbp)
    6c44:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
    6c48:	e8 00 00 00 00       	callq  6c4d <__rename_dir_direntry+0x3cd>
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    6c4d:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    6c51:	ba 2f 00 00 00       	mov    $0x2f,%edx
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    6c56:	49 8d 7c 04 01       	lea    0x1(%r12,%rax,1),%rdi
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    6c5b:	66 41 89 14 04       	mov    %dx,(%r12,%rax,1)
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    6c60:	49 8b 70 28          	mov    0x28(%r8),%rsi
    6c64:	e8 00 00 00 00       	callq  6c69 <__rename_dir_direntry+0x3e9>
        p_dentry = tem_dentry->d_parent;
    6c69:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
        //plen = strlen(buf);
        //buf[plen]='\0';
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
    6c6d:	4c 8b 55 98          	mov    -0x68(%rbp),%r10
    6c71:	b9 02 00 00 00       	mov    $0x2,%ecx
    6c76:	4c 8b 4d a8          	mov    -0x58(%rbp),%r9
        strcat(buf, "/");
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
        p_dentry = tem_dentry->d_parent;
    6c7a:	4d 8b 40 18          	mov    0x18(%r8),%r8
        //plen = strlen(buf);
        //buf[plen]='\0';
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
    6c7e:	4c 89 d7             	mov    %r10,%rdi
    6c81:	49 8b 70 28          	mov    0x28(%r8),%rsi
    6c85:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    6c87:	75 b0                	jne    6c39 <__rename_dir_direntry+0x3b9>
    6c89:	49 8b 40 30          	mov    0x30(%r8),%rax
    6c8d:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
    6c92:	75 a5                	jne    6c39 <__rename_dir_direntry+0x3b9>

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    6c94:	49 8d 87 d6 09 00 00 	lea    0x9d6(%r15),%rax
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    6c9b:	4c 89 e2             	mov    %r12,%rdx
    6c9e:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    6ca5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    6cac:	4c 89 55 88          	mov    %r10,-0x78(%rbp)
    6cb0:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    6cb4:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    6cb8:	e8 00 00 00 00       	callq  6cbd <__rename_dir_direntry+0x43d>
    tlen = strlen(buf);
    6cbd:	31 c0                	xor    %eax,%eax
    6cbf:	4c 89 e7             	mov    %r12,%rdi
    6cc2:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    6cc6:	f2 ae                	repnz scas %es:(%rdi),%al
    memcpy(tem, buf, tlen);
    6cc8:	49 8d bf d6 09 00 00 	lea    0x9d6(%r15),%rdi
    6ccf:	4c 89 e6             	mov    %r12,%rsi
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    tlen = strlen(buf);
    6cd2:	48 f7 d1             	not    %rcx
    6cd5:	48 89 c8             	mov    %rcx,%rax
    6cd8:	48 83 e8 01          	sub    $0x1,%rax
    memcpy(tem, buf, tlen);
    6cdc:	48 89 c2             	mov    %rax,%rdx
    6cdf:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    6ce3:	e8 00 00 00 00       	callq  6ce8 <__rename_dir_direntry+0x468>
    tem[tlen]='\0';
    6ce8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    6cec:	4c 8b 55 88          	mov    -0x78(%rbp),%r10
    6cf0:	4c 8b 4d 98          	mov    -0x68(%rbp),%r9
    6cf4:	41 c6 84 07 d6 09 00 	movb   $0x0,0x9d6(%r15,%rax,1)
    6cfb:	00 00 
    do{
        ppath = strrchr(tem, '/');
    6cfd:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    6d01:	be 2f 00 00 00       	mov    $0x2f,%esi
    6d06:	4c 89 55 88          	mov    %r10,-0x78(%rbp)
    6d0a:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
    6d0e:	e8 00 00 00 00       	callq  6d13 <__rename_dir_direntry+0x493>
    6d13:	49 89 c7             	mov    %rax,%r15
        plen = strlen(ppath);
    6d16:	48 89 c7             	mov    %rax,%rdi
    6d19:	e8 00 00 00 00       	callq  6d1e <__rename_dir_direntry+0x49e>
        phlen = tlen - plen;
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    6d1e:	4c 89 fe             	mov    %r15,%rsi
    6d21:	48 89 df             	mov    %rbx,%rdi
    memcpy(tem, buf, tlen);
    tem[tlen]='\0';
    do{
        ppath = strrchr(tem, '/');
        plen = strlen(ppath);
        phlen = tlen - plen;
    6d24:	48 29 45 a8          	sub    %rax,-0x58(%rbp)
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    6d28:	e8 00 00 00 00       	callq  6d2d <__rename_dir_direntry+0x4ad>
        memcpy(tem, buf, tlen);
    6d2d:	4c 8b 7d a8          	mov    -0x58(%rbp),%r15
    6d31:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    6d35:	4c 89 e6             	mov    %r12,%rsi
    6d38:	4c 89 fa             	mov    %r15,%rdx
    6d3b:	e8 00 00 00 00       	callq  6d40 <__rename_dir_direntry+0x4c0>
        tem[tlen]='\0';
    6d40:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
        if(!strcmp(tem,"/"))
    6d44:	4c 8b 55 88          	mov    -0x78(%rbp),%r10
    6d48:	b9 02 00 00 00       	mov    $0x2,%ecx
    6d4d:	4c 8b 4d 98          	mov    -0x68(%rbp),%r9
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
        memcpy(tem, buf, tlen);
        tem[tlen]='\0';
    6d51:	42 c6 04 3e 00       	movb   $0x0,(%rsi,%r15,1)
        if(!strcmp(tem,"/"))
    6d56:	4c 89 d7             	mov    %r10,%rdi
    6d59:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    6d5b:	75 a0                	jne    6cfd <__rename_dir_direntry+0x47d>
            break;
    }while(1);

    //BUG_ON(strlen(ph)==1023);
    nova_dbg("%s ful ph is %s sbi is %s",__func__,ph, sbi->ph_f);
    6d5d:	48 89 d9             	mov    %rbx,%rcx
    6d60:	48 89 da             	mov    %rbx,%rdx
    6d63:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    6d6a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    6d71:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
    6d75:	e8 00 00 00 00       	callq  6d7a <__rename_dir_direntry+0x4fa>
    //BUG_ON(ph==NULL);
    
    mntput(vfsmnt);
    6d7a:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9
    6d7e:	4c 89 cf             	mov    %r9,%rdi
    6d81:	e8 00 00 00 00       	callq  6d86 <__rename_dir_direntry+0x506>
    6d86:	eb 16                	jmp    6d9e <__rename_dir_direntry+0x51e>
            return err;
        err = dafs_remove_dentry(old_dentry);
    }
OUT:
   return err;
}
    6d88:	e8 00 00 00 00       	callq  6d8d <__rename_dir_direntry+0x50d>
    6d8d:	e8 00 00 00 00       	callq  6d92 <__rename_dir_direntry+0x512>
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    if(!vfsmnt){
        nova_dbg("not find mnt");
    6d92:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    6d99:	e8 00 00 00 00       	callq  6d9e <__rename_dir_direntry+0x51e>
    
    //kfree(buf);
    //kfree(tem);
    //nova_dbg("dafs finish get dentry path");
ERR:
    nova_dbg("%s ful ph is %s len %llu, sbi %s ",__func__,ph, strlen(ph), sbi->ph_f);
    6d9e:	48 89 df             	mov    %rbx,%rdi
    6da1:	e8 00 00 00 00       	callq  6da6 <__rename_dir_direntry+0x526>
    6da6:	49 89 d8             	mov    %rbx,%r8
    6da9:	48 89 c1             	mov    %rax,%rcx
    6dac:	48 89 da             	mov    %rbx,%rdx
    6daf:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    6db6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    6dbd:	e8 00 00 00 00       	callq  6dc2 <__rename_dir_direntry+0x542>
    6dc2:	e9 b9 fb ff ff       	jmpq   6980 <__rename_dir_direntry+0x100>
    6dc7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    6dce:	00 00 

0000000000006dd0 <__rename_file_dentry>:
OUT:
   return err;
}

int __rename_file_dentry(struct dentry *old_dentry, struct dentry *new_dentry)
{
    6dd0:	e8 00 00 00 00       	callq  6dd5 <__rename_file_dentry+0x5>
    6dd5:	55                   	push   %rbp
    //u8 isr_sf;
    u64 temlen, phlen, flen;
    u64 hashname, par_hn, ino;
    int ret = 0;

    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);
    6dd6:	31 c9                	xor    %ecx,%ecx
    6dd8:	31 d2                	xor    %edx,%edx
OUT:
   return err;
}

int __rename_file_dentry(struct dentry *old_dentry, struct dentry *new_dentry)
{
    6dda:	48 89 e5             	mov    %rsp,%rbp
    6ddd:	41 57                	push   %r15
    6ddf:	41 56                	push   %r14
    6de1:	41 55                	push   %r13
    6de3:	41 54                	push   %r12
    6de5:	49 89 f5             	mov    %rsi,%r13
    6de8:	53                   	push   %rbx
    //u8 isr_sf;
    u64 temlen, phlen, flen;
    u64 hashname, par_hn, ino;
    int ret = 0;

    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);
    6de9:	48 89 fe             	mov    %rdi,%rsi
OUT:
   return err;
}

int __rename_file_dentry(struct dentry *old_dentry, struct dentry *new_dentry)
{
    6dec:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
    6df0:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    6df7:	00 00 
    6df9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    6dfd:	31 c0                	xor    %eax,%eax
    struct super_block *sb = old_dentry->d_sb;
    6dff:	48 8b 47 68          	mov    0x68(%rdi),%rax
    //u8 isr_sf;
    u64 temlen, phlen, flen;
    u64 hashname, par_hn, ino;
    int ret = 0;

    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);
    6e03:	48 89 c7             	mov    %rax,%rdi
   return err;
}

int __rename_file_dentry(struct dentry *old_dentry, struct dentry *new_dentry)
{
    struct super_block *sb = old_dentry->d_sb;
    6e06:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    //u8 isr_sf;
    u64 temlen, phlen, flen;
    u64 hashname, par_hn, ino;
    int ret = 0;

    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);
    6e0a:	e8 00 00 00 00       	callq  6e0f <__rename_file_dentry+0x3f>
    6e0f:	49 89 c7             	mov    %rax,%r15
}

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
    6e12:	49 8b 45 18          	mov    0x18(%r13),%rax
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    6e16:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    6e1d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi

/*get dentry path except filename*/
static inline char* get_dentry_path(const struct dentry *dentry, int ISREAD)
{
    struct inode *dir = dentry->d_parent->d_inode;
    struct super_block *sb = dir->i_sb;
    6e24:	48 8b 40 30          	mov    0x30(%rax),%rax
    6e28:	4c 8b 60 28          	mov    0x28(%rax),%r12
    6e2c:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    6e33:	00 00 
    struct nova_sb_info *sbi = NOVA_SB(sb);
    char *ph, *buf, *tem, *ppath;
    //char *buf = NULL, *ppath=NULL, *tem=NULL;
    struct fs_struct *fs = current->fs;
    6e35:	48 8b 98 30 06 00 00 	mov    0x630(%rax),%rbx
    6e3c:	4d 8b b4 24 b0 03 00 	mov    0x3b0(%r12),%r14
    6e43:	00 
    struct dentry *tem_dentry, *p_dentry = dentry->d_parent;
    struct dentry *rd;
    //u64 slen;
    u64 phlen,tlen,plen;

    nova_dbg("%s:start",__func__);
    6e44:	e8 00 00 00 00       	callq  6e49 <__rename_file_dentry+0x79>
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    6e49:	4d 85 e4             	test   %r12,%r12
    6e4c:	0f 84 9a 05 00 00    	je     73ec <__rename_file_dentry+0x61c>
    BUG_ON(sbi==NULL);
    6e52:	4d 85 f6             	test   %r14,%r14
    6e55:	0f 84 93 05 00 00    	je     73ee <__rename_file_dentry+0x61e>
    ph = &sbi->ph_f;
    6e5b:	49 8d 86 d8 01 00 00 	lea    0x1d8(%r14),%rax
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    6e62:	48 8d 7b 04          	lea    0x4(%rbx),%rdi
    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    6e66:	41 c6 86 d8 01 00 00 	movb   $0x0,0x1d8(%r14)
    6e6d:	00 
    buf[0]='\0';
    6e6e:	41 c6 86 d7 05 00 00 	movb   $0x0,0x5d7(%r14)
    6e75:	00 
    tem[0]='\0';
    6e76:	41 c6 86 d6 09 00 00 	movb   $0x0,0x9d6(%r14)
    6e7d:	00 
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    6e7e:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    6e82:	e8 00 00 00 00       	callq  6e87 <__rename_file_dentry+0xb7>
    vfsmnt = mntget(fs->pwd.mnt);
    6e87:	48 8b 7b 28          	mov    0x28(%rbx),%rdi
    6e8b:	e8 00 00 00 00       	callq  6e90 <__rename_file_dentry+0xc0>
    if(!vfsmnt){
    6e90:	48 85 c0             	test   %rax,%rax
    tem = &sbi->ph_name;
    ph[0]='\0';
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    6e93:	49 89 c0             	mov    %rax,%r8
    if(!vfsmnt){
    6e96:	0f 84 f2 06 00 00    	je     758e <__rename_file_dentry+0x7be>
    6e9c:	b8 00 ff ff ff       	mov    $0xffffff00,%eax
    6ea1:	f0 0f c1 43 04       	lock xadd %eax,0x4(%rbx)
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
    6ea6:	49 8b 75 28          	mov    0x28(%r13),%rsi
    6eaa:	49 c7 c2 00 00 00 00 	mov    $0x0,%r10
    6eb1:	b9 02 00 00 00       	mov    $0x2,%ecx
    6eb6:	4c 89 d7             	mov    %r10,%rdi
    6eb9:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    6ebb:	0f 85 7e 05 00 00    	jne    743f <__rename_file_dentry+0x66f>
        memcpy(buf,"/",1);
        buf[1]='\0';
    }else{
        //nova_dbg("%s root dentry",__func__);
        memcpy(ph, "/", 1);
    6ec1:	41 c6 86 d8 01 00 00 	movb   $0x2f,0x1d8(%r14)
    6ec8:	2f 
        ph[1]='\0';
    6ec9:	41 c6 86 d9 01 00 00 	movb   $0x0,0x1d9(%r14)
    6ed0:	00 
    o_de = dafs_find_direntry(sb, old_dentry, 0, 0);

    //nova_dbg("dafs start rename file dentry");

    ph = get_dentry_path(new_dentry,0);
    phname = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    6ed1:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
    6ed5:	48 89 df             	mov    %rbx,%rdi
    6ed8:	e8 00 00 00 00       	callq  6edd <__rename_file_dentry+0x10d>
    6edd:	48 8d 78 01          	lea    0x1(%rax),%rdi
    6ee1:	be d0 80 00 00       	mov    $0x80d0,%esi
    6ee6:	e8 00 00 00 00       	callq  6eeb <__rename_file_dentry+0x11b>
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    6eeb:	48 89 df             	mov    %rbx,%rdi
    6eee:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    6ef2:	e8 00 00 00 00       	callq  6ef7 <__rename_file_dentry+0x127>
    6ef7:	48 8d 78 01          	lea    0x1(%rax),%rdi
    6efb:	be d0 80 00 00       	mov    $0x80d0,%esi
    6f00:	e8 00 00 00 00       	callq  6f05 <__rename_file_dentry+0x135>
    6f05:	49 89 c6             	mov    %rax,%r14
    6f08:	48 89 45 98          	mov    %rax,-0x68(%rbp)
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    6f0c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    6f10:	48 89 da             	mov    %rbx,%rdx
    6f13:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    6f1a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
    6f21:	48 8b 80 b0 03 00 00 	mov    0x3b0(%rax),%rax
    6f28:	4c 8b a0 d8 0d 00 00 	mov    0xdd8(%rax),%r12
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    6f2f:	e8 00 00 00 00       	callq  6f34 <__rename_file_dentry+0x164>
    tlen = strlen(phstr);
    6f34:	48 89 df             	mov    %rbx,%rdi
    6f37:	48 89 5d b0          	mov    %rbx,-0x50(%rbp)
    6f3b:	e8 00 00 00 00       	callq  6f40 <__rename_file_dentry+0x170>
    nova_dbg("%s length is %llu", __func__, tlen);
    6f40:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    6f47:	48 89 c2             	mov    %rax,%rdx
    6f4a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    u64 hashname;
    u64 phlen, tlen;
    char *tem;

    nova_dbg("%s start %s",__func__,phstr);
    tlen = strlen(phstr);
    6f51:	48 89 c3             	mov    %rax,%rbx
    nova_dbg("%s length is %llu", __func__, tlen);
    6f54:	e8 00 00 00 00       	callq  6f59 <__rename_file_dentry+0x189>
    memcpy(phs, phstr, tlen);
    6f59:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    6f5d:	48 89 da             	mov    %rbx,%rdx
    6f60:	4c 89 f7             	mov    %r14,%rdi
    6f63:	e8 00 00 00 00       	callq  6f68 <__rename_file_dentry+0x198>
    phs[tlen]='\0';
    6f68:	41 c6 04 1e 00       	movb   $0x0,(%r14,%rbx,1)
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    6f6d:	be 2f 00 00 00       	mov    $0x2f,%esi
            return dzt_ei;
        }
    }while(1);
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    6f72:	41 c6 06 2f          	movb   $0x2f,(%r14)
    phs[1]='\0';
    6f76:	41 c6 46 01 00       	movb   $0x0,0x1(%r14)
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    6f7b:	4c 89 e7             	mov    %r12,%rdi
    6f7e:	e8 00 00 00 00       	callq  6f83 <__rename_file_dentry+0x1b3>
    if(!dzt_ei){
    6f83:	48 85 c0             	test   %rax,%rax
    */
    /*root dir*/
    memcpy(phs, "/", 1);
    phs[1]='\0';
    hashname = BKDRHash(phs ,1);
    dzt_ei = radix_tree_lookup(&dzt_m->dzt_root,hashname);
    6f86:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    if(!dzt_ei){
    6f8a:	0f 84 a5 04 00 00    	je     7435 <__rename_file_dentry+0x665>
 * nova_memunlock_super() before calling! */
static inline struct nova_super_block *nova_get_super(struct super_block *sb)
{
	struct nova_sb_info *sbi = NOVA_SB(sb);

	return (struct nova_super_block *)sbi->virt_addr;
    6f90:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
    ph = get_dentry_path(new_dentry,0);
    phname = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    6f94:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
    phlen = strlen(phn);
    6f98:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
    ph = get_dentry_path(new_dentry,0);
    phname = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    6f9c:	48 8b 40 10          	mov    0x10(%rax),%rax
    6fa0:	48 8b 93 b0 03 00 00 	mov    0x3b0(%rbx),%rdx
 * 得到了block的地址*/
static inline void *nova_get_block(struct super_block *sb, u64 block)
{
	struct nova_super_block *ps = nova_get_super(sb);

	return block ? ((void *)ps + block) : NULL;
    6fa7:	48 89 c3             	mov    %rax,%rbx
    6faa:	48 03 5a 18          	add    0x18(%rdx),%rbx
    6fae:	48 85 c0             	test   %rax,%rax
    6fb1:	b8 00 00 00 00       	mov    $0x0,%eax
    6fb6:	48 0f 45 c3          	cmovne %rbx,%rax
    6fba:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    phlen = strlen(phn);
    6fbe:	e8 00 00 00 00       	callq  6fc3 <__rename_file_dentry+0x1f3>
    if(phlen==1){
    6fc3:	48 83 f8 01          	cmp    $0x1,%rax
    phname = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    phn = kzalloc(sizeof(char)*(strlen(ph)+1), GFP_KERNEL);
    //memcpy(phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    phlen = strlen(phn);
    6fc7:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    if(phlen==1){
    6fcb:	0f 84 e9 03 00 00    	je     73ba <__rename_file_dentry+0x5ea>
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    6fd1:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
    6fd5:	48 89 df             	mov    %rbx,%rdi
    6fd8:	e8 00 00 00 00       	callq  6fdd <__rename_file_dentry+0x20d>
    6fdd:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
        memcpy(phname, ph+phlen, flen);
    6fe1:	4c 8b 75 90          	mov    -0x70(%rbp),%r14
    6fe5:	48 89 de             	mov    %rbx,%rsi
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    6fe8:	48 29 f8             	sub    %rdi,%rax
        memcpy(phname, ph+phlen, flen);
    6feb:	48 01 fe             	add    %rdi,%rsi
    6fee:	4c 89 f7             	mov    %r14,%rdi
    6ff1:	48 89 c3             	mov    %rax,%rbx
    6ff4:	48 89 c2             	mov    %rax,%rdx
    if(phlen==1){
        flen = strlen(ph);
        memcpy(phname, ph, flen);
        phname[flen]='\0';
    } else {
        flen = strlen(ph)-phlen;
    6ff7:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
        memcpy(phname, ph+phlen, flen);
    6ffe:	e8 00 00 00 00       	callq  7003 <__rename_file_dentry+0x233>
        phname[flen]='\0';
    7003:	41 c6 04 1e 00       	movb   $0x0,(%r14,%rbx,1)
    }
    make_zone_ptr(&z_p, n_ze);
    7008:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
    700c:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
    7010:	e8 00 00 00 00       	callq  7015 <__rename_file_dentry+0x245>
    while(bitpos<z_p->zone_max){
    7015:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    7019:	48 8b 78 08          	mov    0x8(%rax),%rdi
    701d:	48 85 ff             	test   %rdi,%rdi
    7020:	0f 84 02 04 00 00    	je     7428 <__rename_file_dentry+0x658>
    7026:	48 8b 30             	mov    (%rax),%rsi
    7029:	45 31 e4             	xor    %r12d,%r12d
    702c:	31 c9                	xor    %ecx,%ecx
    702e:	eb 02                	jmp    7032 <__rename_file_dentry+0x262>
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
            bitpos+=2;
    7030:	89 c1                	mov    %eax,%ecx

static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile("bt %2,%1\n\t"
    7032:	48 63 c1             	movslq %ecx,%rax
    7035:	48 0f a3 06          	bt     %rax,(%rsi)
    7039:	19 c0                	sbb    %eax,%eax
        memcpy(phname, ph+phlen, flen);
        phname[flen]='\0';
    }
    make_zone_ptr(&z_p, n_ze);
    while(bitpos<z_p->zone_max){
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
    703b:	85 c0                	test   %eax,%eax
    703d:	75 10                	jne    704f <__rename_file_dentry+0x27f>
    703f:	8d 59 01             	lea    0x1(%rcx),%ebx
    7042:	48 63 db             	movslq %ebx,%rbx
    7045:	48 0f a3 1e          	bt     %rbx,(%rsi)
    7049:	19 c0                	sbb    %eax,%eax
    704b:	85 c0                	test   %eax,%eax
    704d:	74 15                	je     7064 <__rename_file_dentry+0x294>
            bitpos+=2;
    704f:	8d 51 02             	lea    0x2(%rcx),%edx
            cur_pos++;
    7052:	41 83 c4 01          	add    $0x1,%r12d
        flen = strlen(ph)-phlen;
        memcpy(phname, ph+phlen, flen);
        phname[flen]='\0';
    }
    make_zone_ptr(&z_p, n_ze);
    while(bitpos<z_p->zone_max){
    7056:	48 39 fa             	cmp    %rdi,%rdx
        if(test_bit_le(bitpos, (void *)z_p->statemap)||test_bit_le(bitpos+1, (void *)z_p->statemap)){
            bitpos+=2;
    7059:	48 89 d0             	mov    %rdx,%rax
        flen = strlen(ph)-phlen;
        memcpy(phname, ph+phlen, flen);
        phname[flen]='\0';
    }
    make_zone_ptr(&z_p, n_ze);
    while(bitpos<z_p->zone_max){
    705c:	72 d2                	jb     7030 <__rename_file_dentry+0x260>
    705e:	8d 59 03             	lea    0x3(%rcx),%ebx
    7061:	48 63 db             	movslq %ebx,%rbx
    //pidir = nova_get_inode(sb, dir);
    //dir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;
    //de_len = DAFS_DIR_LEN(namelen + phlen); 

    /*get dentry on nvm*/
    dafs_de = &n_ze->dentry[cur_pos];
    7064:	44 89 e0             	mov    %r12d,%eax
    7067:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
    706b:	48 89 c2             	mov    %rax,%rdx
    706e:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    7072:	4c 8d 90 81 00 00 00 	lea    0x81(%rax),%r10
    7079:	48 c1 e2 07          	shl    $0x7,%rdx
    707d:	4c 8d 1c 16          	lea    (%rsi,%rdx,1),%r11
    7081:	49 c1 e2 07          	shl    $0x7,%r10
    7085:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
    708c:	4e 8d 34 16          	lea    (%rsi,%r10,1),%r14
    //memset(dafs_de, 0, sizeof(dafs_de));
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    7090:	41 c6 83 80 40 00 00 	movb   $0x6,0x4080(%r11)
    7097:	06 
    dafs_de->name_len = new_dentry->d_name.len;
    7098:	41 8b 45 24          	mov    0x24(%r13),%eax
    dafs_de->file_type = o_de->file_type;       //file_type是啥？ not decided

	dafs_de->links_count = o_de->links_count;
    709c:	4c 89 9d 78 ff ff ff 	mov    %r11,-0x88(%rbp)
    /*get dentry on nvm*/
    dafs_de = &n_ze->dentry[cur_pos];
    //memset(dafs_de, 0, sizeof(dafs_de));
    
    dafs_de->entry_type = DAFS_DIR_ENTRY;
    dafs_de->name_len = new_dentry->d_name.len;
    70a3:	41 88 83 81 40 00 00 	mov    %al,0x4081(%r11)
    dafs_de->file_type = o_de->file_type;       //file_type是啥？ not decided
    70aa:	41 0f b6 47 02       	movzbl 0x2(%r15),%eax
    70af:	41 88 83 82 40 00 00 	mov    %al,0x4082(%r11)

	dafs_de->links_count = o_de->links_count;
    70b6:	41 0f b7 47 06       	movzwl 0x6(%r15),%eax
    70bb:	66 41 89 83 86 40 00 	mov    %ax,0x4086(%r11)
    70c2:	00 

    //dafs_de->de_len = cpu_to_le16(de_len);  
    dafs_de->mtime = cpu_to_le32(CURRENT_TIME_SEC.tv_sec);
    70c3:	e8 00 00 00 00       	callq  70c8 <__rename_file_dentry+0x2f8>
    70c8:	4c 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11
    70cf:	41 89 83 88 40 00 00 	mov    %eax,0x4088(%r11)
    /*not root at first*/
    //dafs_de->isr_sf = o_de->isr_sf;
    dafs_de->ino = o_de->ino;
    70d6:	49 8b 47 18          	mov    0x18(%r15),%rax
    70da:	49 89 83 98 40 00 00 	mov    %rax,0x4098(%r11)
    
    dafs_de->size = o_de->size;
    70e1:	49 8b 47 20          	mov    0x20(%r15),%rax
    70e5:	49 89 83 a0 40 00 00 	mov    %rax,0x40a0(%r11)
     
    /*judge name len && set dentry name*/
    if(new_dentry->d_name.len <= SMALL_NAME_LEN){
    70ec:	41 83 7d 24 27       	cmpl   $0x27,0x24(%r13)
    70f1:	0f 86 95 01 00 00    	jbe    728c <__rename_file_dentry+0x4bc>
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,new_dentry->d_name.name,new_dentry->d_name.len);
        dafs_de->name[new_dentry->d_name.len] = '\0'; 

    } else {
        dafs_de->ext_flag = 1;
    70f7:	ba 01 00 00 00       	mov    $0x1,%edx
        ext_de_name(sb, n_ei, n_ze, z_p, cur_pos, new_dentry->d_name.len, new_dentry->d_name.name, 0);
    70fc:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    7100:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,new_dentry->d_name.name,new_dentry->d_name.len);
        dafs_de->name[new_dentry->d_name.len] = '\0'; 

    } else {
        dafs_de->ext_flag = 1;
    7104:	66 41 89 93 84 40 00 	mov    %dx,0x4084(%r11)
    710b:	00 
        ext_de_name(sb, n_ei, n_ze, z_p, cur_pos, new_dentry->d_name.len, new_dentry->d_name.name, 0);
    710c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%rsp)
    7113:	00 
    7114:	45 89 e0             	mov    %r12d,%r8d
    7117:	49 8b 45 28          	mov    0x28(%r13),%rax
    711b:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    711f:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,new_dentry->d_name.name,new_dentry->d_name.len);
        dafs_de->name[new_dentry->d_name.len] = '\0'; 

    } else {
        dafs_de->ext_flag = 1;
    7123:	4c 89 9d 78 ff ff ff 	mov    %r11,-0x88(%rbp)
        ext_de_name(sb, n_ei, n_ze, z_p, cur_pos, new_dentry->d_name.len, new_dentry->d_name.name, 0);
    712a:	48 89 04 24          	mov    %rax,(%rsp)
    712e:	45 8b 4d 24          	mov    0x24(%r13),%r9d
    7132:	e8 00 00 00 00       	callq  7137 <__rename_file_dentry+0x367>
    7137:	4c 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11
    }
    dafs_de->fname_len = cpu_to_le64(flen);
    713e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    7142:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
    7146:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
    714d:	48 c1 e0 07          	shl    $0x7,%rax
    7151:	48 01 f0             	add    %rsi,%rax
    7154:	48 89 b8 90 40 00 00 	mov    %rdi,0x4090(%rax)
    /*fulname is null for NORMAL_FILE*/
    dafs_de->ful_name.f_name[0]= '\0';
    715b:	c6 80 d8 40 00 00 00 	movb   $0x0,0x40d8(%rax)

    /*set isr_sf and par_pos*/
    temlen = flen-new_dentry->d_name.len;
    7162:	41 8b 45 24          	mov    0x24(%r13),%eax
    7166:	49 89 fd             	mov    %rdi,%r13
    7169:	49 29 c5             	sub    %rax,%r13
    if(temlen == 1){
    716c:	49 83 fd 01          	cmp    $0x1,%r13
    7170:	0f 85 59 01 00 00    	jne    72cf <__rename_file_dentry+0x4ff>
        dafs_de->isr_sf = 1;
    7176:	41 c6 83 83 40 00 00 	movb   $0x1,0x4083(%r11)
    717d:	01 
        dafs_de->par_pos = 0;
    717e:	41 c7 83 8c 40 00 00 	movl   $0x0,0x408c(%r11)
    7185:	00 00 00 00 
        par_de = &n_ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
    7189:	48 83 be 98 40 00 00 	cmpq   $0x1,0x4098(%rsi)
    7190:	01 
    7191:	0f 84 60 02 00 00    	je     73f7 <__rename_file_dentry+0x627>
        par_dir->sub_num++;
    }
    
    /*make valid*/
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)z_p->statemap);
    7197:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    719b:	48 8b 00             	mov    (%rax),%rax
 * This operation is atomic and cannot be reordered.
 * It also implies a memory barrier.
 */
static inline int test_and_set_bit(long nr, volatile unsigned long *addr)
{
	GEN_BINARY_RMWcc(LOCK_PREFIX "bts", *addr, "Ir", nr, "%0", "c");
    719e:	f0 48 0f ab 18       	lock bts %rbx,(%rax)
    71a3:	72 00                	jb     71a5 <__rename_file_dentry+0x3d5>
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    71a5:	48 8b 45 80          	mov    -0x80(%rbp),%rax
    71a9:	85 c0                	test   %eax,%eax
    71ab:	0f 8e 3f 02 00 00    	jle    73f0 <__rename_file_dentry+0x620>
    71b1:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
    71b5:	83 e8 01             	sub    $0x1,%eax
    71b8:	31 d2                	xor    %edx,%edx
    71ba:	48 8d 74 03 01       	lea    0x1(%rbx,%rax,1),%rsi
    71bf:	48 89 d8             	mov    %rbx,%rax
		hash = hash * seed + (*str++);
    71c2:	48 89 d1             	mov    %rdx,%rcx
    71c5:	48 83 c0 01          	add    $0x1,%rax
    71c9:	48 c1 e1 05          	shl    $0x5,%rcx
    71cd:	48 29 d1             	sub    %rdx,%rcx
    71d0:	48 89 ca             	mov    %rcx,%rdx
    71d3:	48 0f be 48 ff       	movsbq -0x1(%rax),%rcx
    71d8:	48 01 ca             	add    %rcx,%rdx
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    71db:	48 39 f0             	cmp    %rsi,%rax
    71de:	75 e2                	jne    71c2 <__rename_file_dentry+0x3f2>
   
    /*set pos in hash table for each zone*/
    hashname = BKDRHash(phn, phlen);
    dafs_de->hname = cpu_to_le64(hashname);
    71e0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    71e4:	48 8b 5d b8          	mov    -0x48(%rbp),%rbx
    record_pos_htable(sb, n_ei->ht_head, hashname, cur_pos, 1);
    71e8:	44 89 e1             	mov    %r12d,%ecx
    71eb:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    71ef:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    bitpos++;
    test_and_set_bit_le(bitpos, (void *)z_p->statemap);
   
    /*set pos in hash table for each zone*/
    hashname = BKDRHash(phn, phlen);
    dafs_de->hname = cpu_to_le64(hashname);
    71f5:	48 c1 e0 07          	shl    $0x7,%rax
    71f9:	48 89 94 03 a8 40 00 	mov    %rdx,0x40a8(%rbx,%rax,1)
    7200:	00 
    record_pos_htable(sb, n_ei->ht_head, hashname, cur_pos, 1);
    7201:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
    7205:	48 8b 70 18          	mov    0x18(%rax),%rsi
    7209:	e8 00 00 00 00       	callq  720e <__rename_file_dentry+0x43e>

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
    720e:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 7214 <__rename_file_dentry+0x444>
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    7214:	44 89 f1             	mov    %r14d,%ecx
	if (support_clwb) {
    7217:	31 d2                	xor    %edx,%edx
}

static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
    7219:	83 e1 3f             	and    $0x3f,%ecx
    721c:	83 e9 80             	sub    $0xffffff80,%ecx
	if (support_clwb) {
    721f:	85 c0                	test   %eax,%eax
    7221:	74 58                	je     727b <__rename_file_dentry+0x4ab>
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
    7223:	89 d0                	mov    %edx,%eax
    7225:	4c 01 f0             	add    %r14,%rax
    7228:	66 0f ae 30          	clwb   (%rax)
static inline void nova_flush_buffer(void *buf, uint32_t len, bool fence)
{
	uint32_t i;
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    722c:	83 c2 40             	add    $0x40,%edx
    722f:	39 d1                	cmp    %edx,%ecx
    7231:	77 f0                	ja     7223 <__rename_file_dentry+0x453>

    nova_flush_buffer(dafs_de, DAFS_DEF_DENTRY_SIZE, 0);
    
    //dafs_remove_dentry(old_dentry);
    
    kfree(phname);
    7233:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
    7237:	e8 00 00 00 00       	callq  723c <__rename_file_dentry+0x46c>
    kfree(ph);
    723c:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    7240:	e8 00 00 00 00       	callq  7245 <__rename_file_dentry+0x475>
    kfree(phn);
    7245:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
    7249:	e8 00 00 00 00       	callq  724e <__rename_file_dentry+0x47e>
    kfree(z_p);
    724e:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    7252:	e8 00 00 00 00       	callq  7257 <__rename_file_dentry+0x487>
    //NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    //nova_dbg("%s end",__func__);

    return ret;
    
}
    7257:	31 c0                	xor    %eax,%eax
    7259:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
    725d:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    7264:	00 00 
    7266:	0f 85 ce 01 00 00    	jne    743a <__rename_file_dentry+0x66a>
    726c:	48 83 ec 80          	sub    $0xffffffffffffff80,%rsp
    7270:	5b                   	pop    %rbx
    7271:	41 5c                	pop    %r12
    7273:	41 5d                	pop    %r13
    7275:	41 5e                	pop    %r14
    7277:	41 5f                	pop    %r15
    7279:	5d                   	pop    %rbp
    727a:	c3                   	retq   
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clflush(buf + i);
    727b:	89 d0                	mov    %edx,%eax
    727d:	4c 01 f0             	add    %r14,%rax
    7280:	0f ae 38             	clflush (%rax)
	len = len + ((unsigned long)(buf) & (CACHELINE_SIZE - 1));
	if (support_clwb) {
		for (i = 0; i < len; i += CACHELINE_SIZE)
			_mm_clwb(buf + i);
	} else {
		for (i = 0; i < len; i += CACHELINE_SIZE)
    7283:	83 c2 40             	add    $0x40,%edx
    7286:	39 d1                	cmp    %edx,%ecx
    7288:	77 f1                	ja     727b <__rename_file_dentry+0x4ab>
    728a:	eb a7                	jmp    7233 <__rename_file_dentry+0x463>
    dafs_de->size = o_de->size;
     
    /*judge name len && set dentry name*/
    if(new_dentry->d_name.len <= SMALL_NAME_LEN){
        dafs_de->ext_flag = 0;
        memcpy(dafs_de->name,new_dentry->d_name.name,new_dentry->d_name.len);
    728c:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
    7290:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
    
    dafs_de->size = o_de->size;
     
    /*judge name len && set dentry name*/
    if(new_dentry->d_name.len <= SMALL_NAME_LEN){
        dafs_de->ext_flag = 0;
    7297:	31 c9                	xor    %ecx,%ecx
    7299:	66 41 89 8b 84 40 00 	mov    %cx,0x4084(%r11)
    72a0:	00 
        memcpy(dafs_de->name,new_dentry->d_name.name,new_dentry->d_name.len);
    72a1:	48 8d bc 16 b0 40 00 	lea    0x40b0(%rsi,%rdx,1),%rdi
    72a8:	00 
    72a9:	41 8b 55 24          	mov    0x24(%r13),%edx
    72ad:	49 8b 75 28          	mov    0x28(%r13),%rsi
    72b1:	e8 00 00 00 00       	callq  72b6 <__rename_file_dentry+0x4e6>
        dafs_de->name[new_dentry->d_name.len] = '\0'; 
    72b6:	41 8b 45 24          	mov    0x24(%r13),%eax
    72ba:	4c 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11
    72c1:	41 c6 84 03 b0 40 00 	movb   $0x0,0x40b0(%r11,%rax,1)
    72c8:	00 00 
    72ca:	e9 6f fe ff ff       	jmpq   713e <__rename_file_dentry+0x36e>
            new_sf->pos = cpu_to_le32(cur_pos);
            list_add_tail(&new_sf->list, &par_dir->sub_file);
            par_dir->sub_num++;
        }
    } else {
        dafs_de->isr_sf = 0;
    72cf:	41 c6 83 83 40 00 00 	movb   $0x0,0x4083(%r11)
    72d6:	00 
        tem = kzalloc(sizeof(char)*temlen, GFP_KERNEL);
    72d7:	4c 89 ef             	mov    %r13,%rdi
            new_sf->pos = cpu_to_le32(cur_pos);
            list_add_tail(&new_sf->list, &par_dir->sub_file);
            par_dir->sub_num++;
        }
    } else {
        dafs_de->isr_sf = 0;
    72da:	4c 89 9d 78 ff ff ff 	mov    %r11,-0x88(%rbp)
        tem = kzalloc(sizeof(char)*temlen, GFP_KERNEL);
        temlen--;
    72e1:	4d 8d 7d ff          	lea    -0x1(%r13),%r15
            list_add_tail(&new_sf->list, &par_dir->sub_file);
            par_dir->sub_num++;
        }
    } else {
        dafs_de->isr_sf = 0;
        tem = kzalloc(sizeof(char)*temlen, GFP_KERNEL);
    72e5:	e8 e6 8f ff ff       	callq  2d0 <kzalloc.constprop.8>
        temlen--;
        memcpy(tem, phname, temlen);
    72ea:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
    72ee:	4c 89 fa             	mov    %r15,%rdx
    72f1:	48 89 c7             	mov    %rax,%rdi
    72f4:	e8 00 00 00 00       	callq  72f9 <__rename_file_dentry+0x529>
    72f9:	45 85 ff             	test   %r15d,%r15d
    72fc:	48 89 c1             	mov    %rax,%rcx
        tem[temlen]='\0';
    72ff:	42 c6 44 28 ff 00    	movb   $0x0,-0x1(%rax,%r13,1)
    7305:	4c 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11
    730c:	0f 8e 0e 01 00 00    	jle    7420 <__rename_file_dentry+0x650>
    7312:	41 8d 47 ff          	lea    -0x1(%r15),%eax
    7316:	45 31 ed             	xor    %r13d,%r13d
    7319:	48 8d 54 01 01       	lea    0x1(%rcx,%rax,1),%rdx
		hash = hash * seed + (*str++);
    731e:	4c 89 e8             	mov    %r13,%rax
    7321:	48 83 c1 01          	add    $0x1,%rcx
    7325:	48 c1 e0 05          	shl    $0x5,%rax
    7329:	4c 29 e8             	sub    %r13,%rax
    732c:	49 89 c5             	mov    %rax,%r13
    732f:	48 0f be 41 ff       	movsbq -0x1(%rcx),%rax
    7334:	49 01 c5             	add    %rax,%r13
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
	int i;

	for (i = 0; i < length; i++) {
    7337:	48 39 d1             	cmp    %rdx,%rcx
    733a:	75 e2                	jne    731e <__rename_file_dentry+0x54e>
        par_hn = BKDRHash(tem, temlen);
        lookup_in_hashtable(sb, n_ei->ht_head, par_hn, 1, &par_pos);
    733c:	4c 8b 7d a0          	mov    -0x60(%rbp),%r15
    7340:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    7344:	4c 8d 45 c4          	lea    -0x3c(%rbp),%r8
    7348:	b9 01 00 00 00       	mov    $0x1,%ecx
    734d:	4c 89 ea             	mov    %r13,%rdx
    7350:	4c 89 9d 78 ff ff ff 	mov    %r11,-0x88(%rbp)
    7357:	49 8b 77 18          	mov    0x18(%r15),%rsi
    735b:	e8 00 00 00 00       	callq  7360 <__rename_file_dentry+0x590>
        dafs_de->par_pos = cpu_to_le32(par_pos);
    7360:	8b 45 c4             	mov    -0x3c(%rbp),%eax
    7363:	4c 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11
    736a:	41 89 83 8c 40 00 00 	mov    %eax,0x408c(%r11)
        //nova_dbg("%s new dentry par name %s, pos%d",__func__, tem, par_pos);
        /*set subpos*/
        par_dir = radix_tree_lookup(&n_ei->dir_tree, par_hn);
    7371:	49 8d 7f 38          	lea    0x38(%r15),%rdi
    7375:	4c 89 ee             	mov    %r13,%rsi
    7378:	e8 00 00 00 00       	callq  737d <__rename_file_dentry+0x5ad>
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    737d:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 7384 <__rename_file_dentry+0x5b4>
    7384:	49 89 c5             	mov    %rax,%r13
    7387:	ba 14 00 00 00       	mov    $0x14,%edx
    738c:	be d0 80 00 00       	mov    $0x80d0,%esi
    7391:	e8 00 00 00 00       	callq  7396 <__rename_file_dentry+0x5c6>
        new_sf = kzalloc(sizeof(struct file_p), GFP_KERNEL);
        new_sf->pos = cpu_to_le32(cur_pos);
    7396:	44 89 60 10          	mov    %r12d,0x10(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    739a:	49 8b 55 20          	mov    0x20(%r13),%rdx
        list_add_tail(&new_sf->list, &par_dir->sub_file);
    739e:	49 8d 4d 18          	lea    0x18(%r13),%rcx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    73a2:	49 89 45 20          	mov    %rax,0x20(%r13)
    73a6:	48 89 08             	mov    %rcx,(%rax)
	new->next = next;
	new->prev = prev;
    73a9:	48 89 50 08          	mov    %rdx,0x8(%rax)
	prev->next = new;
    73ad:	48 89 02             	mov    %rax,(%rdx)
        par_dir->sub_num++;
    73b0:	49 83 45 08 01       	addq   $0x1,0x8(%r13)
    73b5:	e9 dd fd ff ff       	jmpq   7197 <__rename_file_dentry+0x3c7>
    //memcpy(phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
    73ba:	4c 8b 75 b0          	mov    -0x50(%rbp),%r14
    73be:	4c 89 f7             	mov    %r14,%rdi
    73c1:	e8 00 00 00 00       	callq  73c6 <__rename_file_dentry+0x5f6>
        memcpy(phname, ph, flen);
    73c6:	4c 89 f6             	mov    %r14,%rsi
    73c9:	4c 8b 75 90          	mov    -0x70(%rbp),%r14
    //memcpy(phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
    73cd:	48 89 c3             	mov    %rax,%rbx
        memcpy(phname, ph, flen);
    73d0:	48 89 c2             	mov    %rax,%rdx
    //memcpy(phname, ph, strlen(ph)+1);
    n_ei = find_dzt(sb, ph, phn);
    n_ze = (struct dafs_zone_entry *)nova_get_block(sb, n_ei->dz_addr);
    phlen = strlen(phn);
    if(phlen==1){
        flen = strlen(ph);
    73d3:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
        memcpy(phname, ph, flen);
    73da:	4c 89 f7             	mov    %r14,%rdi
    73dd:	e8 00 00 00 00       	callq  73e2 <__rename_file_dentry+0x612>
        phname[flen]='\0';
    73e2:	41 c6 04 1e 00       	movb   $0x0,(%r14,%rbx,1)
    73e7:	e9 1c fc ff ff       	jmpq   7008 <__rename_file_dentry+0x238>
    //buf = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //tem = kmalloc(sizeof(char)*DAFS_PATH_LEN, GFP_KERNEL);
    //if(!buf)
    //    goto ERR;

    BUG_ON(sb==NULL);
    73ec:	0f 0b                	ud2    
    BUG_ON(sbi==NULL);
    73ee:	0f 0b                	ud2    
}*/
// BKDR String Hash Function
static inline unsigned long BKDRHash(const char *str, int length)
{
	unsigned int seed = 31; // 31 131 1313 13131 131313 etc..
	unsigned long hash = 0;
    73f0:	31 d2                	xor    %edx,%edx
    73f2:	e9 e9 fd ff ff       	jmpq   71e0 <__rename_file_dentry+0x410>
        par_de = &n_ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
            //nova_dbg("new par is root");
            par_hn = le64_to_cpu(par_de->hname);
            lookup_in_hashtable(sb, n_ei->ht_head, par_hn, 1, &par_pos);
    73f7:	4c 8b 7d a0          	mov    -0x60(%rbp),%r15
        dafs_de->par_pos = 0;
        par_de = &n_ze->dentry[0];
        ino = le64_to_cpu(par_de->ino);
        if(ino == NOVA_ROOT_INO){
            //nova_dbg("new par is root");
            par_hn = le64_to_cpu(par_de->hname);
    73fb:	4c 8b ae a8 40 00 00 	mov    0x40a8(%rsi),%r13
            lookup_in_hashtable(sb, n_ei->ht_head, par_hn, 1, &par_pos);
    7402:	4c 8d 45 c4          	lea    -0x3c(%rbp),%r8
    7406:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    740a:	b9 01 00 00 00       	mov    $0x1,%ecx
    740f:	49 8b 77 18          	mov    0x18(%r15),%rsi
    7413:	4c 89 ea             	mov    %r13,%rdx
    7416:	e8 00 00 00 00       	callq  741b <__rename_file_dentry+0x64b>
    741b:	e9 51 ff ff ff       	jmpq   7371 <__rename_file_dentry+0x5a1>
    7420:	45 31 ed             	xor    %r13d,%r13d
    7423:	e9 14 ff ff ff       	jmpq   733c <__rename_file_dentry+0x56c>
        flen = strlen(ph)-phlen;
        memcpy(phname, ph+phlen, flen);
        phname[flen]='\0';
    }
    make_zone_ptr(&z_p, n_ze);
    while(bitpos<z_p->zone_max){
    7428:	bb 01 00 00 00       	mov    $0x1,%ebx
    struct dzt_entry_info *n_ei;
    struct zone_ptr *z_p;
    struct dir_info *par_dir;
    struct file_p *new_sf;
    char *ph, *tem, *phname, *phn;
    u32 bitpos=0, cur_pos=0, par_pos;
    742d:	45 31 e4             	xor    %r12d,%r12d
    7430:	e9 2f fc ff ff       	jmpq   7064 <__rename_file_dentry+0x294>
    7435:	e8 00 00 00 00       	callq  743a <__rename_file_dentry+0x66a>
    //NOVA_END_TIMING(add_dentry_t, add_dentry_time);
    //nova_dbg("%s end",__func__);

    return ret;
    
}
    743a:	e8 00 00 00 00       	callq  743f <__rename_file_dentry+0x66f>
    //    goto ERR;

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    743f:	49 8d 9e d7 05 00 00 	lea    0x5d7(%r14),%rbx
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    if(strcmp(dentry->d_name.name,"/")){
        memcpy(buf,"/",1);
    7446:	41 c6 86 d7 05 00 00 	movb   $0x2f,0x5d7(%r14)
    744d:	2f 
        buf[1]='\0';
    744e:	41 c6 86 d8 05 00 00 	movb   $0x0,0x5d8(%r14)
    7455:	00 
    }
    rd= vfsmnt->mnt_root;
    //nova_dbg("mount point is:%s cur dentry %s par dentry %s", rd->d_name.name,dentry->d_name.name, p_dentry->d_name.name);

    read_unlock(&fs->lock);
    tem_dentry = dentry;
    7456:	4d 89 ec             	mov    %r13,%r12
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    7459:	48 89 df             	mov    %rbx,%rdi
    745c:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
    7460:	4c 89 55 b8          	mov    %r10,-0x48(%rbp)
    7464:	e8 00 00 00 00       	callq  7469 <__rename_file_dentry+0x699>
    7469:	be 2f 00 00 00       	mov    $0x2f,%esi
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    746e:	48 8d 7c 03 01       	lea    0x1(%rbx,%rax,1),%rdi
    //plen = strlen(buf);

    do{
        //memcpy(buf+plen, "/", 1);
        //buf[plen+1] = '\0';
        strcat(buf, "/");
    7473:	66 89 34 03          	mov    %si,(%rbx,%rax,1)
        //plen = strlen(buf);
        //memcpy(buf+plen, tem_dentry->d_name.name, tem_dentry->d_name.len);
        //buf[plen+tem_dentry->d_name.len]='\0';
        strcat(buf, tem_dentry->d_name.name);
    7477:	49 8b 74 24 28       	mov    0x28(%r12),%rsi
    747c:	e8 00 00 00 00       	callq  7481 <__rename_file_dentry+0x6b1>
        p_dentry = tem_dentry->d_parent;
    7481:	4d 8b 64 24 18       	mov    0x18(%r12),%r12
        //plen = strlen(buf);
        //buf[plen]='\0';
        tem_dentry = p_dentry;
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
    7486:	4c 8b 55 b8          	mov    -0x48(%rbp),%r10
    748a:	b9 02 00 00 00       	mov    $0x2,%ecx
    748f:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
    7493:	49 8b 74 24 28       	mov    0x28(%r12),%rsi
    7498:	4c 89 d7             	mov    %r10,%rdi
    749b:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    749d:	75 ba                	jne    7459 <__rename_file_dentry+0x689>
    749f:	49 8b 44 24 30       	mov    0x30(%r12),%rax
    74a4:	48 83 78 40 01       	cmpq   $0x1,0x40(%rax)
    74a9:	75 ae                	jne    7459 <__rename_file_dentry+0x689>

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    74ab:	49 8d 86 d6 09 00 00 	lea    0x9d6(%r14),%rax
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    74b2:	48 89 da             	mov    %rbx,%rdx
    74b5:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    74bc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    74c3:	4c 89 55 98          	mov    %r10,-0x68(%rbp)

    BUG_ON(sb==NULL);
    BUG_ON(sbi==NULL);
    ph = &sbi->ph_f;
    buf = &sbi->ph_dzt;
    tem = &sbi->ph_name;
    74c7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        if(!strcmp(p_dentry->d_name.name, "/") && p_dentry->d_inode->i_ino == NOVA_ROOT_INO)
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    74cb:	e8 00 00 00 00       	callq  74d0 <__rename_file_dentry+0x700>
    tlen = strlen(buf);
    74d0:	48 89 df             	mov    %rbx,%rdi
    74d3:	e8 00 00 00 00       	callq  74d8 <__rename_file_dentry+0x708>
    memcpy(tem, buf, tlen);
    74d8:	49 8d be d6 09 00 00 	lea    0x9d6(%r14),%rdi
    74df:	48 89 c2             	mov    %rax,%rdx
    74e2:	48 89 de             	mov    %rbx,%rsi
            break;
    }while(1);

    //BUG_ON(buf==NULL);
    nova_dbg("%s buf is %s",__func__, buf);
    tlen = strlen(buf);
    74e5:	49 89 c4             	mov    %rax,%r12
    memcpy(tem, buf, tlen);
    74e8:	e8 00 00 00 00       	callq  74ed <__rename_file_dentry+0x71d>
    tem[tlen]='\0';
    74ed:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
    74f1:	4c 8b 55 98          	mov    -0x68(%rbp),%r10
    74f5:	43 c6 84 26 d6 09 00 	movb   $0x0,0x9d6(%r14,%r12,1)
    74fc:	00 00 
    74fe:	4c 89 6d a0          	mov    %r13,-0x60(%rbp)
    7502:	49 89 dd             	mov    %rbx,%r13
    7505:	4d 89 c6             	mov    %r8,%r14
    do{
        ppath = strrchr(tem, '/');
    7508:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    750c:	be 2f 00 00 00       	mov    $0x2f,%esi
    7511:	4c 89 55 98          	mov    %r10,-0x68(%rbp)
    7515:	e8 00 00 00 00       	callq  751a <__rename_file_dentry+0x74a>
        plen = strlen(ppath);
    751a:	48 89 c7             	mov    %rax,%rdi
    nova_dbg("%s buf is %s",__func__, buf);
    tlen = strlen(buf);
    memcpy(tem, buf, tlen);
    tem[tlen]='\0';
    do{
        ppath = strrchr(tem, '/');
    751d:	48 89 c3             	mov    %rax,%rbx
        plen = strlen(ppath);
    7520:	e8 00 00 00 00       	callq  7525 <__rename_file_dentry+0x755>
        phlen = tlen - plen;
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    7525:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    7529:	48 89 de             	mov    %rbx,%rsi
    memcpy(tem, buf, tlen);
    tem[tlen]='\0';
    do{
        ppath = strrchr(tem, '/');
        plen = strlen(ppath);
        phlen = tlen - plen;
    752c:	49 29 c4             	sub    %rax,%r12
        tlen = phlen;
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
    752f:	e8 00 00 00 00       	callq  7534 <__rename_file_dentry+0x764>
        memcpy(tem, buf, tlen);
    7534:	48 8b 5d b8          	mov    -0x48(%rbp),%rbx
    7538:	4c 89 ee             	mov    %r13,%rsi
    753b:	4c 89 e2             	mov    %r12,%rdx
    753e:	48 89 df             	mov    %rbx,%rdi
    7541:	e8 00 00 00 00       	callq  7546 <__rename_file_dentry+0x776>
        tem[tlen]='\0';
        if(!strcmp(tem,"/"))
    7546:	4c 8b 55 98          	mov    -0x68(%rbp),%r10
        //BUG_ON(strlen(tem)==0);
        //memcpy(ph,ppath,plen);
        //ph[plen]='\0';
        strcat(ph, ppath);
        memcpy(tem, buf, tlen);
        tem[tlen]='\0';
    754a:	48 89 de             	mov    %rbx,%rsi
    754d:	42 c6 04 23 00       	movb   $0x0,(%rbx,%r12,1)
        if(!strcmp(tem,"/"))
    7552:	b9 02 00 00 00       	mov    $0x2,%ecx
    7557:	4c 89 d7             	mov    %r10,%rdi
    755a:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
    755c:	75 aa                	jne    7508 <__rename_file_dentry+0x738>
            break;
    }while(1);

    //BUG_ON(strlen(ph)==1023);
    nova_dbg("%s ful ph is %s sbi is %s",__func__,ph, sbi->ph_f);
    755e:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    7562:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    7569:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    7570:	4c 89 75 b8          	mov    %r14,-0x48(%rbp)
    7574:	4c 8b 6d a0          	mov    -0x60(%rbp),%r13
    7578:	48 89 d1             	mov    %rdx,%rcx
    757b:	e8 00 00 00 00       	callq  7580 <__rename_file_dentry+0x7b0>
    //BUG_ON(ph==NULL);
    
    mntput(vfsmnt);
    7580:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
    7584:	4c 89 c7             	mov    %r8,%rdi
    7587:	e8 00 00 00 00       	callq  758c <__rename_file_dentry+0x7bc>
    758c:	eb 0c                	jmp    759a <__rename_file_dentry+0x7ca>
    buf[0]='\0';
    tem[0]='\0';
    read_lock(&fs->lock);
    vfsmnt = mntget(fs->pwd.mnt);
    if(!vfsmnt){
        nova_dbg("not find mnt");
    758e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    7595:	e8 00 00 00 00       	callq  759a <__rename_file_dentry+0x7ca>
    
    //kfree(buf);
    //kfree(tem);
    //nova_dbg("dafs finish get dentry path");
ERR:
    nova_dbg("%s ful ph is %s len %llu, sbi %s ",__func__,ph, strlen(ph), sbi->ph_f);
    759a:	48 8b 5d b0          	mov    -0x50(%rbp),%rbx
    759e:	48 89 df             	mov    %rbx,%rdi
    75a1:	e8 00 00 00 00       	callq  75a6 <__rename_file_dentry+0x7d6>
    75a6:	49 89 d8             	mov    %rbx,%r8
    75a9:	48 89 c1             	mov    %rax,%rcx
    75ac:	48 89 da             	mov    %rbx,%rdx
    75af:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    75b6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    75bd:	e8 00 00 00 00       	callq  75c2 <__rename_file_dentry+0x7f2>
    75c2:	e9 0a f9 ff ff       	jmpq   6ed1 <__rename_file_dentry+0x101>

Disassembly of section .text.unlikely:

0000000000000000 <find_dzt.part.3>:
/* find currect zone
 * ph record file ful name
 * 反向查找
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
   0:	55                   	push   %rbp
   1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
   8:	48 89 e5             	mov    %rsp,%rbp
   b:	e8 00 00 00 00       	callq  10 <find_dzt.part.3+0x10>
    struct dzt_entry_info *dzt_ei;
    struct nova_sb_info *sbi = NOVA_SB(sb);
    struct dzt_manager *dzt_m = sbi->dzt_m_info;
  10:	0f 0b                	ud2    

0000000000000012 <get_dentry_path.isra.4.part.5>:
  12:	55                   	push   %rbp
  13:	48 89 e5             	mov    %rsp,%rbp
/* find currect zone
 * ph record file ful name
 * 反向查找
 * 可以用多线程*/
static inline struct dzt_entry_info *find_dzt(struct super_block *sb, char *phstr, char *phs)
{
  16:	0f 0b                	ud2    
